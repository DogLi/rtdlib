
use std::fmt::Debug;
use std::str::FromStr;
use crate::tdkit;

/// All tdlib type abstract class defined the same behavior
pub trait RObject {
 #[doc(hidden)] fn td_name(&self) -> &'static str;
 /// convert TDLib type to rust enum RTDType
 fn td_type(&self) -> RTDType;
 /// The string that implements the return of to_json should be called `tdkit::fill_json_struct` for optimization,
 /// appending the `@struct` field, although usually struct will actively generate `@struct`, but not in `Object` and `Function`,
 /// because the implementation of typetag cannot be automatically generated.
 fn to_json(&self) -> String;
}

/// This class is a base class for all TDLib TL-objects.
/// This parent class is not important and will not be implemented for every class.
trait TlObject: Debug + Clone {}

/// TDLib all class name mappers
#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDType {
  Object,
  Function,
  AccountTtl,
  Address,
  Animation,
  Animations,
  Audio,
  AuthenticationCodeInfo,
  AuthenticationCodeType,
  AuthenticationCodeTypeTelegramMessage,
  AuthenticationCodeTypeSms,
  AuthenticationCodeTypeCall,
  AuthenticationCodeTypeFlashCall,
  AuthorizationState,
  AuthorizationStateWaitTdlibParameters,
  AuthorizationStateWaitEncryptionKey,
  AuthorizationStateWaitPhoneNumber,
  AuthorizationStateWaitCode,
  AuthorizationStateWaitPassword,
  AuthorizationStateReady,
  AuthorizationStateLoggingOut,
  AuthorizationStateClosing,
  AuthorizationStateClosed,
  BasicGroup,
  BasicGroupFullInfo,
  BotCommand,
  BotInfo,
  Call,
  CallConnection,
  CallDiscardReason,
  CallDiscardReasonEmpty,
  CallDiscardReasonMissed,
  CallDiscardReasonDeclined,
  CallDiscardReasonDisconnected,
  CallDiscardReasonHungUp,
  CallId,
  CallProtocol,
  CallState,
  CallStatePending,
  CallStateExchangingKeys,
  CallStateReady,
  CallStateHangingUp,
  CallStateDiscarded,
  CallStateError,
  CallbackQueryAnswer,
  CallbackQueryPayload,
  CallbackQueryPayloadData,
  CallbackQueryPayloadGame,
  Chat,
  ChatAction,
  ChatActionTyping,
  ChatActionRecordingVideo,
  ChatActionUploadingVideo,
  ChatActionRecordingVoiceNote,
  ChatActionUploadingVoiceNote,
  ChatActionUploadingPhoto,
  ChatActionUploadingDocument,
  ChatActionChoosingLocation,
  ChatActionChoosingContact,
  ChatActionStartPlayingGame,
  ChatActionRecordingVideoNote,
  ChatActionUploadingVideoNote,
  ChatActionCancel,
  ChatEvent,
  ChatEventAction,
  ChatEventMessageEdited,
  ChatEventMessageDeleted,
  ChatEventMessagePinned,
  ChatEventMessageUnpinned,
  ChatEventMemberJoined,
  ChatEventMemberLeft,
  ChatEventMemberInvited,
  ChatEventMemberPromoted,
  ChatEventMemberRestricted,
  ChatEventTitleChanged,
  ChatEventDescriptionChanged,
  ChatEventUsernameChanged,
  ChatEventPhotoChanged,
  ChatEventInvitesToggled,
  ChatEventSignMessagesToggled,
  ChatEventStickerSetChanged,
  ChatEventIsAllHistoryAvailableToggled,
  ChatEventLogFilters,
  ChatEvents,
  ChatInviteLink,
  ChatInviteLinkInfo,
  ChatMember,
  ChatMemberStatus,
  ChatMemberStatusCreator,
  ChatMemberStatusAdministrator,
  ChatMemberStatusMember,
  ChatMemberStatusRestricted,
  ChatMemberStatusLeft,
  ChatMemberStatusBanned,
  ChatMembers,
  ChatMembersFilter,
  ChatMembersFilterAdministrators,
  ChatMembersFilterMembers,
  ChatMembersFilterRestricted,
  ChatMembersFilterBanned,
  ChatMembersFilterBots,
  ChatNotificationSettings,
  ChatPhoto,
  ChatReportReason,
  ChatReportReasonSpam,
  ChatReportReasonViolence,
  ChatReportReasonPornography,
  ChatReportReasonChildAbuse,
  ChatReportReasonCopyright,
  ChatReportReasonCustom,
  ChatReportSpamState,
  ChatType,
  ChatTypePrivate,
  ChatTypeBasicGroup,
  ChatTypeSupergroup,
  ChatTypeSecret,
  Chats,
  CheckChatUsernameResult,
  CheckChatUsernameResultOk,
  CheckChatUsernameResultUsernameInvalid,
  CheckChatUsernameResultUsernameOccupied,
  CheckChatUsernameResultPublicChatsTooMuch,
  CheckChatUsernameResultPublicGroupsUnavailable,
  ConnectedWebsite,
  ConnectedWebsites,
  ConnectionState,
  ConnectionStateWaitingForNetwork,
  ConnectionStateConnectingToProxy,
  ConnectionStateConnecting,
  ConnectionStateUpdating,
  ConnectionStateReady,
  Contact,
  Count,
  CustomRequestResult,
  DatabaseStatistics,
  Date,
  DatedFile,
  DeepLinkInfo,
  DeviceToken,
  DeviceTokenFirebaseCloudMessaging,
  DeviceTokenApplePush,
  DeviceTokenApplePushVoIP,
  DeviceTokenWindowsPush,
  DeviceTokenMicrosoftPush,
  DeviceTokenMicrosoftPushVoIP,
  DeviceTokenWebPush,
  DeviceTokenSimplePush,
  DeviceTokenUbuntuPush,
  DeviceTokenBlackBerryPush,
  DeviceTokenTizenPush,
  Document,
  DraftMessage,
  EmailAddressAuthenticationCodeInfo,
  EncryptedCredentials,
  EncryptedPassportElement,
  Error,
  File,
  FilePart,
  FileType,
  FileTypeNone,
  FileTypeAnimation,
  FileTypeAudio,
  FileTypeDocument,
  FileTypePhoto,
  FileTypeProfilePhoto,
  FileTypeSecret,
  FileTypeSecretThumbnail,
  FileTypeSecure,
  FileTypeSticker,
  FileTypeThumbnail,
  FileTypeUnknown,
  FileTypeVideo,
  FileTypeVideoNote,
  FileTypeVoiceNote,
  FileTypeWallpaper,
  FormattedText,
  FoundMessages,
  Game,
  GameHighScore,
  GameHighScores,
  Hashtags,
  HttpUrl,
  IdentityDocument,
  ImportedContacts,
  InlineKeyboardButton,
  InlineKeyboardButtonType,
  InlineKeyboardButtonTypeUrl,
  InlineKeyboardButtonTypeCallback,
  InlineKeyboardButtonTypeCallbackGame,
  InlineKeyboardButtonTypeSwitchInline,
  InlineKeyboardButtonTypeBuy,
  InlineQueryResult,
  InlineQueryResultArticle,
  InlineQueryResultContact,
  InlineQueryResultLocation,
  InlineQueryResultVenue,
  InlineQueryResultGame,
  InlineQueryResultAnimation,
  InlineQueryResultAudio,
  InlineQueryResultDocument,
  InlineQueryResultPhoto,
  InlineQueryResultSticker,
  InlineQueryResultVideo,
  InlineQueryResultVoiceNote,
  InlineQueryResults,
  InputCredentials,
  InputCredentialsSaved,
  InputCredentialsNew,
  InputCredentialsAndroidPay,
  InputCredentialsApplePay,
  InputFile,
  InputFileId,
  InputFileRemote,
  InputFileLocal,
  InputFileGenerated,
  InputIdentityDocument,
  InputInlineQueryResult,
  InputInlineQueryResultAnimatedGif,
  InputInlineQueryResultAnimatedMpeg4,
  InputInlineQueryResultArticle,
  InputInlineQueryResultAudio,
  InputInlineQueryResultContact,
  InputInlineQueryResultDocument,
  InputInlineQueryResultGame,
  InputInlineQueryResultLocation,
  InputInlineQueryResultPhoto,
  InputInlineQueryResultSticker,
  InputInlineQueryResultVenue,
  InputInlineQueryResultVideo,
  InputInlineQueryResultVoiceNote,
  InputMessageContent,
  InputMessageText,
  InputMessageAnimation,
  InputMessageAudio,
  InputMessageDocument,
  InputMessagePhoto,
  InputMessageSticker,
  InputMessageVideo,
  InputMessageVideoNote,
  InputMessageVoiceNote,
  InputMessageLocation,
  InputMessageVenue,
  InputMessageContact,
  InputMessageGame,
  InputMessageInvoice,
  InputMessagePoll,
  InputMessageForwarded,
  InputPassportElement,
  InputPassportElementPersonalDetails,
  InputPassportElementPassport,
  InputPassportElementDriverLicense,
  InputPassportElementIdentityCard,
  InputPassportElementInternalPassport,
  InputPassportElementAddress,
  InputPassportElementUtilityBill,
  InputPassportElementBankStatement,
  InputPassportElementRentalAgreement,
  InputPassportElementPassportRegistration,
  InputPassportElementTemporaryRegistration,
  InputPassportElementPhoneNumber,
  InputPassportElementEmailAddress,
  InputPassportElementError,
  InputPassportElementErrorSource,
  InputPassportElementErrorSourceUnspecified,
  InputPassportElementErrorSourceDataField,
  InputPassportElementErrorSourceFrontSide,
  InputPassportElementErrorSourceReverseSide,
  InputPassportElementErrorSourceSelfie,
  InputPassportElementErrorSourceTranslationFile,
  InputPassportElementErrorSourceTranslationFiles,
  InputPassportElementErrorSourceFile,
  InputPassportElementErrorSourceFiles,
  InputPersonalDocument,
  InputSticker,
  InputThumbnail,
  Invoice,
  KeyboardButton,
  KeyboardButtonType,
  KeyboardButtonTypeText,
  KeyboardButtonTypeRequestPhoneNumber,
  KeyboardButtonTypeRequestLocation,
  LabeledPricePart,
  LanguagePackInfo,
  LanguagePackString,
  LanguagePackStringValue,
  LanguagePackStringValueOrdinary,
  LanguagePackStringValuePluralized,
  LanguagePackStringValueDeleted,
  LanguagePackStrings,
  LinkState,
  LinkStateNone,
  LinkStateKnowsPhoneNumber,
  LinkStateIsContact,
  LocalFile,
  LocalizationTargetInfo,
  Location,
  LogStream,
  LogStreamDefault,
  LogStreamFile,
  LogStreamEmpty,
  LogTags,
  LogVerbosityLevel,
  MaskPoint,
  MaskPointForehead,
  MaskPointEyes,
  MaskPointMouth,
  MaskPointChin,
  MaskPosition,
  Message,
  MessageContent,
  MessageText,
  MessageAnimation,
  MessageAudio,
  MessageDocument,
  MessagePhoto,
  MessageExpiredPhoto,
  MessageSticker,
  MessageVideo,
  MessageExpiredVideo,
  MessageVideoNote,
  MessageVoiceNote,
  MessageLocation,
  MessageVenue,
  MessageContact,
  MessageGame,
  MessagePoll,
  MessageInvoice,
  MessageCall,
  MessageBasicGroupChatCreate,
  MessageSupergroupChatCreate,
  MessageChatChangeTitle,
  MessageChatChangePhoto,
  MessageChatDeletePhoto,
  MessageChatAddMembers,
  MessageChatJoinByLink,
  MessageChatDeleteMember,
  MessageChatUpgradeTo,
  MessageChatUpgradeFrom,
  MessagePinMessage,
  MessageScreenshotTaken,
  MessageChatSetTtl,
  MessageCustomServiceAction,
  MessageGameScore,
  MessagePaymentSuccessful,
  MessagePaymentSuccessfulBot,
  MessageContactRegistered,
  MessageWebsiteConnected,
  MessagePassportDataSent,
  MessagePassportDataReceived,
  MessageUnsupported,
  MessageForwardInfo,
  MessageForwardOrigin,
  MessageForwardOriginUser,
  MessageForwardOriginHiddenUser,
  MessageForwardOriginChannel,
  MessageSendingState,
  MessageSendingStatePending,
  MessageSendingStateFailed,
  Messages,
  NetworkStatistics,
  NetworkStatisticsEntry,
  NetworkStatisticsEntryFile,
  NetworkStatisticsEntryCall,
  NetworkType,
  NetworkTypeNone,
  NetworkTypeMobile,
  NetworkTypeMobileRoaming,
  NetworkTypeWiFi,
  NetworkTypeOther,
  Notification,
  NotificationGroup,
  NotificationGroupType,
  NotificationGroupTypeMessages,
  NotificationGroupTypeMentions,
  NotificationGroupTypeSecretChat,
  NotificationGroupTypeCalls,
  NotificationSettingsScope,
  NotificationSettingsScopePrivateChats,
  NotificationSettingsScopeGroupChats,
  NotificationSettingsScopeChannelChats,
  NotificationType,
  NotificationTypeNewMessage,
  NotificationTypeNewSecretChat,
  NotificationTypeNewCall,
  NotificationTypeNewPushMessage,
  Ok,
  OptionValue,
  OptionValueBoolean,
  OptionValueEmpty,
  OptionValueInteger,
  OptionValueString,
  OrderInfo,
  PageBlock,
  PageBlockTitle,
  PageBlockSubtitle,
  PageBlockAuthorDate,
  PageBlockHeader,
  PageBlockSubheader,
  PageBlockKicker,
  PageBlockParagraph,
  PageBlockPreformatted,
  PageBlockFooter,
  PageBlockDivider,
  PageBlockAnchor,
  PageBlockList,
  PageBlockBlockQuote,
  PageBlockPullQuote,
  PageBlockAnimation,
  PageBlockAudio,
  PageBlockPhoto,
  PageBlockVideo,
  PageBlockCover,
  PageBlockEmbedded,
  PageBlockEmbeddedPost,
  PageBlockCollage,
  PageBlockSlideshow,
  PageBlockChatLink,
  PageBlockTable,
  PageBlockDetails,
  PageBlockRelatedArticles,
  PageBlockMap,
  PageBlockCaption,
  PageBlockHorizontalAlignment,
  PageBlockHorizontalAlignmentLeft,
  PageBlockHorizontalAlignmentCenter,
  PageBlockHorizontalAlignmentRight,
  PageBlockListItem,
  PageBlockRelatedArticle,
  PageBlockTableCell,
  PageBlockVerticalAlignment,
  PageBlockVerticalAlignmentTop,
  PageBlockVerticalAlignmentMiddle,
  PageBlockVerticalAlignmentBottom,
  PassportAuthorizationForm,
  PassportElement,
  PassportElementPersonalDetails,
  PassportElementPassport,
  PassportElementDriverLicense,
  PassportElementIdentityCard,
  PassportElementInternalPassport,
  PassportElementAddress,
  PassportElementUtilityBill,
  PassportElementBankStatement,
  PassportElementRentalAgreement,
  PassportElementPassportRegistration,
  PassportElementTemporaryRegistration,
  PassportElementPhoneNumber,
  PassportElementEmailAddress,
  PassportElementError,
  PassportElementErrorSource,
  PassportElementErrorSourceUnspecified,
  PassportElementErrorSourceDataField,
  PassportElementErrorSourceFrontSide,
  PassportElementErrorSourceReverseSide,
  PassportElementErrorSourceSelfie,
  PassportElementErrorSourceTranslationFile,
  PassportElementErrorSourceTranslationFiles,
  PassportElementErrorSourceFile,
  PassportElementErrorSourceFiles,
  PassportElementType,
  PassportElementTypePersonalDetails,
  PassportElementTypePassport,
  PassportElementTypeDriverLicense,
  PassportElementTypeIdentityCard,
  PassportElementTypeInternalPassport,
  PassportElementTypeAddress,
  PassportElementTypeUtilityBill,
  PassportElementTypeBankStatement,
  PassportElementTypeRentalAgreement,
  PassportElementTypePassportRegistration,
  PassportElementTypeTemporaryRegistration,
  PassportElementTypePhoneNumber,
  PassportElementTypeEmailAddress,
  PassportElements,
  PassportElementsWithErrors,
  PassportRequiredElement,
  PassportSuitableElement,
  PasswordState,
  PaymentForm,
  PaymentReceipt,
  PaymentResult,
  PaymentsProviderStripe,
  PersonalDetails,
  PersonalDocument,
  Photo,
  PhotoSize,
  Poll,
  PollOption,
  ProfilePhoto,
  Proxies,
  Proxy,
  ProxyType,
  ProxyTypeSocks5,
  ProxyTypeHttp,
  ProxyTypeMtproto,
  PublicMessageLink,
  PushMessageContent,
  PushMessageContentHidden,
  PushMessageContentAnimation,
  PushMessageContentAudio,
  PushMessageContentContact,
  PushMessageContentContactRegistered,
  PushMessageContentDocument,
  PushMessageContentGame,
  PushMessageContentGameScore,
  PushMessageContentInvoice,
  PushMessageContentLocation,
  PushMessageContentPhoto,
  PushMessageContentPoll,
  PushMessageContentScreenshotTaken,
  PushMessageContentSticker,
  PushMessageContentText,
  PushMessageContentVideo,
  PushMessageContentVideoNote,
  PushMessageContentVoiceNote,
  PushMessageContentBasicGroupChatCreate,
  PushMessageContentChatAddMembers,
  PushMessageContentChatChangePhoto,
  PushMessageContentChatChangeTitle,
  PushMessageContentChatDeleteMember,
  PushMessageContentChatJoinByLink,
  PushMessageContentMessageForwards,
  PushMessageContentMediaAlbum,
  PushReceiverId,
  RecoveryEmailAddress,
  RemoteFile,
  ReplyMarkup,
  ReplyMarkupRemoveKeyboard,
  ReplyMarkupForceReply,
  ReplyMarkupShowKeyboard,
  ReplyMarkupInlineKeyboard,
  RichText,
  RichTextPlain,
  RichTextBold,
  RichTextItalic,
  RichTextUnderline,
  RichTextStrikethrough,
  RichTextFixed,
  RichTextUrl,
  RichTextEmailAddress,
  RichTextSubscript,
  RichTextSuperscript,
  RichTextMarked,
  RichTextPhoneNumber,
  RichTextIcon,
  RichTextAnchor,
  RichTexts,
  SavedCredentials,
  ScopeNotificationSettings,
  SearchMessagesFilter,
  SearchMessagesFilterEmpty,
  SearchMessagesFilterAnimation,
  SearchMessagesFilterAudio,
  SearchMessagesFilterDocument,
  SearchMessagesFilterPhoto,
  SearchMessagesFilterVideo,
  SearchMessagesFilterVoiceNote,
  SearchMessagesFilterPhotoAndVideo,
  SearchMessagesFilterUrl,
  SearchMessagesFilterChatPhoto,
  SearchMessagesFilterCall,
  SearchMessagesFilterMissedCall,
  SearchMessagesFilterVideoNote,
  SearchMessagesFilterVoiceAndVideoNote,
  SearchMessagesFilterMention,
  SearchMessagesFilterUnreadMention,
  Seconds,
  SecretChat,
  SecretChatState,
  SecretChatStatePending,
  SecretChatStateReady,
  SecretChatStateClosed,
  Session,
  Sessions,
  ShippingOption,
  Sticker,
  StickerEmojis,
  StickerSet,
  StickerSetInfo,
  StickerSets,
  Stickers,
  StorageStatistics,
  StorageStatisticsByChat,
  StorageStatisticsByFileType,
  StorageStatisticsFast,
  Supergroup,
  SupergroupFullInfo,
  SupergroupMembersFilter,
  SupergroupMembersFilterRecent,
  SupergroupMembersFilterAdministrators,
  SupergroupMembersFilterSearch,
  SupergroupMembersFilterRestricted,
  SupergroupMembersFilterBanned,
  SupergroupMembersFilterBots,
  TMeUrl,
  TMeUrlType,
  TMeUrlTypeUser,
  TMeUrlTypeSupergroup,
  TMeUrlTypeChatInvite,
  TMeUrlTypeStickerSet,
  TMeUrls,
  TdlibParameters,
  TemporaryPasswordState,
  TermsOfService,
  TestBytes,
  TestInt,
  TestString,
  TestVectorInt,
  TestVectorIntObject,
  TestVectorString,
  TestVectorStringObject,
  Text,
  TextEntities,
  TextEntity,
  TextEntityType,
  TextEntityTypeMention,
  TextEntityTypeHashtag,
  TextEntityTypeCashtag,
  TextEntityTypeBotCommand,
  TextEntityTypeUrl,
  TextEntityTypeEmailAddress,
  TextEntityTypeBold,
  TextEntityTypeItalic,
  TextEntityTypeCode,
  TextEntityTypePre,
  TextEntityTypePreCode,
  TextEntityTypeTextUrl,
  TextEntityTypeMentionName,
  TextEntityTypePhoneNumber,
  TextParseMode,
  TextParseModeMarkdown,
  TextParseModeHTML,
  TopChatCategory,
  TopChatCategoryUsers,
  TopChatCategoryBots,
  TopChatCategoryGroups,
  TopChatCategoryChannels,
  TopChatCategoryInlineBots,
  TopChatCategoryCalls,
  Update,
  UpdateAuthorizationState,
  UpdateNewMessage,
  UpdateMessageSendAcknowledged,
  UpdateMessageSendSucceeded,
  UpdateMessageSendFailed,
  UpdateMessageContent,
  UpdateMessageEdited,
  UpdateMessageViews,
  UpdateMessageContentOpened,
  UpdateMessageMentionRead,
  UpdateNewChat,
  UpdateChatTitle,
  UpdateChatPhoto,
  UpdateChatLastMessage,
  UpdateChatOrder,
  UpdateChatIsPinned,
  UpdateChatIsMarkedAsUnread,
  UpdateChatIsSponsored,
  UpdateChatDefaultDisableNotification,
  UpdateChatReadInbox,
  UpdateChatReadOutbox,
  UpdateChatUnreadMentionCount,
  UpdateChatNotificationSettings,
  UpdateScopeNotificationSettings,
  UpdateChatPinnedMessage,
  UpdateChatReplyMarkup,
  UpdateChatDraftMessage,
  UpdateChatOnlineMemberCount,
  UpdateNotification,
  UpdateNotificationGroup,
  UpdateActiveNotifications,
  UpdateHavePendingNotifications,
  UpdateDeleteMessages,
  UpdateUserChatAction,
  UpdateUserStatus,
  UpdateUser,
  UpdateBasicGroup,
  UpdateSupergroup,
  UpdateSecretChat,
  UpdateUserFullInfo,
  UpdateBasicGroupFullInfo,
  UpdateSupergroupFullInfo,
  UpdateServiceNotification,
  UpdateFile,
  UpdateFileGenerationStart,
  UpdateFileGenerationStop,
  UpdateCall,
  UpdateUserPrivacySettingRules,
  UpdateUnreadMessageCount,
  UpdateUnreadChatCount,
  UpdateOption,
  UpdateInstalledStickerSets,
  UpdateTrendingStickerSets,
  UpdateRecentStickers,
  UpdateFavoriteStickers,
  UpdateSavedAnimations,
  UpdateLanguagePackStrings,
  UpdateConnectionState,
  UpdateTermsOfService,
  UpdateNewInlineQuery,
  UpdateNewChosenInlineResult,
  UpdateNewCallbackQuery,
  UpdateNewInlineCallbackQuery,
  UpdateNewShippingQuery,
  UpdateNewPreCheckoutQuery,
  UpdateNewCustomEvent,
  UpdateNewCustomQuery,
  UpdatePoll,
  Updates,
  User,
  UserFullInfo,
  UserPrivacySetting,
  UserPrivacySettingShowStatus,
  UserPrivacySettingAllowChatInvites,
  UserPrivacySettingAllowCalls,
  UserPrivacySettingAllowPeerToPeerCalls,
  UserPrivacySettingRule,
  UserPrivacySettingRuleAllowAll,
  UserPrivacySettingRuleAllowContacts,
  UserPrivacySettingRuleAllowUsers,
  UserPrivacySettingRuleRestrictAll,
  UserPrivacySettingRuleRestrictContacts,
  UserPrivacySettingRuleRestrictUsers,
  UserPrivacySettingRules,
  UserProfilePhoto,
  UserProfilePhotos,
  UserStatus,
  UserStatusEmpty,
  UserStatusOnline,
  UserStatusOffline,
  UserStatusRecently,
  UserStatusLastWeek,
  UserStatusLastMonth,
  UserType,
  UserTypeRegular,
  UserTypeDeleted,
  UserTypeBot,
  UserTypeUnknown,
  Users,
  ValidatedOrderInfo,
  Venue,
  Video,
  VideoNote,
  VoiceNote,
  Wallpaper,
  Wallpapers,
  WebPage,
  WebPageInstantView,
  AcceptCall,
  AcceptTermsOfService,
  AddChatMember,
  AddChatMembers,
  AddCustomServerLanguagePack,
  AddFavoriteSticker,
  AddLocalMessage,
  AddLogMessage,
  AddNetworkStatistics,
  AddProxy,
  AddRecentSticker,
  AddRecentlyFoundChat,
  AddSavedAnimation,
  AddStickerToSet,
  AnswerCallbackQuery,
  AnswerCustomQuery,
  AnswerInlineQuery,
  AnswerPreCheckoutQuery,
  AnswerShippingQuery,
  BlockUser,
  CancelDownloadFile,
  CancelUploadFile,
  ChangeChatReportSpamState,
  ChangeImportedContacts,
  ChangePhoneNumber,
  ChangeStickerSet,
  CheckAuthenticationBotToken,
  CheckAuthenticationCode,
  CheckAuthenticationPassword,
  CheckChangePhoneNumberCode,
  CheckChatInviteLink,
  CheckChatUsername,
  CheckDatabaseEncryptionKey,
  CheckEmailAddressVerificationCode,
  CheckPhoneNumberConfirmationCode,
  CheckPhoneNumberVerificationCode,
  CheckRecoveryEmailAddressCode,
  CleanFileName,
  ClearAllDraftMessages,
  ClearImportedContacts,
  ClearRecentStickers,
  ClearRecentlyFoundChats,
  Close,
  CloseChat,
  CloseSecretChat,
  CreateBasicGroupChat,
  CreateCall,
  CreateNewBasicGroupChat,
  CreateNewSecretChat,
  CreateNewStickerSet,
  CreateNewSupergroupChat,
  CreatePrivateChat,
  CreateSecretChat,
  CreateSupergroupChat,
  CreateTemporaryPassword,
  DeleteAccount,
  DeleteChatHistory,
  DeleteChatMessagesFromUser,
  DeleteChatReplyMarkup,
  DeleteFile,
  DeleteLanguagePack,
  DeleteMessages,
  DeletePassportElement,
  DeleteProfilePhoto,
  DeleteSavedCredentials,
  DeleteSavedOrderInfo,
  DeleteSupergroup,
  Destroy,
  DisableProxy,
  DiscardCall,
  DisconnectAllWebsites,
  DisconnectWebsite,
  DownloadFile,
  EditCustomLanguagePackInfo,
  EditInlineMessageCaption,
  EditInlineMessageLiveLocation,
  EditInlineMessageMedia,
  EditInlineMessageReplyMarkup,
  EditInlineMessageText,
  EditMessageCaption,
  EditMessageLiveLocation,
  EditMessageMedia,
  EditMessageReplyMarkup,
  EditMessageText,
  EditProxy,
  EnableProxy,
  FinishFileGeneration,
  ForwardMessages,
  GenerateChatInviteLink,
  GetAccountTtl,
  GetActiveLiveLocationMessages,
  GetActiveSessions,
  GetAllPassportElements,
  GetApplicationConfig,
  GetArchivedStickerSets,
  GetAttachedStickerSets,
  GetAuthorizationState,
  GetBasicGroup,
  GetBasicGroupFullInfo,
  GetBlockedUsers,
  GetCallbackQueryAnswer,
  GetChat,
  GetChatAdministrators,
  GetChatEventLog,
  GetChatHistory,
  GetChatMember,
  GetChatMessageByDate,
  GetChatMessageCount,
  GetChatNotificationSettingsExceptions,
  GetChatPinnedMessage,
  GetChatReportSpamState,
  GetChatStatisticsUrl,
  GetChats,
  GetConnectedWebsites,
  GetContacts,
  GetCountryCode,
  GetCreatedPublicChats,
  GetCurrentState,
  GetDatabaseStatistics,
  GetDeepLinkInfo,
  GetFavoriteStickers,
  GetFile,
  GetFileDownloadedPrefixSize,
  GetFileExtension,
  GetFileMimeType,
  GetGameHighScores,
  GetGroupsInCommon,
  GetImportedContactCount,
  GetInlineGameHighScores,
  GetInlineQueryResults,
  GetInstalledStickerSets,
  GetInviteText,
  GetLanguagePackInfo,
  GetLanguagePackString,
  GetLanguagePackStrings,
  GetLocalizationTargetInfo,
  GetLogStream,
  GetLogTagVerbosityLevel,
  GetLogTags,
  GetLogVerbosityLevel,
  GetMapThumbnailFile,
  GetMe,
  GetMessage,
  GetMessageLink,
  GetMessageLocally,
  GetMessages,
  GetNetworkStatistics,
  GetOption,
  GetPassportAuthorizationForm,
  GetPassportAuthorizationFormAvailableElements,
  GetPassportElement,
  GetPasswordState,
  GetPaymentForm,
  GetPaymentReceipt,
  GetPreferredCountryLanguage,
  GetProxies,
  GetProxyLink,
  GetPublicMessageLink,
  GetPushReceiverId,
  GetRecentInlineBots,
  GetRecentStickers,
  GetRecentlyVisitedTMeUrls,
  GetRecoveryEmailAddress,
  GetRemoteFile,
  GetRepliedMessage,
  GetSavedAnimations,
  GetSavedOrderInfo,
  GetScopeNotificationSettings,
  GetSecretChat,
  GetStickerEmojis,
  GetStickerSet,
  GetStickers,
  GetStorageStatistics,
  GetStorageStatisticsFast,
  GetSupergroup,
  GetSupergroupFullInfo,
  GetSupergroupMembers,
  GetSupportUser,
  GetTemporaryPasswordState,
  GetTextEntities,
  GetTopChats,
  GetTrendingStickerSets,
  GetUser,
  GetUserFullInfo,
  GetUserPrivacySettingRules,
  GetUserProfilePhotos,
  GetWallpapers,
  GetWebPageInstantView,
  GetWebPagePreview,
  ImportContacts,
  JoinChat,
  JoinChatByInviteLink,
  LeaveChat,
  LogOut,
  OpenChat,
  OpenMessageContent,
  OptimizeStorage,
  ParseTextEntities,
  PinChatMessage,
  PingProxy,
  ProcessPushNotification,
  ReadAllChatMentions,
  ReadFilePart,
  RecoverAuthenticationPassword,
  RecoverPassword,
  RegisterDevice,
  RemoveContacts,
  RemoveFavoriteSticker,
  RemoveNotification,
  RemoveNotificationGroup,
  RemoveProxy,
  RemoveRecentHashtag,
  RemoveRecentSticker,
  RemoveRecentlyFoundChat,
  RemoveSavedAnimation,
  RemoveStickerFromSet,
  RemoveTopChat,
  ReorderInstalledStickerSets,
  ReportChat,
  ReportSupergroupSpam,
  RequestAuthenticationPasswordRecovery,
  RequestPasswordRecovery,
  ResendAuthenticationCode,
  ResendChangePhoneNumberCode,
  ResendEmailAddressVerificationCode,
  ResendPhoneNumberConfirmationCode,
  ResendPhoneNumberVerificationCode,
  ResendRecoveryEmailAddressCode,
  ResetAllNotificationSettings,
  ResetNetworkStatistics,
  SearchCallMessages,
  SearchChatMembers,
  SearchChatMessages,
  SearchChatRecentLocationMessages,
  SearchChats,
  SearchChatsOnServer,
  SearchContacts,
  SearchHashtags,
  SearchInstalledStickerSets,
  SearchMessages,
  SearchPublicChat,
  SearchPublicChats,
  SearchSecretMessages,
  SearchStickerSet,
  SearchStickerSets,
  SearchStickers,
  SendBotStartMessage,
  SendCallDebugInformation,
  SendCallRating,
  SendChatAction,
  SendChatScreenshotTakenNotification,
  SendChatSetTtlMessage,
  SendCustomRequest,
  SendEmailAddressVerificationCode,
  SendInlineQueryResultMessage,
  SendMessage,
  SendMessageAlbum,
  SendPassportAuthorizationForm,
  SendPaymentForm,
  SendPhoneNumberConfirmationCode,
  SendPhoneNumberVerificationCode,
  SetAccountTtl,
  SetAlarm,
  SetAuthenticationPhoneNumber,
  SetBio,
  SetBotUpdatesStatus,
  SetChatClientData,
  SetChatDraftMessage,
  SetChatMemberStatus,
  SetChatNotificationSettings,
  SetChatPhoto,
  SetChatTitle,
  SetCustomLanguagePack,
  SetCustomLanguagePackString,
  SetDatabaseEncryptionKey,
  SetFileGenerationProgress,
  SetGameScore,
  SetInlineGameScore,
  SetLogStream,
  SetLogTagVerbosityLevel,
  SetLogVerbosityLevel,
  SetName,
  SetNetworkType,
  SetOption,
  SetPassportElement,
  SetPassportElementErrors,
  SetPassword,
  SetPinnedChats,
  SetPollAnswer,
  SetProfilePhoto,
  SetRecoveryEmailAddress,
  SetScopeNotificationSettings,
  SetStickerPositionInSet,
  SetSupergroupDescription,
  SetSupergroupStickerSet,
  SetSupergroupUsername,
  SetTdlibParameters,
  SetUserPrivacySettingRules,
  SetUsername,
  StopPoll,
  SynchronizeLanguagePack,
  TerminateAllOtherSessions,
  TerminateSession,
  TestCallBytes,
  TestCallEmpty,
  TestCallString,
  TestCallVectorInt,
  TestCallVectorIntObject,
  TestCallVectorString,
  TestCallVectorStringObject,
  TestGetDifference,
  TestNetwork,
  TestSquareInt,
  TestUseError,
  TestUseUpdate,
  ToggleBasicGroupAdministrators,
  ToggleChatDefaultDisableNotification,
  ToggleChatIsMarkedAsUnread,
  ToggleChatIsPinned,
  ToggleSupergroupInvites,
  ToggleSupergroupIsAllHistoryAvailable,
  ToggleSupergroupSignMessages,
  UnblockUser,
  UnpinChatMessage,
  UpgradeBasicGroupChatToSupergroupChat,
  UploadFile,
  UploadStickerFile,
  ValidateOrderInfo,
  ViewMessages,
  ViewTrendingStickerSets,
  WriteGeneratedFilePart,
  
}

impl RTDType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}

/// This class is a base class for all TDLib API classes. 

pub trait Object: RObject + Debug {}










/// This class is a base class for all TDLib API functions. 

pub trait Function: Object + RObject + Debug {}








#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDFunctionType {
  AcceptCall,
  AcceptTermsOfService,
  AddChatMember,
  AddChatMembers,
  AddCustomServerLanguagePack,
  AddFavoriteSticker,
  AddLocalMessage,
  AddLogMessage,
  AddNetworkStatistics,
  AddProxy,
  AddRecentlyFoundChat,
  AddRecentSticker,
  AddSavedAnimation,
  AddStickerToSet,
  AnswerCallbackQuery,
  AnswerCustomQuery,
  AnswerInlineQuery,
  AnswerPreCheckoutQuery,
  AnswerShippingQuery,
  BlockUser,
  CancelDownloadFile,
  CancelUploadFile,
  ChangeChatReportSpamState,
  ChangeImportedContacts,
  ChangePhoneNumber,
  ChangeStickerSet,
  CheckAuthenticationBotToken,
  CheckAuthenticationCode,
  CheckAuthenticationPassword,
  CheckChangePhoneNumberCode,
  CheckChatInviteLink,
  CheckChatUsername,
  CheckDatabaseEncryptionKey,
  CheckEmailAddressVerificationCode,
  CheckPhoneNumberConfirmationCode,
  CheckPhoneNumberVerificationCode,
  CheckRecoveryEmailAddressCode,
  CleanFileName,
  ClearAllDraftMessages,
  ClearImportedContacts,
  ClearRecentlyFoundChats,
  ClearRecentStickers,
  Close,
  CloseChat,
  CloseSecretChat,
  CreateBasicGroupChat,
  CreateCall,
  CreateNewBasicGroupChat,
  CreateNewSecretChat,
  CreateNewStickerSet,
  CreateNewSupergroupChat,
  CreatePrivateChat,
  CreateSecretChat,
  CreateSupergroupChat,
  CreateTemporaryPassword,
  DeleteAccount,
  DeleteChatHistory,
  DeleteChatMessagesFromUser,
  DeleteChatReplyMarkup,
  DeleteFile,
  DeleteLanguagePack,
  DeleteMessages,
  DeletePassportElement,
  DeleteProfilePhoto,
  DeleteSavedCredentials,
  DeleteSavedOrderInfo,
  DeleteSupergroup,
  Destroy,
  DisableProxy,
  DiscardCall,
  DisconnectAllWebsites,
  DisconnectWebsite,
  DownloadFile,
  EditCustomLanguagePackInfo,
  EditInlineMessageCaption,
  EditInlineMessageLiveLocation,
  EditInlineMessageMedia,
  EditInlineMessageReplyMarkup,
  EditInlineMessageText,
  EditMessageCaption,
  EditMessageLiveLocation,
  EditMessageMedia,
  EditMessageReplyMarkup,
  EditMessageText,
  EditProxy,
  EnableProxy,
  FinishFileGeneration,
  ForwardMessages,
  GenerateChatInviteLink,
  GetAccountTtl,
  GetActiveLiveLocationMessages,
  GetActiveSessions,
  GetAllPassportElements,
  GetApplicationConfig,
  GetArchivedStickerSets,
  GetAttachedStickerSets,
  GetAuthorizationState,
  GetBasicGroup,
  GetBasicGroupFullInfo,
  GetBlockedUsers,
  GetCallbackQueryAnswer,
  GetChat,
  GetChatAdministrators,
  GetChatEventLog,
  GetChatHistory,
  GetChatMember,
  GetChatMessageByDate,
  GetChatMessageCount,
  GetChatNotificationSettingsExceptions,
  GetChatPinnedMessage,
  GetChatReportSpamState,
  GetChats,
  GetChatStatisticsUrl,
  GetConnectedWebsites,
  GetContacts,
  GetCountryCode,
  GetCreatedPublicChats,
  GetCurrentState,
  GetDatabaseStatistics,
  GetDeepLinkInfo,
  GetFavoriteStickers,
  GetFile,
  GetFileDownloadedPrefixSize,
  GetFileExtension,
  GetFileMimeType,
  GetGameHighScores,
  GetGroupsInCommon,
  GetImportedContactCount,
  GetInlineGameHighScores,
  GetInlineQueryResults,
  GetInstalledStickerSets,
  GetInviteText,
  GetJsonString,
  GetJsonValue,
  GetLanguagePackInfo,
  GetLanguagePackString,
  GetLanguagePackStrings,
  GetLocalizationTargetInfo,
  GetLogStream,
  GetLogTags,
  GetLogTagVerbosityLevel,
  GetLogVerbosityLevel,
  GetMapThumbnailFile,
  GetMe,
  GetMessage,
  GetMessageLink,
  GetMessageLocally,
  GetMessages,
  GetNetworkStatistics,
  GetOption,
  GetPassportAuthorizationForm,
  GetPassportAuthorizationFormAvailableElements,
  GetPassportElement,
  GetPasswordState,
  GetPaymentForm,
  GetPaymentReceipt,
  GetPreferredCountryLanguage,
  GetProxies,
  GetProxyLink,
  GetPublicMessageLink,
  GetPushReceiverId,
  GetRecentInlineBots,
  GetRecentlyVisitedTMeUrls,
  GetRecentStickers,
  GetRecoveryEmailAddress,
  GetRemoteFile,
  GetRepliedMessage,
  GetSavedAnimations,
  GetSavedOrderInfo,
  GetScopeNotificationSettings,
  GetSecretChat,
  GetStickerEmojis,
  GetStickers,
  GetStickerSet,
  GetStorageStatistics,
  GetStorageStatisticsFast,
  GetSupergroup,
  GetSupergroupFullInfo,
  GetSupergroupMembers,
  GetSupportUser,
  GetTemporaryPasswordState,
  GetTextEntities,
  GetTopChats,
  GetTrendingStickerSets,
  GetUser,
  GetUserFullInfo,
  GetUserPrivacySettingRules,
  GetUserProfilePhotos,
  GetWallpapers,
  GetWebPageInstantView,
  GetWebPagePreview,
  ImportContacts,
  JoinChat,
  JoinChatByInviteLink,
  LeaveChat,
  LogOut,
  OpenChat,
  OpenMessageContent,
  OptimizeStorage,
  ParseTextEntities,
  PinChatMessage,
  PingProxy,
  ProcessPushNotification,
  ReadAllChatMentions,
  ReadFilePart,
  RecoverAuthenticationPassword,
  RecoverPassword,
  RegisterDevice,
  RemoveContacts,
  RemoveFavoriteSticker,
  RemoveNotification,
  RemoveNotificationGroup,
  RemoveProxy,
  RemoveRecentHashtag,
  RemoveRecentlyFoundChat,
  RemoveRecentSticker,
  RemoveSavedAnimation,
  RemoveStickerFromSet,
  RemoveTopChat,
  ReorderInstalledStickerSets,
  ReportChat,
  ReportSupergroupSpam,
  RequestAuthenticationPasswordRecovery,
  RequestPasswordRecovery,
  ResendAuthenticationCode,
  ResendChangePhoneNumberCode,
  ResendEmailAddressVerificationCode,
  ResendPhoneNumberConfirmationCode,
  ResendPhoneNumberVerificationCode,
  ResendRecoveryEmailAddressCode,
  ResetAllNotificationSettings,
  ResetNetworkStatistics,
  SaveApplicationLogEvent,
  SearchCallMessages,
  SearchChatMembers,
  SearchChatMessages,
  SearchChatRecentLocationMessages,
  SearchChats,
  SearchChatsOnServer,
  SearchContacts,
  SearchHashtags,
  SearchInstalledStickerSets,
  SearchMessages,
  SearchPublicChat,
  SearchPublicChats,
  SearchSecretMessages,
  SearchStickers,
  SearchStickerSet,
  SearchStickerSets,
  SendBotStartMessage,
  SendCallDebugInformation,
  SendCallRating,
  SendChatAction,
  SendChatScreenshotTakenNotification,
  SendChatSetTtlMessage,
  SendCustomRequest,
  SendEmailAddressVerificationCode,
  SendInlineQueryResultMessage,
  SendMessage,
  SendMessageAlbum,
  SendPassportAuthorizationForm,
  SendPaymentForm,
  SendPhoneNumberConfirmationCode,
  SendPhoneNumberVerificationCode,
  SetAccountTtl,
  SetAlarm,
  SetAuthenticationPhoneNumber,
  SetBio,
  SetBotUpdatesStatus,
  SetChatClientData,
  SetChatDraftMessage,
  SetChatMemberStatus,
  SetChatNotificationSettings,
  SetChatPhoto,
  SetChatTitle,
  SetCustomLanguagePack,
  SetCustomLanguagePackString,
  SetDatabaseEncryptionKey,
  SetFileGenerationProgress,
  SetGameScore,
  SetInlineGameScore,
  SetLogStream,
  SetLogTagVerbosityLevel,
  SetLogVerbosityLevel,
  SetName,
  SetNetworkType,
  SetOption,
  SetPassportElement,
  SetPassportElementErrors,
  SetPassword,
  SetPinnedChats,
  SetPollAnswer,
  SetProfilePhoto,
  SetRecoveryEmailAddress,
  SetScopeNotificationSettings,
  SetStickerPositionInSet,
  SetSupergroupDescription,
  SetSupergroupStickerSet,
  SetSupergroupUsername,
  SetTdlibParameters,
  SetUsername,
  SetUserPrivacySettingRules,
  StopPoll,
  SynchronizeLanguagePack,
  TerminateAllOtherSessions,
  TerminateSession,
  TestCallBytes,
  TestCallEmpty,
  TestCallString,
  TestCallVectorInt,
  TestCallVectorIntObject,
  TestCallVectorString,
  TestCallVectorStringObject,
  TestGetDifference,
  TestNetwork,
  TestSquareInt,
  TestUseError,
  TestUseUpdate,
  ToggleBasicGroupAdministrators,
  ToggleChatDefaultDisableNotification,
  ToggleChatIsMarkedAsUnread,
  ToggleChatIsPinned,
  ToggleSupergroupInvites,
  ToggleSupergroupIsAllHistoryAvailable,
  ToggleSupergroupSignMessages,
  UnblockUser,
  UnpinChatMessage,
  UpgradeBasicGroupChatToSupergroupChat,
  UploadFile,
  UploadStickerFile,
  ValidateOrderInfo,
  ViewMessages,
  ViewTrendingStickerSets,
  WriteGeneratedFilePart,
  
}
impl RTDFunctionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Contains information about the period of inactivity after which the current user's account will automatically be deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // accountTtl
  /// Number of days of inactivity before the account will be flagged for deletion; should range from 30-366 days.
  days: Option<i32>,
  
}



impl Object for AccountTtl {}
impl RObject for AccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "accountTtl" }
  fn td_type(&self) -> RTDType { RTDType::AccountTtl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl AccountTtl {
  
  pub fn builder() -> RTDAccountTtlBuilder {
    let instance = Self {
      td_name: "accountTtl".to_string(),
      days: None,
      
    };
    RTDAccountTtlBuilder::new(instance)
  }
  
  
  pub fn days(&self) -> Option<i32> { self.days.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AccountTtl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAccountTtlBuilder { instance: AccountTtl }

impl RTDAccountTtlBuilder {
  fn new(instance: AccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> AccountTtl { self.instance.clone() }
  
  pub fn days(&mut self, days: i32) -> &mut Self {
    self.instance.days = Some(days);
    self
  }
  
}



/// Describes an address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // address
  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,
  /// State, if applicable.
  state: Option<String>,
  /// City.
  city: Option<String>,
  /// First line of the address.
  street_line1: Option<String>,
  /// Second line of the address.
  street_line2: Option<String>,
  /// Address postal code.
  postal_code: Option<String>,
  
}



impl Object for Address {}
impl RObject for Address {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "address" }
  fn td_type(&self) -> RTDType { RTDType::Address }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Address {
  
  pub fn builder() -> RTDAddressBuilder {
    let instance = Self {
      td_name: "address".to_string(),
      country_code: None,
      state: None,
      city: None,
      street_line1: None,
      street_line2: None,
      postal_code: None,
      
    };
    RTDAddressBuilder::new(instance)
  }
  
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn state(&self) -> Option<String> { self.state.clone() }
  
  pub fn city(&self) -> Option<String> { self.city.clone() }
  
  pub fn street_line1(&self) -> Option<String> { self.street_line1.clone() }
  
  pub fn street_line2(&self) -> Option<String> { self.street_line2.clone() }
  
  pub fn postal_code(&self) -> Option<String> { self.postal_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Address> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddressBuilder { instance: Address }

impl RTDAddressBuilder {
  fn new(instance: Address) -> Self { Self { instance } }

  pub fn build(&self) -> Address { self.instance.clone() }
  
  pub fn country_code<S: AsRef<str>>(&mut self, country_code: S) -> &mut Self {
    self.instance.country_code = Some(country_code.as_ref().to_string());
    self
  }
  
  pub fn state<S: AsRef<str>>(&mut self, state: S) -> &mut Self {
    self.instance.state = Some(state.as_ref().to_string());
    self
  }
  
  pub fn city<S: AsRef<str>>(&mut self, city: S) -> &mut Self {
    self.instance.city = Some(city.as_ref().to_string());
    self
  }
  
  pub fn street_line1<S: AsRef<str>>(&mut self, street_line1: S) -> &mut Self {
    self.instance.street_line1 = Some(street_line1.as_ref().to_string());
    self
  }
  
  pub fn street_line2<S: AsRef<str>>(&mut self, street_line2: S) -> &mut Self {
    self.instance.street_line2 = Some(street_line2.as_ref().to_string());
    self
  }
  
  pub fn postal_code<S: AsRef<str>>(&mut self, postal_code: S) -> &mut Self {
    self.instance.postal_code = Some(postal_code.as_ref().to_string());
    self
  }
  
}



/// Describes an animation file. The animation must be encoded in GIF or MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // animation
  /// Duration of the animation, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Width of the animation.
  width: Option<i32>,
  /// Height of the animation.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file, usually "image/gif" or "video/mp4".
  mime_type: Option<String>,
  /// Animation thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the animation.
  animation: Option<File>,
  
}



impl Object for Animation {}
impl RObject for Animation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "animation" }
  fn td_type(&self) -> RTDType { RTDType::Animation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Animation {
  
  pub fn builder() -> RTDAnimationBuilder {
    let instance = Self {
      td_name: "animation".to_string(),
      duration: None,
      width: None,
      height: None,
      file_name: None,
      mime_type: None,
      thumbnail: None,
      animation: None,
      
    };
    RTDAnimationBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn animation(&self) -> Option<File> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Animation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnimationBuilder { instance: Animation }

impl RTDAnimationBuilder {
  fn new(instance: Animation) -> Self { Self { instance } }

  pub fn build(&self) -> Animation { self.instance.clone() }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn animation(&mut self, animation: File) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}



/// Represents a list of animations. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // animations
  /// List of animations.
  animations: Option<Vec<Animation>>,
  
}



impl Object for Animations {}
impl RObject for Animations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "animations" }
  fn td_type(&self) -> RTDType { RTDType::Animations }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Animations {
  
  pub fn builder() -> RTDAnimationsBuilder {
    let instance = Self {
      td_name: "animations".to_string(),
      animations: None,
      
    };
    RTDAnimationsBuilder::new(instance)
  }
  
  
  pub fn animations(&self) -> Option<Vec<Animation>> { self.animations.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Animations> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnimationsBuilder { instance: Animations }

impl RTDAnimationsBuilder {
  fn new(instance: Animations) -> Self { Self { instance } }

  pub fn build(&self) -> Animations { self.instance.clone() }
  
  pub fn animations(&mut self, animations: Vec<Animation>) -> &mut Self {
    self.instance.animations = Some(animations);
    self
  }
  
}



/// Describes an audio file. Audio is usually in MP3 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Audio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // audio
  /// Duration of the audio, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Title of the audio; as defined by the sender.
  title: Option<String>,
  /// Performer of the audio; as defined by the sender.
  performer: Option<String>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// The MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// The thumbnail of the album cover; as defined by the sender. The full size thumbnail should be extracted from the downloaded file; may be null.
  album_cover_thumbnail: Option<PhotoSize>,
  /// File containing the audio.
  audio: Option<File>,
  
}



impl Object for Audio {}
impl RObject for Audio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "audio" }
  fn td_type(&self) -> RTDType { RTDType::Audio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Audio {
  
  pub fn builder() -> RTDAudioBuilder {
    let instance = Self {
      td_name: "audio".to_string(),
      duration: None,
      title: None,
      performer: None,
      file_name: None,
      mime_type: None,
      album_cover_thumbnail: None,
      audio: None,
      
    };
    RTDAudioBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn album_cover_thumbnail(&self) -> Option<PhotoSize> { self.album_cover_thumbnail.clone() }
  
  pub fn audio(&self) -> Option<File> { self.audio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Audio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAudioBuilder { instance: Audio }

impl RTDAudioBuilder {
  fn new(instance: Audio) -> Self { Self { instance } }

  pub fn build(&self) -> Audio { self.instance.clone() }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn performer<S: AsRef<str>>(&mut self, performer: S) -> &mut Self {
    self.instance.performer = Some(performer.as_ref().to_string());
    self
  }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn album_cover_thumbnail(&mut self, album_cover_thumbnail: PhotoSize) -> &mut Self {
    self.instance.album_cover_thumbnail = Some(album_cover_thumbnail);
    self
  }
  
  pub fn audio(&mut self, audio: File) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
}



/// Information about the authentication code that was sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeInfo
  /// A phone number that is being authenticated.
  phone_number: Option<String>,
  /// Describes the way the code was sent to the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<AuthenticationCodeType>>,
  /// Describes the way the next code will be sent to the user; may be null.
  next_type: Option<Box<AuthenticationCodeType>>,
  /// Timeout before the code should be re-sent, in seconds.
  timeout: Option<i32>,
  
}


impl Clone for AuthenticationCodeInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AuthenticationCodeInfo {}
impl RObject for AuthenticationCodeInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeInfo" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl AuthenticationCodeInfo {
  
  pub fn builder() -> RTDAuthenticationCodeInfoBuilder {
    let instance = Self {
      td_name: "authenticationCodeInfo".to_string(),
      phone_number: None,
      type_: None,
      next_type: None,
      timeout: None,
      
    };
    RTDAuthenticationCodeInfoBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn type_(&self) -> Option<Box<AuthenticationCodeType>> { self.type_.clone() }
  
  pub fn next_type(&self) -> Option<Box<AuthenticationCodeType>> { self.next_type.clone() }
  
  pub fn timeout(&self) -> Option<i32> { self.timeout.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthenticationCodeInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAuthenticationCodeInfoBuilder { instance: AuthenticationCodeInfo }

impl RTDAuthenticationCodeInfoBuilder {
  fn new(instance: AuthenticationCodeInfo) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeInfo { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn type_(&mut self, type_: Box<AuthenticationCodeType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn next_type(&mut self, next_type: Box<AuthenticationCodeType>) -> &mut Self {
    self.instance.next_type = Some(next_type);
    self
  }
  
  pub fn timeout(&mut self, timeout: i32) -> &mut Self {
    self.instance.timeout = Some(timeout);
    self
  }
  
}



/// This class is an abstract base class. Provides information about the method by which an authentication code is delivered to the user. 
#[typetag::serde(tag = "@struct")]
pub trait AuthenticationCodeType: Object + RObject + Debug {}







impl AuthenticationCodeType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<AuthenticationCodeType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<AuthenticationCodeType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDAuthenticationCodeTypeType {
  AuthenticationCodeTypeCall,
  AuthenticationCodeTypeFlashCall,
  AuthenticationCodeTypeSms,
  AuthenticationCodeTypeTelegramMessage,
  
}
impl RTDAuthenticationCodeTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// An authentication code is delivered via a private Telegram message, which can be viewed in another client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeTelegramMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeTelegramMessage
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeTelegramMessage {}
impl RObject for AuthenticationCodeTypeTelegramMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeTelegramMessage" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeTelegramMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeTelegramMessage {}


impl AuthenticationCodeTypeTelegramMessage {
  
  pub fn builder() -> RTDAuthenticationCodeTypeTelegramMessageBuilder {
    let instance = Self {
      td_name: "authenticationCodeTypeTelegramMessage".to_string(),
      length: None,
      
    };
    RTDAuthenticationCodeTypeTelegramMessageBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthenticationCodeTypeTelegramMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAuthenticationCodeTypeTelegramMessageBuilder { instance: AuthenticationCodeTypeTelegramMessage }

impl RTDAuthenticationCodeTypeTelegramMessageBuilder {
  fn new(instance: AuthenticationCodeTypeTelegramMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeTelegramMessage { self.instance.clone() }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}



/// An authentication code is delivered via an SMS message to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeSms {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeSms
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeSms {}
impl RObject for AuthenticationCodeTypeSms {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeSms" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeSms }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeSms {}


impl AuthenticationCodeTypeSms {
  
  pub fn builder() -> RTDAuthenticationCodeTypeSmsBuilder {
    let instance = Self {
      td_name: "authenticationCodeTypeSms".to_string(),
      length: None,
      
    };
    RTDAuthenticationCodeTypeSmsBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthenticationCodeTypeSms> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAuthenticationCodeTypeSmsBuilder { instance: AuthenticationCodeTypeSms }

impl RTDAuthenticationCodeTypeSmsBuilder {
  fn new(instance: AuthenticationCodeTypeSms) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeSms { self.instance.clone() }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}



/// An authentication code is delivered via a phone call to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeCall
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeCall {}
impl RObject for AuthenticationCodeTypeCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeCall" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeCall {}


impl AuthenticationCodeTypeCall {
  
  pub fn builder() -> RTDAuthenticationCodeTypeCallBuilder {
    let instance = Self {
      td_name: "authenticationCodeTypeCall".to_string(),
      length: None,
      
    };
    RTDAuthenticationCodeTypeCallBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthenticationCodeTypeCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAuthenticationCodeTypeCallBuilder { instance: AuthenticationCodeTypeCall }

impl RTDAuthenticationCodeTypeCallBuilder {
  fn new(instance: AuthenticationCodeTypeCall) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeCall { self.instance.clone() }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}



/// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeFlashCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeFlashCall
  /// Pattern of the phone number from which the call will be made.
  pattern: Option<String>,
  
}



impl Object for AuthenticationCodeTypeFlashCall {}
impl RObject for AuthenticationCodeTypeFlashCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeFlashCall" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeFlashCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeFlashCall {}


impl AuthenticationCodeTypeFlashCall {
  
  pub fn builder() -> RTDAuthenticationCodeTypeFlashCallBuilder {
    let instance = Self {
      td_name: "authenticationCodeTypeFlashCall".to_string(),
      pattern: None,
      
    };
    RTDAuthenticationCodeTypeFlashCallBuilder::new(instance)
  }
  
  
  pub fn pattern(&self) -> Option<String> { self.pattern.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthenticationCodeTypeFlashCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAuthenticationCodeTypeFlashCallBuilder { instance: AuthenticationCodeTypeFlashCall }

impl RTDAuthenticationCodeTypeFlashCallBuilder {
  fn new(instance: AuthenticationCodeTypeFlashCall) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeFlashCall { self.instance.clone() }
  
  pub fn pattern<S: AsRef<str>>(&mut self, pattern: S) -> &mut Self {
    self.instance.pattern = Some(pattern.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Represents the current authorization state of the client. 
#[typetag::serde(tag = "@struct")]
pub trait AuthorizationState: Object + RObject + Debug {}







impl AuthorizationState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<AuthorizationState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<AuthorizationState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDAuthorizationStateType {
  AuthorizationStateClosed,
  AuthorizationStateClosing,
  AuthorizationStateLoggingOut,
  AuthorizationStateReady,
  AuthorizationStateWaitCode,
  AuthorizationStateWaitEncryptionKey,
  AuthorizationStateWaitPassword,
  AuthorizationStateWaitPhoneNumber,
  AuthorizationStateWaitTdlibParameters,
  
}
impl RTDAuthorizationStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// TDLib needs TdlibParameters for initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitTdlibParameters
  
}



impl Object for AuthorizationStateWaitTdlibParameters {}
impl RObject for AuthorizationStateWaitTdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitTdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitTdlibParameters }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitTdlibParameters {}


impl AuthorizationStateWaitTdlibParameters {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateWaitTdlibParameters> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// TDLib needs an encryption key to decrypt the local database. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitEncryptionKey
  /// True, if the database is currently encrypted.
  is_encrypted: Option<bool>,
  
}



impl Object for AuthorizationStateWaitEncryptionKey {}
impl RObject for AuthorizationStateWaitEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitEncryptionKey }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitEncryptionKey {}


impl AuthorizationStateWaitEncryptionKey {
  
  
  pub fn is_encrypted(&self) -> Option<bool> { self.is_encrypted.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateWaitEncryptionKey> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// TDLib needs the user's phone number to authorize. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitPhoneNumber
  
}



impl Object for AuthorizationStateWaitPhoneNumber {}
impl RObject for AuthorizationStateWaitPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitPhoneNumber {}


impl AuthorizationStateWaitPhoneNumber {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateWaitPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// TDLib needs the user's authentication code to finalize authorization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitCode
  /// True, if the user is already registered.
  is_registered: Option<bool>,
  /// Telegram terms of service, which should be accepted before user can continue registration; may be null.
  terms_of_service: Option<TermsOfService>,
  /// Information about the authorization code that was sent.
  code_info: Option<AuthenticationCodeInfo>,
  
}



impl Object for AuthorizationStateWaitCode {}
impl RObject for AuthorizationStateWaitCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitCode" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitCode {}


impl AuthorizationStateWaitCode {
  
  
  pub fn is_registered(&self) -> Option<bool> { self.is_registered.clone() }
  
  pub fn terms_of_service(&self) -> Option<TermsOfService> { self.terms_of_service.clone() }
  
  pub fn code_info(&self) -> Option<AuthenticationCodeInfo> { self.code_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateWaitCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The user has been authorized, but needs to enter a password to start using the application. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitPassword
  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True if a recovery email address has been set up.
  has_recovery_email_address: Option<bool>,
  /// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent.
  recovery_email_address_pattern: Option<String>,
  
}



impl Object for AuthorizationStateWaitPassword {}
impl RObject for AuthorizationStateWaitPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitPassword" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitPassword {}


impl AuthorizationStateWaitPassword {
  
  
  pub fn password_hint(&self) -> Option<String> { self.password_hint.clone() }
  
  pub fn has_recovery_email_address(&self) -> Option<bool> { self.has_recovery_email_address.clone() }
  
  pub fn recovery_email_address_pattern(&self) -> Option<String> { self.recovery_email_address_pattern.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateWaitPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The user has been successfully authorized. TDLib is now ready to answer queries. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateReady
  
}



impl Object for AuthorizationStateReady {}
impl RObject for AuthorizationStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateReady" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateReady }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateReady {}


impl AuthorizationStateReady {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateReady> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The user is currently logging out. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateLoggingOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateLoggingOut
  
}



impl Object for AuthorizationStateLoggingOut {}
impl RObject for AuthorizationStateLoggingOut {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateLoggingOut" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateLoggingOut }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateLoggingOut {}


impl AuthorizationStateLoggingOut {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateLoggingOut> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosing {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateClosing
  
}



impl Object for AuthorizationStateClosing {}
impl RObject for AuthorizationStateClosing {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateClosing" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateClosing }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateClosing {}


impl AuthorizationStateClosing {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateClosing> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one should create a new instance of the TDLib client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateClosed
  
}



impl Object for AuthorizationStateClosed {}
impl RObject for AuthorizationStateClosed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateClosed" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateClosed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateClosed {}


impl AuthorizationStateClosed {
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AuthorizationStateClosed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users). 
#[derive(Debug, Serialize, Deserialize)]
pub struct BasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // basicGroup
  /// Group identifier.
  id: Option<i32>,
  /// Number of members in the group.
  member_count: Option<i32>,
  /// Status of the current user in the group.
  status: Option<Box<ChatMemberStatus>>,
  /// True, if all members have been granted administrator rights in the group.
  everyone_is_administrator: Option<bool>,
  /// True, if the group is active.
  is_active: Option<bool>,
  /// Identifier of the supergroup to which this group was upgraded; 0 if none.
  upgraded_to_supergroup_id: Option<i32>,
  
}


impl Clone for BasicGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for BasicGroup {}
impl RObject for BasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "basicGroup" }
  fn td_type(&self) -> RTDType { RTDType::BasicGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl BasicGroup {
  
  pub fn builder() -> RTDBasicGroupBuilder {
    let instance = Self {
      td_name: "basicGroup".to_string(),
      id: None,
      member_count: None,
      status: None,
      everyone_is_administrator: None,
      is_active: None,
      upgraded_to_supergroup_id: None,
      
    };
    RTDBasicGroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn everyone_is_administrator(&self) -> Option<bool> { self.everyone_is_administrator.clone() }
  
  pub fn is_active(&self) -> Option<bool> { self.is_active.clone() }
  
  pub fn upgraded_to_supergroup_id(&self) -> Option<i32> { self.upgraded_to_supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<BasicGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDBasicGroupBuilder { instance: BasicGroup }

impl RTDBasicGroupBuilder {
  fn new(instance: BasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> BasicGroup { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn everyone_is_administrator(&mut self, everyone_is_administrator: bool) -> &mut Self {
    self.instance.everyone_is_administrator = Some(everyone_is_administrator);
    self
  }
  
  pub fn is_active(&mut self, is_active: bool) -> &mut Self {
    self.instance.is_active = Some(is_active);
    self
  }
  
  pub fn upgraded_to_supergroup_id(&mut self, upgraded_to_supergroup_id: i32) -> &mut Self {
    self.instance.upgraded_to_supergroup_id = Some(upgraded_to_supergroup_id);
    self
  }
  
}



/// Contains full information about a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // basicGroupFullInfo
  /// User identifier of the creator of the group; 0 if unknown.
  creator_user_id: Option<i32>,
  /// Group members.
  members: Option<Vec<ChatMember>>,
  /// Invite link for this group; available only for the group creator and only after it has been generated at least once.
  invite_link: Option<String>,
  
}



impl Object for BasicGroupFullInfo {}
impl RObject for BasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "basicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::BasicGroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl BasicGroupFullInfo {
  
  pub fn builder() -> RTDBasicGroupFullInfoBuilder {
    let instance = Self {
      td_name: "basicGroupFullInfo".to_string(),
      creator_user_id: None,
      members: None,
      invite_link: None,
      
    };
    RTDBasicGroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn creator_user_id(&self) -> Option<i32> { self.creator_user_id.clone() }
  
  pub fn members(&self) -> Option<Vec<ChatMember>> { self.members.clone() }
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<BasicGroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDBasicGroupFullInfoBuilder { instance: BasicGroupFullInfo }

impl RTDBasicGroupFullInfoBuilder {
  fn new(instance: BasicGroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> BasicGroupFullInfo { self.instance.clone() }
  
  pub fn creator_user_id(&mut self, creator_user_id: i32) -> &mut Self {
    self.instance.creator_user_id = Some(creator_user_id);
    self
  }
  
  pub fn members(&mut self, members: Vec<ChatMember>) -> &mut Self {
    self.instance.members = Some(members);
    self
  }
  
  pub fn invite_link<S: AsRef<str>>(&mut self, invite_link: S) -> &mut Self {
    self.instance.invite_link = Some(invite_link.as_ref().to_string());
    self
  }
  
}



/// Represents commands supported by a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // botCommand
  /// Text of the bot command.
  command: Option<String>,
  /// Description of the bot command.
  description: Option<String>,
  
}



impl Object for BotCommand {}
impl RObject for BotCommand {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "botCommand" }
  fn td_type(&self) -> RTDType { RTDType::BotCommand }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl BotCommand {
  
  pub fn builder() -> RTDBotCommandBuilder {
    let instance = Self {
      td_name: "botCommand".to_string(),
      command: None,
      description: None,
      
    };
    RTDBotCommandBuilder::new(instance)
  }
  
  
  pub fn command(&self) -> Option<String> { self.command.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<BotCommand> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDBotCommandBuilder { instance: BotCommand }

impl RTDBotCommandBuilder {
  fn new(instance: BotCommand) -> Self { Self { instance } }

  pub fn build(&self) -> BotCommand { self.instance.clone() }
  
  pub fn command<S: AsRef<str>>(&mut self, command: S) -> &mut Self {
    self.instance.command = Some(command.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Provides information about a bot and its supported commands. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // botInfo
  /// Long description shown on the user info page.
  description: Option<String>,
  /// A list of commands supported by the bot.
  commands: Option<Vec<BotCommand>>,
  
}



impl Object for BotInfo {}
impl RObject for BotInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "botInfo" }
  fn td_type(&self) -> RTDType { RTDType::BotInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl BotInfo {
  
  pub fn builder() -> RTDBotInfoBuilder {
    let instance = Self {
      td_name: "botInfo".to_string(),
      description: None,
      commands: None,
      
    };
    RTDBotInfoBuilder::new(instance)
  }
  
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn commands(&self) -> Option<Vec<BotCommand>> { self.commands.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<BotInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDBotInfoBuilder { instance: BotInfo }

impl RTDBotInfoBuilder {
  fn new(instance: BotInfo) -> Self { Self { instance } }

  pub fn build(&self) -> BotInfo { self.instance.clone() }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn commands(&mut self, commands: Vec<BotCommand>) -> &mut Self {
    self.instance.commands = Some(commands);
    self
  }
  
}



/// Describes a call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Call {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // call
  /// Call identifier, not persistent.
  id: Option<i32>,
  /// Peer user identifier.
  user_id: Option<i32>,
  /// True, if the call is outgoing.
  is_outgoing: Option<bool>,
  /// Call state.
  state: Option<Box<CallState>>,
  
}


impl Clone for Call {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Call {}
impl RObject for Call {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "call" }
  fn td_type(&self) -> RTDType { RTDType::Call }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Call {
  
  pub fn builder() -> RTDCallBuilder {
    let instance = Self {
      td_name: "call".to_string(),
      id: None,
      user_id: None,
      is_outgoing: None,
      state: None,
      
    };
    RTDCallBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn is_outgoing(&self) -> Option<bool> { self.is_outgoing.clone() }
  
  pub fn state(&self) -> Option<Box<CallState>> { self.state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Call> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallBuilder { instance: Call }

impl RTDCallBuilder {
  fn new(instance: Call) -> Self { Self { instance } }

  pub fn build(&self) -> Call { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn is_outgoing(&mut self, is_outgoing: bool) -> &mut Self {
    self.instance.is_outgoing = Some(is_outgoing);
    self
  }
  
  pub fn state(&mut self, state: Box<CallState>) -> &mut Self {
    self.instance.state = Some(state);
    self
  }
  
}



/// Describes the address of UDP reflectors. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallConnection {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callConnection
  /// Reflector identifier.
  id: Option<i64>,
  /// IPv4 reflector address.
  ip: Option<String>,
  /// IPv6 reflector address.
  ipv6: Option<String>,
  /// Reflector port number.
  port: Option<i32>,
  /// Connection peer tag.
  peer_tag: Option<String>,
  
}



impl Object for CallConnection {}
impl RObject for CallConnection {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callConnection" }
  fn td_type(&self) -> RTDType { RTDType::CallConnection }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl CallConnection {
  
  pub fn builder() -> RTDCallConnectionBuilder {
    let instance = Self {
      td_name: "callConnection".to_string(),
      id: None,
      ip: None,
      ipv6: None,
      port: None,
      peer_tag: None,
      
    };
    RTDCallConnectionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn ipv6(&self) -> Option<String> { self.ipv6.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn peer_tag(&self) -> Option<String> { self.peer_tag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallConnection> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallConnectionBuilder { instance: CallConnection }

impl RTDCallConnectionBuilder {
  fn new(instance: CallConnection) -> Self { Self { instance } }

  pub fn build(&self) -> CallConnection { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn ip<S: AsRef<str>>(&mut self, ip: S) -> &mut Self {
    self.instance.ip = Some(ip.as_ref().to_string());
    self
  }
  
  pub fn ipv6<S: AsRef<str>>(&mut self, ipv6: S) -> &mut Self {
    self.instance.ipv6 = Some(ipv6.as_ref().to_string());
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn peer_tag<S: AsRef<str>>(&mut self, peer_tag: S) -> &mut Self {
    self.instance.peer_tag = Some(peer_tag.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Describes the reason why a call was discarded. 
#[typetag::serde(tag = "@struct")]
pub trait CallDiscardReason: Object + RObject + Debug {}







impl CallDiscardReason {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<CallDiscardReason>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<CallDiscardReason> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallDiscardReasonType {
  CallDiscardReasonDeclined,
  CallDiscardReasonDisconnected,
  CallDiscardReasonEmpty,
  CallDiscardReasonHungUp,
  CallDiscardReasonMissed,
  
}
impl RTDCallDiscardReasonType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The call wasn't discarded, or the reason is unknown. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonEmpty
  
}



impl Object for CallDiscardReasonEmpty {}
impl RObject for CallDiscardReasonEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonEmpty" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonEmpty {}


impl CallDiscardReasonEmpty {
  
  pub fn builder() -> RTDCallDiscardReasonEmptyBuilder {
    let instance = Self {
      td_name: "callDiscardReasonEmpty".to_string(),
      
    };
    RTDCallDiscardReasonEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallDiscardReasonEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallDiscardReasonEmptyBuilder { instance: CallDiscardReasonEmpty }

impl RTDCallDiscardReasonEmptyBuilder {
  fn new(instance: CallDiscardReasonEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonEmpty { self.instance.clone() }
  
}



/// The call was ended before the conversation started. It was cancelled by the caller or missed by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonMissed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonMissed
  
}



impl Object for CallDiscardReasonMissed {}
impl RObject for CallDiscardReasonMissed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonMissed" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonMissed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonMissed {}


impl CallDiscardReasonMissed {
  
  pub fn builder() -> RTDCallDiscardReasonMissedBuilder {
    let instance = Self {
      td_name: "callDiscardReasonMissed".to_string(),
      
    };
    RTDCallDiscardReasonMissedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallDiscardReasonMissed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallDiscardReasonMissedBuilder { instance: CallDiscardReasonMissed }

impl RTDCallDiscardReasonMissedBuilder {
  fn new(instance: CallDiscardReasonMissed) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonMissed { self.instance.clone() }
  
}



/// The call was ended before the conversation started. It was declined by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDeclined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonDeclined
  
}



impl Object for CallDiscardReasonDeclined {}
impl RObject for CallDiscardReasonDeclined {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonDeclined" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonDeclined }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonDeclined {}


impl CallDiscardReasonDeclined {
  
  pub fn builder() -> RTDCallDiscardReasonDeclinedBuilder {
    let instance = Self {
      td_name: "callDiscardReasonDeclined".to_string(),
      
    };
    RTDCallDiscardReasonDeclinedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallDiscardReasonDeclined> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallDiscardReasonDeclinedBuilder { instance: CallDiscardReasonDeclined }

impl RTDCallDiscardReasonDeclinedBuilder {
  fn new(instance: CallDiscardReasonDeclined) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonDeclined { self.instance.clone() }
  
}



/// The call was ended during the conversation because the users were disconnected. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDisconnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonDisconnected
  
}



impl Object for CallDiscardReasonDisconnected {}
impl RObject for CallDiscardReasonDisconnected {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonDisconnected" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonDisconnected }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonDisconnected {}


impl CallDiscardReasonDisconnected {
  
  pub fn builder() -> RTDCallDiscardReasonDisconnectedBuilder {
    let instance = Self {
      td_name: "callDiscardReasonDisconnected".to_string(),
      
    };
    RTDCallDiscardReasonDisconnectedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallDiscardReasonDisconnected> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallDiscardReasonDisconnectedBuilder { instance: CallDiscardReasonDisconnected }

impl RTDCallDiscardReasonDisconnectedBuilder {
  fn new(instance: CallDiscardReasonDisconnected) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonDisconnected { self.instance.clone() }
  
}



/// The call was ended because one of the parties hung up. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonHungUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonHungUp
  
}



impl Object for CallDiscardReasonHungUp {}
impl RObject for CallDiscardReasonHungUp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonHungUp" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonHungUp }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonHungUp {}


impl CallDiscardReasonHungUp {
  
  pub fn builder() -> RTDCallDiscardReasonHungUpBuilder {
    let instance = Self {
      td_name: "callDiscardReasonHungUp".to_string(),
      
    };
    RTDCallDiscardReasonHungUpBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallDiscardReasonHungUp> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallDiscardReasonHungUpBuilder { instance: CallDiscardReasonHungUp }

impl RTDCallDiscardReasonHungUpBuilder {
  fn new(instance: CallDiscardReasonHungUp) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonHungUp { self.instance.clone() }
  
}



/// Contains the call identifier. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callId
  /// Call identifier.
  id: Option<i32>,
  
}



impl Object for CallId {}
impl RObject for CallId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callId" }
  fn td_type(&self) -> RTDType { RTDType::CallId }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl CallId {
  
  pub fn builder() -> RTDCallIdBuilder {
    let instance = Self {
      td_name: "callId".to_string(),
      id: None,
      
    };
    RTDCallIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallId> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallIdBuilder { instance: CallId }

impl RTDCallIdBuilder {
  fn new(instance: CallId) -> Self { Self { instance } }

  pub fn build(&self) -> CallId { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}



/// Specifies the supported call protocols. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallProtocol {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callProtocol
  /// True, if UDP peer-to-peer connections are supported.
  udp_p2p: Option<bool>,
  /// True, if connection through UDP reflectors is supported.
  udp_reflector: Option<bool>,
  /// Minimum supported API layer; use 65.
  min_layer: Option<i32>,
  /// Maximum supported API layer; use 65.
  max_layer: Option<i32>,
  
}



impl Object for CallProtocol {}
impl RObject for CallProtocol {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callProtocol" }
  fn td_type(&self) -> RTDType { RTDType::CallProtocol }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl CallProtocol {
  
  pub fn builder() -> RTDCallProtocolBuilder {
    let instance = Self {
      td_name: "callProtocol".to_string(),
      udp_p2p: None,
      udp_reflector: None,
      min_layer: None,
      max_layer: None,
      
    };
    RTDCallProtocolBuilder::new(instance)
  }
  
  
  pub fn udp_p2p(&self) -> Option<bool> { self.udp_p2p.clone() }
  
  pub fn udp_reflector(&self) -> Option<bool> { self.udp_reflector.clone() }
  
  pub fn min_layer(&self) -> Option<i32> { self.min_layer.clone() }
  
  pub fn max_layer(&self) -> Option<i32> { self.max_layer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallProtocol> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallProtocolBuilder { instance: CallProtocol }

impl RTDCallProtocolBuilder {
  fn new(instance: CallProtocol) -> Self { Self { instance } }

  pub fn build(&self) -> CallProtocol { self.instance.clone() }
  
  pub fn udp_p2p(&mut self, udp_p2p: bool) -> &mut Self {
    self.instance.udp_p2p = Some(udp_p2p);
    self
  }
  
  pub fn udp_reflector(&mut self, udp_reflector: bool) -> &mut Self {
    self.instance.udp_reflector = Some(udp_reflector);
    self
  }
  
  pub fn min_layer(&mut self, min_layer: i32) -> &mut Self {
    self.instance.min_layer = Some(min_layer);
    self
  }
  
  pub fn max_layer(&mut self, max_layer: i32) -> &mut Self {
    self.instance.max_layer = Some(max_layer);
    self
  }
  
}



/// This class is an abstract base class. Describes the current call state. 
#[typetag::serde(tag = "@struct")]
pub trait CallState: Object + RObject + Debug {}







impl CallState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<CallState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<CallState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallStateType {
  CallStateDiscarded,
  CallStateError,
  CallStateExchangingKeys,
  CallStateHangingUp,
  CallStatePending,
  CallStateReady,
  
}
impl RTDCallStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The call is pending, waiting to be accepted by a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStatePending
  /// True, if the call has already been created by the server.
  is_created: Option<bool>,
  /// True, if the call has already been received by the other party.
  is_received: Option<bool>,
  
}



impl Object for CallStatePending {}
impl RObject for CallStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStatePending" }
  fn td_type(&self) -> RTDType { RTDType::CallStatePending }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStatePending {}


impl CallStatePending {
  
  pub fn builder() -> RTDCallStatePendingBuilder {
    let instance = Self {
      td_name: "callStatePending".to_string(),
      is_created: None,
      is_received: None,
      
    };
    RTDCallStatePendingBuilder::new(instance)
  }
  
  
  pub fn is_created(&self) -> Option<bool> { self.is_created.clone() }
  
  pub fn is_received(&self) -> Option<bool> { self.is_received.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStatePending> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStatePendingBuilder { instance: CallStatePending }

impl RTDCallStatePendingBuilder {
  fn new(instance: CallStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> CallStatePending { self.instance.clone() }
  
  pub fn is_created(&mut self, is_created: bool) -> &mut Self {
    self.instance.is_created = Some(is_created);
    self
  }
  
  pub fn is_received(&mut self, is_received: bool) -> &mut Self {
    self.instance.is_received = Some(is_received);
    self
  }
  
}



/// The call has been answered and encryption keys are being exchanged. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateExchangingKeys {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateExchangingKeys
  
}



impl Object for CallStateExchangingKeys {}
impl RObject for CallStateExchangingKeys {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateExchangingKeys" }
  fn td_type(&self) -> RTDType { RTDType::CallStateExchangingKeys }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStateExchangingKeys {}


impl CallStateExchangingKeys {
  
  pub fn builder() -> RTDCallStateExchangingKeysBuilder {
    let instance = Self {
      td_name: "callStateExchangingKeys".to_string(),
      
    };
    RTDCallStateExchangingKeysBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStateExchangingKeys> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStateExchangingKeysBuilder { instance: CallStateExchangingKeys }

impl RTDCallStateExchangingKeysBuilder {
  fn new(instance: CallStateExchangingKeys) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateExchangingKeys { self.instance.clone() }
  
}



/// The call is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateReady
  /// Call protocols supported by the peer.
  protocol: Option<CallProtocol>,
  /// Available UDP reflectors.
  connections: Option<Vec<CallConnection>>,
  /// A JSON-encoded call config.
  config: Option<String>,
  /// Call encryption key.
  encryption_key: Option<String>,
  /// Encryption key emojis fingerprint.
  emojis: Option<Vec<String>>,
  /// True, if peer-to-peer connection is allowed by users privacy settings.
  allow_p2p: Option<bool>,
  
}



impl Object for CallStateReady {}
impl RObject for CallStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateReady" }
  fn td_type(&self) -> RTDType { RTDType::CallStateReady }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStateReady {}


impl CallStateReady {
  
  pub fn builder() -> RTDCallStateReadyBuilder {
    let instance = Self {
      td_name: "callStateReady".to_string(),
      protocol: None,
      connections: None,
      config: None,
      encryption_key: None,
      emojis: None,
      allow_p2p: None,
      
    };
    RTDCallStateReadyBuilder::new(instance)
  }
  
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn connections(&self) -> Option<Vec<CallConnection>> { self.connections.clone() }
  
  pub fn config(&self) -> Option<String> { self.config.clone() }
  
  pub fn encryption_key(&self) -> Option<String> { self.encryption_key.clone() }
  
  pub fn emojis(&self) -> Option<Vec<String>> { self.emojis.clone() }
  
  pub fn allow_p2p(&self) -> Option<bool> { self.allow_p2p.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStateReady> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStateReadyBuilder { instance: CallStateReady }

impl RTDCallStateReadyBuilder {
  fn new(instance: CallStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateReady { self.instance.clone() }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
  pub fn connections(&mut self, connections: Vec<CallConnection>) -> &mut Self {
    self.instance.connections = Some(connections);
    self
  }
  
  pub fn config<S: AsRef<str>>(&mut self, config: S) -> &mut Self {
    self.instance.config = Some(config.as_ref().to_string());
    self
  }
  
  pub fn encryption_key<S: AsRef<str>>(&mut self, encryption_key: S) -> &mut Self {
    self.instance.encryption_key = Some(encryption_key.as_ref().to_string());
    self
  }
  
  pub fn emojis(&mut self, emojis: Vec<String>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
  pub fn allow_p2p(&mut self, allow_p2p: bool) -> &mut Self {
    self.instance.allow_p2p = Some(allow_p2p);
    self
  }
  
}



/// The call is hanging up after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateHangingUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateHangingUp
  
}



impl Object for CallStateHangingUp {}
impl RObject for CallStateHangingUp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateHangingUp" }
  fn td_type(&self) -> RTDType { RTDType::CallStateHangingUp }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStateHangingUp {}


impl CallStateHangingUp {
  
  pub fn builder() -> RTDCallStateHangingUpBuilder {
    let instance = Self {
      td_name: "callStateHangingUp".to_string(),
      
    };
    RTDCallStateHangingUpBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStateHangingUp> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStateHangingUpBuilder { instance: CallStateHangingUp }

impl RTDCallStateHangingUpBuilder {
  fn new(instance: CallStateHangingUp) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateHangingUp { self.instance.clone() }
  
}



/// The call has ended successfully. 
#[derive(Debug, Serialize, Deserialize)]
pub struct CallStateDiscarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateDiscarded
  /// The reason, why the call has ended.
  reason: Option<Box<CallDiscardReason>>,
  /// True, if the call rating should be sent to the server.
  need_rating: Option<bool>,
  /// True, if the call debug information should be sent to the server.
  need_debug_information: Option<bool>,
  
}


impl Clone for CallStateDiscarded {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for CallStateDiscarded {}
impl RObject for CallStateDiscarded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateDiscarded" }
  fn td_type(&self) -> RTDType { RTDType::CallStateDiscarded }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStateDiscarded {}


impl CallStateDiscarded {
  
  pub fn builder() -> RTDCallStateDiscardedBuilder {
    let instance = Self {
      td_name: "callStateDiscarded".to_string(),
      reason: None,
      need_rating: None,
      need_debug_information: None,
      
    };
    RTDCallStateDiscardedBuilder::new(instance)
  }
  
  
  pub fn reason(&self) -> Option<Box<CallDiscardReason>> { self.reason.clone() }
  
  pub fn need_rating(&self) -> Option<bool> { self.need_rating.clone() }
  
  pub fn need_debug_information(&self) -> Option<bool> { self.need_debug_information.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStateDiscarded> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStateDiscardedBuilder { instance: CallStateDiscarded }

impl RTDCallStateDiscardedBuilder {
  fn new(instance: CallStateDiscarded) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateDiscarded { self.instance.clone() }
  
  pub fn reason(&mut self, reason: Box<CallDiscardReason>) -> &mut Self {
    self.instance.reason = Some(reason);
    self
  }
  
  pub fn need_rating(&mut self, need_rating: bool) -> &mut Self {
    self.instance.need_rating = Some(need_rating);
    self
  }
  
  pub fn need_debug_information(&mut self, need_debug_information: bool) -> &mut Self {
    self.instance.need_debug_information = Some(need_debug_information);
    self
  }
  
}



/// The call has ended with an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateError
  /// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout.
  error: Option<Error>,
  
}



impl Object for CallStateError {}
impl RObject for CallStateError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateError" }
  fn td_type(&self) -> RTDType { RTDType::CallStateError }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallState for CallStateError {}


impl CallStateError {
  
  pub fn builder() -> RTDCallStateErrorBuilder {
    let instance = Self {
      td_name: "callStateError".to_string(),
      error: None,
      
    };
    RTDCallStateErrorBuilder::new(instance)
  }
  
  
  pub fn error(&self) -> Option<Error> { self.error.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallStateError> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallStateErrorBuilder { instance: CallStateError }

impl RTDCallStateErrorBuilder {
  fn new(instance: CallStateError) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateError { self.instance.clone() }
  
  pub fn error(&mut self, error: Error) -> &mut Self {
    self.instance.error = Some(error);
    self
  }
  
}



/// Contains a bot's answer to a callback query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryAnswer
  /// Text of the answer.
  text: Option<String>,
  /// True, if an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,
  
}



impl Object for CallbackQueryAnswer {}
impl RObject for CallbackQueryAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryAnswer" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryAnswer }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl CallbackQueryAnswer {
  
  pub fn builder() -> RTDCallbackQueryAnswerBuilder {
    let instance = Self {
      td_name: "callbackQueryAnswer".to_string(),
      text: None,
      show_alert: None,
      url: None,
      
    };
    RTDCallbackQueryAnswerBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn show_alert(&self) -> Option<bool> { self.show_alert.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallbackQueryAnswer> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallbackQueryAnswerBuilder { instance: CallbackQueryAnswer }

impl RTDCallbackQueryAnswerBuilder {
  fn new(instance: CallbackQueryAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryAnswer { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn show_alert(&mut self, show_alert: bool) -> &mut Self {
    self.instance.show_alert = Some(show_alert);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Represents a payload of a callback query. 
#[typetag::serde(tag = "@struct")]
pub trait CallbackQueryPayload: Object + RObject + Debug {}







impl CallbackQueryPayload {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<CallbackQueryPayload>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<CallbackQueryPayload> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallbackQueryPayloadType {
  CallbackQueryPayloadData,
  CallbackQueryPayloadGame,
  
}
impl RTDCallbackQueryPayloadType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The payload from a general callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryPayloadData
  /// Data that was attached to the callback button.
  data: Option<String>,
  
}



impl Object for CallbackQueryPayloadData {}
impl RObject for CallbackQueryPayloadData {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryPayloadData" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryPayloadData }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallbackQueryPayload for CallbackQueryPayloadData {}


impl CallbackQueryPayloadData {
  
  pub fn builder() -> RTDCallbackQueryPayloadDataBuilder {
    let instance = Self {
      td_name: "callbackQueryPayloadData".to_string(),
      data: None,
      
    };
    RTDCallbackQueryPayloadDataBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallbackQueryPayloadData> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallbackQueryPayloadDataBuilder { instance: CallbackQueryPayloadData }

impl RTDCallbackQueryPayloadDataBuilder {
  fn new(instance: CallbackQueryPayloadData) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryPayloadData { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// The payload from a game callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryPayloadGame
  /// A short name of the game that was attached to the callback button.
  game_short_name: Option<String>,
  
}



impl Object for CallbackQueryPayloadGame {}
impl RObject for CallbackQueryPayloadGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryPayloadGame" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryPayloadGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CallbackQueryPayload for CallbackQueryPayloadGame {}


impl CallbackQueryPayloadGame {
  
  pub fn builder() -> RTDCallbackQueryPayloadGameBuilder {
    let instance = Self {
      td_name: "callbackQueryPayloadGame".to_string(),
      game_short_name: None,
      
    };
    RTDCallbackQueryPayloadGameBuilder::new(instance)
  }
  
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CallbackQueryPayloadGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCallbackQueryPayloadGameBuilder { instance: CallbackQueryPayloadGame }

impl RTDCallbackQueryPayloadGameBuilder {
  fn new(instance: CallbackQueryPayloadGame) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryPayloadGame { self.instance.clone() }
  
  pub fn game_short_name<S: AsRef<str>>(&mut self, game_short_name: S) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name.as_ref().to_string());
    self
  }
  
}



/// A chat. (Can be a private chat, basic group, supergroup, or secret chat.) 
#[derive(Debug, Serialize, Deserialize)]
pub struct Chat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chat
  /// Chat unique identifier.
  id: Option<i64>,
  /// Type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Last message in the chat; may be null.
  last_message: Option<Message>,
  /// Descending parameter by which chats are sorted in the main chat list. If the order number of two chats is the same, they must be sorted in descending order by ID. If 0, the position of the chat in the list is undetermined.
  order: Option<i64>,
  /// True, if the chat is pinned.
  is_pinned: Option<bool>,
  /// True, if the chat is marked as unread.
  is_marked_as_unread: Option<bool>,
  /// True, if the chat is sponsored by the user's MTProxy server.
  is_sponsored: Option<bool>,
  /// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the chat messages can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the chat can be reported to Telegram moderators through reportChat.
  can_be_reported: Option<bool>,
  /// Default value of the disable_notification parameter, used when a message is sent to the chat.
  default_disable_notification: Option<bool>,
  /// Number of unread messages in the chat.
  unread_count: Option<i32>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// Identifier of the last read outgoing message.
  last_read_outbox_message_id: Option<i64>,
  /// Number of unread messages with a mention/reply in the chat.
  unread_mention_count: Option<i32>,
  /// Notification settings for this chat.
  notification_settings: Option<ChatNotificationSettings>,
  /// Identifier of the pinned message in the chat; 0 if none.
  pinned_message_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,
  /// A draft of a message in the chat; may be null.
  draft_message: Option<DraftMessage>,
  /// Contains client-specific data associated with the chat. (For example, the chat position or local chat notification settings can be stored here.) Persistent if a message database is used.
  client_data: Option<String>,
  
}


impl Clone for Chat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Chat {}
impl RObject for Chat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chat" }
  fn td_type(&self) -> RTDType { RTDType::Chat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Chat {
  
  pub fn builder() -> RTDChatBuilder {
    let instance = Self {
      td_name: "chat".to_string(),
      id: None,
      type_: None,
      title: None,
      photo: None,
      last_message: None,
      order: None,
      is_pinned: None,
      is_marked_as_unread: None,
      is_sponsored: None,
      can_be_deleted_only_for_self: None,
      can_be_deleted_for_all_users: None,
      can_be_reported: None,
      default_disable_notification: None,
      unread_count: None,
      last_read_inbox_message_id: None,
      last_read_outbox_message_id: None,
      unread_mention_count: None,
      notification_settings: None,
      pinned_message_id: None,
      reply_markup_message_id: None,
      draft_message: None,
      client_data: None,
      
    };
    RTDChatBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn type_(&self) -> Option<Box<ChatType>> { self.type_.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn last_message(&self) -> Option<Message> { self.last_message.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn is_sponsored(&self) -> Option<bool> { self.is_sponsored.clone() }
  
  pub fn can_be_deleted_only_for_self(&self) -> Option<bool> { self.can_be_deleted_only_for_self.clone() }
  
  pub fn can_be_deleted_for_all_users(&self) -> Option<bool> { self.can_be_deleted_for_all_users.clone() }
  
  pub fn can_be_reported(&self) -> Option<bool> { self.can_be_reported.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn last_read_inbox_message_id(&self) -> Option<i64> { self.last_read_inbox_message_id.clone() }
  
  pub fn last_read_outbox_message_id(&self) -> Option<i64> { self.last_read_outbox_message_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn pinned_message_id(&self) -> Option<i64> { self.pinned_message_id.clone() }
  
  pub fn reply_markup_message_id(&self) -> Option<i64> { self.reply_markup_message_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn client_data(&self) -> Option<String> { self.client_data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Chat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatBuilder { instance: Chat }

impl RTDChatBuilder {
  fn new(instance: Chat) -> Self { Self { instance } }

  pub fn build(&self) -> Chat { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ChatType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn last_message(&mut self, last_message: Message) -> &mut Self {
    self.instance.last_message = Some(last_message);
    self
  }
  
  pub fn order(&mut self, order: i64) -> &mut Self {
    self.instance.order = Some(order);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
  pub fn is_marked_as_unread(&mut self, is_marked_as_unread: bool) -> &mut Self {
    self.instance.is_marked_as_unread = Some(is_marked_as_unread);
    self
  }
  
  pub fn is_sponsored(&mut self, is_sponsored: bool) -> &mut Self {
    self.instance.is_sponsored = Some(is_sponsored);
    self
  }
  
  pub fn can_be_deleted_only_for_self(&mut self, can_be_deleted_only_for_self: bool) -> &mut Self {
    self.instance.can_be_deleted_only_for_self = Some(can_be_deleted_only_for_self);
    self
  }
  
  pub fn can_be_deleted_for_all_users(&mut self, can_be_deleted_for_all_users: bool) -> &mut Self {
    self.instance.can_be_deleted_for_all_users = Some(can_be_deleted_for_all_users);
    self
  }
  
  pub fn can_be_reported(&mut self, can_be_reported: bool) -> &mut Self {
    self.instance.can_be_reported = Some(can_be_reported);
    self
  }
  
  pub fn default_disable_notification(&mut self, default_disable_notification: bool) -> &mut Self {
    self.instance.default_disable_notification = Some(default_disable_notification);
    self
  }
  
  pub fn unread_count(&mut self, unread_count: i32) -> &mut Self {
    self.instance.unread_count = Some(unread_count);
    self
  }
  
  pub fn last_read_inbox_message_id(&mut self, last_read_inbox_message_id: i64) -> &mut Self {
    self.instance.last_read_inbox_message_id = Some(last_read_inbox_message_id);
    self
  }
  
  pub fn last_read_outbox_message_id(&mut self, last_read_outbox_message_id: i64) -> &mut Self {
    self.instance.last_read_outbox_message_id = Some(last_read_outbox_message_id);
    self
  }
  
  pub fn unread_mention_count(&mut self, unread_mention_count: i32) -> &mut Self {
    self.instance.unread_mention_count = Some(unread_mention_count);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ChatNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
  pub fn pinned_message_id(&mut self, pinned_message_id: i64) -> &mut Self {
    self.instance.pinned_message_id = Some(pinned_message_id);
    self
  }
  
  pub fn reply_markup_message_id(&mut self, reply_markup_message_id: i64) -> &mut Self {
    self.instance.reply_markup_message_id = Some(reply_markup_message_id);
    self
  }
  
  pub fn draft_message(&mut self, draft_message: DraftMessage) -> &mut Self {
    self.instance.draft_message = Some(draft_message);
    self
  }
  
  pub fn client_data<S: AsRef<str>>(&mut self, client_data: S) -> &mut Self {
    self.instance.client_data = Some(client_data.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Describes the different types of activity in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatAction: Object + RObject + Debug {}







impl ChatAction {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatAction>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatAction> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatActionType {
  ChatActionCancel,
  ChatActionChoosingContact,
  ChatActionChoosingLocation,
  ChatActionRecordingVideo,
  ChatActionRecordingVideoNote,
  ChatActionRecordingVoiceNote,
  ChatActionStartPlayingGame,
  ChatActionTyping,
  ChatActionUploadingDocument,
  ChatActionUploadingPhoto,
  ChatActionUploadingVideo,
  ChatActionUploadingVideoNote,
  ChatActionUploadingVoiceNote,
  
}
impl RTDChatActionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The user is typing a message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionTyping {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionTyping
  
}



impl Object for ChatActionTyping {}
impl RObject for ChatActionTyping {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionTyping" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionTyping }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionTyping {}


impl ChatActionTyping {
  
  pub fn builder() -> RTDChatActionTypingBuilder {
    let instance = Self {
      td_name: "chatActionTyping".to_string(),
      
    };
    RTDChatActionTypingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionTyping> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionTypingBuilder { instance: ChatActionTyping }

impl RTDChatActionTypingBuilder {
  fn new(instance: ChatActionTyping) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionTyping { self.instance.clone() }
  
}



/// The user is recording a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVideo
  
}



impl Object for ChatActionRecordingVideo {}
impl RObject for ChatActionRecordingVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVideo" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVideo {}


impl ChatActionRecordingVideo {
  
  pub fn builder() -> RTDChatActionRecordingVideoBuilder {
    let instance = Self {
      td_name: "chatActionRecordingVideo".to_string(),
      
    };
    RTDChatActionRecordingVideoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionRecordingVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionRecordingVideoBuilder { instance: ChatActionRecordingVideo }

impl RTDChatActionRecordingVideoBuilder {
  fn new(instance: ChatActionRecordingVideo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVideo { self.instance.clone() }
  
}



/// The user is uploading a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVideo
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVideo {}
impl RObject for ChatActionUploadingVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVideo" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVideo {}


impl ChatActionUploadingVideo {
  
  pub fn builder() -> RTDChatActionUploadingVideoBuilder {
    let instance = Self {
      td_name: "chatActionUploadingVideo".to_string(),
      progress: None,
      
    };
    RTDChatActionUploadingVideoBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionUploadingVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionUploadingVideoBuilder { instance: ChatActionUploadingVideo }

impl RTDChatActionUploadingVideoBuilder {
  fn new(instance: ChatActionUploadingVideo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVideo { self.instance.clone() }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}



/// The user is recording a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVoiceNote
  
}



impl Object for ChatActionRecordingVoiceNote {}
impl RObject for ChatActionRecordingVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVoiceNote {}


impl ChatActionRecordingVoiceNote {
  
  pub fn builder() -> RTDChatActionRecordingVoiceNoteBuilder {
    let instance = Self {
      td_name: "chatActionRecordingVoiceNote".to_string(),
      
    };
    RTDChatActionRecordingVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionRecordingVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionRecordingVoiceNoteBuilder { instance: ChatActionRecordingVoiceNote }

impl RTDChatActionRecordingVoiceNoteBuilder {
  fn new(instance: ChatActionRecordingVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVoiceNote { self.instance.clone() }
  
}



/// The user is uploading a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVoiceNote
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVoiceNote {}
impl RObject for ChatActionUploadingVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVoiceNote {}


impl ChatActionUploadingVoiceNote {
  
  pub fn builder() -> RTDChatActionUploadingVoiceNoteBuilder {
    let instance = Self {
      td_name: "chatActionUploadingVoiceNote".to_string(),
      progress: None,
      
    };
    RTDChatActionUploadingVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionUploadingVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionUploadingVoiceNoteBuilder { instance: ChatActionUploadingVoiceNote }

impl RTDChatActionUploadingVoiceNoteBuilder {
  fn new(instance: ChatActionUploadingVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVoiceNote { self.instance.clone() }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}



/// The user is uploading a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingPhoto
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingPhoto {}
impl RObject for ChatActionUploadingPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingPhoto" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingPhoto {}


impl ChatActionUploadingPhoto {
  
  pub fn builder() -> RTDChatActionUploadingPhotoBuilder {
    let instance = Self {
      td_name: "chatActionUploadingPhoto".to_string(),
      progress: None,
      
    };
    RTDChatActionUploadingPhotoBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionUploadingPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionUploadingPhotoBuilder { instance: ChatActionUploadingPhoto }

impl RTDChatActionUploadingPhotoBuilder {
  fn new(instance: ChatActionUploadingPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingPhoto { self.instance.clone() }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}



/// The user is uploading a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingDocument
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingDocument {}
impl RObject for ChatActionUploadingDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingDocument" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingDocument {}


impl ChatActionUploadingDocument {
  
  pub fn builder() -> RTDChatActionUploadingDocumentBuilder {
    let instance = Self {
      td_name: "chatActionUploadingDocument".to_string(),
      progress: None,
      
    };
    RTDChatActionUploadingDocumentBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionUploadingDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionUploadingDocumentBuilder { instance: ChatActionUploadingDocument }

impl RTDChatActionUploadingDocumentBuilder {
  fn new(instance: ChatActionUploadingDocument) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingDocument { self.instance.clone() }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}



/// The user is picking a location or venue to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionChoosingLocation
  
}



impl Object for ChatActionChoosingLocation {}
impl RObject for ChatActionChoosingLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionChoosingLocation" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionChoosingLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionChoosingLocation {}


impl ChatActionChoosingLocation {
  
  pub fn builder() -> RTDChatActionChoosingLocationBuilder {
    let instance = Self {
      td_name: "chatActionChoosingLocation".to_string(),
      
    };
    RTDChatActionChoosingLocationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionChoosingLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionChoosingLocationBuilder { instance: ChatActionChoosingLocation }

impl RTDChatActionChoosingLocationBuilder {
  fn new(instance: ChatActionChoosingLocation) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionChoosingLocation { self.instance.clone() }
  
}



/// The user is picking a contact to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionChoosingContact
  
}



impl Object for ChatActionChoosingContact {}
impl RObject for ChatActionChoosingContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionChoosingContact" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionChoosingContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionChoosingContact {}


impl ChatActionChoosingContact {
  
  pub fn builder() -> RTDChatActionChoosingContactBuilder {
    let instance = Self {
      td_name: "chatActionChoosingContact".to_string(),
      
    };
    RTDChatActionChoosingContactBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionChoosingContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionChoosingContactBuilder { instance: ChatActionChoosingContact }

impl RTDChatActionChoosingContactBuilder {
  fn new(instance: ChatActionChoosingContact) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionChoosingContact { self.instance.clone() }
  
}



/// The user has started to play a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionStartPlayingGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionStartPlayingGame
  
}



impl Object for ChatActionStartPlayingGame {}
impl RObject for ChatActionStartPlayingGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionStartPlayingGame" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionStartPlayingGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionStartPlayingGame {}


impl ChatActionStartPlayingGame {
  
  pub fn builder() -> RTDChatActionStartPlayingGameBuilder {
    let instance = Self {
      td_name: "chatActionStartPlayingGame".to_string(),
      
    };
    RTDChatActionStartPlayingGameBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionStartPlayingGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionStartPlayingGameBuilder { instance: ChatActionStartPlayingGame }

impl RTDChatActionStartPlayingGameBuilder {
  fn new(instance: ChatActionStartPlayingGame) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionStartPlayingGame { self.instance.clone() }
  
}



/// The user is recording a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVideoNote
  
}



impl Object for ChatActionRecordingVideoNote {}
impl RObject for ChatActionRecordingVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVideoNote {}


impl ChatActionRecordingVideoNote {
  
  pub fn builder() -> RTDChatActionRecordingVideoNoteBuilder {
    let instance = Self {
      td_name: "chatActionRecordingVideoNote".to_string(),
      
    };
    RTDChatActionRecordingVideoNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionRecordingVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionRecordingVideoNoteBuilder { instance: ChatActionRecordingVideoNote }

impl RTDChatActionRecordingVideoNoteBuilder {
  fn new(instance: ChatActionRecordingVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVideoNote { self.instance.clone() }
  
}



/// The user is uploading a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVideoNote
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVideoNote {}
impl RObject for ChatActionUploadingVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVideoNote {}


impl ChatActionUploadingVideoNote {
  
  pub fn builder() -> RTDChatActionUploadingVideoNoteBuilder {
    let instance = Self {
      td_name: "chatActionUploadingVideoNote".to_string(),
      progress: None,
      
    };
    RTDChatActionUploadingVideoNoteBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionUploadingVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionUploadingVideoNoteBuilder { instance: ChatActionUploadingVideoNote }

impl RTDChatActionUploadingVideoNoteBuilder {
  fn new(instance: ChatActionUploadingVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVideoNote { self.instance.clone() }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}



/// The user has cancelled the previous action. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionCancel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionCancel
  
}



impl Object for ChatActionCancel {}
impl RObject for ChatActionCancel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionCancel" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionCancel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatAction for ChatActionCancel {}


impl ChatActionCancel {
  
  pub fn builder() -> RTDChatActionCancelBuilder {
    let instance = Self {
      td_name: "chatActionCancel".to_string(),
      
    };
    RTDChatActionCancelBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatActionCancel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatActionCancelBuilder { instance: ChatActionCancel }

impl RTDChatActionCancelBuilder {
  fn new(instance: ChatActionCancel) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionCancel { self.instance.clone() }
  
}



/// Represents a chat event. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEvent
  /// Chat event identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the event happened.
  date: Option<i32>,
  /// Identifier of the user who performed the action that triggered the event.
  user_id: Option<i32>,
  /// Action performed by the user.
  action: Option<Box<ChatEventAction>>,
  
}


impl Clone for ChatEvent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatEvent {}
impl RObject for ChatEvent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEvent" }
  fn td_type(&self) -> RTDType { RTDType::ChatEvent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatEvent {
  
  pub fn builder() -> RTDChatEventBuilder {
    let instance = Self {
      td_name: "chatEvent".to_string(),
      id: None,
      date: None,
      user_id: None,
      action: None,
      
    };
    RTDChatEventBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatEventAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEvent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventBuilder { instance: ChatEvent }

impl RTDChatEventBuilder {
  fn new(instance: ChatEvent) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEvent { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn action(&mut self, action: Box<ChatEventAction>) -> &mut Self {
    self.instance.action = Some(action);
    self
  }
  
}



/// This class is an abstract base class. Represents a chat event. 
#[typetag::serde(tag = "@struct")]
pub trait ChatEventAction: Object + RObject + Debug {}







impl ChatEventAction {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatEventAction>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatEventAction> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatEventActionType {
  ChatEventDescriptionChanged,
  ChatEventInvitesToggled,
  ChatEventIsAllHistoryAvailableToggled,
  ChatEventMemberInvited,
  ChatEventMemberJoined,
  ChatEventMemberLeft,
  ChatEventMemberPromoted,
  ChatEventMemberRestricted,
  ChatEventMessageDeleted,
  ChatEventMessageEdited,
  ChatEventMessagePinned,
  ChatEventMessageUnpinned,
  ChatEventPhotoChanged,
  ChatEventSignMessagesToggled,
  ChatEventStickerSetChanged,
  ChatEventTitleChanged,
  ChatEventUsernameChanged,
  
}
impl RTDChatEventActionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A message was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageEdited
  /// The original message before the edit.
  old_message: Option<Message>,
  /// The message after it was edited.
  new_message: Option<Message>,
  
}



impl Object for ChatEventMessageEdited {}
impl RObject for ChatEventMessageEdited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageEdited" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageEdited }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageEdited {}


impl ChatEventMessageEdited {
  
  pub fn builder() -> RTDChatEventMessageEditedBuilder {
    let instance = Self {
      td_name: "chatEventMessageEdited".to_string(),
      old_message: None,
      new_message: None,
      
    };
    RTDChatEventMessageEditedBuilder::new(instance)
  }
  
  
  pub fn old_message(&self) -> Option<Message> { self.old_message.clone() }
  
  pub fn new_message(&self) -> Option<Message> { self.new_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMessageEdited> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMessageEditedBuilder { instance: ChatEventMessageEdited }

impl RTDChatEventMessageEditedBuilder {
  fn new(instance: ChatEventMessageEdited) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageEdited { self.instance.clone() }
  
  pub fn old_message(&mut self, old_message: Message) -> &mut Self {
    self.instance.old_message = Some(old_message);
    self
  }
  
  pub fn new_message(&mut self, new_message: Message) -> &mut Self {
    self.instance.new_message = Some(new_message);
    self
  }
  
}



/// A message was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageDeleted
  /// Deleted message.
  message: Option<Message>,
  
}



impl Object for ChatEventMessageDeleted {}
impl RObject for ChatEventMessageDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageDeleted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageDeleted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageDeleted {}


impl ChatEventMessageDeleted {
  
  pub fn builder() -> RTDChatEventMessageDeletedBuilder {
    let instance = Self {
      td_name: "chatEventMessageDeleted".to_string(),
      message: None,
      
    };
    RTDChatEventMessageDeletedBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMessageDeleted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMessageDeletedBuilder { instance: ChatEventMessageDeleted }

impl RTDChatEventMessageDeletedBuilder {
  fn new(instance: ChatEventMessageDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageDeleted { self.instance.clone() }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}



/// A message was pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessagePinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessagePinned
  /// Pinned message.
  message: Option<Message>,
  
}



impl Object for ChatEventMessagePinned {}
impl RObject for ChatEventMessagePinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessagePinned" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessagePinned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessagePinned {}


impl ChatEventMessagePinned {
  
  pub fn builder() -> RTDChatEventMessagePinnedBuilder {
    let instance = Self {
      td_name: "chatEventMessagePinned".to_string(),
      message: None,
      
    };
    RTDChatEventMessagePinnedBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMessagePinned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMessagePinnedBuilder { instance: ChatEventMessagePinned }

impl RTDChatEventMessagePinnedBuilder {
  fn new(instance: ChatEventMessagePinned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessagePinned { self.instance.clone() }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}



/// A message was unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageUnpinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageUnpinned
  
}



impl Object for ChatEventMessageUnpinned {}
impl RObject for ChatEventMessageUnpinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageUnpinned" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageUnpinned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageUnpinned {}


impl ChatEventMessageUnpinned {
  
  pub fn builder() -> RTDChatEventMessageUnpinnedBuilder {
    let instance = Self {
      td_name: "chatEventMessageUnpinned".to_string(),
      
    };
    RTDChatEventMessageUnpinnedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMessageUnpinned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMessageUnpinnedBuilder { instance: ChatEventMessageUnpinned }

impl RTDChatEventMessageUnpinnedBuilder {
  fn new(instance: ChatEventMessageUnpinned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageUnpinned { self.instance.clone() }
  
}



/// A new member joined the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberJoined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberJoined
  
}



impl Object for ChatEventMemberJoined {}
impl RObject for ChatEventMemberJoined {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberJoined" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberJoined }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberJoined {}


impl ChatEventMemberJoined {
  
  pub fn builder() -> RTDChatEventMemberJoinedBuilder {
    let instance = Self {
      td_name: "chatEventMemberJoined".to_string(),
      
    };
    RTDChatEventMemberJoinedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMemberJoined> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMemberJoinedBuilder { instance: ChatEventMemberJoined }

impl RTDChatEventMemberJoinedBuilder {
  fn new(instance: ChatEventMemberJoined) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberJoined { self.instance.clone() }
  
}



/// A member left the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberLeft
  
}



impl Object for ChatEventMemberLeft {}
impl RObject for ChatEventMemberLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberLeft" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberLeft }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberLeft {}


impl ChatEventMemberLeft {
  
  pub fn builder() -> RTDChatEventMemberLeftBuilder {
    let instance = Self {
      td_name: "chatEventMemberLeft".to_string(),
      
    };
    RTDChatEventMemberLeftBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMemberLeft> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMemberLeftBuilder { instance: ChatEventMemberLeft }

impl RTDChatEventMemberLeftBuilder {
  fn new(instance: ChatEventMemberLeft) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberLeft { self.instance.clone() }
  
}



/// A new chat member was invited. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberInvited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberInvited
  /// New member user identifier.
  user_id: Option<i32>,
  /// New member status.
  status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberInvited {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatEventMemberInvited {}
impl RObject for ChatEventMemberInvited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberInvited" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberInvited }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberInvited {}


impl ChatEventMemberInvited {
  
  pub fn builder() -> RTDChatEventMemberInvitedBuilder {
    let instance = Self {
      td_name: "chatEventMemberInvited".to_string(),
      user_id: None,
      status: None,
      
    };
    RTDChatEventMemberInvitedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMemberInvited> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMemberInvitedBuilder { instance: ChatEventMemberInvited }

impl RTDChatEventMemberInvitedBuilder {
  fn new(instance: ChatEventMemberInvited) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberInvited { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
}



/// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberPromoted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberPromoted
  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberPromoted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatEventMemberPromoted {}
impl RObject for ChatEventMemberPromoted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberPromoted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberPromoted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberPromoted {}


impl ChatEventMemberPromoted {
  
  pub fn builder() -> RTDChatEventMemberPromotedBuilder {
    let instance = Self {
      td_name: "chatEventMemberPromoted".to_string(),
      user_id: None,
      old_status: None,
      new_status: None,
      
    };
    RTDChatEventMemberPromotedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn old_status(&self) -> Option<Box<ChatMemberStatus>> { self.old_status.clone() }
  
  pub fn new_status(&self) -> Option<Box<ChatMemberStatus>> { self.new_status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMemberPromoted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMemberPromotedBuilder { instance: ChatEventMemberPromoted }

impl RTDChatEventMemberPromotedBuilder {
  fn new(instance: ChatEventMemberPromoted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberPromoted { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn old_status(&mut self, old_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.old_status = Some(old_status);
    self
  }
  
  pub fn new_status(&mut self, new_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.new_status = Some(new_status);
    self
  }
  
}



/// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberRestricted
  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberRestricted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatEventMemberRestricted {}
impl RObject for ChatEventMemberRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberRestricted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberRestricted {}


impl ChatEventMemberRestricted {
  
  pub fn builder() -> RTDChatEventMemberRestrictedBuilder {
    let instance = Self {
      td_name: "chatEventMemberRestricted".to_string(),
      user_id: None,
      old_status: None,
      new_status: None,
      
    };
    RTDChatEventMemberRestrictedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn old_status(&self) -> Option<Box<ChatMemberStatus>> { self.old_status.clone() }
  
  pub fn new_status(&self) -> Option<Box<ChatMemberStatus>> { self.new_status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventMemberRestricted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventMemberRestrictedBuilder { instance: ChatEventMemberRestricted }

impl RTDChatEventMemberRestrictedBuilder {
  fn new(instance: ChatEventMemberRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberRestricted { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn old_status(&mut self, old_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.old_status = Some(old_status);
    self
  }
  
  pub fn new_status(&mut self, new_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.new_status = Some(new_status);
    self
  }
  
}



/// The chat title was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventTitleChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventTitleChanged
  /// Previous chat title.
  old_title: Option<String>,
  /// New chat title.
  new_title: Option<String>,
  
}



impl Object for ChatEventTitleChanged {}
impl RObject for ChatEventTitleChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventTitleChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventTitleChanged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventTitleChanged {}


impl ChatEventTitleChanged {
  
  pub fn builder() -> RTDChatEventTitleChangedBuilder {
    let instance = Self {
      td_name: "chatEventTitleChanged".to_string(),
      old_title: None,
      new_title: None,
      
    };
    RTDChatEventTitleChangedBuilder::new(instance)
  }
  
  
  pub fn old_title(&self) -> Option<String> { self.old_title.clone() }
  
  pub fn new_title(&self) -> Option<String> { self.new_title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventTitleChanged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventTitleChangedBuilder { instance: ChatEventTitleChanged }

impl RTDChatEventTitleChangedBuilder {
  fn new(instance: ChatEventTitleChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventTitleChanged { self.instance.clone() }
  
  pub fn old_title<S: AsRef<str>>(&mut self, old_title: S) -> &mut Self {
    self.instance.old_title = Some(old_title.as_ref().to_string());
    self
  }
  
  pub fn new_title<S: AsRef<str>>(&mut self, new_title: S) -> &mut Self {
    self.instance.new_title = Some(new_title.as_ref().to_string());
    self
  }
  
}



/// The chat description was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventDescriptionChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventDescriptionChanged
  /// Previous chat description.
  old_description: Option<String>,
  /// New chat description.
  new_description: Option<String>,
  
}



impl Object for ChatEventDescriptionChanged {}
impl RObject for ChatEventDescriptionChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventDescriptionChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventDescriptionChanged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventDescriptionChanged {}


impl ChatEventDescriptionChanged {
  
  pub fn builder() -> RTDChatEventDescriptionChangedBuilder {
    let instance = Self {
      td_name: "chatEventDescriptionChanged".to_string(),
      old_description: None,
      new_description: None,
      
    };
    RTDChatEventDescriptionChangedBuilder::new(instance)
  }
  
  
  pub fn old_description(&self) -> Option<String> { self.old_description.clone() }
  
  pub fn new_description(&self) -> Option<String> { self.new_description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventDescriptionChanged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventDescriptionChangedBuilder { instance: ChatEventDescriptionChanged }

impl RTDChatEventDescriptionChangedBuilder {
  fn new(instance: ChatEventDescriptionChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventDescriptionChanged { self.instance.clone() }
  
  pub fn old_description<S: AsRef<str>>(&mut self, old_description: S) -> &mut Self {
    self.instance.old_description = Some(old_description.as_ref().to_string());
    self
  }
  
  pub fn new_description<S: AsRef<str>>(&mut self, new_description: S) -> &mut Self {
    self.instance.new_description = Some(new_description.as_ref().to_string());
    self
  }
  
}



/// The chat username was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventUsernameChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventUsernameChanged
  /// Previous chat username.
  old_username: Option<String>,
  /// New chat username.
  new_username: Option<String>,
  
}



impl Object for ChatEventUsernameChanged {}
impl RObject for ChatEventUsernameChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventUsernameChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventUsernameChanged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventUsernameChanged {}


impl ChatEventUsernameChanged {
  
  pub fn builder() -> RTDChatEventUsernameChangedBuilder {
    let instance = Self {
      td_name: "chatEventUsernameChanged".to_string(),
      old_username: None,
      new_username: None,
      
    };
    RTDChatEventUsernameChangedBuilder::new(instance)
  }
  
  
  pub fn old_username(&self) -> Option<String> { self.old_username.clone() }
  
  pub fn new_username(&self) -> Option<String> { self.new_username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventUsernameChanged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventUsernameChangedBuilder { instance: ChatEventUsernameChanged }

impl RTDChatEventUsernameChangedBuilder {
  fn new(instance: ChatEventUsernameChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventUsernameChanged { self.instance.clone() }
  
  pub fn old_username<S: AsRef<str>>(&mut self, old_username: S) -> &mut Self {
    self.instance.old_username = Some(old_username.as_ref().to_string());
    self
  }
  
  pub fn new_username<S: AsRef<str>>(&mut self, new_username: S) -> &mut Self {
    self.instance.new_username = Some(new_username.as_ref().to_string());
    self
  }
  
}



/// The chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventPhotoChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventPhotoChanged
  /// Previous chat photo value; may be null.
  old_photo: Option<ChatPhoto>,
  /// New chat photo value; may be null.
  new_photo: Option<ChatPhoto>,
  
}



impl Object for ChatEventPhotoChanged {}
impl RObject for ChatEventPhotoChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventPhotoChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventPhotoChanged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventPhotoChanged {}


impl ChatEventPhotoChanged {
  
  pub fn builder() -> RTDChatEventPhotoChangedBuilder {
    let instance = Self {
      td_name: "chatEventPhotoChanged".to_string(),
      old_photo: None,
      new_photo: None,
      
    };
    RTDChatEventPhotoChangedBuilder::new(instance)
  }
  
  
  pub fn old_photo(&self) -> Option<ChatPhoto> { self.old_photo.clone() }
  
  pub fn new_photo(&self) -> Option<ChatPhoto> { self.new_photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventPhotoChanged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventPhotoChangedBuilder { instance: ChatEventPhotoChanged }

impl RTDChatEventPhotoChangedBuilder {
  fn new(instance: ChatEventPhotoChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventPhotoChanged { self.instance.clone() }
  
  pub fn old_photo(&mut self, old_photo: ChatPhoto) -> &mut Self {
    self.instance.old_photo = Some(old_photo);
    self
  }
  
  pub fn new_photo(&mut self, new_photo: ChatPhoto) -> &mut Self {
    self.instance.new_photo = Some(new_photo);
    self
  }
  
}



/// The anyone_can_invite setting of a supergroup chat was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventInvitesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventInvitesToggled
  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,
  
}



impl Object for ChatEventInvitesToggled {}
impl RObject for ChatEventInvitesToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventInvitesToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventInvitesToggled }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventInvitesToggled {}


impl ChatEventInvitesToggled {
  
  pub fn builder() -> RTDChatEventInvitesToggledBuilder {
    let instance = Self {
      td_name: "chatEventInvitesToggled".to_string(),
      anyone_can_invite: None,
      
    };
    RTDChatEventInvitesToggledBuilder::new(instance)
  }
  
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventInvitesToggled> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventInvitesToggledBuilder { instance: ChatEventInvitesToggled }

impl RTDChatEventInvitesToggledBuilder {
  fn new(instance: ChatEventInvitesToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventInvitesToggled { self.instance.clone() }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
}



/// The sign_messages setting of a channel was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventSignMessagesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventSignMessagesToggled
  /// New value of sign_messages.
  sign_messages: Option<bool>,
  
}



impl Object for ChatEventSignMessagesToggled {}
impl RObject for ChatEventSignMessagesToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventSignMessagesToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventSignMessagesToggled }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventSignMessagesToggled {}


impl ChatEventSignMessagesToggled {
  
  pub fn builder() -> RTDChatEventSignMessagesToggledBuilder {
    let instance = Self {
      td_name: "chatEventSignMessagesToggled".to_string(),
      sign_messages: None,
      
    };
    RTDChatEventSignMessagesToggledBuilder::new(instance)
  }
  
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventSignMessagesToggled> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventSignMessagesToggledBuilder { instance: ChatEventSignMessagesToggled }

impl RTDChatEventSignMessagesToggledBuilder {
  fn new(instance: ChatEventSignMessagesToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventSignMessagesToggled { self.instance.clone() }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
}



/// The supergroup sticker set was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventStickerSetChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventStickerSetChanged
  /// Previous identifier of the chat sticker set; 0 if none.
  old_sticker_set_id: Option<i64>,
  /// New identifier of the chat sticker set; 0 if none.
  new_sticker_set_id: Option<i64>,
  
}



impl Object for ChatEventStickerSetChanged {}
impl RObject for ChatEventStickerSetChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventStickerSetChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventStickerSetChanged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventStickerSetChanged {}


impl ChatEventStickerSetChanged {
  
  pub fn builder() -> RTDChatEventStickerSetChangedBuilder {
    let instance = Self {
      td_name: "chatEventStickerSetChanged".to_string(),
      old_sticker_set_id: None,
      new_sticker_set_id: None,
      
    };
    RTDChatEventStickerSetChangedBuilder::new(instance)
  }
  
  
  pub fn old_sticker_set_id(&self) -> Option<i64> { self.old_sticker_set_id.clone() }
  
  pub fn new_sticker_set_id(&self) -> Option<i64> { self.new_sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventStickerSetChanged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventStickerSetChangedBuilder { instance: ChatEventStickerSetChanged }

impl RTDChatEventStickerSetChangedBuilder {
  fn new(instance: ChatEventStickerSetChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventStickerSetChanged { self.instance.clone() }
  
  pub fn old_sticker_set_id(&mut self, old_sticker_set_id: i64) -> &mut Self {
    self.instance.old_sticker_set_id = Some(old_sticker_set_id);
    self
  }
  
  pub fn new_sticker_set_id(&mut self, new_sticker_set_id: i64) -> &mut Self {
    self.instance.new_sticker_set_id = Some(new_sticker_set_id);
    self
  }
  
}



/// The is_all_history_available setting of a supergroup was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventIsAllHistoryAvailableToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventIsAllHistoryAvailableToggled
  /// New value of is_all_history_available.
  is_all_history_available: Option<bool>,
  
}



impl Object for ChatEventIsAllHistoryAvailableToggled {}
impl RObject for ChatEventIsAllHistoryAvailableToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventIsAllHistoryAvailableToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventIsAllHistoryAvailableToggled }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatEventAction for ChatEventIsAllHistoryAvailableToggled {}


impl ChatEventIsAllHistoryAvailableToggled {
  
  pub fn builder() -> RTDChatEventIsAllHistoryAvailableToggledBuilder {
    let instance = Self {
      td_name: "chatEventIsAllHistoryAvailableToggled".to_string(),
      is_all_history_available: None,
      
    };
    RTDChatEventIsAllHistoryAvailableToggledBuilder::new(instance)
  }
  
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventIsAllHistoryAvailableToggled> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventIsAllHistoryAvailableToggledBuilder { instance: ChatEventIsAllHistoryAvailableToggled }

impl RTDChatEventIsAllHistoryAvailableToggledBuilder {
  fn new(instance: ChatEventIsAllHistoryAvailableToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventIsAllHistoryAvailableToggled { self.instance.clone() }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
}



/// Represents a set of filters used to obtain a chat event log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventLogFilters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventLogFilters
  /// True, if message edits should be returned.
  message_edits: Option<bool>,
  /// True, if message deletions should be returned.
  message_deletions: Option<bool>,
  /// True, if pin/unpin events should be returned.
  message_pins: Option<bool>,
  /// True, if members joining events should be returned.
  member_joins: Option<bool>,
  /// True, if members leaving events should be returned.
  member_leaves: Option<bool>,
  /// True, if invited member events should be returned.
  member_invites: Option<bool>,
  /// True, if member promotion/demotion events should be returned.
  member_promotions: Option<bool>,
  /// True, if member restricted/unrestricted/banned/unbanned events should be returned.
  member_restrictions: Option<bool>,
  /// True, if changes in chat information should be returned.
  info_changes: Option<bool>,
  /// True, if changes in chat settings should be returned.
  setting_changes: Option<bool>,
  
}



impl Object for ChatEventLogFilters {}
impl RObject for ChatEventLogFilters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventLogFilters" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventLogFilters }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatEventLogFilters {
  
  pub fn builder() -> RTDChatEventLogFiltersBuilder {
    let instance = Self {
      td_name: "chatEventLogFilters".to_string(),
      message_edits: None,
      message_deletions: None,
      message_pins: None,
      member_joins: None,
      member_leaves: None,
      member_invites: None,
      member_promotions: None,
      member_restrictions: None,
      info_changes: None,
      setting_changes: None,
      
    };
    RTDChatEventLogFiltersBuilder::new(instance)
  }
  
  
  pub fn message_edits(&self) -> Option<bool> { self.message_edits.clone() }
  
  pub fn message_deletions(&self) -> Option<bool> { self.message_deletions.clone() }
  
  pub fn message_pins(&self) -> Option<bool> { self.message_pins.clone() }
  
  pub fn member_joins(&self) -> Option<bool> { self.member_joins.clone() }
  
  pub fn member_leaves(&self) -> Option<bool> { self.member_leaves.clone() }
  
  pub fn member_invites(&self) -> Option<bool> { self.member_invites.clone() }
  
  pub fn member_promotions(&self) -> Option<bool> { self.member_promotions.clone() }
  
  pub fn member_restrictions(&self) -> Option<bool> { self.member_restrictions.clone() }
  
  pub fn info_changes(&self) -> Option<bool> { self.info_changes.clone() }
  
  pub fn setting_changes(&self) -> Option<bool> { self.setting_changes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEventLogFilters> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventLogFiltersBuilder { instance: ChatEventLogFilters }

impl RTDChatEventLogFiltersBuilder {
  fn new(instance: ChatEventLogFilters) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventLogFilters { self.instance.clone() }
  
  pub fn message_edits(&mut self, message_edits: bool) -> &mut Self {
    self.instance.message_edits = Some(message_edits);
    self
  }
  
  pub fn message_deletions(&mut self, message_deletions: bool) -> &mut Self {
    self.instance.message_deletions = Some(message_deletions);
    self
  }
  
  pub fn message_pins(&mut self, message_pins: bool) -> &mut Self {
    self.instance.message_pins = Some(message_pins);
    self
  }
  
  pub fn member_joins(&mut self, member_joins: bool) -> &mut Self {
    self.instance.member_joins = Some(member_joins);
    self
  }
  
  pub fn member_leaves(&mut self, member_leaves: bool) -> &mut Self {
    self.instance.member_leaves = Some(member_leaves);
    self
  }
  
  pub fn member_invites(&mut self, member_invites: bool) -> &mut Self {
    self.instance.member_invites = Some(member_invites);
    self
  }
  
  pub fn member_promotions(&mut self, member_promotions: bool) -> &mut Self {
    self.instance.member_promotions = Some(member_promotions);
    self
  }
  
  pub fn member_restrictions(&mut self, member_restrictions: bool) -> &mut Self {
    self.instance.member_restrictions = Some(member_restrictions);
    self
  }
  
  pub fn info_changes(&mut self, info_changes: bool) -> &mut Self {
    self.instance.info_changes = Some(info_changes);
    self
  }
  
  pub fn setting_changes(&mut self, setting_changes: bool) -> &mut Self {
    self.instance.setting_changes = Some(setting_changes);
    self
  }
  
}



/// Contains a list of chat events. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEvents {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEvents
  /// List of events.
  events: Option<Vec<ChatEvent>>,
  
}



impl Object for ChatEvents {}
impl RObject for ChatEvents {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEvents" }
  fn td_type(&self) -> RTDType { RTDType::ChatEvents }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatEvents {
  
  pub fn builder() -> RTDChatEventsBuilder {
    let instance = Self {
      td_name: "chatEvents".to_string(),
      events: None,
      
    };
    RTDChatEventsBuilder::new(instance)
  }
  
  
  pub fn events(&self) -> Option<Vec<ChatEvent>> { self.events.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatEvents> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatEventsBuilder { instance: ChatEvents }

impl RTDChatEventsBuilder {
  fn new(instance: ChatEvents) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEvents { self.instance.clone() }
  
  pub fn events(&mut self, events: Vec<ChatEvent>) -> &mut Self {
    self.instance.events = Some(events);
    self
  }
  
}



/// Contains a chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatInviteLink
  /// Chat invite link.
  invite_link: Option<String>,
  
}



impl Object for ChatInviteLink {}
impl RObject for ChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::ChatInviteLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatInviteLink {
  
  pub fn builder() -> RTDChatInviteLinkBuilder {
    let instance = Self {
      td_name: "chatInviteLink".to_string(),
      invite_link: None,
      
    };
    RTDChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatInviteLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatInviteLinkBuilder { instance: ChatInviteLink }

impl RTDChatInviteLinkBuilder {
  fn new(instance: ChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> ChatInviteLink { self.instance.clone() }
  
  pub fn invite_link<S: AsRef<str>>(&mut self, invite_link: S) -> &mut Self {
    self.instance.invite_link = Some(invite_link.as_ref().to_string());
    self
  }
  
}



/// Contains information about a chat invite link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatInviteLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatInviteLinkInfo
  /// Chat identifier of the invite link; 0 if the user is not a member of this chat.
  chat_id: Option<i64>,
  /// Contains information about the type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Title of the chat.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Number of members.
  member_count: Option<i32>,
  /// User identifiers of some chat members that may be known to the current user.
  member_user_ids: Option<Vec<i32>>,
  /// True, if the chat is a public supergroup or channel with a username.
  is_public: Option<bool>,
  
}


impl Clone for ChatInviteLinkInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatInviteLinkInfo {}
impl RObject for ChatInviteLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatInviteLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::ChatInviteLinkInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatInviteLinkInfo {
  
  pub fn builder() -> RTDChatInviteLinkInfoBuilder {
    let instance = Self {
      td_name: "chatInviteLinkInfo".to_string(),
      chat_id: None,
      type_: None,
      title: None,
      photo: None,
      member_count: None,
      member_user_ids: None,
      is_public: None,
      
    };
    RTDChatInviteLinkInfoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn type_(&self) -> Option<Box<ChatType>> { self.type_.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn is_public(&self) -> Option<bool> { self.is_public.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatInviteLinkInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatInviteLinkInfoBuilder { instance: ChatInviteLinkInfo }

impl RTDChatInviteLinkInfoBuilder {
  fn new(instance: ChatInviteLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatInviteLinkInfo { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ChatType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
  pub fn is_public(&mut self, is_public: bool) -> &mut Self {
    self.instance.is_public = Some(is_public);
    self
  }
  
}



/// A user with information about joining/leaving a chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMember
  /// User identifier of the chat member.
  user_id: Option<i32>,
  /// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown.
  inviter_user_id: Option<i32>,
  /// Point in time (Unix timestamp) when the user joined a chat.
  joined_chat_date: Option<i32>,
  /// Status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,
  /// If the user is a bot, information about the bot; may be null. Can be null even for a bot if the bot is not a chat member.
  bot_info: Option<BotInfo>,
  
}


impl Clone for ChatMember {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ChatMember {}
impl RObject for ChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMember" }
  fn td_type(&self) -> RTDType { RTDType::ChatMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatMember {
  
  pub fn builder() -> RTDChatMemberBuilder {
    let instance = Self {
      td_name: "chatMember".to_string(),
      user_id: None,
      inviter_user_id: None,
      joined_chat_date: None,
      status: None,
      bot_info: None,
      
    };
    RTDChatMemberBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn inviter_user_id(&self) -> Option<i32> { self.inviter_user_id.clone() }
  
  pub fn joined_chat_date(&self) -> Option<i32> { self.joined_chat_date.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn bot_info(&self) -> Option<BotInfo> { self.bot_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberBuilder { instance: ChatMember }

impl RTDChatMemberBuilder {
  fn new(instance: ChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMember { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn inviter_user_id(&mut self, inviter_user_id: i32) -> &mut Self {
    self.instance.inviter_user_id = Some(inviter_user_id);
    self
  }
  
  pub fn joined_chat_date(&mut self, joined_chat_date: i32) -> &mut Self {
    self.instance.joined_chat_date = Some(joined_chat_date);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn bot_info(&mut self, bot_info: BotInfo) -> &mut Self {
    self.instance.bot_info = Some(bot_info);
    self
  }
  
}



/// This class is an abstract base class. Provides information about the status of a member in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatMemberStatus: Object + RObject + Debug {}







impl ChatMemberStatus {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatMemberStatus>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatMemberStatus> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatMemberStatusType {
  ChatMemberStatusAdministrator,
  ChatMemberStatusBanned,
  ChatMemberStatusCreator,
  ChatMemberStatusLeft,
  ChatMemberStatusMember,
  ChatMemberStatusRestricted,
  
}
impl RTDChatMemberStatusType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The user is the creator of a chat and has all the administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusCreator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusCreator
  /// True, if the user is a member of the chat.
  is_member: Option<bool>,
  
}



impl Object for ChatMemberStatusCreator {}
impl RObject for ChatMemberStatusCreator {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusCreator" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusCreator }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusCreator {}


impl ChatMemberStatusCreator {
  
  pub fn builder() -> RTDChatMemberStatusCreatorBuilder {
    let instance = Self {
      td_name: "chatMemberStatusCreator".to_string(),
      is_member: None,
      
    };
    RTDChatMemberStatusCreatorBuilder::new(instance)
  }
  
  
  pub fn is_member(&self) -> Option<bool> { self.is_member.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusCreator> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusCreatorBuilder { instance: ChatMemberStatusCreator }

impl RTDChatMemberStatusCreatorBuilder {
  fn new(instance: ChatMemberStatusCreator) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusCreator { self.instance.clone() }
  
  pub fn is_member(&mut self, is_member: bool) -> &mut Self {
    self.instance.is_member = Some(is_member);
    self
  }
  
}



/// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusAdministrator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusAdministrator
  /// True, if the current user can edit the administrator privileges for the called user.
  can_be_edited: Option<bool>,
  /// True, if the administrator can change the chat title, photo, and other settings.
  can_change_info: Option<bool>,
  /// True, if the administrator can create channel posts; applicable to channels only.
  can_post_messages: Option<bool>,
  /// True, if the administrator can edit messages of other users and pin messages; applicable to channels only.
  can_edit_messages: Option<bool>,
  /// True, if the administrator can delete messages of other users.
  can_delete_messages: Option<bool>,
  /// True, if the administrator can invite new users to the chat.
  can_invite_users: Option<bool>,
  /// True, if the administrator can restrict, ban, or unban chat members.
  can_restrict_members: Option<bool>,
  /// True, if the administrator can pin messages; applicable to groups only.
  can_pin_messages: Option<bool>,
  /// True, if the administrator can add new administrators with a subset of his own privileges or demote administrators that were directly or indirectly promoted by him.
  can_promote_members: Option<bool>,
  
}



impl Object for ChatMemberStatusAdministrator {}
impl RObject for ChatMemberStatusAdministrator {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusAdministrator" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusAdministrator }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusAdministrator {}


impl ChatMemberStatusAdministrator {
  
  pub fn builder() -> RTDChatMemberStatusAdministratorBuilder {
    let instance = Self {
      td_name: "chatMemberStatusAdministrator".to_string(),
      can_be_edited: None,
      can_change_info: None,
      can_post_messages: None,
      can_edit_messages: None,
      can_delete_messages: None,
      can_invite_users: None,
      can_restrict_members: None,
      can_pin_messages: None,
      can_promote_members: None,
      
    };
    RTDChatMemberStatusAdministratorBuilder::new(instance)
  }
  
  
  pub fn can_be_edited(&self) -> Option<bool> { self.can_be_edited.clone() }
  
  pub fn can_change_info(&self) -> Option<bool> { self.can_change_info.clone() }
  
  pub fn can_post_messages(&self) -> Option<bool> { self.can_post_messages.clone() }
  
  pub fn can_edit_messages(&self) -> Option<bool> { self.can_edit_messages.clone() }
  
  pub fn can_delete_messages(&self) -> Option<bool> { self.can_delete_messages.clone() }
  
  pub fn can_invite_users(&self) -> Option<bool> { self.can_invite_users.clone() }
  
  pub fn can_restrict_members(&self) -> Option<bool> { self.can_restrict_members.clone() }
  
  pub fn can_pin_messages(&self) -> Option<bool> { self.can_pin_messages.clone() }
  
  pub fn can_promote_members(&self) -> Option<bool> { self.can_promote_members.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusAdministrator> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusAdministratorBuilder { instance: ChatMemberStatusAdministrator }

impl RTDChatMemberStatusAdministratorBuilder {
  fn new(instance: ChatMemberStatusAdministrator) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusAdministrator { self.instance.clone() }
  
  pub fn can_be_edited(&mut self, can_be_edited: bool) -> &mut Self {
    self.instance.can_be_edited = Some(can_be_edited);
    self
  }
  
  pub fn can_change_info(&mut self, can_change_info: bool) -> &mut Self {
    self.instance.can_change_info = Some(can_change_info);
    self
  }
  
  pub fn can_post_messages(&mut self, can_post_messages: bool) -> &mut Self {
    self.instance.can_post_messages = Some(can_post_messages);
    self
  }
  
  pub fn can_edit_messages(&mut self, can_edit_messages: bool) -> &mut Self {
    self.instance.can_edit_messages = Some(can_edit_messages);
    self
  }
  
  pub fn can_delete_messages(&mut self, can_delete_messages: bool) -> &mut Self {
    self.instance.can_delete_messages = Some(can_delete_messages);
    self
  }
  
  pub fn can_invite_users(&mut self, can_invite_users: bool) -> &mut Self {
    self.instance.can_invite_users = Some(can_invite_users);
    self
  }
  
  pub fn can_restrict_members(&mut self, can_restrict_members: bool) -> &mut Self {
    self.instance.can_restrict_members = Some(can_restrict_members);
    self
  }
  
  pub fn can_pin_messages(&mut self, can_pin_messages: bool) -> &mut Self {
    self.instance.can_pin_messages = Some(can_pin_messages);
    self
  }
  
  pub fn can_promote_members(&mut self, can_promote_members: bool) -> &mut Self {
    self.instance.can_promote_members = Some(can_promote_members);
    self
  }
  
}



/// The user is a member of a chat, without any additional privileges or restrictions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusMember
  
}



impl Object for ChatMemberStatusMember {}
impl RObject for ChatMemberStatusMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusMember" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusMember {}


impl ChatMemberStatusMember {
  
  pub fn builder() -> RTDChatMemberStatusMemberBuilder {
    let instance = Self {
      td_name: "chatMemberStatusMember".to_string(),
      
    };
    RTDChatMemberStatusMemberBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusMemberBuilder { instance: ChatMemberStatusMember }

impl RTDChatMemberStatusMemberBuilder {
  fn new(instance: ChatMemberStatusMember) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusMember { self.instance.clone() }
  
}



/// The user is under certain restrictions in the chat. Not supported in basic groups and channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusRestricted
  /// True, if the user is a member of the chat.
  is_member: Option<bool>,
  /// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever.
  restricted_until_date: Option<i32>,
  /// True, if the user can send text messages, contacts, locations, and venues.
  can_send_messages: Option<bool>,
  /// True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions.
  can_send_media_messages: Option<bool>,
  /// True, if the user can send animations, games, and stickers and use inline bots. Implies can_send_media_messages permissions.
  can_send_other_messages: Option<bool>,
  /// True, if the user may add a web page preview to his messages. Implies can_send_messages permissions.
  can_add_web_page_previews: Option<bool>,
  
}



impl Object for ChatMemberStatusRestricted {}
impl RObject for ChatMemberStatusRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusRestricted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusRestricted {}


impl ChatMemberStatusRestricted {
  
  pub fn builder() -> RTDChatMemberStatusRestrictedBuilder {
    let instance = Self {
      td_name: "chatMemberStatusRestricted".to_string(),
      is_member: None,
      restricted_until_date: None,
      can_send_messages: None,
      can_send_media_messages: None,
      can_send_other_messages: None,
      can_add_web_page_previews: None,
      
    };
    RTDChatMemberStatusRestrictedBuilder::new(instance)
  }
  
  
  pub fn is_member(&self) -> Option<bool> { self.is_member.clone() }
  
  pub fn restricted_until_date(&self) -> Option<i32> { self.restricted_until_date.clone() }
  
  pub fn can_send_messages(&self) -> Option<bool> { self.can_send_messages.clone() }
  
  pub fn can_send_media_messages(&self) -> Option<bool> { self.can_send_media_messages.clone() }
  
  pub fn can_send_other_messages(&self) -> Option<bool> { self.can_send_other_messages.clone() }
  
  pub fn can_add_web_page_previews(&self) -> Option<bool> { self.can_add_web_page_previews.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusRestricted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusRestrictedBuilder { instance: ChatMemberStatusRestricted }

impl RTDChatMemberStatusRestrictedBuilder {
  fn new(instance: ChatMemberStatusRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusRestricted { self.instance.clone() }
  
  pub fn is_member(&mut self, is_member: bool) -> &mut Self {
    self.instance.is_member = Some(is_member);
    self
  }
  
  pub fn restricted_until_date(&mut self, restricted_until_date: i32) -> &mut Self {
    self.instance.restricted_until_date = Some(restricted_until_date);
    self
  }
  
  pub fn can_send_messages(&mut self, can_send_messages: bool) -> &mut Self {
    self.instance.can_send_messages = Some(can_send_messages);
    self
  }
  
  pub fn can_send_media_messages(&mut self, can_send_media_messages: bool) -> &mut Self {
    self.instance.can_send_media_messages = Some(can_send_media_messages);
    self
  }
  
  pub fn can_send_other_messages(&mut self, can_send_other_messages: bool) -> &mut Self {
    self.instance.can_send_other_messages = Some(can_send_other_messages);
    self
  }
  
  pub fn can_add_web_page_previews(&mut self, can_add_web_page_previews: bool) -> &mut Self {
    self.instance.can_add_web_page_previews = Some(can_add_web_page_previews);
    self
  }
  
}



/// The user is not a chat member. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusLeft
  
}



impl Object for ChatMemberStatusLeft {}
impl RObject for ChatMemberStatusLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusLeft" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusLeft }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusLeft {}


impl ChatMemberStatusLeft {
  
  pub fn builder() -> RTDChatMemberStatusLeftBuilder {
    let instance = Self {
      td_name: "chatMemberStatusLeft".to_string(),
      
    };
    RTDChatMemberStatusLeftBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusLeft> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusLeftBuilder { instance: ChatMemberStatusLeft }

impl RTDChatMemberStatusLeftBuilder {
  fn new(instance: ChatMemberStatusLeft) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusLeft { self.instance.clone() }
  
}



/// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusBanned
  /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever.
  banned_until_date: Option<i32>,
  
}



impl Object for ChatMemberStatusBanned {}
impl RObject for ChatMemberStatusBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusBanned" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusBanned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusBanned {}


impl ChatMemberStatusBanned {
  
  pub fn builder() -> RTDChatMemberStatusBannedBuilder {
    let instance = Self {
      td_name: "chatMemberStatusBanned".to_string(),
      banned_until_date: None,
      
    };
    RTDChatMemberStatusBannedBuilder::new(instance)
  }
  
  
  pub fn banned_until_date(&self) -> Option<i32> { self.banned_until_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMemberStatusBanned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMemberStatusBannedBuilder { instance: ChatMemberStatusBanned }

impl RTDChatMemberStatusBannedBuilder {
  fn new(instance: ChatMemberStatusBanned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusBanned { self.instance.clone() }
  
  pub fn banned_until_date(&mut self, banned_until_date: i32) -> &mut Self {
    self.instance.banned_until_date = Some(banned_until_date);
    self
  }
  
}



/// Contains a list of chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembers
  /// Approximate total count of chat members found.
  total_count: Option<i32>,
  /// A list of chat members.
  members: Option<Vec<ChatMember>>,
  
}



impl Object for ChatMembers {}
impl RObject for ChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembers" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatMembers {
  
  pub fn builder() -> RTDChatMembersBuilder {
    let instance = Self {
      td_name: "chatMembers".to_string(),
      total_count: None,
      members: None,
      
    };
    RTDChatMembersBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn members(&self) -> Option<Vec<ChatMember>> { self.members.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersBuilder { instance: ChatMembers }

impl RTDChatMembersBuilder {
  fn new(instance: ChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembers { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn members(&mut self, members: Vec<ChatMember>) -> &mut Self {
    self.instance.members = Some(members);
    self
  }
  
}



/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait ChatMembersFilter: Object + RObject + Debug {}







impl ChatMembersFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatMembersFilter>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatMembersFilter> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatMembersFilterType {
  ChatMembersFilterAdministrators,
  ChatMembersFilterBanned,
  ChatMembersFilterBots,
  ChatMembersFilterMembers,
  ChatMembersFilterRestricted,
  
}
impl RTDChatMembersFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterAdministrators
  
}



impl Object for ChatMembersFilterAdministrators {}
impl RObject for ChatMembersFilterAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterAdministrators }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterAdministrators {}


impl ChatMembersFilterAdministrators {
  
  pub fn builder() -> RTDChatMembersFilterAdministratorsBuilder {
    let instance = Self {
      td_name: "chatMembersFilterAdministrators".to_string(),
      
    };
    RTDChatMembersFilterAdministratorsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembersFilterAdministrators> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersFilterAdministratorsBuilder { instance: ChatMembersFilterAdministrators }

impl RTDChatMembersFilterAdministratorsBuilder {
  fn new(instance: ChatMembersFilterAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterAdministrators { self.instance.clone() }
  
}



/// Returns all chat members, including restricted chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterMembers
  
}



impl Object for ChatMembersFilterMembers {}
impl RObject for ChatMembersFilterMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterMembers" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterMembers {}


impl ChatMembersFilterMembers {
  
  pub fn builder() -> RTDChatMembersFilterMembersBuilder {
    let instance = Self {
      td_name: "chatMembersFilterMembers".to_string(),
      
    };
    RTDChatMembersFilterMembersBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembersFilterMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersFilterMembersBuilder { instance: ChatMembersFilterMembers }

impl RTDChatMembersFilterMembersBuilder {
  fn new(instance: ChatMembersFilterMembers) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterMembers { self.instance.clone() }
  
}



/// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterRestricted
  
}



impl Object for ChatMembersFilterRestricted {}
impl RObject for ChatMembersFilterRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterRestricted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterRestricted {}


impl ChatMembersFilterRestricted {
  
  pub fn builder() -> RTDChatMembersFilterRestrictedBuilder {
    let instance = Self {
      td_name: "chatMembersFilterRestricted".to_string(),
      
    };
    RTDChatMembersFilterRestrictedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembersFilterRestricted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersFilterRestrictedBuilder { instance: ChatMembersFilterRestricted }

impl RTDChatMembersFilterRestrictedBuilder {
  fn new(instance: ChatMembersFilterRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterRestricted { self.instance.clone() }
  
}



/// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterBanned
  
}



impl Object for ChatMembersFilterBanned {}
impl RObject for ChatMembersFilterBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterBanned" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterBanned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterBanned {}


impl ChatMembersFilterBanned {
  
  pub fn builder() -> RTDChatMembersFilterBannedBuilder {
    let instance = Self {
      td_name: "chatMembersFilterBanned".to_string(),
      
    };
    RTDChatMembersFilterBannedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembersFilterBanned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersFilterBannedBuilder { instance: ChatMembersFilterBanned }

impl RTDChatMembersFilterBannedBuilder {
  fn new(instance: ChatMembersFilterBanned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterBanned { self.instance.clone() }
  
}



/// Returns bot members of the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterBots
  
}



impl Object for ChatMembersFilterBots {}
impl RObject for ChatMembersFilterBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterBots" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterBots }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterBots {}


impl ChatMembersFilterBots {
  
  pub fn builder() -> RTDChatMembersFilterBotsBuilder {
    let instance = Self {
      td_name: "chatMembersFilterBots".to_string(),
      
    };
    RTDChatMembersFilterBotsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatMembersFilterBots> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatMembersFilterBotsBuilder { instance: ChatMembersFilterBots }

impl RTDChatMembersFilterBotsBuilder {
  fn new(instance: ChatMembersFilterBots) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterBots { self.instance.clone() }
  
}



/// Contains information about notification settings for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatNotificationSettings
  /// If true, mute_for is ignored and the value for the relevant type of chat is used instead.
  use_default_mute_for: Option<bool>,
  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// If true, sound is ignored and the value for the relevant type of chat is used instead.
  use_default_sound: Option<bool>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// If true, show_preview is ignored and the value for the relevant type of chat is used instead.
  use_default_show_preview: Option<bool>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_pinned_message_notifications: Option<bool>,
  /// If true, notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_mention_notifications: Option<bool>,
  /// If true, notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,
  
}



impl Object for ChatNotificationSettings {}
impl RObject for ChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ChatNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatNotificationSettings {
  
  pub fn builder() -> RTDChatNotificationSettingsBuilder {
    let instance = Self {
      td_name: "chatNotificationSettings".to_string(),
      use_default_mute_for: None,
      mute_for: None,
      use_default_sound: None,
      sound: None,
      use_default_show_preview: None,
      show_preview: None,
      use_default_disable_pinned_message_notifications: None,
      disable_pinned_message_notifications: None,
      use_default_disable_mention_notifications: None,
      disable_mention_notifications: None,
      
    };
    RTDChatNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn use_default_mute_for(&self) -> Option<bool> { self.use_default_mute_for.clone() }
  
  pub fn mute_for(&self) -> Option<i32> { self.mute_for.clone() }
  
  pub fn use_default_sound(&self) -> Option<bool> { self.use_default_sound.clone() }
  
  pub fn sound(&self) -> Option<String> { self.sound.clone() }
  
  pub fn use_default_show_preview(&self) -> Option<bool> { self.use_default_show_preview.clone() }
  
  pub fn show_preview(&self) -> Option<bool> { self.show_preview.clone() }
  
  pub fn use_default_disable_pinned_message_notifications(&self) -> Option<bool> { self.use_default_disable_pinned_message_notifications.clone() }
  
  pub fn disable_pinned_message_notifications(&self) -> Option<bool> { self.disable_pinned_message_notifications.clone() }
  
  pub fn use_default_disable_mention_notifications(&self) -> Option<bool> { self.use_default_disable_mention_notifications.clone() }
  
  pub fn disable_mention_notifications(&self) -> Option<bool> { self.disable_mention_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatNotificationSettingsBuilder { instance: ChatNotificationSettings }

impl RTDChatNotificationSettingsBuilder {
  fn new(instance: ChatNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ChatNotificationSettings { self.instance.clone() }
  
  pub fn use_default_mute_for(&mut self, use_default_mute_for: bool) -> &mut Self {
    self.instance.use_default_mute_for = Some(use_default_mute_for);
    self
  }
  
  pub fn mute_for(&mut self, mute_for: i32) -> &mut Self {
    self.instance.mute_for = Some(mute_for);
    self
  }
  
  pub fn use_default_sound(&mut self, use_default_sound: bool) -> &mut Self {
    self.instance.use_default_sound = Some(use_default_sound);
    self
  }
  
  pub fn sound<S: AsRef<str>>(&mut self, sound: S) -> &mut Self {
    self.instance.sound = Some(sound.as_ref().to_string());
    self
  }
  
  pub fn use_default_show_preview(&mut self, use_default_show_preview: bool) -> &mut Self {
    self.instance.use_default_show_preview = Some(use_default_show_preview);
    self
  }
  
  pub fn show_preview(&mut self, show_preview: bool) -> &mut Self {
    self.instance.show_preview = Some(show_preview);
    self
  }
  
  pub fn use_default_disable_pinned_message_notifications(&mut self, use_default_disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.use_default_disable_pinned_message_notifications = Some(use_default_disable_pinned_message_notifications);
    self
  }
  
  pub fn disable_pinned_message_notifications(&mut self, disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.disable_pinned_message_notifications = Some(disable_pinned_message_notifications);
    self
  }
  
  pub fn use_default_disable_mention_notifications(&mut self, use_default_disable_mention_notifications: bool) -> &mut Self {
    self.instance.use_default_disable_mention_notifications = Some(use_default_disable_mention_notifications);
    self
  }
  
  pub fn disable_mention_notifications(&mut self, disable_mention_notifications: bool) -> &mut Self {
    self.instance.disable_mention_notifications = Some(disable_mention_notifications);
    self
  }
  
}



/// Describes the photo of a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatPhoto
  /// A small (160x160) chat photo.
  small: Option<File>,
  /// A big (640x640) chat photo.
  big: Option<File>,
  
}



impl Object for ChatPhoto {}
impl RObject for ChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::ChatPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatPhoto {
  
  pub fn builder() -> RTDChatPhotoBuilder {
    let instance = Self {
      td_name: "chatPhoto".to_string(),
      small: None,
      big: None,
      
    };
    RTDChatPhotoBuilder::new(instance)
  }
  
  
  pub fn small(&self) -> Option<File> { self.small.clone() }
  
  pub fn big(&self) -> Option<File> { self.big.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatPhotoBuilder { instance: ChatPhoto }

impl RTDChatPhotoBuilder {
  fn new(instance: ChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ChatPhoto { self.instance.clone() }
  
  pub fn small(&mut self, small: File) -> &mut Self {
    self.instance.small = Some(small);
    self
  }
  
  pub fn big(&mut self, big: File) -> &mut Self {
    self.instance.big = Some(big);
    self
  }
  
}



/// This class is an abstract base class. Describes the reason why a chat is reported. 
#[typetag::serde(tag = "@struct")]
pub trait ChatReportReason: Object + RObject + Debug {}







impl ChatReportReason {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatReportReason>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatReportReason> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatReportReasonType {
  ChatReportReasonChildAbuse,
  ChatReportReasonCopyright,
  ChatReportReasonCustom,
  ChatReportReasonPornography,
  ChatReportReasonSpam,
  ChatReportReasonViolence,
  
}
impl RTDChatReportReasonType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The chat contains spam messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonSpam
  
}



impl Object for ChatReportReasonSpam {}
impl RObject for ChatReportReasonSpam {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonSpam" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonSpam }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonSpam {}


impl ChatReportReasonSpam {
  
  pub fn builder() -> RTDChatReportReasonSpamBuilder {
    let instance = Self {
      td_name: "chatReportReasonSpam".to_string(),
      
    };
    RTDChatReportReasonSpamBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonSpam> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonSpamBuilder { instance: ChatReportReasonSpam }

impl RTDChatReportReasonSpamBuilder {
  fn new(instance: ChatReportReasonSpam) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonSpam { self.instance.clone() }
  
}



/// The chat promotes violence. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonViolence {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonViolence
  
}



impl Object for ChatReportReasonViolence {}
impl RObject for ChatReportReasonViolence {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonViolence" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonViolence }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonViolence {}


impl ChatReportReasonViolence {
  
  pub fn builder() -> RTDChatReportReasonViolenceBuilder {
    let instance = Self {
      td_name: "chatReportReasonViolence".to_string(),
      
    };
    RTDChatReportReasonViolenceBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonViolence> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonViolenceBuilder { instance: ChatReportReasonViolence }

impl RTDChatReportReasonViolenceBuilder {
  fn new(instance: ChatReportReasonViolence) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonViolence { self.instance.clone() }
  
}



/// The chat contains pornographic messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonPornography {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonPornography
  
}



impl Object for ChatReportReasonPornography {}
impl RObject for ChatReportReasonPornography {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonPornography" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonPornography }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonPornography {}


impl ChatReportReasonPornography {
  
  pub fn builder() -> RTDChatReportReasonPornographyBuilder {
    let instance = Self {
      td_name: "chatReportReasonPornography".to_string(),
      
    };
    RTDChatReportReasonPornographyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonPornography> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonPornographyBuilder { instance: ChatReportReasonPornography }

impl RTDChatReportReasonPornographyBuilder {
  fn new(instance: ChatReportReasonPornography) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonPornography { self.instance.clone() }
  
}



/// The chat has child abuse related content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonChildAbuse {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonChildAbuse
  
}



impl Object for ChatReportReasonChildAbuse {}
impl RObject for ChatReportReasonChildAbuse {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonChildAbuse" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonChildAbuse }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonChildAbuse {}


impl ChatReportReasonChildAbuse {
  
  pub fn builder() -> RTDChatReportReasonChildAbuseBuilder {
    let instance = Self {
      td_name: "chatReportReasonChildAbuse".to_string(),
      
    };
    RTDChatReportReasonChildAbuseBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonChildAbuse> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonChildAbuseBuilder { instance: ChatReportReasonChildAbuse }

impl RTDChatReportReasonChildAbuseBuilder {
  fn new(instance: ChatReportReasonChildAbuse) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonChildAbuse { self.instance.clone() }
  
}



/// The chat contains copyrighted content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCopyright {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonCopyright
  
}



impl Object for ChatReportReasonCopyright {}
impl RObject for ChatReportReasonCopyright {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonCopyright" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonCopyright }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonCopyright {}


impl ChatReportReasonCopyright {
  
  pub fn builder() -> RTDChatReportReasonCopyrightBuilder {
    let instance = Self {
      td_name: "chatReportReasonCopyright".to_string(),
      
    };
    RTDChatReportReasonCopyrightBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonCopyright> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonCopyrightBuilder { instance: ChatReportReasonCopyright }

impl RTDChatReportReasonCopyrightBuilder {
  fn new(instance: ChatReportReasonCopyright) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonCopyright { self.instance.clone() }
  
}



/// A custom reason provided by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCustom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonCustom
  /// Report text.
  text: Option<String>,
  
}



impl Object for ChatReportReasonCustom {}
impl RObject for ChatReportReasonCustom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonCustom" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonCustom }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonCustom {}


impl ChatReportReasonCustom {
  
  pub fn builder() -> RTDChatReportReasonCustomBuilder {
    let instance = Self {
      td_name: "chatReportReasonCustom".to_string(),
      text: None,
      
    };
    RTDChatReportReasonCustomBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportReasonCustom> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportReasonCustomBuilder { instance: ChatReportReasonCustom }

impl RTDChatReportReasonCustomBuilder {
  fn new(instance: ChatReportReasonCustom) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonCustom { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// Contains information about the availability of the "Report spam" action for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportSpamState
  /// True, if a prompt with the "Report spam" action should be shown to the user.
  can_report_spam: Option<bool>,
  
}



impl Object for ChatReportSpamState {}
impl RObject for ChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportSpamState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ChatReportSpamState {
  
  pub fn builder() -> RTDChatReportSpamStateBuilder {
    let instance = Self {
      td_name: "chatReportSpamState".to_string(),
      can_report_spam: None,
      
    };
    RTDChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn can_report_spam(&self) -> Option<bool> { self.can_report_spam.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatReportSpamState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatReportSpamStateBuilder { instance: ChatReportSpamState }

impl RTDChatReportSpamStateBuilder {
  fn new(instance: ChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportSpamState { self.instance.clone() }
  
  pub fn can_report_spam(&mut self, can_report_spam: bool) -> &mut Self {
    self.instance.can_report_spam = Some(can_report_spam);
    self
  }
  
}



/// This class is an abstract base class. Describes the type of a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatType: Object + RObject + Debug {}







impl ChatType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ChatType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ChatType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatTypeType {
  ChatTypeBasicGroup,
  ChatTypePrivate,
  ChatTypeSecret,
  ChatTypeSupergroup,
  
}
impl RTDChatTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// An ordinary chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypePrivate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypePrivate
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for ChatTypePrivate {}
impl RObject for ChatTypePrivate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypePrivate" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypePrivate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatType for ChatTypePrivate {}


impl ChatTypePrivate {
  
  pub fn builder() -> RTDChatTypePrivateBuilder {
    let instance = Self {
      td_name: "chatTypePrivate".to_string(),
      user_id: None,
      
    };
    RTDChatTypePrivateBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatTypePrivate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatTypePrivateBuilder { instance: ChatTypePrivate }

impl RTDChatTypePrivateBuilder {
  fn new(instance: ChatTypePrivate) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypePrivate { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// A basic group (i.e., a chat with 0-200 other users). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeBasicGroup
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for ChatTypeBasicGroup {}
impl RObject for ChatTypeBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeBasicGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatType for ChatTypeBasicGroup {}


impl ChatTypeBasicGroup {
  
  pub fn builder() -> RTDChatTypeBasicGroupBuilder {
    let instance = Self {
      td_name: "chatTypeBasicGroup".to_string(),
      basic_group_id: None,
      
    };
    RTDChatTypeBasicGroupBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatTypeBasicGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatTypeBasicGroupBuilder { instance: ChatTypeBasicGroup }

impl RTDChatTypeBasicGroupBuilder {
  fn new(instance: ChatTypeBasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeBasicGroup { self.instance.clone() }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}



/// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeSupergroup
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,
  
}



impl Object for ChatTypeSupergroup {}
impl RObject for ChatTypeSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeSupergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatType for ChatTypeSupergroup {}


impl ChatTypeSupergroup {
  
  pub fn builder() -> RTDChatTypeSupergroupBuilder {
    let instance = Self {
      td_name: "chatTypeSupergroup".to_string(),
      supergroup_id: None,
      is_channel: None,
      
    };
    RTDChatTypeSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatTypeSupergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatTypeSupergroupBuilder { instance: ChatTypeSupergroup }

impl RTDChatTypeSupergroupBuilder {
  fn new(instance: ChatTypeSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeSupergroup { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
}



/// A secret chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeSecret
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  /// User identifier of the secret chat peer.
  user_id: Option<i32>,
  
}



impl Object for ChatTypeSecret {}
impl RObject for ChatTypeSecret {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeSecret" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeSecret }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ChatType for ChatTypeSecret {}


impl ChatTypeSecret {
  
  pub fn builder() -> RTDChatTypeSecretBuilder {
    let instance = Self {
      td_name: "chatTypeSecret".to_string(),
      secret_chat_id: None,
      user_id: None,
      
    };
    RTDChatTypeSecretBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChatTypeSecret> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatTypeSecretBuilder { instance: ChatTypeSecret }

impl RTDChatTypeSecretBuilder {
  fn new(instance: ChatTypeSecret) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeSecret { self.instance.clone() }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Represents a list of chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Chats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chats
  /// List of chat identifiers.
  chat_ids: Option<Vec<i64>>,
  
}



impl Object for Chats {}
impl RObject for Chats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chats" }
  fn td_type(&self) -> RTDType { RTDType::Chats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Chats {
  
  pub fn builder() -> RTDChatsBuilder {
    let instance = Self {
      td_name: "chats".to_string(),
      chat_ids: None,
      
    };
    RTDChatsBuilder::new(instance)
  }
  
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Chats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChatsBuilder { instance: Chats }

impl RTDChatsBuilder {
  fn new(instance: Chats) -> Self { Self { instance } }

  pub fn build(&self) -> Chats { self.instance.clone() }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
}



/// This class is an abstract base class. Represents result of checking whether a username can be set for a chat. 
#[typetag::serde(tag = "@struct")]
pub trait CheckChatUsernameResult: Object + RObject + Debug {}







impl CheckChatUsernameResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<CheckChatUsernameResult>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<CheckChatUsernameResult> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCheckChatUsernameResultType {
  CheckChatUsernameResultOk,
  CheckChatUsernameResultPublicChatsTooMuch,
  CheckChatUsernameResultPublicGroupsUnavailable,
  CheckChatUsernameResultUsernameInvalid,
  CheckChatUsernameResultUsernameOccupied,
  
}
impl RTDCheckChatUsernameResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The username can be set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultOk {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultOk
  
}



impl Object for CheckChatUsernameResultOk {}
impl RObject for CheckChatUsernameResultOk {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultOk" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultOk }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultOk {}


impl CheckChatUsernameResultOk {
  
  pub fn builder() -> RTDCheckChatUsernameResultOkBuilder {
    let instance = Self {
      td_name: "checkChatUsernameResultOk".to_string(),
      
    };
    RTDCheckChatUsernameResultOkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsernameResultOk> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameResultOkBuilder { instance: CheckChatUsernameResultOk }

impl RTDCheckChatUsernameResultOkBuilder {
  fn new(instance: CheckChatUsernameResultOk) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultOk { self.instance.clone() }
  
}



/// The username is invalid. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameInvalid {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultUsernameInvalid
  
}



impl Object for CheckChatUsernameResultUsernameInvalid {}
impl RObject for CheckChatUsernameResultUsernameInvalid {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultUsernameInvalid" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultUsernameInvalid }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultUsernameInvalid {}


impl CheckChatUsernameResultUsernameInvalid {
  
  pub fn builder() -> RTDCheckChatUsernameResultUsernameInvalidBuilder {
    let instance = Self {
      td_name: "checkChatUsernameResultUsernameInvalid".to_string(),
      
    };
    RTDCheckChatUsernameResultUsernameInvalidBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsernameResultUsernameInvalid> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameResultUsernameInvalidBuilder { instance: CheckChatUsernameResultUsernameInvalid }

impl RTDCheckChatUsernameResultUsernameInvalidBuilder {
  fn new(instance: CheckChatUsernameResultUsernameInvalid) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultUsernameInvalid { self.instance.clone() }
  
}



/// The username is occupied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameOccupied {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultUsernameOccupied
  
}



impl Object for CheckChatUsernameResultUsernameOccupied {}
impl RObject for CheckChatUsernameResultUsernameOccupied {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultUsernameOccupied" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultUsernameOccupied }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultUsernameOccupied {}


impl CheckChatUsernameResultUsernameOccupied {
  
  pub fn builder() -> RTDCheckChatUsernameResultUsernameOccupiedBuilder {
    let instance = Self {
      td_name: "checkChatUsernameResultUsernameOccupied".to_string(),
      
    };
    RTDCheckChatUsernameResultUsernameOccupiedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsernameResultUsernameOccupied> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameResultUsernameOccupiedBuilder { instance: CheckChatUsernameResultUsernameOccupied }

impl RTDCheckChatUsernameResultUsernameOccupiedBuilder {
  fn new(instance: CheckChatUsernameResultUsernameOccupied) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultUsernameOccupied { self.instance.clone() }
  
}



/// The user has too much public chats, one of them should be made private first. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicChatsTooMuch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultPublicChatsTooMuch
  
}



impl Object for CheckChatUsernameResultPublicChatsTooMuch {}
impl RObject for CheckChatUsernameResultPublicChatsTooMuch {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultPublicChatsTooMuch" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultPublicChatsTooMuch }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultPublicChatsTooMuch {}


impl CheckChatUsernameResultPublicChatsTooMuch {
  
  pub fn builder() -> RTDCheckChatUsernameResultPublicChatsTooMuchBuilder {
    let instance = Self {
      td_name: "checkChatUsernameResultPublicChatsTooMuch".to_string(),
      
    };
    RTDCheckChatUsernameResultPublicChatsTooMuchBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsernameResultPublicChatsTooMuch> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameResultPublicChatsTooMuchBuilder { instance: CheckChatUsernameResultPublicChatsTooMuch }

impl RTDCheckChatUsernameResultPublicChatsTooMuchBuilder {
  fn new(instance: CheckChatUsernameResultPublicChatsTooMuch) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultPublicChatsTooMuch { self.instance.clone() }
  
}



/// The user can't be a member of a public supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicGroupsUnavailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultPublicGroupsUnavailable
  
}



impl Object for CheckChatUsernameResultPublicGroupsUnavailable {}
impl RObject for CheckChatUsernameResultPublicGroupsUnavailable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultPublicGroupsUnavailable" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultPublicGroupsUnavailable }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultPublicGroupsUnavailable {}


impl CheckChatUsernameResultPublicGroupsUnavailable {
  
  pub fn builder() -> RTDCheckChatUsernameResultPublicGroupsUnavailableBuilder {
    let instance = Self {
      td_name: "checkChatUsernameResultPublicGroupsUnavailable".to_string(),
      
    };
    RTDCheckChatUsernameResultPublicGroupsUnavailableBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsernameResultPublicGroupsUnavailable> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameResultPublicGroupsUnavailableBuilder { instance: CheckChatUsernameResultPublicGroupsUnavailable }

impl RTDCheckChatUsernameResultPublicGroupsUnavailableBuilder {
  fn new(instance: CheckChatUsernameResultPublicGroupsUnavailable) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultPublicGroupsUnavailable { self.instance.clone() }
  
}



/// Contains information about one website the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectedWebsite
  /// Website identifier.
  id: Option<i64>,
  /// The domain name of the website.
  domain_name: Option<String>,
  /// User identifier of a bot linked with the website.
  bot_user_id: Option<i32>,
  /// The version of a browser used to log in.
  browser: Option<String>,
  /// Operating system the browser is running on.
  platform: Option<String>,
  /// Point in time (Unix timestamp) when the user was logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when obtained authorization was last used.
  last_active_date: Option<i32>,
  /// IP address from which the user was logged in, in human-readable format.
  ip: Option<String>,
  /// Human-readable description of a country and a region, from which the user was logged in, based on the IP address.
  location: Option<String>,
  
}



impl Object for ConnectedWebsite {}
impl RObject for ConnectedWebsite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectedWebsite" }
  fn td_type(&self) -> RTDType { RTDType::ConnectedWebsite }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ConnectedWebsite {
  
  pub fn builder() -> RTDConnectedWebsiteBuilder {
    let instance = Self {
      td_name: "connectedWebsite".to_string(),
      id: None,
      domain_name: None,
      bot_user_id: None,
      browser: None,
      platform: None,
      log_in_date: None,
      last_active_date: None,
      ip: None,
      location: None,
      
    };
    RTDConnectedWebsiteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn domain_name(&self) -> Option<String> { self.domain_name.clone() }
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn browser(&self) -> Option<String> { self.browser.clone() }
  
  pub fn platform(&self) -> Option<String> { self.platform.clone() }
  
  pub fn log_in_date(&self) -> Option<i32> { self.log_in_date.clone() }
  
  pub fn last_active_date(&self) -> Option<i32> { self.last_active_date.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn location(&self) -> Option<String> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectedWebsite> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectedWebsiteBuilder { instance: ConnectedWebsite }

impl RTDConnectedWebsiteBuilder {
  fn new(instance: ConnectedWebsite) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectedWebsite { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn domain_name<S: AsRef<str>>(&mut self, domain_name: S) -> &mut Self {
    self.instance.domain_name = Some(domain_name.as_ref().to_string());
    self
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn browser<S: AsRef<str>>(&mut self, browser: S) -> &mut Self {
    self.instance.browser = Some(browser.as_ref().to_string());
    self
  }
  
  pub fn platform<S: AsRef<str>>(&mut self, platform: S) -> &mut Self {
    self.instance.platform = Some(platform.as_ref().to_string());
    self
  }
  
  pub fn log_in_date(&mut self, log_in_date: i32) -> &mut Self {
    self.instance.log_in_date = Some(log_in_date);
    self
  }
  
  pub fn last_active_date(&mut self, last_active_date: i32) -> &mut Self {
    self.instance.last_active_date = Some(last_active_date);
    self
  }
  
  pub fn ip<S: AsRef<str>>(&mut self, ip: S) -> &mut Self {
    self.instance.ip = Some(ip.as_ref().to_string());
    self
  }
  
  pub fn location<S: AsRef<str>>(&mut self, location: S) -> &mut Self {
    self.instance.location = Some(location.as_ref().to_string());
    self
  }
  
}



/// Contains a list of websites the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectedWebsites
  /// List of connected websites.
  websites: Option<Vec<ConnectedWebsite>>,
  
}



impl Object for ConnectedWebsites {}
impl RObject for ConnectedWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectedWebsites" }
  fn td_type(&self) -> RTDType { RTDType::ConnectedWebsites }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ConnectedWebsites {
  
  pub fn builder() -> RTDConnectedWebsitesBuilder {
    let instance = Self {
      td_name: "connectedWebsites".to_string(),
      websites: None,
      
    };
    RTDConnectedWebsitesBuilder::new(instance)
  }
  
  
  pub fn websites(&self) -> Option<Vec<ConnectedWebsite>> { self.websites.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectedWebsites> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectedWebsitesBuilder { instance: ConnectedWebsites }

impl RTDConnectedWebsitesBuilder {
  fn new(instance: ConnectedWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectedWebsites { self.instance.clone() }
  
  pub fn websites(&mut self, websites: Vec<ConnectedWebsite>) -> &mut Self {
    self.instance.websites = Some(websites);
    self
  }
  
}



/// This class is an abstract base class. Describes the current state of the connection to Telegram servers. 
#[typetag::serde(tag = "@struct")]
pub trait ConnectionState: Object + RObject + Debug {}







impl ConnectionState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ConnectionState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ConnectionState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDConnectionStateType {
  ConnectionStateConnecting,
  ConnectionStateConnectingToProxy,
  ConnectionStateReady,
  ConnectionStateUpdating,
  ConnectionStateWaitingForNetwork,
  
}
impl RTDConnectionStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Currently waiting for the network to become available. Use SetNetworkType to change the available network type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateWaitingForNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateWaitingForNetwork
  
}



impl Object for ConnectionStateWaitingForNetwork {}
impl RObject for ConnectionStateWaitingForNetwork {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateWaitingForNetwork" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateWaitingForNetwork }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateWaitingForNetwork {}


impl ConnectionStateWaitingForNetwork {
  
  pub fn builder() -> RTDConnectionStateWaitingForNetworkBuilder {
    let instance = Self {
      td_name: "connectionStateWaitingForNetwork".to_string(),
      
    };
    RTDConnectionStateWaitingForNetworkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectionStateWaitingForNetwork> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectionStateWaitingForNetworkBuilder { instance: ConnectionStateWaitingForNetwork }

impl RTDConnectionStateWaitingForNetworkBuilder {
  fn new(instance: ConnectionStateWaitingForNetwork) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateWaitingForNetwork { self.instance.clone() }
  
}



/// Currently establishing a connection with a proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnectingToProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateConnectingToProxy
  
}



impl Object for ConnectionStateConnectingToProxy {}
impl RObject for ConnectionStateConnectingToProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateConnectingToProxy" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateConnectingToProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateConnectingToProxy {}


impl ConnectionStateConnectingToProxy {
  
  pub fn builder() -> RTDConnectionStateConnectingToProxyBuilder {
    let instance = Self {
      td_name: "connectionStateConnectingToProxy".to_string(),
      
    };
    RTDConnectionStateConnectingToProxyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectionStateConnectingToProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectionStateConnectingToProxyBuilder { instance: ConnectionStateConnectingToProxy }

impl RTDConnectionStateConnectingToProxyBuilder {
  fn new(instance: ConnectionStateConnectingToProxy) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateConnectingToProxy { self.instance.clone() }
  
}



/// Currently establishing a connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnecting {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateConnecting
  
}



impl Object for ConnectionStateConnecting {}
impl RObject for ConnectionStateConnecting {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateConnecting" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateConnecting }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateConnecting {}


impl ConnectionStateConnecting {
  
  pub fn builder() -> RTDConnectionStateConnectingBuilder {
    let instance = Self {
      td_name: "connectionStateConnecting".to_string(),
      
    };
    RTDConnectionStateConnectingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectionStateConnecting> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectionStateConnectingBuilder { instance: ConnectionStateConnecting }

impl RTDConnectionStateConnectingBuilder {
  fn new(instance: ConnectionStateConnecting) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateConnecting { self.instance.clone() }
  
}



/// Downloading data received while the client was offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateUpdating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateUpdating
  
}



impl Object for ConnectionStateUpdating {}
impl RObject for ConnectionStateUpdating {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateUpdating" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateUpdating }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateUpdating {}


impl ConnectionStateUpdating {
  
  pub fn builder() -> RTDConnectionStateUpdatingBuilder {
    let instance = Self {
      td_name: "connectionStateUpdating".to_string(),
      
    };
    RTDConnectionStateUpdatingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectionStateUpdating> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectionStateUpdatingBuilder { instance: ConnectionStateUpdating }

impl RTDConnectionStateUpdatingBuilder {
  fn new(instance: ConnectionStateUpdating) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateUpdating { self.instance.clone() }
  
}



/// There is a working connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateReady
  
}



impl Object for ConnectionStateReady {}
impl RObject for ConnectionStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateReady" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateReady }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateReady {}


impl ConnectionStateReady {
  
  pub fn builder() -> RTDConnectionStateReadyBuilder {
    let instance = Self {
      td_name: "connectionStateReady".to_string(),
      
    };
    RTDConnectionStateReadyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ConnectionStateReady> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDConnectionStateReadyBuilder { instance: ConnectionStateReady }

impl RTDConnectionStateReadyBuilder {
  fn new(instance: ConnectionStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateReady { self.instance.clone() }
  
}



/// Describes a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // contact
  /// Phone number of the user.
  phone_number: Option<String>,
  /// First name of the user; 1-255 characters in length.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Additional data about the user in a form of vCard; 0-2048 bytes in length.
  vcard: Option<String>,
  /// Identifier of the user, if known; otherwise 0.
  user_id: Option<i32>,
  
}



impl Object for Contact {}
impl RObject for Contact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "contact" }
  fn td_type(&self) -> RTDType { RTDType::Contact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Contact {
  
  pub fn builder() -> RTDContactBuilder {
    let instance = Self {
      td_name: "contact".to_string(),
      phone_number: None,
      first_name: None,
      last_name: None,
      vcard: None,
      user_id: None,
      
    };
    RTDContactBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn vcard(&self) -> Option<String> { self.vcard.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Contact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDContactBuilder { instance: Contact }

impl RTDContactBuilder {
  fn new(instance: Contact) -> Self { Self { instance } }

  pub fn build(&self) -> Contact { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn first_name<S: AsRef<str>>(&mut self, first_name: S) -> &mut Self {
    self.instance.first_name = Some(first_name.as_ref().to_string());
    self
  }
  
  pub fn last_name<S: AsRef<str>>(&mut self, last_name: S) -> &mut Self {
    self.instance.last_name = Some(last_name.as_ref().to_string());
    self
  }
  
  pub fn vcard<S: AsRef<str>>(&mut self, vcard: S) -> &mut Self {
    self.instance.vcard = Some(vcard.as_ref().to_string());
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Contains a counter. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Count {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // count
  /// Count.
  count: Option<i32>,
  
}



impl Object for Count {}
impl RObject for Count {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "count" }
  fn td_type(&self) -> RTDType { RTDType::Count }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Count {
  
  pub fn builder() -> RTDCountBuilder {
    let instance = Self {
      td_name: "count".to_string(),
      count: None,
      
    };
    RTDCountBuilder::new(instance)
  }
  
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Count> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCountBuilder { instance: Count }

impl RTDCountBuilder {
  fn new(instance: Count) -> Self { Self { instance } }

  pub fn build(&self) -> Count { self.instance.clone() }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}



/// Contains the result of a custom request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomRequestResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // customRequestResult
  /// A JSON-serialized result.
  result: Option<String>,
  
}



impl Object for CustomRequestResult {}
impl RObject for CustomRequestResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "customRequestResult" }
  fn td_type(&self) -> RTDType { RTDType::CustomRequestResult }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl CustomRequestResult {
  
  pub fn builder() -> RTDCustomRequestResultBuilder {
    let instance = Self {
      td_name: "customRequestResult".to_string(),
      result: None,
      
    };
    RTDCustomRequestResultBuilder::new(instance)
  }
  
  
  pub fn result(&self) -> Option<String> { self.result.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CustomRequestResult> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCustomRequestResultBuilder { instance: CustomRequestResult }

impl RTDCustomRequestResultBuilder {
  fn new(instance: CustomRequestResult) -> Self { Self { instance } }

  pub fn build(&self) -> CustomRequestResult { self.instance.clone() }
  
  pub fn result<S: AsRef<str>>(&mut self, result: S) -> &mut Self {
    self.instance.result = Some(result.as_ref().to_string());
    self
  }
  
}



/// Contains database statistics. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // databaseStatistics
  /// Database statistics in an unspecified human-readable format.
  statistics: Option<String>,
  
}



impl Object for DatabaseStatistics {}
impl RObject for DatabaseStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "databaseStatistics" }
  fn td_type(&self) -> RTDType { RTDType::DatabaseStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl DatabaseStatistics {
  
  pub fn builder() -> RTDDatabaseStatisticsBuilder {
    let instance = Self {
      td_name: "databaseStatistics".to_string(),
      statistics: None,
      
    };
    RTDDatabaseStatisticsBuilder::new(instance)
  }
  
  
  pub fn statistics(&self) -> Option<String> { self.statistics.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DatabaseStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDatabaseStatisticsBuilder { instance: DatabaseStatistics }

impl RTDDatabaseStatisticsBuilder {
  fn new(instance: DatabaseStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> DatabaseStatistics { self.instance.clone() }
  
  pub fn statistics<S: AsRef<str>>(&mut self, statistics: S) -> &mut Self {
    self.instance.statistics = Some(statistics.as_ref().to_string());
    self
  }
  
}



/// Represents a date according to the Gregorian calendar. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Date {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // date
  /// Day of the month, 1-31.
  day: Option<i32>,
  /// Month, 1-12.
  month: Option<i32>,
  /// Year, 1-9999.
  year: Option<i32>,
  
}



impl Object for Date {}
impl RObject for Date {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "date" }
  fn td_type(&self) -> RTDType { RTDType::Date }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Date {
  
  pub fn builder() -> RTDDateBuilder {
    let instance = Self {
      td_name: "date".to_string(),
      day: None,
      month: None,
      year: None,
      
    };
    RTDDateBuilder::new(instance)
  }
  
  
  pub fn day(&self) -> Option<i32> { self.day.clone() }
  
  pub fn month(&self) -> Option<i32> { self.month.clone() }
  
  pub fn year(&self) -> Option<i32> { self.year.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Date> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDateBuilder { instance: Date }

impl RTDDateBuilder {
  fn new(instance: Date) -> Self { Self { instance } }

  pub fn build(&self) -> Date { self.instance.clone() }
  
  pub fn day(&mut self, day: i32) -> &mut Self {
    self.instance.day = Some(day);
    self
  }
  
  pub fn month(&mut self, month: i32) -> &mut Self {
    self.instance.month = Some(month);
    self
  }
  
  pub fn year(&mut self, year: i32) -> &mut Self {
    self.instance.year = Some(year);
    self
  }
  
}



/// File with the date it was uploaded. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatedFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // datedFile
  /// The file.
  file: Option<File>,
  /// Point in time (Unix timestamp) when the file was uploaded.
  date: Option<i32>,
  
}



impl Object for DatedFile {}
impl RObject for DatedFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "datedFile" }
  fn td_type(&self) -> RTDType { RTDType::DatedFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl DatedFile {
  
  pub fn builder() -> RTDDatedFileBuilder {
    let instance = Self {
      td_name: "datedFile".to_string(),
      file: None,
      date: None,
      
    };
    RTDDatedFileBuilder::new(instance)
  }
  
  
  pub fn file(&self) -> Option<File> { self.file.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DatedFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDatedFileBuilder { instance: DatedFile }

impl RTDDatedFileBuilder {
  fn new(instance: DatedFile) -> Self { Self { instance } }

  pub fn build(&self) -> DatedFile { self.instance.clone() }
  
  pub fn file(&mut self, file: File) -> &mut Self {
    self.instance.file = Some(file);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
}



/// Contains information about a tg:// deep link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deepLinkInfo
  /// Text to be shown to the user.
  text: Option<FormattedText>,
  /// True, if user should be asked to update the application.
  need_update_application: Option<bool>,
  
}



impl Object for DeepLinkInfo {}
impl RObject for DeepLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deepLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::DeepLinkInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl DeepLinkInfo {
  
  pub fn builder() -> RTDDeepLinkInfoBuilder {
    let instance = Self {
      td_name: "deepLinkInfo".to_string(),
      text: None,
      need_update_application: None,
      
    };
    RTDDeepLinkInfoBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn need_update_application(&self) -> Option<bool> { self.need_update_application.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeepLinkInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeepLinkInfoBuilder { instance: DeepLinkInfo }

impl RTDDeepLinkInfoBuilder {
  fn new(instance: DeepLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> DeepLinkInfo { self.instance.clone() }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn need_update_application(&mut self, need_update_application: bool) -> &mut Self {
    self.instance.need_update_application = Some(need_update_application);
    self
  }
  
}



/// This class is an abstract base class. Represents a data needed to subscribe for push notifications through 
#[typetag::serde(tag = "@struct")]
pub trait DeviceToken: Object + RObject + Debug {}







impl DeviceToken {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<DeviceToken>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<DeviceToken> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDDeviceTokenType {
  DeviceTokenApplePush,
  DeviceTokenApplePushVoIP,
  DeviceTokenBlackBerryPush,
  DeviceTokenFirebaseCloudMessaging,
  DeviceTokenMicrosoftPush,
  DeviceTokenMicrosoftPushVoIP,
  DeviceTokenSimplePush,
  DeviceTokenTizenPush,
  DeviceTokenUbuntuPush,
  DeviceTokenWebPush,
  DeviceTokenWindowsPush,
  
}
impl RTDDeviceTokenType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A token for Firebase Cloud Messaging. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenFirebaseCloudMessaging {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenFirebaseCloudMessaging
  /// Device registration token; may be empty to de-register a device.
  token: Option<String>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,
  
}



impl Object for DeviceTokenFirebaseCloudMessaging {}
impl RObject for DeviceTokenFirebaseCloudMessaging {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenFirebaseCloudMessaging" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenFirebaseCloudMessaging }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenFirebaseCloudMessaging {}


impl DeviceTokenFirebaseCloudMessaging {
  
  pub fn builder() -> RTDDeviceTokenFirebaseCloudMessagingBuilder {
    let instance = Self {
      td_name: "deviceTokenFirebaseCloudMessaging".to_string(),
      token: None,
      encrypt: None,
      
    };
    RTDDeviceTokenFirebaseCloudMessagingBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn encrypt(&self) -> Option<bool> { self.encrypt.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenFirebaseCloudMessaging> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenFirebaseCloudMessagingBuilder { instance: DeviceTokenFirebaseCloudMessaging }

impl RTDDeviceTokenFirebaseCloudMessagingBuilder {
  fn new(instance: DeviceTokenFirebaseCloudMessaging) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenFirebaseCloudMessaging { self.instance.clone() }
  
  pub fn token<S: AsRef<str>>(&mut self, token: S) -> &mut Self {
    self.instance.token = Some(token.as_ref().to_string());
    self
  }
  
  pub fn encrypt(&mut self, encrypt: bool) -> &mut Self {
    self.instance.encrypt = Some(encrypt);
    self
  }
  
}



/// A token for Apple Push Notification service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenApplePush
  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,
  
}



impl Object for DeviceTokenApplePush {}
impl RObject for DeviceTokenApplePush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenApplePush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenApplePush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenApplePush {}


impl DeviceTokenApplePush {
  
  pub fn builder() -> RTDDeviceTokenApplePushBuilder {
    let instance = Self {
      td_name: "deviceTokenApplePush".to_string(),
      device_token: None,
      is_app_sandbox: None,
      
    };
    RTDDeviceTokenApplePushBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> Option<String> { self.device_token.clone() }
  
  pub fn is_app_sandbox(&self) -> Option<bool> { self.is_app_sandbox.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenApplePush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenApplePushBuilder { instance: DeviceTokenApplePush }

impl RTDDeviceTokenApplePushBuilder {
  fn new(instance: DeviceTokenApplePush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenApplePush { self.instance.clone() }
  
  pub fn device_token<S: AsRef<str>>(&mut self, device_token: S) -> &mut Self {
    self.instance.device_token = Some(device_token.as_ref().to_string());
    self
  }
  
  pub fn is_app_sandbox(&mut self, is_app_sandbox: bool) -> &mut Self {
    self.instance.is_app_sandbox = Some(is_app_sandbox);
    self
  }
  
}



/// A token for Apple Push Notification service VoIP notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenApplePushVoIP
  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,
  
}



impl Object for DeviceTokenApplePushVoIP {}
impl RObject for DeviceTokenApplePushVoIP {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenApplePushVoIP" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenApplePushVoIP }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenApplePushVoIP {}


impl DeviceTokenApplePushVoIP {
  
  pub fn builder() -> RTDDeviceTokenApplePushVoIPBuilder {
    let instance = Self {
      td_name: "deviceTokenApplePushVoIP".to_string(),
      device_token: None,
      is_app_sandbox: None,
      encrypt: None,
      
    };
    RTDDeviceTokenApplePushVoIPBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> Option<String> { self.device_token.clone() }
  
  pub fn is_app_sandbox(&self) -> Option<bool> { self.is_app_sandbox.clone() }
  
  pub fn encrypt(&self) -> Option<bool> { self.encrypt.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenApplePushVoIP> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenApplePushVoIPBuilder { instance: DeviceTokenApplePushVoIP }

impl RTDDeviceTokenApplePushVoIPBuilder {
  fn new(instance: DeviceTokenApplePushVoIP) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenApplePushVoIP { self.instance.clone() }
  
  pub fn device_token<S: AsRef<str>>(&mut self, device_token: S) -> &mut Self {
    self.instance.device_token = Some(device_token.as_ref().to_string());
    self
  }
  
  pub fn is_app_sandbox(&mut self, is_app_sandbox: bool) -> &mut Self {
    self.instance.is_app_sandbox = Some(is_app_sandbox);
    self
  }
  
  pub fn encrypt(&mut self, encrypt: bool) -> &mut Self {
    self.instance.encrypt = Some(encrypt);
    self
  }
  
}



/// A token for Windows Push Notification Services. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWindowsPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenWindowsPush
  /// The access token that will be used to send notifications; may be empty to de-register a device.
  access_token: Option<String>,
  
}



impl Object for DeviceTokenWindowsPush {}
impl RObject for DeviceTokenWindowsPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenWindowsPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenWindowsPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenWindowsPush {}


impl DeviceTokenWindowsPush {
  
  pub fn builder() -> RTDDeviceTokenWindowsPushBuilder {
    let instance = Self {
      td_name: "deviceTokenWindowsPush".to_string(),
      access_token: None,
      
    };
    RTDDeviceTokenWindowsPushBuilder::new(instance)
  }
  
  
  pub fn access_token(&self) -> Option<String> { self.access_token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenWindowsPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenWindowsPushBuilder { instance: DeviceTokenWindowsPush }

impl RTDDeviceTokenWindowsPushBuilder {
  fn new(instance: DeviceTokenWindowsPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenWindowsPush { self.instance.clone() }
  
  pub fn access_token<S: AsRef<str>>(&mut self, access_token: S) -> &mut Self {
    self.instance.access_token = Some(access_token.as_ref().to_string());
    self
  }
  
}



/// A token for Microsoft Push Notification Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenMicrosoftPush
  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,
  
}



impl Object for DeviceTokenMicrosoftPush {}
impl RObject for DeviceTokenMicrosoftPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenMicrosoftPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenMicrosoftPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenMicrosoftPush {}


impl DeviceTokenMicrosoftPush {
  
  pub fn builder() -> RTDDeviceTokenMicrosoftPushBuilder {
    let instance = Self {
      td_name: "deviceTokenMicrosoftPush".to_string(),
      channel_uri: None,
      
    };
    RTDDeviceTokenMicrosoftPushBuilder::new(instance)
  }
  
  
  pub fn channel_uri(&self) -> Option<String> { self.channel_uri.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenMicrosoftPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenMicrosoftPushBuilder { instance: DeviceTokenMicrosoftPush }

impl RTDDeviceTokenMicrosoftPushBuilder {
  fn new(instance: DeviceTokenMicrosoftPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenMicrosoftPush { self.instance.clone() }
  
  pub fn channel_uri<S: AsRef<str>>(&mut self, channel_uri: S) -> &mut Self {
    self.instance.channel_uri = Some(channel_uri.as_ref().to_string());
    self
  }
  
}



/// A token for Microsoft Push Notification Service VoIP channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenMicrosoftPushVoIP
  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,
  
}



impl Object for DeviceTokenMicrosoftPushVoIP {}
impl RObject for DeviceTokenMicrosoftPushVoIP {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenMicrosoftPushVoIP" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenMicrosoftPushVoIP }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenMicrosoftPushVoIP {}


impl DeviceTokenMicrosoftPushVoIP {
  
  pub fn builder() -> RTDDeviceTokenMicrosoftPushVoIPBuilder {
    let instance = Self {
      td_name: "deviceTokenMicrosoftPushVoIP".to_string(),
      channel_uri: None,
      
    };
    RTDDeviceTokenMicrosoftPushVoIPBuilder::new(instance)
  }
  
  
  pub fn channel_uri(&self) -> Option<String> { self.channel_uri.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenMicrosoftPushVoIP> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenMicrosoftPushVoIPBuilder { instance: DeviceTokenMicrosoftPushVoIP }

impl RTDDeviceTokenMicrosoftPushVoIPBuilder {
  fn new(instance: DeviceTokenMicrosoftPushVoIP) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenMicrosoftPushVoIP { self.instance.clone() }
  
  pub fn channel_uri<S: AsRef<str>>(&mut self, channel_uri: S) -> &mut Self {
    self.instance.channel_uri = Some(channel_uri.as_ref().to_string());
    self
  }
  
}



/// A token for web Push API. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWebPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenWebPush
  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,
  /// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key.
  p256dh_base64url: Option<String>,
  /// Base64url-encoded authentication secret.
  auth_base64url: Option<String>,
  
}



impl Object for DeviceTokenWebPush {}
impl RObject for DeviceTokenWebPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenWebPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenWebPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenWebPush {}


impl DeviceTokenWebPush {
  
  pub fn builder() -> RTDDeviceTokenWebPushBuilder {
    let instance = Self {
      td_name: "deviceTokenWebPush".to_string(),
      endpoint: None,
      p256dh_base64url: None,
      auth_base64url: None,
      
    };
    RTDDeviceTokenWebPushBuilder::new(instance)
  }
  
  
  pub fn endpoint(&self) -> Option<String> { self.endpoint.clone() }
  
  pub fn p256dh_base64url(&self) -> Option<String> { self.p256dh_base64url.clone() }
  
  pub fn auth_base64url(&self) -> Option<String> { self.auth_base64url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenWebPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenWebPushBuilder { instance: DeviceTokenWebPush }

impl RTDDeviceTokenWebPushBuilder {
  fn new(instance: DeviceTokenWebPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenWebPush { self.instance.clone() }
  
  pub fn endpoint<S: AsRef<str>>(&mut self, endpoint: S) -> &mut Self {
    self.instance.endpoint = Some(endpoint.as_ref().to_string());
    self
  }
  
  pub fn p256dh_base64url<S: AsRef<str>>(&mut self, p256dh_base64url: S) -> &mut Self {
    self.instance.p256dh_base64url = Some(p256dh_base64url.as_ref().to_string());
    self
  }
  
  pub fn auth_base64url<S: AsRef<str>>(&mut self, auth_base64url: S) -> &mut Self {
    self.instance.auth_base64url = Some(auth_base64url.as_ref().to_string());
    self
  }
  
}



/// A token for Simple Push API for Firefox OS. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenSimplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenSimplePush
  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,
  
}



impl Object for DeviceTokenSimplePush {}
impl RObject for DeviceTokenSimplePush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenSimplePush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenSimplePush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenSimplePush {}


impl DeviceTokenSimplePush {
  
  pub fn builder() -> RTDDeviceTokenSimplePushBuilder {
    let instance = Self {
      td_name: "deviceTokenSimplePush".to_string(),
      endpoint: None,
      
    };
    RTDDeviceTokenSimplePushBuilder::new(instance)
  }
  
  
  pub fn endpoint(&self) -> Option<String> { self.endpoint.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenSimplePush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenSimplePushBuilder { instance: DeviceTokenSimplePush }

impl RTDDeviceTokenSimplePushBuilder {
  fn new(instance: DeviceTokenSimplePush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenSimplePush { self.instance.clone() }
  
  pub fn endpoint<S: AsRef<str>>(&mut self, endpoint: S) -> &mut Self {
    self.instance.endpoint = Some(endpoint.as_ref().to_string());
    self
  }
  
}



/// A token for Ubuntu Push 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenUbuntuPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenUbuntuPush
  /// Token; may be empty to de-register a device.
  token: Option<String>,
  
}



impl Object for DeviceTokenUbuntuPush {}
impl RObject for DeviceTokenUbuntuPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenUbuntuPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenUbuntuPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenUbuntuPush {}


impl DeviceTokenUbuntuPush {
  
  pub fn builder() -> RTDDeviceTokenUbuntuPushBuilder {
    let instance = Self {
      td_name: "deviceTokenUbuntuPush".to_string(),
      token: None,
      
    };
    RTDDeviceTokenUbuntuPushBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenUbuntuPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenUbuntuPushBuilder { instance: DeviceTokenUbuntuPush }

impl RTDDeviceTokenUbuntuPushBuilder {
  fn new(instance: DeviceTokenUbuntuPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenUbuntuPush { self.instance.clone() }
  
  pub fn token<S: AsRef<str>>(&mut self, token: S) -> &mut Self {
    self.instance.token = Some(token.as_ref().to_string());
    self
  }
  
}



/// A token for BlackBerry Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenBlackBerryPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenBlackBerryPush
  /// Token; may be empty to de-register a device.
  token: Option<String>,
  
}



impl Object for DeviceTokenBlackBerryPush {}
impl RObject for DeviceTokenBlackBerryPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenBlackBerryPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenBlackBerryPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenBlackBerryPush {}


impl DeviceTokenBlackBerryPush {
  
  pub fn builder() -> RTDDeviceTokenBlackBerryPushBuilder {
    let instance = Self {
      td_name: "deviceTokenBlackBerryPush".to_string(),
      token: None,
      
    };
    RTDDeviceTokenBlackBerryPushBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenBlackBerryPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenBlackBerryPushBuilder { instance: DeviceTokenBlackBerryPush }

impl RTDDeviceTokenBlackBerryPushBuilder {
  fn new(instance: DeviceTokenBlackBerryPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenBlackBerryPush { self.instance.clone() }
  
  pub fn token<S: AsRef<str>>(&mut self, token: S) -> &mut Self {
    self.instance.token = Some(token.as_ref().to_string());
    self
  }
  
}



/// A token for Tizen Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenTizenPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenTizenPush
  /// Push service registration identifier; may be empty to de-register a device.
  reg_id: Option<String>,
  
}



impl Object for DeviceTokenTizenPush {}
impl RObject for DeviceTokenTizenPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenTizenPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenTizenPush }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenTizenPush {}


impl DeviceTokenTizenPush {
  
  pub fn builder() -> RTDDeviceTokenTizenPushBuilder {
    let instance = Self {
      td_name: "deviceTokenTizenPush".to_string(),
      reg_id: None,
      
    };
    RTDDeviceTokenTizenPushBuilder::new(instance)
  }
  
  
  pub fn reg_id(&self) -> Option<String> { self.reg_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeviceTokenTizenPush> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeviceTokenTizenPushBuilder { instance: DeviceTokenTizenPush }

impl RTDDeviceTokenTizenPushBuilder {
  fn new(instance: DeviceTokenTizenPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenTizenPush { self.instance.clone() }
  
  pub fn reg_id<S: AsRef<str>>(&mut self, reg_id: S) -> &mut Self {
    self.instance.reg_id = Some(reg_id.as_ref().to_string());
    self
  }
  
}



/// Describes a document of any type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Document {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // document
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// Document thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the document.
  document: Option<File>,
  
}



impl Object for Document {}
impl RObject for Document {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "document" }
  fn td_type(&self) -> RTDType { RTDType::Document }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Document {
  
  pub fn builder() -> RTDDocumentBuilder {
    let instance = Self {
      td_name: "document".to_string(),
      file_name: None,
      mime_type: None,
      thumbnail: None,
      document: None,
      
    };
    RTDDocumentBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn document(&self) -> Option<File> { self.document.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Document> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDocumentBuilder { instance: Document }

impl RTDDocumentBuilder {
  fn new(instance: Document) -> Self { Self { instance } }

  pub fn build(&self) -> Document { self.instance.clone() }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn document(&mut self, document: File) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
}



/// Contains information about a message draft. 
#[derive(Debug, Serialize, Deserialize)]
pub struct DraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // draftMessage
  /// Identifier of the message to reply to; 0 if none.
  reply_to_message_id: Option<i64>,
  /// Content of the message draft; this should always be of type inputMessageText.
  input_message_text: Option<Box<InputMessageContent>>,
  
}


impl Clone for DraftMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for DraftMessage {}
impl RObject for DraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "draftMessage" }
  fn td_type(&self) -> RTDType { RTDType::DraftMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl DraftMessage {
  
  pub fn builder() -> RTDDraftMessageBuilder {
    let instance = Self {
      td_name: "draftMessage".to_string(),
      reply_to_message_id: None,
      input_message_text: None,
      
    };
    RTDDraftMessageBuilder::new(instance)
  }
  
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn input_message_text(&self) -> Option<Box<InputMessageContent>> { self.input_message_text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DraftMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDraftMessageBuilder { instance: DraftMessage }

impl RTDDraftMessageBuilder {
  fn new(instance: DraftMessage) -> Self { Self { instance } }

  pub fn build(&self) -> DraftMessage { self.instance.clone() }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn input_message_text(&mut self, input_message_text: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_text = Some(input_message_text);
    self
  }
  
}



/// Information about the email address authentication code that was sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmailAddressAuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // emailAddressAuthenticationCodeInfo
  /// Pattern of the email address to which an authentication code was sent.
  email_address_pattern: Option<String>,
  /// Length of the code; 0 if unknown.
  length: Option<i32>,
  
}



impl Object for EmailAddressAuthenticationCodeInfo {}
impl RObject for EmailAddressAuthenticationCodeInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "emailAddressAuthenticationCodeInfo" }
  fn td_type(&self) -> RTDType { RTDType::EmailAddressAuthenticationCodeInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl EmailAddressAuthenticationCodeInfo {
  
  pub fn builder() -> RTDEmailAddressAuthenticationCodeInfoBuilder {
    let instance = Self {
      td_name: "emailAddressAuthenticationCodeInfo".to_string(),
      email_address_pattern: None,
      length: None,
      
    };
    RTDEmailAddressAuthenticationCodeInfoBuilder::new(instance)
  }
  
  
  pub fn email_address_pattern(&self) -> Option<String> { self.email_address_pattern.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EmailAddressAuthenticationCodeInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEmailAddressAuthenticationCodeInfoBuilder { instance: EmailAddressAuthenticationCodeInfo }

impl RTDEmailAddressAuthenticationCodeInfoBuilder {
  fn new(instance: EmailAddressAuthenticationCodeInfo) -> Self { Self { instance } }

  pub fn build(&self) -> EmailAddressAuthenticationCodeInfo { self.instance.clone() }
  
  pub fn email_address_pattern<S: AsRef<str>>(&mut self, email_address_pattern: S) -> &mut Self {
    self.instance.email_address_pattern = Some(email_address_pattern.as_ref().to_string());
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}



/// Contains encrypted Telegram Passport data credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // encryptedCredentials
  /// The encrypted credentials.
  data: Option<String>,
  /// The decrypted data hash.
  hash: Option<String>,
  /// Secret for data decryption, encrypted with the service's public key.
  secret: Option<String>,
  
}



impl Object for EncryptedCredentials {}
impl RObject for EncryptedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "encryptedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::EncryptedCredentials }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl EncryptedCredentials {
  
  pub fn builder() -> RTDEncryptedCredentialsBuilder {
    let instance = Self {
      td_name: "encryptedCredentials".to_string(),
      data: None,
      hash: None,
      secret: None,
      
    };
    RTDEncryptedCredentialsBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn secret(&self) -> Option<String> { self.secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EncryptedCredentials> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEncryptedCredentialsBuilder { instance: EncryptedCredentials }

impl RTDEncryptedCredentialsBuilder {
  fn new(instance: EncryptedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> EncryptedCredentials { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
  pub fn hash<S: AsRef<str>>(&mut self, hash: S) -> &mut Self {
    self.instance.hash = Some(hash.as_ref().to_string());
    self
  }
  
  pub fn secret<S: AsRef<str>>(&mut self, secret: S) -> &mut Self {
    self.instance.secret = Some(secret.as_ref().to_string());
    self
  }
  
}



/// Contains information about an encrypted Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // encryptedPassportElement
  /// Type of Telegram Passport element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Encrypted JSON-encoded data about the user.
  data: Option<String>,
  /// The front side of an identity document.
  front_side: Option<DatedFile>,
  /// The reverse side of an identity document; may be null.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  /// List of attached files.
  files: Option<Vec<DatedFile>>,
  /// Unencrypted data, phone number or email address.
  value: Option<String>,
  /// Hash of the entire element.
  hash: Option<String>,
  
}


impl Clone for EncryptedPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EncryptedPassportElement {}
impl RObject for EncryptedPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "encryptedPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::EncryptedPassportElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl EncryptedPassportElement {
  
  pub fn builder() -> RTDEncryptedPassportElementBuilder {
    let instance = Self {
      td_name: "encryptedPassportElement".to_string(),
      type_: None,
      data: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      files: None,
      value: None,
      hash: None,
      
    };
    RTDEncryptedPassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn front_side(&self) -> Option<DatedFile> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<DatedFile> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<DatedFile> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn files(&self) -> Option<Vec<DatedFile>> { self.files.clone() }
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EncryptedPassportElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEncryptedPassportElementBuilder { instance: EncryptedPassportElement }

impl RTDEncryptedPassportElementBuilder {
  fn new(instance: EncryptedPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> EncryptedPassportElement { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
  pub fn front_side(&mut self, front_side: DatedFile) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: DatedFile) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: DatedFile) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
  pub fn files(&mut self, files: Vec<DatedFile>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn value<S: AsRef<str>>(&mut self, value: S) -> &mut Self {
    self.instance.value = Some(value.as_ref().to_string());
    self
  }
  
  pub fn hash<S: AsRef<str>>(&mut self, hash: S) -> &mut Self {
    self.instance.hash = Some(hash.as_ref().to_string());
    self
  }
  
}



/// An object of this type can be returned on every function call, in case of an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // error
  /// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user.
  code: Option<i32>,
  /// Error message; subject to future changes.
  message: Option<String>,
  
}



impl Object for Error {}
impl RObject for Error {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "error" }
  fn td_type(&self) -> RTDType { RTDType::Error }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Error {
  
  pub fn builder() -> RTDErrorBuilder {
    let instance = Self {
      td_name: "error".to_string(),
      code: None,
      message: None,
      
    };
    RTDErrorBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<i32> { self.code.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Error> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDErrorBuilder { instance: Error }

impl RTDErrorBuilder {
  fn new(instance: Error) -> Self { Self { instance } }

  pub fn build(&self) -> Error { self.instance.clone() }
  
  pub fn code(&mut self, code: i32) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
  pub fn message<S: AsRef<str>>(&mut self, message: S) -> &mut Self {
    self.instance.message = Some(message.as_ref().to_string());
    self
  }
  
}



/// Represents a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // file
  /// Unique file identifier.
  id: Option<i32>,
  /// File size; 0 if unknown.
  size: Option<i32>,
  /// Expected file size in case the exact file size is unknown, but an approximate size is known. Can be used to show download/upload progress.
  expected_size: Option<i32>,
  /// Information about the local copy of the file.
  local: Option<LocalFile>,
  /// Information about the remote copy of the file.
  remote: Option<RemoteFile>,
  
}



impl Object for File {}
impl RObject for File {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "file" }
  fn td_type(&self) -> RTDType { RTDType::File }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl File {
  
  pub fn builder() -> RTDFileBuilder {
    let instance = Self {
      td_name: "file".to_string(),
      id: None,
      size: None,
      expected_size: None,
      local: None,
      remote: None,
      
    };
    RTDFileBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn size(&self) -> Option<i32> { self.size.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn local(&self) -> Option<LocalFile> { self.local.clone() }
  
  pub fn remote(&self) -> Option<RemoteFile> { self.remote.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<File> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileBuilder { instance: File }

impl RTDFileBuilder {
  fn new(instance: File) -> Self { Self { instance } }

  pub fn build(&self) -> File { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn size(&mut self, size: i32) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
  pub fn local(&mut self, local: LocalFile) -> &mut Self {
    self.instance.local = Some(local);
    self
  }
  
  pub fn remote(&mut self, remote: RemoteFile) -> &mut Self {
    self.instance.remote = Some(remote);
    self
  }
  
}



/// Contains a part of a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // filePart
  /// File bytes.
  data: Option<String>,
  
}



impl Object for FilePart {}
impl RObject for FilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "filePart" }
  fn td_type(&self) -> RTDType { RTDType::FilePart }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl FilePart {
  
  pub fn builder() -> RTDFilePartBuilder {
    let instance = Self {
      td_name: "filePart".to_string(),
      data: None,
      
    };
    RTDFilePartBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FilePart> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFilePartBuilder { instance: FilePart }

impl RTDFilePartBuilder {
  fn new(instance: FilePart) -> Self { Self { instance } }

  pub fn build(&self) -> FilePart { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Represents the type of a file. 
#[typetag::serde(tag = "@struct")]
pub trait FileType: Object + RObject + Debug {}







impl FileType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<FileType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<FileType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDFileTypeType {
  FileTypeAnimation,
  FileTypeAudio,
  FileTypeDocument,
  FileTypeNone,
  FileTypePhoto,
  FileTypeProfilePhoto,
  FileTypeSecret,
  FileTypeSecretThumbnail,
  FileTypeSecure,
  FileTypeSticker,
  FileTypeThumbnail,
  FileTypeUnknown,
  FileTypeVideo,
  FileTypeVideoNote,
  FileTypeVoiceNote,
  FileTypeWallpaper,
  
}
impl RTDFileTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The data is not a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeNone
  
}



impl Object for FileTypeNone {}
impl RObject for FileTypeNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeNone" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeNone }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeNone {}


impl FileTypeNone {
  
  pub fn builder() -> RTDFileTypeNoneBuilder {
    let instance = Self {
      td_name: "fileTypeNone".to_string(),
      
    };
    RTDFileTypeNoneBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeNone> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeNoneBuilder { instance: FileTypeNone }

impl RTDFileTypeNoneBuilder {
  fn new(instance: FileTypeNone) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeNone { self.instance.clone() }
  
}



/// The file is an animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeAnimation
  
}



impl Object for FileTypeAnimation {}
impl RObject for FileTypeAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeAnimation" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeAnimation {}


impl FileTypeAnimation {
  
  pub fn builder() -> RTDFileTypeAnimationBuilder {
    let instance = Self {
      td_name: "fileTypeAnimation".to_string(),
      
    };
    RTDFileTypeAnimationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeAnimationBuilder { instance: FileTypeAnimation }

impl RTDFileTypeAnimationBuilder {
  fn new(instance: FileTypeAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeAnimation { self.instance.clone() }
  
}



/// The file is an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeAudio
  
}



impl Object for FileTypeAudio {}
impl RObject for FileTypeAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeAudio" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeAudio {}


impl FileTypeAudio {
  
  pub fn builder() -> RTDFileTypeAudioBuilder {
    let instance = Self {
      td_name: "fileTypeAudio".to_string(),
      
    };
    RTDFileTypeAudioBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeAudioBuilder { instance: FileTypeAudio }

impl RTDFileTypeAudioBuilder {
  fn new(instance: FileTypeAudio) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeAudio { self.instance.clone() }
  
}



/// The file is a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeDocument
  
}



impl Object for FileTypeDocument {}
impl RObject for FileTypeDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeDocument" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeDocument {}


impl FileTypeDocument {
  
  pub fn builder() -> RTDFileTypeDocumentBuilder {
    let instance = Self {
      td_name: "fileTypeDocument".to_string(),
      
    };
    RTDFileTypeDocumentBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeDocumentBuilder { instance: FileTypeDocument }

impl RTDFileTypeDocumentBuilder {
  fn new(instance: FileTypeDocument) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeDocument { self.instance.clone() }
  
}



/// The file is a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypePhoto
  
}



impl Object for FileTypePhoto {}
impl RObject for FileTypePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypePhoto" }
  fn td_type(&self) -> RTDType { RTDType::FileTypePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypePhoto {}


impl FileTypePhoto {
  
  pub fn builder() -> RTDFileTypePhotoBuilder {
    let instance = Self {
      td_name: "fileTypePhoto".to_string(),
      
    };
    RTDFileTypePhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypePhotoBuilder { instance: FileTypePhoto }

impl RTDFileTypePhotoBuilder {
  fn new(instance: FileTypePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypePhoto { self.instance.clone() }
  
}



/// The file is a profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeProfilePhoto
  
}



impl Object for FileTypeProfilePhoto {}
impl RObject for FileTypeProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeProfilePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeProfilePhoto {}


impl FileTypeProfilePhoto {
  
  pub fn builder() -> RTDFileTypeProfilePhotoBuilder {
    let instance = Self {
      td_name: "fileTypeProfilePhoto".to_string(),
      
    };
    RTDFileTypeProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeProfilePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeProfilePhotoBuilder { instance: FileTypeProfilePhoto }

impl RTDFileTypeProfilePhotoBuilder {
  fn new(instance: FileTypeProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeProfilePhoto { self.instance.clone() }
  
}



/// The file was sent to a secret chat (the file type is not known to the server). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecret
  
}



impl Object for FileTypeSecret {}
impl RObject for FileTypeSecret {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecret" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecret }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeSecret {}


impl FileTypeSecret {
  
  pub fn builder() -> RTDFileTypeSecretBuilder {
    let instance = Self {
      td_name: "fileTypeSecret".to_string(),
      
    };
    RTDFileTypeSecretBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeSecret> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeSecretBuilder { instance: FileTypeSecret }

impl RTDFileTypeSecretBuilder {
  fn new(instance: FileTypeSecret) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecret { self.instance.clone() }
  
}



/// The file is a thumbnail of a file from a secret chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecretThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecretThumbnail
  
}



impl Object for FileTypeSecretThumbnail {}
impl RObject for FileTypeSecretThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecretThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecretThumbnail }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeSecretThumbnail {}


impl FileTypeSecretThumbnail {
  
  pub fn builder() -> RTDFileTypeSecretThumbnailBuilder {
    let instance = Self {
      td_name: "fileTypeSecretThumbnail".to_string(),
      
    };
    RTDFileTypeSecretThumbnailBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeSecretThumbnail> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeSecretThumbnailBuilder { instance: FileTypeSecretThumbnail }

impl RTDFileTypeSecretThumbnailBuilder {
  fn new(instance: FileTypeSecretThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecretThumbnail { self.instance.clone() }
  
}



/// The file is a file from Secure storage used for storing Telegram Passport files. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecure {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecure
  
}



impl Object for FileTypeSecure {}
impl RObject for FileTypeSecure {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecure" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecure }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeSecure {}


impl FileTypeSecure {
  
  pub fn builder() -> RTDFileTypeSecureBuilder {
    let instance = Self {
      td_name: "fileTypeSecure".to_string(),
      
    };
    RTDFileTypeSecureBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeSecure> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeSecureBuilder { instance: FileTypeSecure }

impl RTDFileTypeSecureBuilder {
  fn new(instance: FileTypeSecure) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecure { self.instance.clone() }
  
}



/// The file is a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSticker
  
}



impl Object for FileTypeSticker {}
impl RObject for FileTypeSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSticker" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeSticker {}


impl FileTypeSticker {
  
  pub fn builder() -> RTDFileTypeStickerBuilder {
    let instance = Self {
      td_name: "fileTypeSticker".to_string(),
      
    };
    RTDFileTypeStickerBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeStickerBuilder { instance: FileTypeSticker }

impl RTDFileTypeStickerBuilder {
  fn new(instance: FileTypeSticker) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSticker { self.instance.clone() }
  
}



/// The file is a thumbnail of another file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeThumbnail
  
}



impl Object for FileTypeThumbnail {}
impl RObject for FileTypeThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeThumbnail }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeThumbnail {}


impl FileTypeThumbnail {
  
  pub fn builder() -> RTDFileTypeThumbnailBuilder {
    let instance = Self {
      td_name: "fileTypeThumbnail".to_string(),
      
    };
    RTDFileTypeThumbnailBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeThumbnail> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeThumbnailBuilder { instance: FileTypeThumbnail }

impl RTDFileTypeThumbnailBuilder {
  fn new(instance: FileTypeThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeThumbnail { self.instance.clone() }
  
}



/// The file type is not yet known. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeUnknown
  
}



impl Object for FileTypeUnknown {}
impl RObject for FileTypeUnknown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeUnknown" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeUnknown }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeUnknown {}


impl FileTypeUnknown {
  
  pub fn builder() -> RTDFileTypeUnknownBuilder {
    let instance = Self {
      td_name: "fileTypeUnknown".to_string(),
      
    };
    RTDFileTypeUnknownBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeUnknown> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeUnknownBuilder { instance: FileTypeUnknown }

impl RTDFileTypeUnknownBuilder {
  fn new(instance: FileTypeUnknown) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeUnknown { self.instance.clone() }
  
}



/// The file is a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVideo
  
}



impl Object for FileTypeVideo {}
impl RObject for FileTypeVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVideo" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeVideo {}


impl FileTypeVideo {
  
  pub fn builder() -> RTDFileTypeVideoBuilder {
    let instance = Self {
      td_name: "fileTypeVideo".to_string(),
      
    };
    RTDFileTypeVideoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeVideoBuilder { instance: FileTypeVideo }

impl RTDFileTypeVideoBuilder {
  fn new(instance: FileTypeVideo) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVideo { self.instance.clone() }
  
}



/// The file is a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVideoNote
  
}



impl Object for FileTypeVideoNote {}
impl RObject for FileTypeVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeVideoNote {}


impl FileTypeVideoNote {
  
  pub fn builder() -> RTDFileTypeVideoNoteBuilder {
    let instance = Self {
      td_name: "fileTypeVideoNote".to_string(),
      
    };
    RTDFileTypeVideoNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeVideoNoteBuilder { instance: FileTypeVideoNote }

impl RTDFileTypeVideoNoteBuilder {
  fn new(instance: FileTypeVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVideoNote { self.instance.clone() }
  
}



/// The file is a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVoiceNote
  
}



impl Object for FileTypeVoiceNote {}
impl RObject for FileTypeVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeVoiceNote {}


impl FileTypeVoiceNote {
  
  pub fn builder() -> RTDFileTypeVoiceNoteBuilder {
    let instance = Self {
      td_name: "fileTypeVoiceNote".to_string(),
      
    };
    RTDFileTypeVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeVoiceNoteBuilder { instance: FileTypeVoiceNote }

impl RTDFileTypeVoiceNoteBuilder {
  fn new(instance: FileTypeVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVoiceNote { self.instance.clone() }
  
}



/// The file is a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeWallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeWallpaper
  
}



impl Object for FileTypeWallpaper {}
impl RObject for FileTypeWallpaper {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeWallpaper" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeWallpaper }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl FileType for FileTypeWallpaper {}


impl FileTypeWallpaper {
  
  pub fn builder() -> RTDFileTypeWallpaperBuilder {
    let instance = Self {
      td_name: "fileTypeWallpaper".to_string(),
      
    };
    RTDFileTypeWallpaperBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FileTypeWallpaper> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFileTypeWallpaperBuilder { instance: FileTypeWallpaper }

impl RTDFileTypeWallpaperBuilder {
  fn new(instance: FileTypeWallpaper) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeWallpaper { self.instance.clone() }
  
}



/// A text with some entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormattedText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // formattedText
  /// The text.
  text: Option<String>,
  /// Entities contained in the text.
  entities: Option<Vec<TextEntity>>,
  
}



impl Object for FormattedText {}
impl RObject for FormattedText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "formattedText" }
  fn td_type(&self) -> RTDType { RTDType::FormattedText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl FormattedText {
  
  pub fn builder() -> RTDFormattedTextBuilder {
    let instance = Self {
      td_name: "formattedText".to_string(),
      text: None,
      entities: None,
      
    };
    RTDFormattedTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn entities(&self) -> Option<Vec<TextEntity>> { self.entities.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FormattedText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFormattedTextBuilder { instance: FormattedText }

impl RTDFormattedTextBuilder {
  fn new(instance: FormattedText) -> Self { Self { instance } }

  pub fn build(&self) -> FormattedText { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn entities(&mut self, entities: Vec<TextEntity>) -> &mut Self {
    self.instance.entities = Some(entities);
    self
  }
  
}



/// Contains a list of messages found by a search. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FoundMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // foundMessages
  /// List of messages.
  messages: Option<Vec<Message>>,
  /// Value to pass as from_search_id to get more results.
  next_from_search_id: Option<i64>,
  
}



impl Object for FoundMessages {}
impl RObject for FoundMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "foundMessages" }
  fn td_type(&self) -> RTDType { RTDType::FoundMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl FoundMessages {
  
  pub fn builder() -> RTDFoundMessagesBuilder {
    let instance = Self {
      td_name: "foundMessages".to_string(),
      messages: None,
      next_from_search_id: None,
      
    };
    RTDFoundMessagesBuilder::new(instance)
  }
  
  
  pub fn messages(&self) -> Option<Vec<Message>> { self.messages.clone() }
  
  pub fn next_from_search_id(&self) -> Option<i64> { self.next_from_search_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FoundMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFoundMessagesBuilder { instance: FoundMessages }

impl RTDFoundMessagesBuilder {
  fn new(instance: FoundMessages) -> Self { Self { instance } }

  pub fn build(&self) -> FoundMessages { self.instance.clone() }
  
  pub fn messages(&mut self, messages: Vec<Message>) -> &mut Self {
    self.instance.messages = Some(messages);
    self
  }
  
  pub fn next_from_search_id(&mut self, next_from_search_id: i64) -> &mut Self {
    self.instance.next_from_search_id = Some(next_from_search_id);
    self
  }
  
}



/// Describes a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Game {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // game
  /// Game ID.
  id: Option<i64>,
  /// Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}.
  short_name: Option<String>,
  /// Game title.
  title: Option<String>,
  /// Game text, usually containing scoreboards for a game.
  text: Option<FormattedText>,
  /// Game description.
  description: Option<String>,
  /// Game photo.
  photo: Option<Photo>,
  /// Game animation; may be null.
  animation: Option<Animation>,
  
}



impl Object for Game {}
impl RObject for Game {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "game" }
  fn td_type(&self) -> RTDType { RTDType::Game }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Game {
  
  pub fn builder() -> RTDGameBuilder {
    let instance = Self {
      td_name: "game".to_string(),
      id: None,
      short_name: None,
      title: None,
      text: None,
      description: None,
      photo: None,
      animation: None,
      
    };
    RTDGameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn short_name(&self) -> Option<String> { self.short_name.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Game> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGameBuilder { instance: Game }

impl RTDGameBuilder {
  fn new(instance: Game) -> Self { Self { instance } }

  pub fn build(&self) -> Game { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn short_name<S: AsRef<str>>(&mut self, short_name: S) -> &mut Self {
    self.instance.short_name = Some(short_name.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}



/// Contains one row of the game high score table. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // gameHighScore
  /// Position in the high score table.
  position: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// User score.
  score: Option<i32>,
  
}



impl Object for GameHighScore {}
impl RObject for GameHighScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "gameHighScore" }
  fn td_type(&self) -> RTDType { RTDType::GameHighScore }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl GameHighScore {
  
  pub fn builder() -> RTDGameHighScoreBuilder {
    let instance = Self {
      td_name: "gameHighScore".to_string(),
      position: None,
      user_id: None,
      score: None,
      
    };
    RTDGameHighScoreBuilder::new(instance)
  }
  
  
  pub fn position(&self) -> Option<i32> { self.position.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GameHighScore> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGameHighScoreBuilder { instance: GameHighScore }

impl RTDGameHighScoreBuilder {
  fn new(instance: GameHighScore) -> Self { Self { instance } }

  pub fn build(&self) -> GameHighScore { self.instance.clone() }
  
  pub fn position(&mut self, position: i32) -> &mut Self {
    self.instance.position = Some(position);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
}



/// Contains a list of game high scores. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // gameHighScores
  /// A list of game high scores.
  scores: Option<Vec<GameHighScore>>,
  
}



impl Object for GameHighScores {}
impl RObject for GameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "gameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GameHighScores }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl GameHighScores {
  
  pub fn builder() -> RTDGameHighScoresBuilder {
    let instance = Self {
      td_name: "gameHighScores".to_string(),
      scores: None,
      
    };
    RTDGameHighScoresBuilder::new(instance)
  }
  
  
  pub fn scores(&self) -> Option<Vec<GameHighScore>> { self.scores.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GameHighScores> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGameHighScoresBuilder { instance: GameHighScores }

impl RTDGameHighScoresBuilder {
  fn new(instance: GameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GameHighScores { self.instance.clone() }
  
  pub fn scores(&mut self, scores: Vec<GameHighScore>) -> &mut Self {
    self.instance.scores = Some(scores);
    self
  }
  
}



/// Contains a list of hashtags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // hashtags
  /// A list of hashtags.
  hashtags: Option<Vec<String>>,
  
}



impl Object for Hashtags {}
impl RObject for Hashtags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "hashtags" }
  fn td_type(&self) -> RTDType { RTDType::Hashtags }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Hashtags {
  
  pub fn builder() -> RTDHashtagsBuilder {
    let instance = Self {
      td_name: "hashtags".to_string(),
      hashtags: None,
      
    };
    RTDHashtagsBuilder::new(instance)
  }
  
  
  pub fn hashtags(&self) -> Option<Vec<String>> { self.hashtags.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Hashtags> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDHashtagsBuilder { instance: Hashtags }

impl RTDHashtagsBuilder {
  fn new(instance: Hashtags) -> Self { Self { instance } }

  pub fn build(&self) -> Hashtags { self.instance.clone() }
  
  pub fn hashtags(&mut self, hashtags: Vec<String>) -> &mut Self {
    self.instance.hashtags = Some(hashtags);
    self
  }
  
}



/// Contains an HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // httpUrl
  /// The URL.
  url: Option<String>,
  
}



impl Object for HttpUrl {}
impl RObject for HttpUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "httpUrl" }
  fn td_type(&self) -> RTDType { RTDType::HttpUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl HttpUrl {
  
  pub fn builder() -> RTDHttpUrlBuilder {
    let instance = Self {
      td_name: "httpUrl".to_string(),
      url: None,
      
    };
    RTDHttpUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<HttpUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDHttpUrlBuilder { instance: HttpUrl }

impl RTDHttpUrlBuilder {
  fn new(instance: HttpUrl) -> Self { Self { instance } }

  pub fn build(&self) -> HttpUrl { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// An identity document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // identityDocument
  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date; may be null.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<DatedFile>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  
}



impl Object for IdentityDocument {}
impl RObject for IdentityDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "identityDocument" }
  fn td_type(&self) -> RTDType { RTDType::IdentityDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl IdentityDocument {
  
  pub fn builder() -> RTDIdentityDocumentBuilder {
    let instance = Self {
      td_name: "identityDocument".to_string(),
      number: None,
      expiry_date: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      
    };
    RTDIdentityDocumentBuilder::new(instance)
  }
  
  
  pub fn number(&self) -> Option<String> { self.number.clone() }
  
  pub fn expiry_date(&self) -> Option<Date> { self.expiry_date.clone() }
  
  pub fn front_side(&self) -> Option<DatedFile> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<DatedFile> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<DatedFile> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<IdentityDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDIdentityDocumentBuilder { instance: IdentityDocument }

impl RTDIdentityDocumentBuilder {
  fn new(instance: IdentityDocument) -> Self { Self { instance } }

  pub fn build(&self) -> IdentityDocument { self.instance.clone() }
  
  pub fn number<S: AsRef<str>>(&mut self, number: S) -> &mut Self {
    self.instance.number = Some(number.as_ref().to_string());
    self
  }
  
  pub fn expiry_date(&mut self, expiry_date: Date) -> &mut Self {
    self.instance.expiry_date = Some(expiry_date);
    self
  }
  
  pub fn front_side(&mut self, front_side: DatedFile) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: DatedFile) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: DatedFile) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}



/// Represents the result of an ImportContacts request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // importedContacts
  /// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user.
  user_ids: Option<Vec<i32>>,
  /// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable.
  importer_count: Option<Vec<i32>>,
  
}



impl Object for ImportedContacts {}
impl RObject for ImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "importedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ImportedContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ImportedContacts {
  
  pub fn builder() -> RTDImportedContactsBuilder {
    let instance = Self {
      td_name: "importedContacts".to_string(),
      user_ids: None,
      importer_count: None,
      
    };
    RTDImportedContactsBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn importer_count(&self) -> Option<Vec<i32>> { self.importer_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ImportedContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDImportedContactsBuilder { instance: ImportedContacts }

impl RTDImportedContactsBuilder {
  fn new(instance: ImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ImportedContacts { self.instance.clone() }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
  pub fn importer_count(&mut self, importer_count: Vec<i32>) -> &mut Self {
    self.instance.importer_count = Some(importer_count);
    self
  }
  
}



/// Represents a single button in an inline keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineKeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButton
  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<InlineKeyboardButtonType>>,
  
}


impl Clone for InlineKeyboardButton {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InlineKeyboardButton {}
impl RObject for InlineKeyboardButton {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButton" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButton }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InlineKeyboardButton {
  
  pub fn builder() -> RTDInlineKeyboardButtonBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButton".to_string(),
      text: None,
      type_: None,
      
    };
    RTDInlineKeyboardButtonBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn type_(&self) -> Option<Box<InlineKeyboardButtonType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButton> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonBuilder { instance: InlineKeyboardButton }

impl RTDInlineKeyboardButtonBuilder {
  fn new(instance: InlineKeyboardButton) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButton { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn type_(&mut self, type_: Box<InlineKeyboardButtonType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// This class is an abstract base class. Describes the type of an inline keyboard button. 
#[typetag::serde(tag = "@struct")]
pub trait InlineKeyboardButtonType: Object + RObject + Debug {}







impl InlineKeyboardButtonType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InlineKeyboardButtonType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InlineKeyboardButtonType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInlineKeyboardButtonTypeType {
  InlineKeyboardButtonTypeBuy,
  InlineKeyboardButtonTypeCallback,
  InlineKeyboardButtonTypeCallbackGame,
  InlineKeyboardButtonTypeSwitchInline,
  InlineKeyboardButtonTypeUrl,
  
}
impl RTDInlineKeyboardButtonTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A button that opens a specified URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeUrl
  /// HTTP or tg:// URL to open.
  url: Option<String>,
  
}



impl Object for InlineKeyboardButtonTypeUrl {}
impl RObject for InlineKeyboardButtonTypeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeUrl" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeUrl {}


impl InlineKeyboardButtonTypeUrl {
  
  pub fn builder() -> RTDInlineKeyboardButtonTypeUrlBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButtonTypeUrl".to_string(),
      url: None,
      
    };
    RTDInlineKeyboardButtonTypeUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButtonTypeUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonTypeUrlBuilder { instance: InlineKeyboardButtonTypeUrl }

impl RTDInlineKeyboardButtonTypeUrlBuilder {
  fn new(instance: InlineKeyboardButtonTypeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeUrl { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// A button that sends a special callback query to a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallback {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeCallback
  /// Data to be sent to the bot via a callback query.
  data: Option<String>,
  
}



impl Object for InlineKeyboardButtonTypeCallback {}
impl RObject for InlineKeyboardButtonTypeCallback {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeCallback" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeCallback }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallback {}


impl InlineKeyboardButtonTypeCallback {
  
  pub fn builder() -> RTDInlineKeyboardButtonTypeCallbackBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButtonTypeCallback".to_string(),
      data: None,
      
    };
    RTDInlineKeyboardButtonTypeCallbackBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButtonTypeCallback> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonTypeCallbackBuilder { instance: InlineKeyboardButtonTypeCallback }

impl RTDInlineKeyboardButtonTypeCallbackBuilder {
  fn new(instance: InlineKeyboardButtonTypeCallback) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeCallback { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// A button with a game that sends a special callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallbackGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeCallbackGame
  
}



impl Object for InlineKeyboardButtonTypeCallbackGame {}
impl RObject for InlineKeyboardButtonTypeCallbackGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeCallbackGame" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeCallbackGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallbackGame {}


impl InlineKeyboardButtonTypeCallbackGame {
  
  pub fn builder() -> RTDInlineKeyboardButtonTypeCallbackGameBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButtonTypeCallbackGame".to_string(),
      
    };
    RTDInlineKeyboardButtonTypeCallbackGameBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButtonTypeCallbackGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonTypeCallbackGameBuilder { instance: InlineKeyboardButtonTypeCallbackGame }

impl RTDInlineKeyboardButtonTypeCallbackGameBuilder {
  fn new(instance: InlineKeyboardButtonTypeCallbackGame) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeCallbackGame { self.instance.clone() }
  
}



/// A button that forces an inline query to the bot to be inserted in the input field. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeSwitchInline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeSwitchInline
  /// Inline query to be sent to the bot.
  query: Option<String>,
  /// True, if the inline query should be sent from the current chat.
  in_current_chat: Option<bool>,
  
}



impl Object for InlineKeyboardButtonTypeSwitchInline {}
impl RObject for InlineKeyboardButtonTypeSwitchInline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeSwitchInline" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeSwitchInline }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeSwitchInline {}


impl InlineKeyboardButtonTypeSwitchInline {
  
  pub fn builder() -> RTDInlineKeyboardButtonTypeSwitchInlineBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButtonTypeSwitchInline".to_string(),
      query: None,
      in_current_chat: None,
      
    };
    RTDInlineKeyboardButtonTypeSwitchInlineBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn in_current_chat(&self) -> Option<bool> { self.in_current_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButtonTypeSwitchInline> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonTypeSwitchInlineBuilder { instance: InlineKeyboardButtonTypeSwitchInline }

impl RTDInlineKeyboardButtonTypeSwitchInlineBuilder {
  fn new(instance: InlineKeyboardButtonTypeSwitchInline) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeSwitchInline { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn in_current_chat(&mut self, in_current_chat: bool) -> &mut Self {
    self.instance.in_current_chat = Some(in_current_chat);
    self
  }
  
}



/// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeBuy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeBuy
  
}



impl Object for InlineKeyboardButtonTypeBuy {}
impl RObject for InlineKeyboardButtonTypeBuy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeBuy" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeBuy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeBuy {}


impl InlineKeyboardButtonTypeBuy {
  
  pub fn builder() -> RTDInlineKeyboardButtonTypeBuyBuilder {
    let instance = Self {
      td_name: "inlineKeyboardButtonTypeBuy".to_string(),
      
    };
    RTDInlineKeyboardButtonTypeBuyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineKeyboardButtonTypeBuy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineKeyboardButtonTypeBuyBuilder { instance: InlineKeyboardButtonTypeBuy }

impl RTDInlineKeyboardButtonTypeBuyBuilder {
  fn new(instance: InlineKeyboardButtonTypeBuy) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeBuy { self.instance.clone() }
  
}



/// This class is an abstract base class. Represents a single result of an inline query. 
#[typetag::serde(tag = "@struct")]
pub trait InlineQueryResult: Object + RObject + Debug {}







impl InlineQueryResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InlineQueryResult>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InlineQueryResult> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInlineQueryResultType {
  InlineQueryResultAnimation,
  InlineQueryResultArticle,
  InlineQueryResultAudio,
  InlineQueryResultContact,
  InlineQueryResultDocument,
  InlineQueryResultGame,
  InlineQueryResultLocation,
  InlineQueryResultPhoto,
  InlineQueryResultSticker,
  InlineQueryResultVenue,
  InlineQueryResultVideo,
  InlineQueryResultVoiceNote,
  
}
impl RTDInlineQueryResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Represents a link to an article or web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultArticle
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultArticle {}
impl RObject for InlineQueryResultArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultArticle" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultArticle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultArticle {}


impl InlineQueryResultArticle {
  
  pub fn builder() -> RTDInlineQueryResultArticleBuilder {
    let instance = Self {
      td_name: "inlineQueryResultArticle".to_string(),
      id: None,
      url: None,
      hide_url: None,
      title: None,
      description: None,
      thumbnail: None,
      
    };
    RTDInlineQueryResultArticleBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn hide_url(&self) -> Option<bool> { self.hide_url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultArticle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultArticleBuilder { instance: InlineQueryResultArticle }

impl RTDInlineQueryResultArticleBuilder {
  fn new(instance: InlineQueryResultArticle) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultArticle { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn hide_url(&mut self, hide_url: bool) -> &mut Self {
    self.instance.hide_url = Some(hide_url);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}



/// Represents a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultContact
  /// Unique identifier of the query result.
  id: Option<String>,
  /// A user contact.
  contact: Option<Contact>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultContact {}
impl RObject for InlineQueryResultContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultContact" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultContact {}


impl InlineQueryResultContact {
  
  pub fn builder() -> RTDInlineQueryResultContactBuilder {
    let instance = Self {
      td_name: "inlineQueryResultContact".to_string(),
      id: None,
      contact: None,
      thumbnail: None,
      
    };
    RTDInlineQueryResultContactBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultContactBuilder { instance: InlineQueryResultContact }

impl RTDInlineQueryResultContactBuilder {
  fn new(instance: InlineQueryResultContact) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultContact { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}



/// Represents a point on the map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultLocation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Title of the result.
  title: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultLocation {}
impl RObject for InlineQueryResultLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultLocation" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultLocation {}


impl InlineQueryResultLocation {
  
  pub fn builder() -> RTDInlineQueryResultLocationBuilder {
    let instance = Self {
      td_name: "inlineQueryResultLocation".to_string(),
      id: None,
      location: None,
      title: None,
      thumbnail: None,
      
    };
    RTDInlineQueryResultLocationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultLocationBuilder { instance: InlineQueryResultLocation }

impl RTDInlineQueryResultLocationBuilder {
  fn new(instance: InlineQueryResultLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultLocation { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}



/// Represents information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVenue
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultVenue {}
impl RObject for InlineQueryResultVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVenue" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVenue }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVenue {}


impl InlineQueryResultVenue {
  
  pub fn builder() -> RTDInlineQueryResultVenueBuilder {
    let instance = Self {
      td_name: "inlineQueryResultVenue".to_string(),
      id: None,
      venue: None,
      thumbnail: None,
      
    };
    RTDInlineQueryResultVenueBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultVenue> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultVenueBuilder { instance: InlineQueryResultVenue }

impl RTDInlineQueryResultVenueBuilder {
  fn new(instance: InlineQueryResultVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVenue { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}



/// Represents information about a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultGame
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Game result.
  game: Option<Game>,
  
}



impl Object for InlineQueryResultGame {}
impl RObject for InlineQueryResultGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultGame" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultGame {}


impl InlineQueryResultGame {
  
  pub fn builder() -> RTDInlineQueryResultGameBuilder {
    let instance = Self {
      td_name: "inlineQueryResultGame".to_string(),
      id: None,
      game: None,
      
    };
    RTDInlineQueryResultGameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn game(&self) -> Option<Game> { self.game.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultGameBuilder { instance: InlineQueryResultGame }

impl RTDInlineQueryResultGameBuilder {
  fn new(instance: InlineQueryResultGame) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultGame { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn game(&mut self, game: Game) -> &mut Self {
    self.instance.game = Some(game);
    self
  }
  
}



/// Represents an animation file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultAnimation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Animation file.
  animation: Option<Animation>,
  /// Animation title.
  title: Option<String>,
  
}



impl Object for InlineQueryResultAnimation {}
impl RObject for InlineQueryResultAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultAnimation" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultAnimation {}


impl InlineQueryResultAnimation {
  
  pub fn builder() -> RTDInlineQueryResultAnimationBuilder {
    let instance = Self {
      td_name: "inlineQueryResultAnimation".to_string(),
      id: None,
      animation: None,
      title: None,
      
    };
    RTDInlineQueryResultAnimationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultAnimationBuilder { instance: InlineQueryResultAnimation }

impl RTDInlineQueryResultAnimationBuilder {
  fn new(instance: InlineQueryResultAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultAnimation { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// Represents an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultAudio
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Audio file.
  audio: Option<Audio>,
  
}



impl Object for InlineQueryResultAudio {}
impl RObject for InlineQueryResultAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultAudio" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultAudio {}


impl InlineQueryResultAudio {
  
  pub fn builder() -> RTDInlineQueryResultAudioBuilder {
    let instance = Self {
      td_name: "inlineQueryResultAudio".to_string(),
      id: None,
      audio: None,
      
    };
    RTDInlineQueryResultAudioBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultAudioBuilder { instance: InlineQueryResultAudio }

impl RTDInlineQueryResultAudioBuilder {
  fn new(instance: InlineQueryResultAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultAudio { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
}



/// Represents a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultDocument
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Document.
  document: Option<Document>,
  /// Document title.
  title: Option<String>,
  /// Document description.
  description: Option<String>,
  
}



impl Object for InlineQueryResultDocument {}
impl RObject for InlineQueryResultDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultDocument" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultDocument {}


impl InlineQueryResultDocument {
  
  pub fn builder() -> RTDInlineQueryResultDocumentBuilder {
    let instance = Self {
      td_name: "inlineQueryResultDocument".to_string(),
      id: None,
      document: None,
      title: None,
      description: None,
      
    };
    RTDInlineQueryResultDocumentBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultDocumentBuilder { instance: InlineQueryResultDocument }

impl RTDInlineQueryResultDocumentBuilder {
  fn new(instance: InlineQueryResultDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultDocument { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Represents a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultPhoto
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Photo.
  photo: Option<Photo>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  
}



impl Object for InlineQueryResultPhoto {}
impl RObject for InlineQueryResultPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultPhoto" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultPhoto {}


impl InlineQueryResultPhoto {
  
  pub fn builder() -> RTDInlineQueryResultPhotoBuilder {
    let instance = Self {
      td_name: "inlineQueryResultPhoto".to_string(),
      id: None,
      photo: None,
      title: None,
      description: None,
      
    };
    RTDInlineQueryResultPhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultPhotoBuilder { instance: InlineQueryResultPhoto }

impl RTDInlineQueryResultPhotoBuilder {
  fn new(instance: InlineQueryResultPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultPhoto { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Represents a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultSticker
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Sticker.
  sticker: Option<Sticker>,
  
}



impl Object for InlineQueryResultSticker {}
impl RObject for InlineQueryResultSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultSticker" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultSticker {}


impl InlineQueryResultSticker {
  
  pub fn builder() -> RTDInlineQueryResultStickerBuilder {
    let instance = Self {
      td_name: "inlineQueryResultSticker".to_string(),
      id: None,
      sticker: None,
      
    };
    RTDInlineQueryResultStickerBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultStickerBuilder { instance: InlineQueryResultSticker }

impl RTDInlineQueryResultStickerBuilder {
  fn new(instance: InlineQueryResultSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultSticker { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Represents a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVideo
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Video.
  video: Option<Video>,
  /// Title of the video.
  title: Option<String>,
  /// Description of the video.
  description: Option<String>,
  
}



impl Object for InlineQueryResultVideo {}
impl RObject for InlineQueryResultVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVideo" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVideo {}


impl InlineQueryResultVideo {
  
  pub fn builder() -> RTDInlineQueryResultVideoBuilder {
    let instance = Self {
      td_name: "inlineQueryResultVideo".to_string(),
      id: None,
      video: None,
      title: None,
      description: None,
      
    };
    RTDInlineQueryResultVideoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultVideoBuilder { instance: InlineQueryResultVideo }

impl RTDInlineQueryResultVideoBuilder {
  fn new(instance: InlineQueryResultVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVideo { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Represents a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVoiceNote
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Voice note.
  voice_note: Option<VoiceNote>,
  /// Title of the voice note.
  title: Option<String>,
  
}



impl Object for InlineQueryResultVoiceNote {}
impl RObject for InlineQueryResultVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVoiceNote {}


impl InlineQueryResultVoiceNote {
  
  pub fn builder() -> RTDInlineQueryResultVoiceNoteBuilder {
    let instance = Self {
      td_name: "inlineQueryResultVoiceNote".to_string(),
      id: None,
      voice_note: None,
      title: None,
      
    };
    RTDInlineQueryResultVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResultVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultVoiceNoteBuilder { instance: InlineQueryResultVoiceNote }

impl RTDInlineQueryResultVoiceNoteBuilder {
  fn new(instance: InlineQueryResultVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVoiceNote { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// Represents the results of the inline query. Use 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResults
  /// Unique identifier of the inline query.
  inline_query_id: Option<i64>,
  /// The offset for the next request. If empty, there are no more results.
  next_offset: Option<String>,
  /// Results of the query.
  results: Option<Vec<Box<InlineQueryResult>>>,
  /// If non-empty, this text should be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// Parameter for the bot start message.
  switch_pm_parameter: Option<String>,
  
}


impl Clone for InlineQueryResults {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InlineQueryResults {}
impl RObject for InlineQueryResults {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResults" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResults }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InlineQueryResults {
  
  pub fn builder() -> RTDInlineQueryResultsBuilder {
    let instance = Self {
      td_name: "inlineQueryResults".to_string(),
      inline_query_id: None,
      next_offset: None,
      results: None,
      switch_pm_text: None,
      switch_pm_parameter: None,
      
    };
    RTDInlineQueryResultsBuilder::new(instance)
  }
  
  
  pub fn inline_query_id(&self) -> Option<i64> { self.inline_query_id.clone() }
  
  pub fn next_offset(&self) -> Option<String> { self.next_offset.clone() }
  
  pub fn results(&self) -> Option<Vec<Box<InlineQueryResult>>> { self.results.clone() }
  
  pub fn switch_pm_text(&self) -> Option<String> { self.switch_pm_text.clone() }
  
  pub fn switch_pm_parameter(&self) -> Option<String> { self.switch_pm_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InlineQueryResults> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInlineQueryResultsBuilder { instance: InlineQueryResults }

impl RTDInlineQueryResultsBuilder {
  fn new(instance: InlineQueryResults) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResults { self.instance.clone() }
  
  pub fn inline_query_id(&mut self, inline_query_id: i64) -> &mut Self {
    self.instance.inline_query_id = Some(inline_query_id);
    self
  }
  
  pub fn next_offset<S: AsRef<str>>(&mut self, next_offset: S) -> &mut Self {
    self.instance.next_offset = Some(next_offset.as_ref().to_string());
    self
  }
  
  pub fn results(&mut self, results: Vec<Box<InlineQueryResult>>) -> &mut Self {
    self.instance.results = Some(results);
    self
  }
  
  pub fn switch_pm_text<S: AsRef<str>>(&mut self, switch_pm_text: S) -> &mut Self {
    self.instance.switch_pm_text = Some(switch_pm_text.as_ref().to_string());
    self
  }
  
  pub fn switch_pm_parameter<S: AsRef<str>>(&mut self, switch_pm_parameter: S) -> &mut Self {
    self.instance.switch_pm_parameter = Some(switch_pm_parameter.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Contains information about the payment method chosen by the user. 
#[typetag::serde(tag = "@struct")]
pub trait InputCredentials: Object + RObject + Debug {}







impl InputCredentials {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputCredentials>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputCredentials> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputCredentialsType {
  InputCredentialsAndroidPay,
  InputCredentialsApplePay,
  InputCredentialsNew,
  InputCredentialsSaved,
  
}
impl RTDInputCredentialsType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsSaved {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsSaved
  /// Identifier of the saved credentials.
  saved_credentials_id: Option<String>,
  
}



impl Object for InputCredentialsSaved {}
impl RObject for InputCredentialsSaved {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsSaved" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsSaved }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsSaved {}


impl InputCredentialsSaved {
  
  pub fn builder() -> RTDInputCredentialsSavedBuilder {
    let instance = Self {
      td_name: "inputCredentialsSaved".to_string(),
      saved_credentials_id: None,
      
    };
    RTDInputCredentialsSavedBuilder::new(instance)
  }
  
  
  pub fn saved_credentials_id(&self) -> Option<String> { self.saved_credentials_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputCredentialsSaved> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputCredentialsSavedBuilder { instance: InputCredentialsSaved }

impl RTDInputCredentialsSavedBuilder {
  fn new(instance: InputCredentialsSaved) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsSaved { self.instance.clone() }
  
  pub fn saved_credentials_id<S: AsRef<str>>(&mut self, saved_credentials_id: S) -> &mut Self {
    self.instance.saved_credentials_id = Some(saved_credentials_id.as_ref().to_string());
    self
  }
  
}



/// Applies if a user enters new credentials on a payment provider website. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsNew {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsNew
  /// Contains JSON-encoded data with a credential identifier from the payment provider.
  data: Option<String>,
  /// True, if the credential identifier can be saved on the server side.
  allow_save: Option<bool>,
  
}



impl Object for InputCredentialsNew {}
impl RObject for InputCredentialsNew {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsNew" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsNew }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsNew {}


impl InputCredentialsNew {
  
  pub fn builder() -> RTDInputCredentialsNewBuilder {
    let instance = Self {
      td_name: "inputCredentialsNew".to_string(),
      data: None,
      allow_save: None,
      
    };
    RTDInputCredentialsNewBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn allow_save(&self) -> Option<bool> { self.allow_save.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputCredentialsNew> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputCredentialsNewBuilder { instance: InputCredentialsNew }

impl RTDInputCredentialsNewBuilder {
  fn new(instance: InputCredentialsNew) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsNew { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
  pub fn allow_save(&mut self, allow_save: bool) -> &mut Self {
    self.instance.allow_save = Some(allow_save);
    self
  }
  
}



/// Applies if a user enters new credentials using Android Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsAndroidPay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsAndroidPay
  /// JSON-encoded data with the credential identifier.
  data: Option<String>,
  
}



impl Object for InputCredentialsAndroidPay {}
impl RObject for InputCredentialsAndroidPay {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsAndroidPay" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsAndroidPay }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsAndroidPay {}


impl InputCredentialsAndroidPay {
  
  pub fn builder() -> RTDInputCredentialsAndroidPayBuilder {
    let instance = Self {
      td_name: "inputCredentialsAndroidPay".to_string(),
      data: None,
      
    };
    RTDInputCredentialsAndroidPayBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputCredentialsAndroidPay> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputCredentialsAndroidPayBuilder { instance: InputCredentialsAndroidPay }

impl RTDInputCredentialsAndroidPayBuilder {
  fn new(instance: InputCredentialsAndroidPay) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsAndroidPay { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// Applies if a user enters new credentials using Apple Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsApplePay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsApplePay
  /// JSON-encoded data with the credential identifier.
  data: Option<String>,
  
}



impl Object for InputCredentialsApplePay {}
impl RObject for InputCredentialsApplePay {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsApplePay" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsApplePay }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsApplePay {}


impl InputCredentialsApplePay {
  
  pub fn builder() -> RTDInputCredentialsApplePayBuilder {
    let instance = Self {
      td_name: "inputCredentialsApplePay".to_string(),
      data: None,
      
    };
    RTDInputCredentialsApplePayBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputCredentialsApplePay> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputCredentialsApplePayBuilder { instance: InputCredentialsApplePay }

impl RTDInputCredentialsApplePayBuilder {
  fn new(instance: InputCredentialsApplePay) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsApplePay { self.instance.clone() }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Points to a file. 
#[typetag::serde(tag = "@struct")]
pub trait InputFile: Object + RObject + Debug {}







impl InputFile {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputFile>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputFile> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputFileType {
  InputFileGenerated,
  InputFileId,
  InputFileLocal,
  InputFileRemote,
  
}
impl RTDInputFileType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A file defined by its unique ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileId
  /// Unique file identifier.
  id: Option<i32>,
  
}



impl Object for InputFileId {}
impl RObject for InputFileId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileId" }
  fn td_type(&self) -> RTDType { RTDType::InputFileId }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputFile for InputFileId {}


impl InputFileId {
  
  pub fn builder() -> RTDInputFileIdBuilder {
    let instance = Self {
      td_name: "inputFileId".to_string(),
      id: None,
      
    };
    RTDInputFileIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputFileId> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputFileIdBuilder { instance: InputFileId }

impl RTDInputFileIdBuilder {
  fn new(instance: InputFileId) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileId { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}



/// A file defined by its remote ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileRemote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileRemote
  /// Remote file identifier.
  id: Option<String>,
  
}



impl Object for InputFileRemote {}
impl RObject for InputFileRemote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileRemote" }
  fn td_type(&self) -> RTDType { RTDType::InputFileRemote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputFile for InputFileRemote {}


impl InputFileRemote {
  
  pub fn builder() -> RTDInputFileRemoteBuilder {
    let instance = Self {
      td_name: "inputFileRemote".to_string(),
      id: None,
      
    };
    RTDInputFileRemoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputFileRemote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputFileRemoteBuilder { instance: InputFileRemote }

impl RTDInputFileRemoteBuilder {
  fn new(instance: InputFileRemote) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileRemote { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
}



/// A file defined by a local path. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileLocal {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileLocal
  /// Local path to the file.
  path: Option<String>,
  
}



impl Object for InputFileLocal {}
impl RObject for InputFileLocal {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileLocal" }
  fn td_type(&self) -> RTDType { RTDType::InputFileLocal }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputFile for InputFileLocal {}


impl InputFileLocal {
  
  pub fn builder() -> RTDInputFileLocalBuilder {
    let instance = Self {
      td_name: "inputFileLocal".to_string(),
      path: None,
      
    };
    RTDInputFileLocalBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputFileLocal> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputFileLocalBuilder { instance: InputFileLocal }

impl RTDInputFileLocalBuilder {
  fn new(instance: InputFileLocal) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileLocal { self.instance.clone() }
  
  pub fn path<S: AsRef<str>>(&mut self, path: S) -> &mut Self {
    self.instance.path = Some(path.as_ref().to_string());
    self
  }
  
}



/// A file generated by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileGenerated {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileGenerated
  /// Local path to a file from which the file is generated; may be empty if there is no such file.
  original_path: Option<String>,
  /// String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage.
  conversion: Option<String>,
  /// Expected size of the generated file; 0 if unknown.
  expected_size: Option<i32>,
  
}



impl Object for InputFileGenerated {}
impl RObject for InputFileGenerated {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileGenerated" }
  fn td_type(&self) -> RTDType { RTDType::InputFileGenerated }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputFile for InputFileGenerated {}


impl InputFileGenerated {
  
  pub fn builder() -> RTDInputFileGeneratedBuilder {
    let instance = Self {
      td_name: "inputFileGenerated".to_string(),
      original_path: None,
      conversion: None,
      expected_size: None,
      
    };
    RTDInputFileGeneratedBuilder::new(instance)
  }
  
  
  pub fn original_path(&self) -> Option<String> { self.original_path.clone() }
  
  pub fn conversion(&self) -> Option<String> { self.conversion.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputFileGenerated> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputFileGeneratedBuilder { instance: InputFileGenerated }

impl RTDInputFileGeneratedBuilder {
  fn new(instance: InputFileGenerated) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileGenerated { self.instance.clone() }
  
  pub fn original_path<S: AsRef<str>>(&mut self, original_path: S) -> &mut Self {
    self.instance.original_path = Some(original_path.as_ref().to_string());
    self
  }
  
  pub fn conversion<S: AsRef<str>>(&mut self, conversion: S) -> &mut Self {
    self.instance.conversion = Some(conversion.as_ref().to_string());
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
}



/// An identity document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputIdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputIdentityDocument
  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date, if available.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<Box<InputFile>>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<Box<InputFile>>,
  /// Selfie with the document, if available.
  selfie: Option<Box<InputFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,
  
}


impl Clone for InputIdentityDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputIdentityDocument {}
impl RObject for InputIdentityDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputIdentityDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputIdentityDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InputIdentityDocument {
  
  pub fn builder() -> RTDInputIdentityDocumentBuilder {
    let instance = Self {
      td_name: "inputIdentityDocument".to_string(),
      number: None,
      expiry_date: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      
    };
    RTDInputIdentityDocumentBuilder::new(instance)
  }
  
  
  pub fn number(&self) -> Option<String> { self.number.clone() }
  
  pub fn expiry_date(&self) -> Option<Date> { self.expiry_date.clone() }
  
  pub fn front_side(&self) -> Option<Box<InputFile>> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<Box<InputFile>> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<Box<InputFile>> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<Box<InputFile>>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputIdentityDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputIdentityDocumentBuilder { instance: InputIdentityDocument }

impl RTDInputIdentityDocumentBuilder {
  fn new(instance: InputIdentityDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputIdentityDocument { self.instance.clone() }
  
  pub fn number<S: AsRef<str>>(&mut self, number: S) -> &mut Self {
    self.instance.number = Some(number.as_ref().to_string());
    self
  }
  
  pub fn expiry_date(&mut self, expiry_date: Date) -> &mut Self {
    self.instance.expiry_date = Some(expiry_date);
    self
  }
  
  pub fn front_side(&mut self, front_side: Box<InputFile>) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: Box<InputFile>) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: Box<InputFile>) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}



/// This class is an abstract base class. Represents a single result of an inline query; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputInlineQueryResult: Object + RObject + Debug {}







impl InputInlineQueryResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputInlineQueryResult>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputInlineQueryResult> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputInlineQueryResultType {
  InputInlineQueryResultAnimatedGif,
  InputInlineQueryResultAnimatedMpeg4,
  InputInlineQueryResultArticle,
  InputInlineQueryResultAudio,
  InputInlineQueryResultContact,
  InputInlineQueryResultDocument,
  InputInlineQueryResultGame,
  InputInlineQueryResultLocation,
  InputInlineQueryResultPhoto,
  InputInlineQueryResultSticker,
  InputInlineQueryResultVenue,
  InputInlineQueryResultVideo,
  InputInlineQueryResultVoiceNote,
  
}
impl RTDInputInlineQueryResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Represents a link to an animated GIF. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedGif {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAnimatedGif
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the query result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the GIF-file (file size must not exceed 1MB).
  gif_url: Option<String>,
  /// Duration of the GIF, in seconds.
  gif_duration: Option<i32>,
  /// Width of the GIF.
  gif_width: Option<i32>,
  /// Height of the GIF.
  gif_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAnimatedGif {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultAnimatedGif {}
impl RObject for InputInlineQueryResultAnimatedGif {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAnimatedGif" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAnimatedGif }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAnimatedGif {}


impl InputInlineQueryResultAnimatedGif {
  
  pub fn builder() -> RTDInputInlineQueryResultAnimatedGifBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultAnimatedGif".to_string(),
      id: None,
      title: None,
      thumbnail_url: None,
      gif_url: None,
      gif_duration: None,
      gif_width: None,
      gif_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultAnimatedGifBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn gif_url(&self) -> Option<String> { self.gif_url.clone() }
  
  pub fn gif_duration(&self) -> Option<i32> { self.gif_duration.clone() }
  
  pub fn gif_width(&self) -> Option<i32> { self.gif_width.clone() }
  
  pub fn gif_height(&self) -> Option<i32> { self.gif_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultAnimatedGif> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultAnimatedGifBuilder { instance: InputInlineQueryResultAnimatedGif }

impl RTDInputInlineQueryResultAnimatedGifBuilder {
  fn new(instance: InputInlineQueryResultAnimatedGif) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAnimatedGif { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn gif_url<S: AsRef<str>>(&mut self, gif_url: S) -> &mut Self {
    self.instance.gif_url = Some(gif_url.as_ref().to_string());
    self
  }
  
  pub fn gif_duration(&mut self, gif_duration: i32) -> &mut Self {
    self.instance.gif_duration = Some(gif_duration);
    self
  }
  
  pub fn gif_width(&mut self, gif_width: i32) -> &mut Self {
    self.instance.gif_width = Some(gif_width);
    self
  }
  
  pub fn gif_height(&mut self, gif_height: i32) -> &mut Self {
    self.instance.gif_height = Some(gif_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to an animated (i.e. without sound) H.264/MPEG-4 AVC video. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedMpeg4 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAnimatedMpeg4
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the MPEG4-file (file size must not exceed 1MB).
  mpeg4_url: Option<String>,
  /// Duration of the video, in seconds.
  mpeg4_duration: Option<i32>,
  /// Width of the video.
  mpeg4_width: Option<i32>,
  /// Height of the video.
  mpeg4_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAnimatedMpeg4 {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultAnimatedMpeg4 {}
impl RObject for InputInlineQueryResultAnimatedMpeg4 {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAnimatedMpeg4" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAnimatedMpeg4 }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAnimatedMpeg4 {}


impl InputInlineQueryResultAnimatedMpeg4 {
  
  pub fn builder() -> RTDInputInlineQueryResultAnimatedMpeg4Builder {
    let instance = Self {
      td_name: "inputInlineQueryResultAnimatedMpeg4".to_string(),
      id: None,
      title: None,
      thumbnail_url: None,
      mpeg4_url: None,
      mpeg4_duration: None,
      mpeg4_width: None,
      mpeg4_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultAnimatedMpeg4Builder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn mpeg4_url(&self) -> Option<String> { self.mpeg4_url.clone() }
  
  pub fn mpeg4_duration(&self) -> Option<i32> { self.mpeg4_duration.clone() }
  
  pub fn mpeg4_width(&self) -> Option<i32> { self.mpeg4_width.clone() }
  
  pub fn mpeg4_height(&self) -> Option<i32> { self.mpeg4_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultAnimatedMpeg4> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultAnimatedMpeg4Builder { instance: InputInlineQueryResultAnimatedMpeg4 }

impl RTDInputInlineQueryResultAnimatedMpeg4Builder {
  fn new(instance: InputInlineQueryResultAnimatedMpeg4) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAnimatedMpeg4 { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn mpeg4_url<S: AsRef<str>>(&mut self, mpeg4_url: S) -> &mut Self {
    self.instance.mpeg4_url = Some(mpeg4_url.as_ref().to_string());
    self
  }
  
  pub fn mpeg4_duration(&mut self, mpeg4_duration: i32) -> &mut Self {
    self.instance.mpeg4_duration = Some(mpeg4_duration);
    self
  }
  
  pub fn mpeg4_width(&mut self, mpeg4_width: i32) -> &mut Self {
    self.instance.mpeg4_width = Some(mpeg4_width);
    self
  }
  
  pub fn mpeg4_height(&mut self, mpeg4_height: i32) -> &mut Self {
    self.instance.mpeg4_height = Some(mpeg4_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to an article or web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultArticle
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultArticle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultArticle {}
impl RObject for InputInlineQueryResultArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultArticle" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultArticle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultArticle {}


impl InputInlineQueryResultArticle {
  
  pub fn builder() -> RTDInputInlineQueryResultArticleBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultArticle".to_string(),
      id: None,
      url: None,
      hide_url: None,
      title: None,
      description: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultArticleBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn hide_url(&self) -> Option<bool> { self.hide_url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultArticle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultArticleBuilder { instance: InputInlineQueryResultArticle }

impl RTDInputInlineQueryResultArticleBuilder {
  fn new(instance: InputInlineQueryResultArticle) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultArticle { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn hide_url(&mut self, hide_url: bool) -> &mut Self {
    self.instance.hide_url = Some(hide_url);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to an MP3 audio file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAudio
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the audio file.
  title: Option<String>,
  /// Performer of the audio file.
  performer: Option<String>,
  /// The URL of the audio file.
  audio_url: Option<String>,
  /// Audio file duration, in seconds.
  audio_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAudio, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAudio {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultAudio {}
impl RObject for InputInlineQueryResultAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAudio" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAudio {}


impl InputInlineQueryResultAudio {
  
  pub fn builder() -> RTDInputInlineQueryResultAudioBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultAudio".to_string(),
      id: None,
      title: None,
      performer: None,
      audio_url: None,
      audio_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultAudioBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn audio_url(&self) -> Option<String> { self.audio_url.clone() }
  
  pub fn audio_duration(&self) -> Option<i32> { self.audio_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultAudioBuilder { instance: InputInlineQueryResultAudio }

impl RTDInputInlineQueryResultAudioBuilder {
  fn new(instance: InputInlineQueryResultAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAudio { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn performer<S: AsRef<str>>(&mut self, performer: S) -> &mut Self {
    self.instance.performer = Some(performer.as_ref().to_string());
    self
  }
  
  pub fn audio_url<S: AsRef<str>>(&mut self, audio_url: S) -> &mut Self {
    self.instance.audio_url = Some(audio_url.as_ref().to_string());
    self
  }
  
  pub fn audio_duration(&mut self, audio_duration: i32) -> &mut Self {
    self.instance.audio_duration = Some(audio_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a user contact. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultContact
  /// Unique identifier of the query result.
  id: Option<String>,
  /// User contact.
  contact: Option<Contact>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultContact {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultContact {}
impl RObject for InputInlineQueryResultContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultContact" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultContact {}


impl InputInlineQueryResultContact {
  
  pub fn builder() -> RTDInputInlineQueryResultContactBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultContact".to_string(),
      id: None,
      contact: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultContactBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultContactBuilder { instance: InputInlineQueryResultContact }

impl RTDInputInlineQueryResultContactBuilder {
  fn new(instance: InputInlineQueryResultContact) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultContact { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to a file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultDocument
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the resulting file.
  title: Option<String>,
  /// Short description of the result, if known.
  description: Option<String>,
  /// URL of the file.
  document_url: Option<String>,
  /// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed.
  mime_type: Option<String>,
  /// The URL of the file thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Width of the thumbnail.
  thumbnail_width: Option<i32>,
  /// Height of the thumbnail.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageDocument, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultDocument {}
impl RObject for InputInlineQueryResultDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultDocument {}


impl InputInlineQueryResultDocument {
  
  pub fn builder() -> RTDInputInlineQueryResultDocumentBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultDocument".to_string(),
      id: None,
      title: None,
      description: None,
      document_url: None,
      mime_type: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultDocumentBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn document_url(&self) -> Option<String> { self.document_url.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultDocumentBuilder { instance: InputInlineQueryResultDocument }

impl RTDInputInlineQueryResultDocumentBuilder {
  fn new(instance: InputInlineQueryResultDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultDocument { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn document_url<S: AsRef<str>>(&mut self, document_url: S) -> &mut Self {
    self.instance.document_url = Some(document_url.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a game. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultGame
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Short name of the game.
  game_short_name: Option<String>,
  /// Message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for InputInlineQueryResultGame {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultGame {}
impl RObject for InputInlineQueryResultGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultGame" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultGame {}


impl InputInlineQueryResultGame {
  
  pub fn builder() -> RTDInputInlineQueryResultGameBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultGame".to_string(),
      id: None,
      game_short_name: None,
      reply_markup: None,
      
    };
    RTDInputInlineQueryResultGameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultGameBuilder { instance: InputInlineQueryResultGame }

impl RTDInputInlineQueryResultGameBuilder {
  fn new(instance: InputInlineQueryResultGame) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultGame { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn game_short_name<S: AsRef<str>>(&mut self, game_short_name: S) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}



/// Represents a point on the map. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultLocation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Amount of time relative to the message sent time until the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultLocation {}
impl RObject for InputInlineQueryResultLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultLocation" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultLocation {}


impl InputInlineQueryResultLocation {
  
  pub fn builder() -> RTDInputInlineQueryResultLocationBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultLocation".to_string(),
      id: None,
      location: None,
      live_period: None,
      title: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultLocationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultLocationBuilder { instance: InputInlineQueryResultLocation }

impl RTDInputInlineQueryResultLocationBuilder {
  fn new(instance: InputInlineQueryResultLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultLocation { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents link to a JPEG image. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultPhoto
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// URL of the photo thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the JPEG photo (photo size must not exceed 5MB).
  photo_url: Option<String>,
  /// Width of the photo.
  photo_width: Option<i32>,
  /// Height of the photo.
  photo_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessagePhoto, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultPhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultPhoto {}
impl RObject for InputInlineQueryResultPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultPhoto" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultPhoto {}


impl InputInlineQueryResultPhoto {
  
  pub fn builder() -> RTDInputInlineQueryResultPhotoBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultPhoto".to_string(),
      id: None,
      title: None,
      description: None,
      thumbnail_url: None,
      photo_url: None,
      photo_width: None,
      photo_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultPhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn photo_url(&self) -> Option<String> { self.photo_url.clone() }
  
  pub fn photo_width(&self) -> Option<i32> { self.photo_width.clone() }
  
  pub fn photo_height(&self) -> Option<i32> { self.photo_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultPhotoBuilder { instance: InputInlineQueryResultPhoto }

impl RTDInputInlineQueryResultPhotoBuilder {
  fn new(instance: InputInlineQueryResultPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultPhoto { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn photo_url<S: AsRef<str>>(&mut self, photo_url: S) -> &mut Self {
    self.instance.photo_url = Some(photo_url.as_ref().to_string());
    self
  }
  
  pub fn photo_width(&mut self, photo_width: i32) -> &mut Self {
    self.instance.photo_width = Some(photo_width);
    self
  }
  
  pub fn photo_height(&mut self, photo_height: i32) -> &mut Self {
    self.instance.photo_height = Some(photo_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to a WEBP sticker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultSticker
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the sticker thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the WEBP sticker (sticker file size must not exceed 5MB).
  sticker_url: Option<String>,
  /// Width of the sticker.
  sticker_width: Option<i32>,
  /// Height of the sticker.
  sticker_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, inputMessageSticker, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultSticker {}
impl RObject for InputInlineQueryResultSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultSticker {}


impl InputInlineQueryResultSticker {
  
  pub fn builder() -> RTDInputInlineQueryResultStickerBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultSticker".to_string(),
      id: None,
      thumbnail_url: None,
      sticker_url: None,
      sticker_width: None,
      sticker_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultStickerBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn sticker_url(&self) -> Option<String> { self.sticker_url.clone() }
  
  pub fn sticker_width(&self) -> Option<i32> { self.sticker_width.clone() }
  
  pub fn sticker_height(&self) -> Option<i32> { self.sticker_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultStickerBuilder { instance: InputInlineQueryResultSticker }

impl RTDInputInlineQueryResultStickerBuilder {
  fn new(instance: InputInlineQueryResultSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultSticker { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn sticker_url<S: AsRef<str>>(&mut self, sticker_url: S) -> &mut Self {
    self.instance.sticker_url = Some(sticker_url.as_ref().to_string());
    self
  }
  
  pub fn sticker_width(&mut self, sticker_width: i32) -> &mut Self {
    self.instance.sticker_width = Some(sticker_width);
    self
  }
  
  pub fn sticker_height(&mut self, sticker_height: i32) -> &mut Self {
    self.instance.sticker_height = Some(sticker_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents information about a venue. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVenue
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVenue {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultVenue {}
impl RObject for InputInlineQueryResultVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVenue" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVenue }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVenue {}


impl InputInlineQueryResultVenue {
  
  pub fn builder() -> RTDInputInlineQueryResultVenueBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultVenue".to_string(),
      id: None,
      venue: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultVenueBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultVenue> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultVenueBuilder { instance: InputInlineQueryResultVenue }

impl RTDInputInlineQueryResultVenueBuilder {
  fn new(instance: InputInlineQueryResultVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVenue { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to a page containing an embedded video player or a video file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVideo
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// The URL of the video thumbnail (JPEG), if it exists.
  thumbnail_url: Option<String>,
  /// URL of the embedded video player or video file.
  video_url: Option<String>,
  /// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported.
  mime_type: Option<String>,
  /// Width of the video.
  video_width: Option<i32>,
  /// Height of the video.
  video_height: Option<i32>,
  /// Video duration, in seconds.
  video_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVideo, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVideo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultVideo {}
impl RObject for InputInlineQueryResultVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVideo" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVideo {}


impl InputInlineQueryResultVideo {
  
  pub fn builder() -> RTDInputInlineQueryResultVideoBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultVideo".to_string(),
      id: None,
      title: None,
      description: None,
      thumbnail_url: None,
      video_url: None,
      mime_type: None,
      video_width: None,
      video_height: None,
      video_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultVideoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn video_url(&self) -> Option<String> { self.video_url.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn video_width(&self) -> Option<i32> { self.video_width.clone() }
  
  pub fn video_height(&self) -> Option<i32> { self.video_height.clone() }
  
  pub fn video_duration(&self) -> Option<i32> { self.video_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultVideoBuilder { instance: InputInlineQueryResultVideo }

impl RTDInputInlineQueryResultVideoBuilder {
  fn new(instance: InputInlineQueryResultVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVideo { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn thumbnail_url<S: AsRef<str>>(&mut self, thumbnail_url: S) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url.as_ref().to_string());
    self
  }
  
  pub fn video_url<S: AsRef<str>>(&mut self, video_url: S) -> &mut Self {
    self.instance.video_url = Some(video_url.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn video_width(&mut self, video_width: i32) -> &mut Self {
    self.instance.video_width = Some(video_width);
    self
  }
  
  pub fn video_height(&mut self, video_height: i32) -> &mut Self {
    self.instance.video_height = Some(video_height);
    self
  }
  
  pub fn video_duration(&mut self, video_duration: i32) -> &mut Self {
    self.instance.video_duration = Some(video_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Represents a link to an opus-encoded audio file within an OGG container, single channel audio. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVoiceNote
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the voice note.
  title: Option<String>,
  /// The URL of the voice note file.
  voice_note_url: Option<String>,
  /// Duration of the voice note, in seconds.
  voice_note_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVoiceNote, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVoiceNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputInlineQueryResultVoiceNote {}
impl RObject for InputInlineQueryResultVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVoiceNote {}


impl InputInlineQueryResultVoiceNote {
  
  pub fn builder() -> RTDInputInlineQueryResultVoiceNoteBuilder {
    let instance = Self {
      td_name: "inputInlineQueryResultVoiceNote".to_string(),
      id: None,
      title: None,
      voice_note_url: None,
      voice_note_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDInputInlineQueryResultVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn voice_note_url(&self) -> Option<String> { self.voice_note_url.clone() }
  
  pub fn voice_note_duration(&self) -> Option<i32> { self.voice_note_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputInlineQueryResultVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputInlineQueryResultVoiceNoteBuilder { instance: InputInlineQueryResultVoiceNote }

impl RTDInputInlineQueryResultVoiceNoteBuilder {
  fn new(instance: InputInlineQueryResultVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVoiceNote { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn voice_note_url<S: AsRef<str>>(&mut self, voice_note_url: S) -> &mut Self {
    self.instance.voice_note_url = Some(voice_note_url.as_ref().to_string());
    self
  }
  
  pub fn voice_note_duration(&mut self, voice_note_duration: i32) -> &mut Self {
    self.instance.voice_note_duration = Some(voice_note_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// This class is an abstract base class. The content of a message to send. 
#[typetag::serde(tag = "@struct")]
pub trait InputMessageContent: Object + RObject + Debug {}







impl InputMessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputMessageContent>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputMessageContent> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputMessageContentType {
  InputMessageAnimation,
  InputMessageAudio,
  InputMessageContact,
  InputMessageDocument,
  InputMessageForwarded,
  InputMessageGame,
  InputMessageInvoice,
  InputMessageLocation,
  InputMessagePhoto,
  InputMessagePoll,
  InputMessageSticker,
  InputMessageText,
  InputMessageVenue,
  InputMessageVideo,
  InputMessageVideoNote,
  InputMessageVoiceNote,
  
}
impl RTDInputMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageText
  /// Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Code, Pre, PreCode and TextUrl entities are allowed to be specified manually.
  text: Option<FormattedText>,
  /// True, if rich web page previews for URLs in the message text should be disabled.
  disable_web_page_preview: Option<bool>,
  /// True, if a chat message draft should be deleted.
  clear_draft: Option<bool>,
  
}



impl Object for InputMessageText {}
impl RObject for InputMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageText" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageText {}


impl InputMessageText {
  
  pub fn builder() -> RTDInputMessageTextBuilder {
    let instance = Self {
      td_name: "inputMessageText".to_string(),
      text: None,
      disable_web_page_preview: None,
      clear_draft: None,
      
    };
    RTDInputMessageTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn disable_web_page_preview(&self) -> Option<bool> { self.disable_web_page_preview.clone() }
  
  pub fn clear_draft(&self) -> Option<bool> { self.clear_draft.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageTextBuilder { instance: InputMessageText }

impl RTDInputMessageTextBuilder {
  fn new(instance: InputMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageText { self.instance.clone() }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn disable_web_page_preview(&mut self, disable_web_page_preview: bool) -> &mut Self {
    self.instance.disable_web_page_preview = Some(disable_web_page_preview);
    self
  }
  
  pub fn clear_draft(&mut self, clear_draft: bool) -> &mut Self {
    self.instance.clear_draft = Some(clear_draft);
    self
  }
  
}



/// An animation message (GIF-style). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageAnimation
  /// Animation file to be sent.
  animation: Option<Box<InputFile>>,
  /// Animation thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the animation, in seconds.
  duration: Option<i32>,
  /// Width of the animation; may be replaced by the server.
  width: Option<i32>,
  /// Height of the animation; may be replaced by the server.
  height: Option<i32>,
  /// Animation caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageAnimation {}
impl RObject for InputMessageAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageAnimation" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageAnimation {}


impl InputMessageAnimation {
  
  pub fn builder() -> RTDInputMessageAnimationBuilder {
    let instance = Self {
      td_name: "inputMessageAnimation".to_string(),
      animation: None,
      thumbnail: None,
      duration: None,
      width: None,
      height: None,
      caption: None,
      
    };
    RTDInputMessageAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageAnimationBuilder { instance: InputMessageAnimation }

impl RTDInputMessageAnimationBuilder {
  fn new(instance: InputMessageAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// An audio message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageAudio
  /// Audio file to be sent.
  audio: Option<Box<InputFile>>,
  /// Thumbnail of the cover for the album, if available.
  album_cover_thumbnail: Option<InputThumbnail>,
  /// Duration of the audio, in seconds; may be replaced by the server.
  duration: Option<i32>,
  /// Title of the audio; 0-64 characters; may be replaced by the server.
  title: Option<String>,
  /// Performer of the audio; 0-64 characters, may be replaced by the server.
  performer: Option<String>,
  /// Audio caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageAudio {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageAudio {}
impl RObject for InputMessageAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageAudio" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageAudio {}


impl InputMessageAudio {
  
  pub fn builder() -> RTDInputMessageAudioBuilder {
    let instance = Self {
      td_name: "inputMessageAudio".to_string(),
      audio: None,
      album_cover_thumbnail: None,
      duration: None,
      title: None,
      performer: None,
      caption: None,
      
    };
    RTDInputMessageAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> Option<Box<InputFile>> { self.audio.clone() }
  
  pub fn album_cover_thumbnail(&self) -> Option<InputThumbnail> { self.album_cover_thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageAudioBuilder { instance: InputMessageAudio }

impl RTDInputMessageAudioBuilder {
  fn new(instance: InputMessageAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageAudio { self.instance.clone() }
  
  pub fn audio(&mut self, audio: Box<InputFile>) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn album_cover_thumbnail(&mut self, album_cover_thumbnail: InputThumbnail) -> &mut Self {
    self.instance.album_cover_thumbnail = Some(album_cover_thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn performer<S: AsRef<str>>(&mut self, performer: S) -> &mut Self {
    self.instance.performer = Some(performer.as_ref().to_string());
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A document message (general file). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageDocument
  /// Document to be sent.
  document: Option<Box<InputFile>>,
  /// Document thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Document caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageDocument {}
impl RObject for InputMessageDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageDocument {}


impl InputMessageDocument {
  
  pub fn builder() -> RTDInputMessageDocumentBuilder {
    let instance = Self {
      td_name: "inputMessageDocument".to_string(),
      document: None,
      thumbnail: None,
      caption: None,
      
    };
    RTDInputMessageDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> Option<Box<InputFile>> { self.document.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageDocumentBuilder { instance: InputMessageDocument }

impl RTDInputMessageDocumentBuilder {
  fn new(instance: InputMessageDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageDocument { self.instance.clone() }
  
  pub fn document(&mut self, document: Box<InputFile>) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A photo message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessagePhoto
  /// Photo to send.
  photo: Option<Box<InputFile>>,
  /// Photo thumbnail to be sent, this is sent to the other party in secret chats only.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the photo, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,
  /// Photo caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,
  
}


impl Clone for InputMessagePhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessagePhoto {}
impl RObject for InputMessagePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessagePhoto" }
  fn td_type(&self) -> RTDType { RTDType::InputMessagePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessagePhoto {}


impl InputMessagePhoto {
  
  pub fn builder() -> RTDInputMessagePhotoBuilder {
    let instance = Self {
      td_name: "inputMessagePhoto".to_string(),
      photo: None,
      thumbnail: None,
      added_sticker_file_ids: None,
      width: None,
      height: None,
      caption: None,
      ttl: None,
      
    };
    RTDInputMessagePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn added_sticker_file_ids(&self) -> Option<Vec<i32>> { self.added_sticker_file_ids.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessagePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessagePhotoBuilder { instance: InputMessagePhoto }

impl RTDInputMessagePhotoBuilder {
  fn new(instance: InputMessagePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessagePhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn added_sticker_file_ids(&mut self, added_sticker_file_ids: Vec<i32>) -> &mut Self {
    self.instance.added_sticker_file_ids = Some(added_sticker_file_ids);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}



/// A sticker message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageSticker
  /// Sticker to be sent.
  sticker: Option<Box<InputFile>>,
  /// Sticker thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Sticker width.
  width: Option<i32>,
  /// Sticker height.
  height: Option<i32>,
  
}


impl Clone for InputMessageSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageSticker {}
impl RObject for InputMessageSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageSticker {}


impl InputMessageSticker {
  
  pub fn builder() -> RTDInputMessageStickerBuilder {
    let instance = Self {
      td_name: "inputMessageSticker".to_string(),
      sticker: None,
      thumbnail: None,
      width: None,
      height: None,
      
    };
    RTDInputMessageStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageStickerBuilder { instance: InputMessageSticker }

impl RTDInputMessageStickerBuilder {
  fn new(instance: InputMessageSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageSticker { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}



/// A video message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVideo
  /// Video to be sent.
  video: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the video, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width.
  width: Option<i32>,
  /// Video height.
  height: Option<i32>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,
  
}


impl Clone for InputMessageVideo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageVideo {}
impl RObject for InputMessageVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVideo" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVideo {}


impl InputMessageVideo {
  
  pub fn builder() -> RTDInputMessageVideoBuilder {
    let instance = Self {
      td_name: "inputMessageVideo".to_string(),
      video: None,
      thumbnail: None,
      added_sticker_file_ids: None,
      duration: None,
      width: None,
      height: None,
      supports_streaming: None,
      caption: None,
      ttl: None,
      
    };
    RTDInputMessageVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> Option<Box<InputFile>> { self.video.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn added_sticker_file_ids(&self) -> Option<Vec<i32>> { self.added_sticker_file_ids.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn supports_streaming(&self) -> Option<bool> { self.supports_streaming.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageVideoBuilder { instance: InputMessageVideo }

impl RTDInputMessageVideoBuilder {
  fn new(instance: InputMessageVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVideo { self.instance.clone() }
  
  pub fn video(&mut self, video: Box<InputFile>) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn added_sticker_file_ids(&mut self, added_sticker_file_ids: Vec<i32>) -> &mut Self {
    self.instance.added_sticker_file_ids = Some(added_sticker_file_ids);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn supports_streaming(&mut self, supports_streaming: bool) -> &mut Self {
    self.instance.supports_streaming = Some(supports_streaming);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}



/// A video note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVideoNote
  /// Video note to be sent.
  video_note: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width and height; must be positive and not greater than 640.
  length: Option<i32>,
  
}


impl Clone for InputMessageVideoNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageVideoNote {}
impl RObject for InputMessageVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVideoNote {}


impl InputMessageVideoNote {
  
  pub fn builder() -> RTDInputMessageVideoNoteBuilder {
    let instance = Self {
      td_name: "inputMessageVideoNote".to_string(),
      video_note: None,
      thumbnail: None,
      duration: None,
      length: None,
      
    };
    RTDInputMessageVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> Option<Box<InputFile>> { self.video_note.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageVideoNoteBuilder { instance: InputMessageVideoNote }

impl RTDInputMessageVideoNoteBuilder {
  fn new(instance: InputMessageVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVideoNote { self.instance.clone() }
  
  pub fn video_note(&mut self, video_note: Box<InputFile>) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}



/// A voice note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVoiceNote
  /// Voice note to be sent.
  voice_note: Option<Box<InputFile>>,
  /// Duration of the voice note, in seconds.
  duration: Option<i32>,
  /// Waveform representation of the voice note, in 5-bit format.
  waveform: Option<String>,
  /// Voice note caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageVoiceNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputMessageVoiceNote {}
impl RObject for InputMessageVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVoiceNote {}


impl InputMessageVoiceNote {
  
  pub fn builder() -> RTDInputMessageVoiceNoteBuilder {
    let instance = Self {
      td_name: "inputMessageVoiceNote".to_string(),
      voice_note: None,
      duration: None,
      waveform: None,
      caption: None,
      
    };
    RTDInputMessageVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> Option<Box<InputFile>> { self.voice_note.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn waveform(&self) -> Option<String> { self.waveform.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageVoiceNoteBuilder { instance: InputMessageVoiceNote }

impl RTDInputMessageVoiceNoteBuilder {
  fn new(instance: InputMessageVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVoiceNote { self.instance.clone() }
  
  pub fn voice_note(&mut self, voice_note: Box<InputFile>) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn waveform<S: AsRef<str>>(&mut self, waveform: S) -> &mut Self {
    self.instance.waveform = Some(waveform.as_ref().to_string());
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageLocation
  /// Location to be sent.
  location: Option<Location>,
  /// Period for which the location can be updated, in seconds; should bebetween 60 and 86400 for a live location and 0 otherwise.
  live_period: Option<i32>,
  
}



impl Object for InputMessageLocation {}
impl RObject for InputMessageLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageLocation" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageLocation {}


impl InputMessageLocation {
  
  pub fn builder() -> RTDInputMessageLocationBuilder {
    let instance = Self {
      td_name: "inputMessageLocation".to_string(),
      location: None,
      live_period: None,
      
    };
    RTDInputMessageLocationBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageLocationBuilder { instance: InputMessageLocation }

impl RTDInputMessageLocationBuilder {
  fn new(instance: InputMessageLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageLocation { self.instance.clone() }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
}



/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVenue
  /// Venue to send.
  venue: Option<Venue>,
  
}



impl Object for InputMessageVenue {}
impl RObject for InputMessageVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVenue" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVenue }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVenue {}


impl InputMessageVenue {
  
  pub fn builder() -> RTDInputMessageVenueBuilder {
    let instance = Self {
      td_name: "inputMessageVenue".to_string(),
      venue: None,
      
    };
    RTDInputMessageVenueBuilder::new(instance)
  }
  
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageVenue> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageVenueBuilder { instance: InputMessageVenue }

impl RTDInputMessageVenueBuilder {
  fn new(instance: InputMessageVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVenue { self.instance.clone() }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
}



/// A message containing a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageContact
  /// Contact to send.
  contact: Option<Contact>,
  
}



impl Object for InputMessageContact {}
impl RObject for InputMessageContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageContact" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageContact {}


impl InputMessageContact {
  
  pub fn builder() -> RTDInputMessageContactBuilder {
    let instance = Self {
      td_name: "inputMessageContact".to_string(),
      contact: None,
      
    };
    RTDInputMessageContactBuilder::new(instance)
  }
  
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageContactBuilder { instance: InputMessageContact }

impl RTDInputMessageContactBuilder {
  fn new(instance: InputMessageContact) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageContact { self.instance.clone() }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
}



/// A message with a game; not supported for channels or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageGame
  /// User identifier of the bot that owns the game.
  bot_user_id: Option<i32>,
  /// Short name of the game.
  game_short_name: Option<String>,
  
}



impl Object for InputMessageGame {}
impl RObject for InputMessageGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageGame" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageGame {}


impl InputMessageGame {
  
  pub fn builder() -> RTDInputMessageGameBuilder {
    let instance = Self {
      td_name: "inputMessageGame".to_string(),
      bot_user_id: None,
      game_short_name: None,
      
    };
    RTDInputMessageGameBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageGameBuilder { instance: InputMessageGame }

impl RTDInputMessageGameBuilder {
  fn new(instance: InputMessageGame) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageGame { self.instance.clone() }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn game_short_name<S: AsRef<str>>(&mut self, game_short_name: S) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name.as_ref().to_string());
    self
  }
  
}



/// A message with an invoice; can be used only by bots and only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageInvoice
  /// Invoice.
  invoice: Option<Invoice>,
  /// Product title; 1-32 characters.
  title: Option<String>,
  /// Product description; 0-255 characters.
  description: Option<String>,
  /// Product photo URL; optional.
  photo_url: Option<String>,
  /// Product photo size.
  photo_size: Option<i32>,
  /// Product photo width.
  photo_width: Option<i32>,
  /// Product photo height.
  photo_height: Option<i32>,
  /// The invoice payload.
  payload: Option<String>,
  /// Payment provider token.
  provider_token: Option<String>,
  /// JSON-encoded data about the invoice, which will be shared with the payment provider.
  provider_data: Option<String>,
  /// Unique invoice bot start_parameter for the generation of this invoice.
  start_parameter: Option<String>,
  
}



impl Object for InputMessageInvoice {}
impl RObject for InputMessageInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageInvoice" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageInvoice }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageInvoice {}


impl InputMessageInvoice {
  
  pub fn builder() -> RTDInputMessageInvoiceBuilder {
    let instance = Self {
      td_name: "inputMessageInvoice".to_string(),
      invoice: None,
      title: None,
      description: None,
      photo_url: None,
      photo_size: None,
      photo_width: None,
      photo_height: None,
      payload: None,
      provider_token: None,
      provider_data: None,
      start_parameter: None,
      
    };
    RTDInputMessageInvoiceBuilder::new(instance)
  }
  
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo_url(&self) -> Option<String> { self.photo_url.clone() }
  
  pub fn photo_size(&self) -> Option<i32> { self.photo_size.clone() }
  
  pub fn photo_width(&self) -> Option<i32> { self.photo_width.clone() }
  
  pub fn photo_height(&self) -> Option<i32> { self.photo_height.clone() }
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn provider_token(&self) -> Option<String> { self.provider_token.clone() }
  
  pub fn provider_data(&self) -> Option<String> { self.provider_data.clone() }
  
  pub fn start_parameter(&self) -> Option<String> { self.start_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageInvoice> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageInvoiceBuilder { instance: InputMessageInvoice }

impl RTDInputMessageInvoiceBuilder {
  fn new(instance: InputMessageInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageInvoice { self.instance.clone() }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn photo_url<S: AsRef<str>>(&mut self, photo_url: S) -> &mut Self {
    self.instance.photo_url = Some(photo_url.as_ref().to_string());
    self
  }
  
  pub fn photo_size(&mut self, photo_size: i32) -> &mut Self {
    self.instance.photo_size = Some(photo_size);
    self
  }
  
  pub fn photo_width(&mut self, photo_width: i32) -> &mut Self {
    self.instance.photo_width = Some(photo_width);
    self
  }
  
  pub fn photo_height(&mut self, photo_height: i32) -> &mut Self {
    self.instance.photo_height = Some(photo_height);
    self
  }
  
  pub fn payload<S: AsRef<str>>(&mut self, payload: S) -> &mut Self {
    self.instance.payload = Some(payload.as_ref().to_string());
    self
  }
  
  pub fn provider_token<S: AsRef<str>>(&mut self, provider_token: S) -> &mut Self {
    self.instance.provider_token = Some(provider_token.as_ref().to_string());
    self
  }
  
  pub fn provider_data<S: AsRef<str>>(&mut self, provider_data: S) -> &mut Self {
    self.instance.provider_data = Some(provider_data.as_ref().to_string());
    self
  }
  
  pub fn start_parameter<S: AsRef<str>>(&mut self, start_parameter: S) -> &mut Self {
    self.instance.start_parameter = Some(start_parameter.as_ref().to_string());
    self
  }
  
}



/// A message with a poll. Polls can't be sent to private or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessagePoll
  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options, 2-10 strings 1-100 characters each.
  options: Option<Vec<String>>,
  
}



impl Object for InputMessagePoll {}
impl RObject for InputMessagePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessagePoll" }
  fn td_type(&self) -> RTDType { RTDType::InputMessagePoll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessagePoll {}


impl InputMessagePoll {
  
  pub fn builder() -> RTDInputMessagePollBuilder {
    let instance = Self {
      td_name: "inputMessagePoll".to_string(),
      question: None,
      options: None,
      
    };
    RTDInputMessagePollBuilder::new(instance)
  }
  
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn options(&self) -> Option<Vec<String>> { self.options.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessagePoll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessagePollBuilder { instance: InputMessagePoll }

impl RTDInputMessagePollBuilder {
  fn new(instance: InputMessagePoll) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessagePoll { self.instance.clone() }
  
  pub fn question<S: AsRef<str>>(&mut self, question: S) -> &mut Self {
    self.instance.question = Some(question.as_ref().to_string());
    self
  }
  
  pub fn options(&mut self, options: Vec<String>) -> &mut Self {
    self.instance.options = Some(options);
    self
  }
  
}



/// A forwarded message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageForwarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageForwarded
  /// Identifier for the chat this forwarded message came from.
  from_chat_id: Option<i64>,
  /// Identifier of the message to forward.
  message_id: Option<i64>,
  /// True, if a game message should be shared within a launched game; applies only to game messages.
  in_game_share: Option<bool>,
  
}



impl Object for InputMessageForwarded {}
impl RObject for InputMessageForwarded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageForwarded" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageForwarded }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputMessageContent for InputMessageForwarded {}


impl InputMessageForwarded {
  
  pub fn builder() -> RTDInputMessageForwardedBuilder {
    let instance = Self {
      td_name: "inputMessageForwarded".to_string(),
      from_chat_id: None,
      message_id: None,
      in_game_share: None,
      
    };
    RTDInputMessageForwardedBuilder::new(instance)
  }
  
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn in_game_share(&self) -> Option<bool> { self.in_game_share.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputMessageForwarded> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputMessageForwardedBuilder { instance: InputMessageForwarded }

impl RTDInputMessageForwardedBuilder {
  fn new(instance: InputMessageForwarded) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageForwarded { self.instance.clone() }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn in_game_share(&mut self, in_game_share: bool) -> &mut Self {
    self.instance.in_game_share = Some(in_game_share);
    self
  }
  
}



/// This class is an abstract base class. Contains information about a Telegram Passport element to be saved. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElement: Object + RObject + Debug {}







impl InputPassportElement {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputPassportElement>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputPassportElement> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputPassportElementType {
  InputPassportElementAddress,
  InputPassportElementBankStatement,
  InputPassportElementDriverLicense,
  InputPassportElementEmailAddress,
  InputPassportElementIdentityCard,
  InputPassportElementInternalPassport,
  InputPassportElementPassport,
  InputPassportElementPassportRegistration,
  InputPassportElementPersonalDetails,
  InputPassportElementPhoneNumber,
  InputPassportElementRentalAgreement,
  InputPassportElementTemporaryRegistration,
  InputPassportElementUtilityBill,
  
}
impl RTDInputPassportElementType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A Telegram Passport element to be saved containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPersonalDetails
  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,
  
}



impl Object for InputPassportElementPersonalDetails {}
impl RObject for InputPassportElementPersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPersonalDetails }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPersonalDetails {}


impl InputPassportElementPersonalDetails {
  
  pub fn builder() -> RTDInputPassportElementPersonalDetailsBuilder {
    let instance = Self {
      td_name: "inputPassportElementPersonalDetails".to_string(),
      personal_details: None,
      
    };
    RTDInputPassportElementPersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn personal_details(&self) -> Option<PersonalDetails> { self.personal_details.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementPersonalDetails> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementPersonalDetailsBuilder { instance: InputPassportElementPersonalDetails }

impl RTDInputPassportElementPersonalDetailsBuilder {
  fn new(instance: InputPassportElementPersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPersonalDetails { self.instance.clone() }
  
  pub fn personal_details(&mut self, personal_details: PersonalDetails) -> &mut Self {
    self.instance.personal_details = Some(personal_details);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPassport
  /// The passport to be saved.
  passport: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementPassport {}
impl RObject for InputPassportElementPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPassport" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPassport {}


impl InputPassportElementPassport {
  
  pub fn builder() -> RTDInputPassportElementPassportBuilder {
    let instance = Self {
      td_name: "inputPassportElementPassport".to_string(),
      passport: None,
      
    };
    RTDInputPassportElementPassportBuilder::new(instance)
  }
  
  
  pub fn passport(&self) -> Option<InputIdentityDocument> { self.passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementPassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementPassportBuilder { instance: InputPassportElementPassport }

impl RTDInputPassportElementPassportBuilder {
  fn new(instance: InputPassportElementPassport) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPassport { self.instance.clone() }
  
  pub fn passport(&mut self, passport: InputIdentityDocument) -> &mut Self {
    self.instance.passport = Some(passport);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementDriverLicense
  /// The driver license to be saved.
  driver_license: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementDriverLicense {}
impl RObject for InputPassportElementDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementDriverLicense }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementDriverLicense {}


impl InputPassportElementDriverLicense {
  
  pub fn builder() -> RTDInputPassportElementDriverLicenseBuilder {
    let instance = Self {
      td_name: "inputPassportElementDriverLicense".to_string(),
      driver_license: None,
      
    };
    RTDInputPassportElementDriverLicenseBuilder::new(instance)
  }
  
  
  pub fn driver_license(&self) -> Option<InputIdentityDocument> { self.driver_license.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementDriverLicense> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementDriverLicenseBuilder { instance: InputPassportElementDriverLicense }

impl RTDInputPassportElementDriverLicenseBuilder {
  fn new(instance: InputPassportElementDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementDriverLicense { self.instance.clone() }
  
  pub fn driver_license(&mut self, driver_license: InputIdentityDocument) -> &mut Self {
    self.instance.driver_license = Some(driver_license);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementIdentityCard
  /// The identity card to be saved.
  identity_card: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementIdentityCard {}
impl RObject for InputPassportElementIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementIdentityCard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementIdentityCard {}


impl InputPassportElementIdentityCard {
  
  pub fn builder() -> RTDInputPassportElementIdentityCardBuilder {
    let instance = Self {
      td_name: "inputPassportElementIdentityCard".to_string(),
      identity_card: None,
      
    };
    RTDInputPassportElementIdentityCardBuilder::new(instance)
  }
  
  
  pub fn identity_card(&self) -> Option<InputIdentityDocument> { self.identity_card.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementIdentityCard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementIdentityCardBuilder { instance: InputPassportElementIdentityCard }

impl RTDInputPassportElementIdentityCardBuilder {
  fn new(instance: InputPassportElementIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementIdentityCard { self.instance.clone() }
  
  pub fn identity_card(&mut self, identity_card: InputIdentityDocument) -> &mut Self {
    self.instance.identity_card = Some(identity_card);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementInternalPassport
  /// The internal passport to be saved.
  internal_passport: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementInternalPassport {}
impl RObject for InputPassportElementInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementInternalPassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementInternalPassport {}


impl InputPassportElementInternalPassport {
  
  pub fn builder() -> RTDInputPassportElementInternalPassportBuilder {
    let instance = Self {
      td_name: "inputPassportElementInternalPassport".to_string(),
      internal_passport: None,
      
    };
    RTDInputPassportElementInternalPassportBuilder::new(instance)
  }
  
  
  pub fn internal_passport(&self) -> Option<InputIdentityDocument> { self.internal_passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementInternalPassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementInternalPassportBuilder { instance: InputPassportElementInternalPassport }

impl RTDInputPassportElementInternalPassportBuilder {
  fn new(instance: InputPassportElementInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementInternalPassport { self.instance.clone() }
  
  pub fn internal_passport(&mut self, internal_passport: InputIdentityDocument) -> &mut Self {
    self.instance.internal_passport = Some(internal_passport);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementAddress
  /// The address to be saved.
  address: Option<Address>,
  
}



impl Object for InputPassportElementAddress {}
impl RObject for InputPassportElementAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementAddress" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementAddress {}


impl InputPassportElementAddress {
  
  pub fn builder() -> RTDInputPassportElementAddressBuilder {
    let instance = Self {
      td_name: "inputPassportElementAddress".to_string(),
      address: None,
      
    };
    RTDInputPassportElementAddressBuilder::new(instance)
  }
  
  
  pub fn address(&self) -> Option<Address> { self.address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementAddressBuilder { instance: InputPassportElementAddress }

impl RTDInputPassportElementAddressBuilder {
  fn new(instance: InputPassportElementAddress) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementAddress { self.instance.clone() }
  
  pub fn address(&mut self, address: Address) -> &mut Self {
    self.instance.address = Some(address);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementUtilityBill
  /// The utility bill to be saved.
  utility_bill: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementUtilityBill {}
impl RObject for InputPassportElementUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementUtilityBill }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementUtilityBill {}


impl InputPassportElementUtilityBill {
  
  pub fn builder() -> RTDInputPassportElementUtilityBillBuilder {
    let instance = Self {
      td_name: "inputPassportElementUtilityBill".to_string(),
      utility_bill: None,
      
    };
    RTDInputPassportElementUtilityBillBuilder::new(instance)
  }
  
  
  pub fn utility_bill(&self) -> Option<InputPersonalDocument> { self.utility_bill.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementUtilityBill> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementUtilityBillBuilder { instance: InputPassportElementUtilityBill }

impl RTDInputPassportElementUtilityBillBuilder {
  fn new(instance: InputPassportElementUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementUtilityBill { self.instance.clone() }
  
  pub fn utility_bill(&mut self, utility_bill: InputPersonalDocument) -> &mut Self {
    self.instance.utility_bill = Some(utility_bill);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementBankStatement
  /// The bank statement to be saved.
  bank_statement: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementBankStatement {}
impl RObject for InputPassportElementBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementBankStatement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementBankStatement {}


impl InputPassportElementBankStatement {
  
  pub fn builder() -> RTDInputPassportElementBankStatementBuilder {
    let instance = Self {
      td_name: "inputPassportElementBankStatement".to_string(),
      bank_statement: None,
      
    };
    RTDInputPassportElementBankStatementBuilder::new(instance)
  }
  
  
  pub fn bank_statement(&self) -> Option<InputPersonalDocument> { self.bank_statement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementBankStatement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementBankStatementBuilder { instance: InputPassportElementBankStatement }

impl RTDInputPassportElementBankStatementBuilder {
  fn new(instance: InputPassportElementBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementBankStatement { self.instance.clone() }
  
  pub fn bank_statement(&mut self, bank_statement: InputPersonalDocument) -> &mut Self {
    self.instance.bank_statement = Some(bank_statement);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementRentalAgreement
  /// The rental agreement to be saved.
  rental_agreement: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementRentalAgreement {}
impl RObject for InputPassportElementRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementRentalAgreement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementRentalAgreement {}


impl InputPassportElementRentalAgreement {
  
  pub fn builder() -> RTDInputPassportElementRentalAgreementBuilder {
    let instance = Self {
      td_name: "inputPassportElementRentalAgreement".to_string(),
      rental_agreement: None,
      
    };
    RTDInputPassportElementRentalAgreementBuilder::new(instance)
  }
  
  
  pub fn rental_agreement(&self) -> Option<InputPersonalDocument> { self.rental_agreement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementRentalAgreement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementRentalAgreementBuilder { instance: InputPassportElementRentalAgreement }

impl RTDInputPassportElementRentalAgreementBuilder {
  fn new(instance: InputPassportElementRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementRentalAgreement { self.instance.clone() }
  
  pub fn rental_agreement(&mut self, rental_agreement: InputPersonalDocument) -> &mut Self {
    self.instance.rental_agreement = Some(rental_agreement);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's passport registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPassportRegistration
  /// The passport registration page to be saved.
  passport_registration: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementPassportRegistration {}
impl RObject for InputPassportElementPassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPassportRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPassportRegistration {}


impl InputPassportElementPassportRegistration {
  
  pub fn builder() -> RTDInputPassportElementPassportRegistrationBuilder {
    let instance = Self {
      td_name: "inputPassportElementPassportRegistration".to_string(),
      passport_registration: None,
      
    };
    RTDInputPassportElementPassportRegistrationBuilder::new(instance)
  }
  
  
  pub fn passport_registration(&self) -> Option<InputPersonalDocument> { self.passport_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementPassportRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementPassportRegistrationBuilder { instance: InputPassportElementPassportRegistration }

impl RTDInputPassportElementPassportRegistrationBuilder {
  fn new(instance: InputPassportElementPassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPassportRegistration { self.instance.clone() }
  
  pub fn passport_registration(&mut self, passport_registration: InputPersonalDocument) -> &mut Self {
    self.instance.passport_registration = Some(passport_registration);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementTemporaryRegistration
  /// The temporary registration document to be saved.
  temporary_registration: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementTemporaryRegistration {}
impl RObject for InputPassportElementTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementTemporaryRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementTemporaryRegistration {}


impl InputPassportElementTemporaryRegistration {
  
  pub fn builder() -> RTDInputPassportElementTemporaryRegistrationBuilder {
    let instance = Self {
      td_name: "inputPassportElementTemporaryRegistration".to_string(),
      temporary_registration: None,
      
    };
    RTDInputPassportElementTemporaryRegistrationBuilder::new(instance)
  }
  
  
  pub fn temporary_registration(&self) -> Option<InputPersonalDocument> { self.temporary_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementTemporaryRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementTemporaryRegistrationBuilder { instance: InputPassportElementTemporaryRegistration }

impl RTDInputPassportElementTemporaryRegistrationBuilder {
  fn new(instance: InputPassportElementTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementTemporaryRegistration { self.instance.clone() }
  
  pub fn temporary_registration(&mut self, temporary_registration: InputPersonalDocument) -> &mut Self {
    self.instance.temporary_registration = Some(temporary_registration);
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPhoneNumber
  /// The phone number to be saved.
  phone_number: Option<String>,
  
}



impl Object for InputPassportElementPhoneNumber {}
impl RObject for InputPassportElementPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPhoneNumber {}


impl InputPassportElementPhoneNumber {
  
  pub fn builder() -> RTDInputPassportElementPhoneNumberBuilder {
    let instance = Self {
      td_name: "inputPassportElementPhoneNumber".to_string(),
      phone_number: None,
      
    };
    RTDInputPassportElementPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementPhoneNumberBuilder { instance: InputPassportElementPhoneNumber }

impl RTDInputPassportElementPhoneNumberBuilder {
  fn new(instance: InputPassportElementPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPhoneNumber { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
}



/// A Telegram Passport element to be saved containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementEmailAddress
  /// The email address to be saved.
  email_address: Option<String>,
  
}



impl Object for InputPassportElementEmailAddress {}
impl RObject for InputPassportElementEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementEmailAddress {}


impl InputPassportElementEmailAddress {
  
  pub fn builder() -> RTDInputPassportElementEmailAddressBuilder {
    let instance = Self {
      td_name: "inputPassportElementEmailAddress".to_string(),
      email_address: None,
      
    };
    RTDInputPassportElementEmailAddressBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementEmailAddressBuilder { instance: InputPassportElementEmailAddress }

impl RTDInputPassportElementEmailAddressBuilder {
  fn new(instance: InputPassportElementEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementEmailAddress { self.instance.clone() }
  
  pub fn email_address<S: AsRef<str>>(&mut self, email_address: S) -> &mut Self {
    self.instance.email_address = Some(email_address.as_ref().to_string());
    self
  }
  
}



/// Contains the description of an error in a Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementError
  /// Type of Telegram Passport element that has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<InputPassportElementErrorSource>>,
  
}


impl Clone for InputPassportElementError {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputPassportElementError {}
impl RObject for InputPassportElementError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementError" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementError }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InputPassportElementError {
  
  pub fn builder() -> RTDInputPassportElementErrorBuilder {
    let instance = Self {
      td_name: "inputPassportElementError".to_string(),
      type_: None,
      message: None,
      source: None,
      
    };
    RTDInputPassportElementErrorBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn source(&self) -> Option<Box<InputPassportElementErrorSource>> { self.source.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementError> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorBuilder { instance: InputPassportElementError }

impl RTDInputPassportElementErrorBuilder {
  fn new(instance: InputPassportElementError) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementError { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn message<S: AsRef<str>>(&mut self, message: S) -> &mut Self {
    self.instance.message = Some(message.as_ref().to_string());
    self
  }
  
  pub fn source(&mut self, source: Box<InputPassportElementErrorSource>) -> &mut Self {
    self.instance.source = Some(source);
    self
  }
  
}



/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElementErrorSource: Object + RObject + Debug {}







impl InputPassportElementErrorSource {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<InputPassportElementErrorSource>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<InputPassportElementErrorSource> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputPassportElementErrorSourceType {
  InputPassportElementErrorSourceDataField,
  InputPassportElementErrorSourceFile,
  InputPassportElementErrorSourceFiles,
  InputPassportElementErrorSourceFrontSide,
  InputPassportElementErrorSourceReverseSide,
  InputPassportElementErrorSourceSelfie,
  InputPassportElementErrorSourceTranslationFile,
  InputPassportElementErrorSourceTranslationFiles,
  InputPassportElementErrorSourceUnspecified,
  
}
impl RTDInputPassportElementErrorSourceType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceUnspecified
  /// Current hash of the entire element.
  element_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceUnspecified {}
impl RObject for InputPassportElementErrorSourceUnspecified {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceUnspecified" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceUnspecified }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceUnspecified {}


impl InputPassportElementErrorSourceUnspecified {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceUnspecifiedBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceUnspecified".to_string(),
      element_hash: None,
      
    };
    RTDInputPassportElementErrorSourceUnspecifiedBuilder::new(instance)
  }
  
  
  pub fn element_hash(&self) -> Option<String> { self.element_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceUnspecified> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceUnspecifiedBuilder { instance: InputPassportElementErrorSourceUnspecified }

impl RTDInputPassportElementErrorSourceUnspecifiedBuilder {
  fn new(instance: InputPassportElementErrorSourceUnspecified) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceUnspecified { self.instance.clone() }
  
  pub fn element_hash<S: AsRef<str>>(&mut self, element_hash: S) -> &mut Self {
    self.instance.element_hash = Some(element_hash.as_ref().to_string());
    self
  }
  
}



/// A data field contains an error. The error is considered resolved when the field's value changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceDataField
  /// Field name.
  field_name: Option<String>,
  /// Current data hash.
  data_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceDataField {}
impl RObject for InputPassportElementErrorSourceDataField {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceDataField" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceDataField }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceDataField {}


impl InputPassportElementErrorSourceDataField {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceDataFieldBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceDataField".to_string(),
      field_name: None,
      data_hash: None,
      
    };
    RTDInputPassportElementErrorSourceDataFieldBuilder::new(instance)
  }
  
  
  pub fn field_name(&self) -> Option<String> { self.field_name.clone() }
  
  pub fn data_hash(&self) -> Option<String> { self.data_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceDataField> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceDataFieldBuilder { instance: InputPassportElementErrorSourceDataField }

impl RTDInputPassportElementErrorSourceDataFieldBuilder {
  fn new(instance: InputPassportElementErrorSourceDataField) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceDataField { self.instance.clone() }
  
  pub fn field_name<S: AsRef<str>>(&mut self, field_name: S) -> &mut Self {
    self.instance.field_name = Some(field_name.as_ref().to_string());
    self
  }
  
  pub fn data_hash<S: AsRef<str>>(&mut self, data_hash: S) -> &mut Self {
    self.instance.data_hash = Some(data_hash.as_ref().to_string());
    self
  }
  
}



/// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFrontSide
  /// Current hash of the file containing the front side.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceFrontSide {}
impl RObject for InputPassportElementErrorSourceFrontSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFrontSide" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFrontSide }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFrontSide {}


impl InputPassportElementErrorSourceFrontSide {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceFrontSideBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceFrontSide".to_string(),
      file_hash: None,
      
    };
    RTDInputPassportElementErrorSourceFrontSideBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceFrontSide> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceFrontSideBuilder { instance: InputPassportElementErrorSourceFrontSide }

impl RTDInputPassportElementErrorSourceFrontSideBuilder {
  fn new(instance: InputPassportElementErrorSourceFrontSide) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFrontSide { self.instance.clone() }
  
  pub fn file_hash<S: AsRef<str>>(&mut self, file_hash: S) -> &mut Self {
    self.instance.file_hash = Some(file_hash.as_ref().to_string());
    self
  }
  
}



/// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceReverseSide
  /// Current hash of the file containing the reverse side.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceReverseSide {}
impl RObject for InputPassportElementErrorSourceReverseSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceReverseSide" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceReverseSide }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceReverseSide {}


impl InputPassportElementErrorSourceReverseSide {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceReverseSideBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceReverseSide".to_string(),
      file_hash: None,
      
    };
    RTDInputPassportElementErrorSourceReverseSideBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceReverseSide> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceReverseSideBuilder { instance: InputPassportElementErrorSourceReverseSide }

impl RTDInputPassportElementErrorSourceReverseSideBuilder {
  fn new(instance: InputPassportElementErrorSourceReverseSide) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceReverseSide { self.instance.clone() }
  
  pub fn file_hash<S: AsRef<str>>(&mut self, file_hash: S) -> &mut Self {
    self.instance.file_hash = Some(file_hash.as_ref().to_string());
    self
  }
  
}



/// The selfie contains an error. The error is considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceSelfie
  /// Current hash of the file containing the selfie.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceSelfie {}
impl RObject for InputPassportElementErrorSourceSelfie {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceSelfie" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceSelfie }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceSelfie {}


impl InputPassportElementErrorSourceSelfie {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceSelfieBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceSelfie".to_string(),
      file_hash: None,
      
    };
    RTDInputPassportElementErrorSourceSelfieBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceSelfie> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceSelfieBuilder { instance: InputPassportElementErrorSourceSelfie }

impl RTDInputPassportElementErrorSourceSelfieBuilder {
  fn new(instance: InputPassportElementErrorSourceSelfie) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceSelfie { self.instance.clone() }
  
  pub fn file_hash<S: AsRef<str>>(&mut self, file_hash: S) -> &mut Self {
    self.instance.file_hash = Some(file_hash.as_ref().to_string());
    self
  }
  
}



/// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceTranslationFile
  /// Current hash of the file containing the translation.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceTranslationFile {}
impl RObject for InputPassportElementErrorSourceTranslationFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceTranslationFile" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceTranslationFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFile {}


impl InputPassportElementErrorSourceTranslationFile {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceTranslationFileBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceTranslationFile".to_string(),
      file_hash: None,
      
    };
    RTDInputPassportElementErrorSourceTranslationFileBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceTranslationFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceTranslationFileBuilder { instance: InputPassportElementErrorSourceTranslationFile }

impl RTDInputPassportElementErrorSourceTranslationFileBuilder {
  fn new(instance: InputPassportElementErrorSourceTranslationFile) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceTranslationFile { self.instance.clone() }
  
  pub fn file_hash<S: AsRef<str>>(&mut self, file_hash: S) -> &mut Self {
    self.instance.file_hash = Some(file_hash.as_ref().to_string());
    self
  }
  
}



/// The translation of the document contains an error. The error is considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceTranslationFiles
  /// Current hashes of all files with the translation.
  file_hashes: Option<Vec<String>>,
  
}



impl Object for InputPassportElementErrorSourceTranslationFiles {}
impl RObject for InputPassportElementErrorSourceTranslationFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceTranslationFiles" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceTranslationFiles }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFiles {}


impl InputPassportElementErrorSourceTranslationFiles {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceTranslationFilesBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceTranslationFiles".to_string(),
      file_hashes: None,
      
    };
    RTDInputPassportElementErrorSourceTranslationFilesBuilder::new(instance)
  }
  
  
  pub fn file_hashes(&self) -> Option<Vec<String>> { self.file_hashes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceTranslationFiles> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceTranslationFilesBuilder { instance: InputPassportElementErrorSourceTranslationFiles }

impl RTDInputPassportElementErrorSourceTranslationFilesBuilder {
  fn new(instance: InputPassportElementErrorSourceTranslationFiles) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceTranslationFiles { self.instance.clone() }
  
  pub fn file_hashes(&mut self, file_hashes: Vec<String>) -> &mut Self {
    self.instance.file_hashes = Some(file_hashes);
    self
  }
  
}



/// The file contains an error. The error is considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFile
  /// Current hash of the file which has the error.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceFile {}
impl RObject for InputPassportElementErrorSourceFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFile" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFile {}


impl InputPassportElementErrorSourceFile {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceFileBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceFile".to_string(),
      file_hash: None,
      
    };
    RTDInputPassportElementErrorSourceFileBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceFileBuilder { instance: InputPassportElementErrorSourceFile }

impl RTDInputPassportElementErrorSourceFileBuilder {
  fn new(instance: InputPassportElementErrorSourceFile) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFile { self.instance.clone() }
  
  pub fn file_hash<S: AsRef<str>>(&mut self, file_hash: S) -> &mut Self {
    self.instance.file_hash = Some(file_hash.as_ref().to_string());
    self
  }
  
}



/// The list of attached files contains an error. The error is considered resolved when the file list changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFiles
  /// Current hashes of all attached files.
  file_hashes: Option<Vec<String>>,
  
}



impl Object for InputPassportElementErrorSourceFiles {}
impl RObject for InputPassportElementErrorSourceFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFiles" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFiles }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFiles {}


impl InputPassportElementErrorSourceFiles {
  
  pub fn builder() -> RTDInputPassportElementErrorSourceFilesBuilder {
    let instance = Self {
      td_name: "inputPassportElementErrorSourceFiles".to_string(),
      file_hashes: None,
      
    };
    RTDInputPassportElementErrorSourceFilesBuilder::new(instance)
  }
  
  
  pub fn file_hashes(&self) -> Option<Vec<String>> { self.file_hashes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPassportElementErrorSourceFiles> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPassportElementErrorSourceFilesBuilder { instance: InputPassportElementErrorSourceFiles }

impl RTDInputPassportElementErrorSourceFilesBuilder {
  fn new(instance: InputPassportElementErrorSourceFiles) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFiles { self.instance.clone() }
  
  pub fn file_hashes(&mut self, file_hashes: Vec<String>) -> &mut Self {
    self.instance.file_hashes = Some(file_hashes);
    self
  }
  
}



/// A personal document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPersonalDocument
  /// List of files containing the pages of the document.
  files: Option<Vec<Box<InputFile>>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,
  
}


impl Clone for InputPersonalDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputPersonalDocument {}
impl RObject for InputPersonalDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPersonalDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputPersonalDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InputPersonalDocument {
  
  pub fn builder() -> RTDInputPersonalDocumentBuilder {
    let instance = Self {
      td_name: "inputPersonalDocument".to_string(),
      files: None,
      translation: None,
      
    };
    RTDInputPersonalDocumentBuilder::new(instance)
  }
  
  
  pub fn files(&self) -> Option<Vec<Box<InputFile>>> { self.files.clone() }
  
  pub fn translation(&self) -> Option<Vec<Box<InputFile>>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputPersonalDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputPersonalDocumentBuilder { instance: InputPersonalDocument }

impl RTDInputPersonalDocumentBuilder {
  fn new(instance: InputPersonalDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputPersonalDocument { self.instance.clone() }
  
  pub fn files(&mut self, files: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}



/// Describes a sticker that should be added to a sticker set. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputSticker
  /// PNG image with the sticker; must be up to 512 kB in size and fit in a 512x512 square.
  png_sticker: Option<Box<InputFile>>,
  /// Emoji corresponding to the sticker.
  emojis: Option<String>,
  /// For masks, position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,
  
}


impl Clone for InputSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputSticker {}
impl RObject for InputSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InputSticker {
  
  pub fn builder() -> RTDInputStickerBuilder {
    let instance = Self {
      td_name: "inputSticker".to_string(),
      png_sticker: None,
      emojis: None,
      mask_position: None,
      
    };
    RTDInputStickerBuilder::new(instance)
  }
  
  
  pub fn png_sticker(&self) -> Option<Box<InputFile>> { self.png_sticker.clone() }
  
  pub fn emojis(&self) -> Option<String> { self.emojis.clone() }
  
  pub fn mask_position(&self) -> Option<MaskPosition> { self.mask_position.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputStickerBuilder { instance: InputSticker }

impl RTDInputStickerBuilder {
  fn new(instance: InputSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputSticker { self.instance.clone() }
  
  pub fn png_sticker(&mut self, png_sticker: Box<InputFile>) -> &mut Self {
    self.instance.png_sticker = Some(png_sticker);
    self
  }
  
  pub fn emojis<S: AsRef<str>>(&mut self, emojis: S) -> &mut Self {
    self.instance.emojis = Some(emojis.as_ref().to_string());
    self
  }
  
  pub fn mask_position(&mut self, mask_position: MaskPosition) -> &mut Self {
    self.instance.mask_position = Some(mask_position);
    self
  }
  
}



/// A thumbnail to be sent along with a file; should be in JPEG or WEBP format for stickers, and less than 200 kB in size. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputThumbnail
  /// Thumbnail file to send. Sending thumbnails by file_id is currently not supported.
  thumbnail: Option<Box<InputFile>>,
  /// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown.
  width: Option<i32>,
  /// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown.
  height: Option<i32>,
  
}


impl Clone for InputThumbnail {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for InputThumbnail {}
impl RObject for InputThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::InputThumbnail }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl InputThumbnail {
  
  pub fn builder() -> RTDInputThumbnailBuilder {
    let instance = Self {
      td_name: "inputThumbnail".to_string(),
      thumbnail: None,
      width: None,
      height: None,
      
    };
    RTDInputThumbnailBuilder::new(instance)
  }
  
  
  pub fn thumbnail(&self) -> Option<Box<InputFile>> { self.thumbnail.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<InputThumbnail> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInputThumbnailBuilder { instance: InputThumbnail }

impl RTDInputThumbnailBuilder {
  fn new(instance: InputThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> InputThumbnail { self.instance.clone() }
  
  pub fn thumbnail(&mut self, thumbnail: Box<InputFile>) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}



/// Product invoice. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Invoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // invoice
  /// ISO 4217 currency code.
  currency: Option<String>,
  /// A list of objects used to calculate the total price of the product.
  price_parts: Option<Vec<LabeledPricePart>>,
  /// True, if the payment is a test payment.
  is_test: Option<bool>,
  /// True, if the user's name is needed for payment.
  need_name: Option<bool>,
  /// True, if the user's phone number is needed for payment.
  need_phone_number: Option<bool>,
  /// True, if the user's email address is needed for payment.
  need_email_address: Option<bool>,
  /// True, if the user's shipping address is needed for payment.
  need_shipping_address: Option<bool>,
  /// True, if the user's phone number will be sent to the provider.
  send_phone_number_to_provider: Option<bool>,
  /// True, if the user's email address will be sent to the provider.
  send_email_address_to_provider: Option<bool>,
  /// True, if the total price depends on the shipping method.
  is_flexible: Option<bool>,
  
}



impl Object for Invoice {}
impl RObject for Invoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "invoice" }
  fn td_type(&self) -> RTDType { RTDType::Invoice }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Invoice {
  
  pub fn builder() -> RTDInvoiceBuilder {
    let instance = Self {
      td_name: "invoice".to_string(),
      currency: None,
      price_parts: None,
      is_test: None,
      need_name: None,
      need_phone_number: None,
      need_email_address: None,
      need_shipping_address: None,
      send_phone_number_to_provider: None,
      send_email_address_to_provider: None,
      is_flexible: None,
      
    };
    RTDInvoiceBuilder::new(instance)
  }
  
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn price_parts(&self) -> Option<Vec<LabeledPricePart>> { self.price_parts.clone() }
  
  pub fn is_test(&self) -> Option<bool> { self.is_test.clone() }
  
  pub fn need_name(&self) -> Option<bool> { self.need_name.clone() }
  
  pub fn need_phone_number(&self) -> Option<bool> { self.need_phone_number.clone() }
  
  pub fn need_email_address(&self) -> Option<bool> { self.need_email_address.clone() }
  
  pub fn need_shipping_address(&self) -> Option<bool> { self.need_shipping_address.clone() }
  
  pub fn send_phone_number_to_provider(&self) -> Option<bool> { self.send_phone_number_to_provider.clone() }
  
  pub fn send_email_address_to_provider(&self) -> Option<bool> { self.send_email_address_to_provider.clone() }
  
  pub fn is_flexible(&self) -> Option<bool> { self.is_flexible.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Invoice> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDInvoiceBuilder { instance: Invoice }

impl RTDInvoiceBuilder {
  fn new(instance: Invoice) -> Self { Self { instance } }

  pub fn build(&self) -> Invoice { self.instance.clone() }
  
  pub fn currency<S: AsRef<str>>(&mut self, currency: S) -> &mut Self {
    self.instance.currency = Some(currency.as_ref().to_string());
    self
  }
  
  pub fn price_parts(&mut self, price_parts: Vec<LabeledPricePart>) -> &mut Self {
    self.instance.price_parts = Some(price_parts);
    self
  }
  
  pub fn is_test(&mut self, is_test: bool) -> &mut Self {
    self.instance.is_test = Some(is_test);
    self
  }
  
  pub fn need_name(&mut self, need_name: bool) -> &mut Self {
    self.instance.need_name = Some(need_name);
    self
  }
  
  pub fn need_phone_number(&mut self, need_phone_number: bool) -> &mut Self {
    self.instance.need_phone_number = Some(need_phone_number);
    self
  }
  
  pub fn need_email_address(&mut self, need_email_address: bool) -> &mut Self {
    self.instance.need_email_address = Some(need_email_address);
    self
  }
  
  pub fn need_shipping_address(&mut self, need_shipping_address: bool) -> &mut Self {
    self.instance.need_shipping_address = Some(need_shipping_address);
    self
  }
  
  pub fn send_phone_number_to_provider(&mut self, send_phone_number_to_provider: bool) -> &mut Self {
    self.instance.send_phone_number_to_provider = Some(send_phone_number_to_provider);
    self
  }
  
  pub fn send_email_address_to_provider(&mut self, send_email_address_to_provider: bool) -> &mut Self {
    self.instance.send_email_address_to_provider = Some(send_email_address_to_provider);
    self
  }
  
  pub fn is_flexible(&mut self, is_flexible: bool) -> &mut Self {
    self.instance.is_flexible = Some(is_flexible);
    self
  }
  
}



/// Represents a single button in a bot keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct KeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButton
  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<KeyboardButtonType>>,
  
}


impl Clone for KeyboardButton {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for KeyboardButton {}
impl RObject for KeyboardButton {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButton" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButton }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl KeyboardButton {
  
  pub fn builder() -> RTDKeyboardButtonBuilder {
    let instance = Self {
      td_name: "keyboardButton".to_string(),
      text: None,
      type_: None,
      
    };
    RTDKeyboardButtonBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn type_(&self) -> Option<Box<KeyboardButtonType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<KeyboardButton> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDKeyboardButtonBuilder { instance: KeyboardButton }

impl RTDKeyboardButtonBuilder {
  fn new(instance: KeyboardButton) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButton { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn type_(&mut self, type_: Box<KeyboardButtonType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// This class is an abstract base class. Describes a keyboard button type. 
#[typetag::serde(tag = "@struct")]
pub trait KeyboardButtonType: Object + RObject + Debug {}







impl KeyboardButtonType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<KeyboardButtonType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<KeyboardButtonType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDKeyboardButtonTypeType {
  KeyboardButtonTypeRequestLocation,
  KeyboardButtonTypeRequestPhoneNumber,
  KeyboardButtonTypeText,
  
}
impl RTDKeyboardButtonTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A simple button, with text that should be sent when the button is pressed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeText
  
}



impl Object for KeyboardButtonTypeText {}
impl RObject for KeyboardButtonTypeText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeText" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeText {}


impl KeyboardButtonTypeText {
  
  pub fn builder() -> RTDKeyboardButtonTypeTextBuilder {
    let instance = Self {
      td_name: "keyboardButtonTypeText".to_string(),
      
    };
    RTDKeyboardButtonTypeTextBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<KeyboardButtonTypeText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDKeyboardButtonTypeTextBuilder { instance: KeyboardButtonTypeText }

impl RTDKeyboardButtonTypeTextBuilder {
  fn new(instance: KeyboardButtonTypeText) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeText { self.instance.clone() }
  
}



/// A button that sends the user's phone number when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeRequestPhoneNumber
  
}



impl Object for KeyboardButtonTypeRequestPhoneNumber {}
impl RObject for KeyboardButtonTypeRequestPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeRequestPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeRequestPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeRequestPhoneNumber {}


impl KeyboardButtonTypeRequestPhoneNumber {
  
  pub fn builder() -> RTDKeyboardButtonTypeRequestPhoneNumberBuilder {
    let instance = Self {
      td_name: "keyboardButtonTypeRequestPhoneNumber".to_string(),
      
    };
    RTDKeyboardButtonTypeRequestPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<KeyboardButtonTypeRequestPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDKeyboardButtonTypeRequestPhoneNumberBuilder { instance: KeyboardButtonTypeRequestPhoneNumber }

impl RTDKeyboardButtonTypeRequestPhoneNumberBuilder {
  fn new(instance: KeyboardButtonTypeRequestPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeRequestPhoneNumber { self.instance.clone() }
  
}



/// A button that sends the user's location when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeRequestLocation
  
}



impl Object for KeyboardButtonTypeRequestLocation {}
impl RObject for KeyboardButtonTypeRequestLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeRequestLocation" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeRequestLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeRequestLocation {}


impl KeyboardButtonTypeRequestLocation {
  
  pub fn builder() -> RTDKeyboardButtonTypeRequestLocationBuilder {
    let instance = Self {
      td_name: "keyboardButtonTypeRequestLocation".to_string(),
      
    };
    RTDKeyboardButtonTypeRequestLocationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<KeyboardButtonTypeRequestLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDKeyboardButtonTypeRequestLocationBuilder { instance: KeyboardButtonTypeRequestLocation }

impl RTDKeyboardButtonTypeRequestLocationBuilder {
  fn new(instance: KeyboardButtonTypeRequestLocation) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeRequestLocation { self.instance.clone() }
  
}



/// Portion of the price of a product (e.g., "delivery cost", "tax amount"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabeledPricePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // labeledPricePart
  /// Label for this portion of the product price.
  label: Option<String>,
  /// Currency amount in minimal quantity of the currency.
  amount: Option<i64>,
  
}



impl Object for LabeledPricePart {}
impl RObject for LabeledPricePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "labeledPricePart" }
  fn td_type(&self) -> RTDType { RTDType::LabeledPricePart }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LabeledPricePart {
  
  pub fn builder() -> RTDLabeledPricePartBuilder {
    let instance = Self {
      td_name: "labeledPricePart".to_string(),
      label: None,
      amount: None,
      
    };
    RTDLabeledPricePartBuilder::new(instance)
  }
  
  
  pub fn label(&self) -> Option<String> { self.label.clone() }
  
  pub fn amount(&self) -> Option<i64> { self.amount.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LabeledPricePart> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLabeledPricePartBuilder { instance: LabeledPricePart }

impl RTDLabeledPricePartBuilder {
  fn new(instance: LabeledPricePart) -> Self { Self { instance } }

  pub fn build(&self) -> LabeledPricePart { self.instance.clone() }
  
  pub fn label<S: AsRef<str>>(&mut self, label: S) -> &mut Self {
    self.instance.label = Some(label.as_ref().to_string());
    self
  }
  
  pub fn amount(&mut self, amount: i64) -> &mut Self {
    self.instance.amount = Some(amount);
    self
  }
  
}



/// Contains information about a language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackInfo
  /// Unique language pack identifier.
  id: Option<String>,
  /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs.
  base_language_pack_id: Option<String>,
  /// Language name.
  name: Option<String>,
  /// Name of the language in that language.
  native_name: Option<String>,
  /// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info.
  plural_code: Option<String>,
  /// True, if the language pack is official.
  is_official: Option<bool>,
  /// True, if the language pack strings are RTL.
  is_rtl: Option<bool>,
  /// True, if the language pack is a beta language pack.
  is_beta: Option<bool>,
  /// True, if the language pack is installed by the current user.
  is_installed: Option<bool>,
  /// Total number of non-deleted strings from the language pack.
  total_string_count: Option<i32>,
  /// Total number of translated strings from the language pack.
  translated_string_count: Option<i32>,
  /// Total number of non-deleted strings from the language pack available locally.
  local_string_count: Option<i32>,
  /// Link to language translation interface; empty for custom local language packs.
  translation_url: Option<String>,
  
}



impl Object for LanguagePackInfo {}
impl RObject for LanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LanguagePackInfo {
  
  pub fn builder() -> RTDLanguagePackInfoBuilder {
    let instance = Self {
      td_name: "languagePackInfo".to_string(),
      id: None,
      base_language_pack_id: None,
      name: None,
      native_name: None,
      plural_code: None,
      is_official: None,
      is_rtl: None,
      is_beta: None,
      is_installed: None,
      total_string_count: None,
      translated_string_count: None,
      local_string_count: None,
      translation_url: None,
      
    };
    RTDLanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn base_language_pack_id(&self) -> Option<String> { self.base_language_pack_id.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn native_name(&self) -> Option<String> { self.native_name.clone() }
  
  pub fn plural_code(&self) -> Option<String> { self.plural_code.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_rtl(&self) -> Option<bool> { self.is_rtl.clone() }
  
  pub fn is_beta(&self) -> Option<bool> { self.is_beta.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn total_string_count(&self) -> Option<i32> { self.total_string_count.clone() }
  
  pub fn translated_string_count(&self) -> Option<i32> { self.translated_string_count.clone() }
  
  pub fn local_string_count(&self) -> Option<i32> { self.local_string_count.clone() }
  
  pub fn translation_url(&self) -> Option<String> { self.translation_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackInfoBuilder { instance: LanguagePackInfo }

impl RTDLanguagePackInfoBuilder {
  fn new(instance: LanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackInfo { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn base_language_pack_id<S: AsRef<str>>(&mut self, base_language_pack_id: S) -> &mut Self {
    self.instance.base_language_pack_id = Some(base_language_pack_id.as_ref().to_string());
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn native_name<S: AsRef<str>>(&mut self, native_name: S) -> &mut Self {
    self.instance.native_name = Some(native_name.as_ref().to_string());
    self
  }
  
  pub fn plural_code<S: AsRef<str>>(&mut self, plural_code: S) -> &mut Self {
    self.instance.plural_code = Some(plural_code.as_ref().to_string());
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_rtl(&mut self, is_rtl: bool) -> &mut Self {
    self.instance.is_rtl = Some(is_rtl);
    self
  }
  
  pub fn is_beta(&mut self, is_beta: bool) -> &mut Self {
    self.instance.is_beta = Some(is_beta);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn total_string_count(&mut self, total_string_count: i32) -> &mut Self {
    self.instance.total_string_count = Some(total_string_count);
    self
  }
  
  pub fn translated_string_count(&mut self, translated_string_count: i32) -> &mut Self {
    self.instance.translated_string_count = Some(translated_string_count);
    self
  }
  
  pub fn local_string_count(&mut self, local_string_count: i32) -> &mut Self {
    self.instance.local_string_count = Some(local_string_count);
    self
  }
  
  pub fn translation_url<S: AsRef<str>>(&mut self, translation_url: S) -> &mut Self {
    self.instance.translation_url = Some(translation_url.as_ref().to_string());
    self
  }
  
}



/// Represents one language pack string. 
#[derive(Debug, Serialize, Deserialize)]
pub struct LanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackString
  /// String key.
  key: Option<String>,
  /// String value.
  value: Option<Box<LanguagePackStringValue>>,
  
}


impl Clone for LanguagePackString {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for LanguagePackString {}
impl RObject for LanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackString" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LanguagePackString {
  
  pub fn builder() -> RTDLanguagePackStringBuilder {
    let instance = Self {
      td_name: "languagePackString".to_string(),
      key: None,
      value: None,
      
    };
    RTDLanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn key(&self) -> Option<String> { self.key.clone() }
  
  pub fn value(&self) -> Option<Box<LanguagePackStringValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackStringBuilder { instance: LanguagePackString }

impl RTDLanguagePackStringBuilder {
  fn new(instance: LanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackString { self.instance.clone() }
  
  pub fn key<S: AsRef<str>>(&mut self, key: S) -> &mut Self {
    self.instance.key = Some(key.as_ref().to_string());
    self
  }
  
  pub fn value(&mut self, value: Box<LanguagePackStringValue>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// This class is an abstract base class. Represents the value of a string in a language pack. 
#[typetag::serde(tag = "@struct")]
pub trait LanguagePackStringValue: Object + RObject + Debug {}







impl LanguagePackStringValue {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<LanguagePackStringValue>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<LanguagePackStringValue> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLanguagePackStringValueType {
  LanguagePackStringValueDeleted,
  LanguagePackStringValueOrdinary,
  LanguagePackStringValuePluralized,
  
}
impl RTDLanguagePackStringValueType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// An ordinary language pack string. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueOrdinary {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValueOrdinary
  /// String value.
  value: Option<String>,
  
}



impl Object for LanguagePackStringValueOrdinary {}
impl RObject for LanguagePackStringValueOrdinary {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValueOrdinary" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValueOrdinary }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValueOrdinary {}


impl LanguagePackStringValueOrdinary {
  
  pub fn builder() -> RTDLanguagePackStringValueOrdinaryBuilder {
    let instance = Self {
      td_name: "languagePackStringValueOrdinary".to_string(),
      value: None,
      
    };
    RTDLanguagePackStringValueOrdinaryBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackStringValueOrdinary> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackStringValueOrdinaryBuilder { instance: LanguagePackStringValueOrdinary }

impl RTDLanguagePackStringValueOrdinaryBuilder {
  fn new(instance: LanguagePackStringValueOrdinary) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValueOrdinary { self.instance.clone() }
  
  pub fn value<S: AsRef<str>>(&mut self, value: S) -> &mut Self {
    self.instance.value = Some(value.as_ref().to_string());
    self
  }
  
}



/// A language pack string which has different forms based on the number of some object it mentions. See 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValuePluralized {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValuePluralized
  /// Value for zero objects.
  zero_value: Option<String>,
  /// Value for one object.
  one_value: Option<String>,
  /// Value for two objects.
  two_value: Option<String>,
  /// Value for few objects.
  few_value: Option<String>,
  /// Value for many objects.
  many_value: Option<String>,
  /// Default value.
  other_value: Option<String>,
  
}



impl Object for LanguagePackStringValuePluralized {}
impl RObject for LanguagePackStringValuePluralized {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValuePluralized" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValuePluralized }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValuePluralized {}


impl LanguagePackStringValuePluralized {
  
  pub fn builder() -> RTDLanguagePackStringValuePluralizedBuilder {
    let instance = Self {
      td_name: "languagePackStringValuePluralized".to_string(),
      zero_value: None,
      one_value: None,
      two_value: None,
      few_value: None,
      many_value: None,
      other_value: None,
      
    };
    RTDLanguagePackStringValuePluralizedBuilder::new(instance)
  }
  
  
  pub fn zero_value(&self) -> Option<String> { self.zero_value.clone() }
  
  pub fn one_value(&self) -> Option<String> { self.one_value.clone() }
  
  pub fn two_value(&self) -> Option<String> { self.two_value.clone() }
  
  pub fn few_value(&self) -> Option<String> { self.few_value.clone() }
  
  pub fn many_value(&self) -> Option<String> { self.many_value.clone() }
  
  pub fn other_value(&self) -> Option<String> { self.other_value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackStringValuePluralized> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackStringValuePluralizedBuilder { instance: LanguagePackStringValuePluralized }

impl RTDLanguagePackStringValuePluralizedBuilder {
  fn new(instance: LanguagePackStringValuePluralized) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValuePluralized { self.instance.clone() }
  
  pub fn zero_value<S: AsRef<str>>(&mut self, zero_value: S) -> &mut Self {
    self.instance.zero_value = Some(zero_value.as_ref().to_string());
    self
  }
  
  pub fn one_value<S: AsRef<str>>(&mut self, one_value: S) -> &mut Self {
    self.instance.one_value = Some(one_value.as_ref().to_string());
    self
  }
  
  pub fn two_value<S: AsRef<str>>(&mut self, two_value: S) -> &mut Self {
    self.instance.two_value = Some(two_value.as_ref().to_string());
    self
  }
  
  pub fn few_value<S: AsRef<str>>(&mut self, few_value: S) -> &mut Self {
    self.instance.few_value = Some(few_value.as_ref().to_string());
    self
  }
  
  pub fn many_value<S: AsRef<str>>(&mut self, many_value: S) -> &mut Self {
    self.instance.many_value = Some(many_value.as_ref().to_string());
    self
  }
  
  pub fn other_value<S: AsRef<str>>(&mut self, other_value: S) -> &mut Self {
    self.instance.other_value = Some(other_value.as_ref().to_string());
    self
  }
  
}



/// A deleted language pack string, the value should be taken from the built-in english language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValueDeleted
  
}



impl Object for LanguagePackStringValueDeleted {}
impl RObject for LanguagePackStringValueDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValueDeleted" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValueDeleted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValueDeleted {}


impl LanguagePackStringValueDeleted {
  
  pub fn builder() -> RTDLanguagePackStringValueDeletedBuilder {
    let instance = Self {
      td_name: "languagePackStringValueDeleted".to_string(),
      
    };
    RTDLanguagePackStringValueDeletedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackStringValueDeleted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackStringValueDeletedBuilder { instance: LanguagePackStringValueDeleted }

impl RTDLanguagePackStringValueDeletedBuilder {
  fn new(instance: LanguagePackStringValueDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValueDeleted { self.instance.clone() }
  
}



/// Contains a list of language pack strings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStrings
  /// A list of language pack strings.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for LanguagePackStrings {}
impl RObject for LanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStrings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LanguagePackStrings {
  
  pub fn builder() -> RTDLanguagePackStringsBuilder {
    let instance = Self {
      td_name: "languagePackStrings".to_string(),
      strings: None,
      
    };
    RTDLanguagePackStringsBuilder::new(instance)
  }
  
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LanguagePackStrings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLanguagePackStringsBuilder { instance: LanguagePackStrings }

impl RTDLanguagePackStringsBuilder {
  fn new(instance: LanguagePackStrings) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStrings { self.instance.clone() }
  
  pub fn strings(&mut self, strings: Vec<LanguagePackString>) -> &mut Self {
    self.instance.strings = Some(strings);
    self
  }
  
}



/// This class is an abstract base class. Represents the relationship between user A and user B. For incoming_link, user A is the current user; for outgoing_link, user B is the current user. 
#[typetag::serde(tag = "@struct")]
pub trait LinkState: Object + RObject + Debug {}







impl LinkState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<LinkState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<LinkState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLinkStateType {
  LinkStateIsContact,
  LinkStateKnowsPhoneNumber,
  LinkStateNone,
  
}
impl RTDLinkStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The phone number of user A is not known to user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateNone
  
}



impl Object for LinkStateNone {}
impl RObject for LinkStateNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateNone" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateNone }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LinkState for LinkStateNone {}


impl LinkStateNone {
  
  pub fn builder() -> RTDLinkStateNoneBuilder {
    let instance = Self {
      td_name: "linkStateNone".to_string(),
      
    };
    RTDLinkStateNoneBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LinkStateNone> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLinkStateNoneBuilder { instance: LinkStateNone }

impl RTDLinkStateNoneBuilder {
  fn new(instance: LinkStateNone) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateNone { self.instance.clone() }
  
}



/// The phone number of user A is known but that number has not been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateKnowsPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateKnowsPhoneNumber
  
}



impl Object for LinkStateKnowsPhoneNumber {}
impl RObject for LinkStateKnowsPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateKnowsPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateKnowsPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LinkState for LinkStateKnowsPhoneNumber {}


impl LinkStateKnowsPhoneNumber {
  
  pub fn builder() -> RTDLinkStateKnowsPhoneNumberBuilder {
    let instance = Self {
      td_name: "linkStateKnowsPhoneNumber".to_string(),
      
    };
    RTDLinkStateKnowsPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LinkStateKnowsPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLinkStateKnowsPhoneNumberBuilder { instance: LinkStateKnowsPhoneNumber }

impl RTDLinkStateKnowsPhoneNumberBuilder {
  fn new(instance: LinkStateKnowsPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateKnowsPhoneNumber { self.instance.clone() }
  
}



/// The phone number of user A has been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateIsContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateIsContact
  
}



impl Object for LinkStateIsContact {}
impl RObject for LinkStateIsContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateIsContact" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateIsContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LinkState for LinkStateIsContact {}


impl LinkStateIsContact {
  
  pub fn builder() -> RTDLinkStateIsContactBuilder {
    let instance = Self {
      td_name: "linkStateIsContact".to_string(),
      
    };
    RTDLinkStateIsContactBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LinkStateIsContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLinkStateIsContactBuilder { instance: LinkStateIsContact }

impl RTDLinkStateIsContactBuilder {
  fn new(instance: LinkStateIsContact) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateIsContact { self.instance.clone() }
  
}



/// Represents a local file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // localFile
  /// Local path to the locally available file part; may be empty.
  path: Option<String>,
  /// True, if it is possible to try to download or generate the file.
  can_be_downloaded: Option<bool>,
  /// True, if the file can be deleted.
  can_be_deleted: Option<bool>,
  /// True, if the file is currently being downloaded (or a local copy is being generated by some other means).
  is_downloading_active: Option<bool>,
  /// True, if the local copy is fully available.
  is_downloading_completed: Option<bool>,
  /// Download will be started from this offset. downloaded_prefix_size is calculated from this offset.
  download_offset: Option<i32>,
  /// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix.
  downloaded_prefix_size: Option<i32>,
  /// Total downloaded file bytes. Should be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage.
  downloaded_size: Option<i32>,
  
}



impl Object for LocalFile {}
impl RObject for LocalFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "localFile" }
  fn td_type(&self) -> RTDType { RTDType::LocalFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LocalFile {
  
  pub fn builder() -> RTDLocalFileBuilder {
    let instance = Self {
      td_name: "localFile".to_string(),
      path: None,
      can_be_downloaded: None,
      can_be_deleted: None,
      is_downloading_active: None,
      is_downloading_completed: None,
      download_offset: None,
      downloaded_prefix_size: None,
      downloaded_size: None,
      
    };
    RTDLocalFileBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn can_be_downloaded(&self) -> Option<bool> { self.can_be_downloaded.clone() }
  
  pub fn can_be_deleted(&self) -> Option<bool> { self.can_be_deleted.clone() }
  
  pub fn is_downloading_active(&self) -> Option<bool> { self.is_downloading_active.clone() }
  
  pub fn is_downloading_completed(&self) -> Option<bool> { self.is_downloading_completed.clone() }
  
  pub fn download_offset(&self) -> Option<i32> { self.download_offset.clone() }
  
  pub fn downloaded_prefix_size(&self) -> Option<i32> { self.downloaded_prefix_size.clone() }
  
  pub fn downloaded_size(&self) -> Option<i32> { self.downloaded_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LocalFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLocalFileBuilder { instance: LocalFile }

impl RTDLocalFileBuilder {
  fn new(instance: LocalFile) -> Self { Self { instance } }

  pub fn build(&self) -> LocalFile { self.instance.clone() }
  
  pub fn path<S: AsRef<str>>(&mut self, path: S) -> &mut Self {
    self.instance.path = Some(path.as_ref().to_string());
    self
  }
  
  pub fn can_be_downloaded(&mut self, can_be_downloaded: bool) -> &mut Self {
    self.instance.can_be_downloaded = Some(can_be_downloaded);
    self
  }
  
  pub fn can_be_deleted(&mut self, can_be_deleted: bool) -> &mut Self {
    self.instance.can_be_deleted = Some(can_be_deleted);
    self
  }
  
  pub fn is_downloading_active(&mut self, is_downloading_active: bool) -> &mut Self {
    self.instance.is_downloading_active = Some(is_downloading_active);
    self
  }
  
  pub fn is_downloading_completed(&mut self, is_downloading_completed: bool) -> &mut Self {
    self.instance.is_downloading_completed = Some(is_downloading_completed);
    self
  }
  
  pub fn download_offset(&mut self, download_offset: i32) -> &mut Self {
    self.instance.download_offset = Some(download_offset);
    self
  }
  
  pub fn downloaded_prefix_size(&mut self, downloaded_prefix_size: i32) -> &mut Self {
    self.instance.downloaded_prefix_size = Some(downloaded_prefix_size);
    self
  }
  
  pub fn downloaded_size(&mut self, downloaded_size: i32) -> &mut Self {
    self.instance.downloaded_size = Some(downloaded_size);
    self
  }
  
}



/// Contains information about the current localization target. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // localizationTargetInfo
  /// List of available language packs for this application.
  language_packs: Option<Vec<LanguagePackInfo>>,
  
}



impl Object for LocalizationTargetInfo {}
impl RObject for LocalizationTargetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "localizationTargetInfo" }
  fn td_type(&self) -> RTDType { RTDType::LocalizationTargetInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LocalizationTargetInfo {
  
  pub fn builder() -> RTDLocalizationTargetInfoBuilder {
    let instance = Self {
      td_name: "localizationTargetInfo".to_string(),
      language_packs: None,
      
    };
    RTDLocalizationTargetInfoBuilder::new(instance)
  }
  
  
  pub fn language_packs(&self) -> Option<Vec<LanguagePackInfo>> { self.language_packs.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LocalizationTargetInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLocalizationTargetInfoBuilder { instance: LocalizationTargetInfo }

impl RTDLocalizationTargetInfoBuilder {
  fn new(instance: LocalizationTargetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> LocalizationTargetInfo { self.instance.clone() }
  
  pub fn language_packs(&mut self, language_packs: Vec<LanguagePackInfo>) -> &mut Self {
    self.instance.language_packs = Some(language_packs);
    self
  }
  
}



/// Describes a location on planet Earth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // location
  /// Latitude of the location in degrees; as defined by the sender.
  latitude: Option<f64>,
  /// Longitude of the location, in degrees; as defined by the sender.
  longitude: Option<f64>,
  
}



impl Object for Location {}
impl RObject for Location {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "location" }
  fn td_type(&self) -> RTDType { RTDType::Location }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Location {
  
  pub fn builder() -> RTDLocationBuilder {
    let instance = Self {
      td_name: "location".to_string(),
      latitude: None,
      longitude: None,
      
    };
    RTDLocationBuilder::new(instance)
  }
  
  
  pub fn latitude(&self) -> Option<f64> { self.latitude.clone() }
  
  pub fn longitude(&self) -> Option<f64> { self.longitude.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Location> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLocationBuilder { instance: Location }

impl RTDLocationBuilder {
  fn new(instance: Location) -> Self { Self { instance } }

  pub fn build(&self) -> Location { self.instance.clone() }
  
  pub fn latitude(&mut self, latitude: f64) -> &mut Self {
    self.instance.latitude = Some(latitude);
    self
  }
  
  pub fn longitude(&mut self, longitude: f64) -> &mut Self {
    self.instance.longitude = Some(longitude);
    self
  }
  
}



/// This class is an abstract base class. Describes a stream to which TDLib internal log is written. 
#[typetag::serde(tag = "@struct")]
pub trait LogStream: Object + RObject + Debug {}







impl LogStream {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<LogStream>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<LogStream> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLogStreamType {
  LogStreamDefault,
  LogStreamEmpty,
  LogStreamFile,
  
}
impl RTDLogStreamType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The log is written to stderr or an OS specific log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamDefault {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamDefault
  
}



impl Object for LogStreamDefault {}
impl RObject for LogStreamDefault {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamDefault" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamDefault }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LogStream for LogStreamDefault {}


impl LogStreamDefault {
  
  pub fn builder() -> RTDLogStreamDefaultBuilder {
    let instance = Self {
      td_name: "logStreamDefault".to_string(),
      
    };
    RTDLogStreamDefaultBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogStreamDefault> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogStreamDefaultBuilder { instance: LogStreamDefault }

impl RTDLogStreamDefaultBuilder {
  fn new(instance: LogStreamDefault) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamDefault { self.instance.clone() }
  
}



/// The log is written to a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamFile
  /// Path to the file to where the internal TDLib log will be written.
  path: Option<String>,
  /// Maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated.
  max_file_size: Option<i64>,
  
}



impl Object for LogStreamFile {}
impl RObject for LogStreamFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamFile" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LogStream for LogStreamFile {}


impl LogStreamFile {
  
  pub fn builder() -> RTDLogStreamFileBuilder {
    let instance = Self {
      td_name: "logStreamFile".to_string(),
      path: None,
      max_file_size: None,
      
    };
    RTDLogStreamFileBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn max_file_size(&self) -> Option<i64> { self.max_file_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogStreamFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogStreamFileBuilder { instance: LogStreamFile }

impl RTDLogStreamFileBuilder {
  fn new(instance: LogStreamFile) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamFile { self.instance.clone() }
  
  pub fn path<S: AsRef<str>>(&mut self, path: S) -> &mut Self {
    self.instance.path = Some(path.as_ref().to_string());
    self
  }
  
  pub fn max_file_size(&mut self, max_file_size: i64) -> &mut Self {
    self.instance.max_file_size = Some(max_file_size);
    self
  }
  
}



/// The log is written nowhere. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamEmpty
  
}



impl Object for LogStreamEmpty {}
impl RObject for LogStreamEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamEmpty" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl LogStream for LogStreamEmpty {}


impl LogStreamEmpty {
  
  pub fn builder() -> RTDLogStreamEmptyBuilder {
    let instance = Self {
      td_name: "logStreamEmpty".to_string(),
      
    };
    RTDLogStreamEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogStreamEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogStreamEmptyBuilder { instance: LogStreamEmpty }

impl RTDLogStreamEmptyBuilder {
  fn new(instance: LogStreamEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamEmpty { self.instance.clone() }
  
}



/// Contains a list of available TDLib internal log tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logTags
  /// List of log tags.
  tags: Option<Vec<String>>,
  
}



impl Object for LogTags {}
impl RObject for LogTags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logTags" }
  fn td_type(&self) -> RTDType { RTDType::LogTags }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LogTags {
  
  pub fn builder() -> RTDLogTagsBuilder {
    let instance = Self {
      td_name: "logTags".to_string(),
      tags: None,
      
    };
    RTDLogTagsBuilder::new(instance)
  }
  
  
  pub fn tags(&self) -> Option<Vec<String>> { self.tags.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogTags> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogTagsBuilder { instance: LogTags }

impl RTDLogTagsBuilder {
  fn new(instance: LogTags) -> Self { Self { instance } }

  pub fn build(&self) -> LogTags { self.instance.clone() }
  
  pub fn tags(&mut self, tags: Vec<String>) -> &mut Self {
    self.instance.tags = Some(tags);
    self
  }
  
}



/// Contains a TDLib internal log verbosity level. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logVerbosityLevel
  /// Log verbosity level.
  verbosity_level: Option<i32>,
  
}



impl Object for LogVerbosityLevel {}
impl RObject for LogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::LogVerbosityLevel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl LogVerbosityLevel {
  
  pub fn builder() -> RTDLogVerbosityLevelBuilder {
    let instance = Self {
      td_name: "logVerbosityLevel".to_string(),
      verbosity_level: None,
      
    };
    RTDLogVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn verbosity_level(&self) -> Option<i32> { self.verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogVerbosityLevel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogVerbosityLevelBuilder { instance: LogVerbosityLevel }

impl RTDLogVerbosityLevelBuilder {
  fn new(instance: LogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> LogVerbosityLevel { self.instance.clone() }
  
  pub fn verbosity_level(&mut self, verbosity_level: i32) -> &mut Self {
    self.instance.verbosity_level = Some(verbosity_level);
    self
  }
  
}



/// This class is an abstract base class. Part of the face, relative to which a mask should be placed. 
#[typetag::serde(tag = "@struct")]
pub trait MaskPoint: Object + RObject + Debug {}







impl MaskPoint {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<MaskPoint>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<MaskPoint> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMaskPointType {
  MaskPointChin,
  MaskPointEyes,
  MaskPointForehead,
  MaskPointMouth,
  
}
impl RTDMaskPointType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A mask should be placed relatively to the forehead. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointForehead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointForehead
  
}



impl Object for MaskPointForehead {}
impl RObject for MaskPointForehead {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointForehead" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointForehead }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MaskPoint for MaskPointForehead {}


impl MaskPointForehead {
  
  pub fn builder() -> RTDMaskPointForeheadBuilder {
    let instance = Self {
      td_name: "maskPointForehead".to_string(),
      
    };
    RTDMaskPointForeheadBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MaskPointForehead> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMaskPointForeheadBuilder { instance: MaskPointForehead }

impl RTDMaskPointForeheadBuilder {
  fn new(instance: MaskPointForehead) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointForehead { self.instance.clone() }
  
}



/// A mask should be placed relatively to the eyes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointEyes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointEyes
  
}



impl Object for MaskPointEyes {}
impl RObject for MaskPointEyes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointEyes" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointEyes }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MaskPoint for MaskPointEyes {}


impl MaskPointEyes {
  
  pub fn builder() -> RTDMaskPointEyesBuilder {
    let instance = Self {
      td_name: "maskPointEyes".to_string(),
      
    };
    RTDMaskPointEyesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MaskPointEyes> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMaskPointEyesBuilder { instance: MaskPointEyes }

impl RTDMaskPointEyesBuilder {
  fn new(instance: MaskPointEyes) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointEyes { self.instance.clone() }
  
}



/// A mask should be placed relatively to the mouth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointMouth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointMouth
  
}



impl Object for MaskPointMouth {}
impl RObject for MaskPointMouth {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointMouth" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointMouth }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MaskPoint for MaskPointMouth {}


impl MaskPointMouth {
  
  pub fn builder() -> RTDMaskPointMouthBuilder {
    let instance = Self {
      td_name: "maskPointMouth".to_string(),
      
    };
    RTDMaskPointMouthBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MaskPointMouth> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMaskPointMouthBuilder { instance: MaskPointMouth }

impl RTDMaskPointMouthBuilder {
  fn new(instance: MaskPointMouth) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointMouth { self.instance.clone() }
  
}



/// A mask should be placed relatively to the chin. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointChin {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointChin
  
}



impl Object for MaskPointChin {}
impl RObject for MaskPointChin {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointChin" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointChin }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MaskPoint for MaskPointChin {}


impl MaskPointChin {
  
  pub fn builder() -> RTDMaskPointChinBuilder {
    let instance = Self {
      td_name: "maskPointChin".to_string(),
      
    };
    RTDMaskPointChinBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MaskPointChin> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMaskPointChinBuilder { instance: MaskPointChin }

impl RTDMaskPointChinBuilder {
  fn new(instance: MaskPointChin) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointChin { self.instance.clone() }
  
}



/// Position on a photo where a mask should be placed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MaskPosition {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPosition
  /// Part of the face, relative to which the mask should be placed.
  point: Option<Box<MaskPoint>>,
  /// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position.)
  x_shift: Option<f64>,
  /// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position.)
  y_shift: Option<f64>,
  /// Mask scaling coefficient. (For example, 2.0 means a doubled size.)
  scale: Option<f64>,
  
}


impl Clone for MaskPosition {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for MaskPosition {}
impl RObject for MaskPosition {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPosition" }
  fn td_type(&self) -> RTDType { RTDType::MaskPosition }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl MaskPosition {
  
  pub fn builder() -> RTDMaskPositionBuilder {
    let instance = Self {
      td_name: "maskPosition".to_string(),
      point: None,
      x_shift: None,
      y_shift: None,
      scale: None,
      
    };
    RTDMaskPositionBuilder::new(instance)
  }
  
  
  pub fn point(&self) -> Option<Box<MaskPoint>> { self.point.clone() }
  
  pub fn x_shift(&self) -> Option<f64> { self.x_shift.clone() }
  
  pub fn y_shift(&self) -> Option<f64> { self.y_shift.clone() }
  
  pub fn scale(&self) -> Option<f64> { self.scale.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MaskPosition> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMaskPositionBuilder { instance: MaskPosition }

impl RTDMaskPositionBuilder {
  fn new(instance: MaskPosition) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPosition { self.instance.clone() }
  
  pub fn point(&mut self, point: Box<MaskPoint>) -> &mut Self {
    self.instance.point = Some(point);
    self
  }
  
  pub fn x_shift(&mut self, x_shift: f64) -> &mut Self {
    self.instance.x_shift = Some(x_shift);
    self
  }
  
  pub fn y_shift(&mut self, y_shift: f64) -> &mut Self {
    self.instance.y_shift = Some(y_shift);
    self
  }
  
  pub fn scale(&mut self, scale: f64) -> &mut Self {
    self.instance.scale = Some(scale);
    self
  }
  
}



/// Describes a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // message
  /// Message identifier, unique for the chat to which the message belongs.
  id: Option<i64>,
  /// Identifier of the user who sent the message; 0 if unknown. It is unknown for channel posts.
  sender_user_id: Option<i32>,
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Information about the sending state of the message; may be null.
  sending_state: Option<Box<MessageSendingState>>,
  /// True, if the message is outgoing.
  is_outgoing: Option<bool>,
  /// True, if the message can be edited. For live location and poll messages this fields shows, whether editMessageLiveLocation or stopPoll can be used with this message by the client.
  can_be_edited: Option<bool>,
  /// True, if the message can be forwarded.
  can_be_forwarded: Option<bool>,
  /// True, if the message can be deleted only for the current user while other users will continue to see it.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the message can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts.
  is_channel_post: Option<bool>,
  /// True, if the message contains an unread mention for the current user.
  contains_unread_mention: Option<bool>,
  /// Point in time (Unix timestamp) when the message was sent.
  date: Option<i32>,
  /// Point in time (Unix timestamp) when the message was last edited.
  edit_date: Option<i32>,
  /// Information about the initial message sender; may be null.
  forward_info: Option<MessageForwardInfo>,
  /// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message.
  reply_to_message_id: Option<i64>,
  /// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires.
  ttl: Option<i32>,
  /// Time left before the message expires, in seconds.
  ttl_expires_in: Option<f64>,
  /// If non-zero, the user identifier of the bot through which this message was sent.
  via_bot_user_id: Option<i32>,
  /// For channel posts, optional author signature.
  author_signature: Option<String>,
  /// Number of times this message was viewed.
  views: Option<i32>,
  /// Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums.
  media_album_id: Option<i64>,
  /// Content of the message.
  content: Option<Box<MessageContent>>,
  /// Reply markup for the message; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for Message {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Message {}
impl RObject for Message {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "message" }
  fn td_type(&self) -> RTDType { RTDType::Message }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Message {
  
  pub fn builder() -> RTDMessageBuilder {
    let instance = Self {
      td_name: "message".to_string(),
      id: None,
      sender_user_id: None,
      chat_id: None,
      sending_state: None,
      is_outgoing: None,
      can_be_edited: None,
      can_be_forwarded: None,
      can_be_deleted_only_for_self: None,
      can_be_deleted_for_all_users: None,
      is_channel_post: None,
      contains_unread_mention: None,
      date: None,
      edit_date: None,
      forward_info: None,
      reply_to_message_id: None,
      ttl: None,
      ttl_expires_in: None,
      via_bot_user_id: None,
      author_signature: None,
      views: None,
      media_album_id: None,
      content: None,
      reply_markup: None,
      
    };
    RTDMessageBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn sending_state(&self) -> Option<Box<MessageSendingState>> { self.sending_state.clone() }
  
  pub fn is_outgoing(&self) -> Option<bool> { self.is_outgoing.clone() }
  
  pub fn can_be_edited(&self) -> Option<bool> { self.can_be_edited.clone() }
  
  pub fn can_be_forwarded(&self) -> Option<bool> { self.can_be_forwarded.clone() }
  
  pub fn can_be_deleted_only_for_self(&self) -> Option<bool> { self.can_be_deleted_only_for_self.clone() }
  
  pub fn can_be_deleted_for_all_users(&self) -> Option<bool> { self.can_be_deleted_for_all_users.clone() }
  
  pub fn is_channel_post(&self) -> Option<bool> { self.is_channel_post.clone() }
  
  pub fn contains_unread_mention(&self) -> Option<bool> { self.contains_unread_mention.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn edit_date(&self) -> Option<i32> { self.edit_date.clone() }
  
  pub fn forward_info(&self) -> Option<MessageForwardInfo> { self.forward_info.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn ttl_expires_in(&self) -> Option<f64> { self.ttl_expires_in.clone() }
  
  pub fn via_bot_user_id(&self) -> Option<i32> { self.via_bot_user_id.clone() }
  
  pub fn author_signature(&self) -> Option<String> { self.author_signature.clone() }
  
  pub fn views(&self) -> Option<i32> { self.views.clone() }
  
  pub fn media_album_id(&self) -> Option<i64> { self.media_album_id.clone() }
  
  pub fn content(&self) -> Option<Box<MessageContent>> { self.content.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Message> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageBuilder { instance: Message }

impl RTDMessageBuilder {
  fn new(instance: Message) -> Self { Self { instance } }

  pub fn build(&self) -> Message { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn sending_state(&mut self, sending_state: Box<MessageSendingState>) -> &mut Self {
    self.instance.sending_state = Some(sending_state);
    self
  }
  
  pub fn is_outgoing(&mut self, is_outgoing: bool) -> &mut Self {
    self.instance.is_outgoing = Some(is_outgoing);
    self
  }
  
  pub fn can_be_edited(&mut self, can_be_edited: bool) -> &mut Self {
    self.instance.can_be_edited = Some(can_be_edited);
    self
  }
  
  pub fn can_be_forwarded(&mut self, can_be_forwarded: bool) -> &mut Self {
    self.instance.can_be_forwarded = Some(can_be_forwarded);
    self
  }
  
  pub fn can_be_deleted_only_for_self(&mut self, can_be_deleted_only_for_self: bool) -> &mut Self {
    self.instance.can_be_deleted_only_for_self = Some(can_be_deleted_only_for_self);
    self
  }
  
  pub fn can_be_deleted_for_all_users(&mut self, can_be_deleted_for_all_users: bool) -> &mut Self {
    self.instance.can_be_deleted_for_all_users = Some(can_be_deleted_for_all_users);
    self
  }
  
  pub fn is_channel_post(&mut self, is_channel_post: bool) -> &mut Self {
    self.instance.is_channel_post = Some(is_channel_post);
    self
  }
  
  pub fn contains_unread_mention(&mut self, contains_unread_mention: bool) -> &mut Self {
    self.instance.contains_unread_mention = Some(contains_unread_mention);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn edit_date(&mut self, edit_date: i32) -> &mut Self {
    self.instance.edit_date = Some(edit_date);
    self
  }
  
  pub fn forward_info(&mut self, forward_info: MessageForwardInfo) -> &mut Self {
    self.instance.forward_info = Some(forward_info);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn ttl_expires_in(&mut self, ttl_expires_in: f64) -> &mut Self {
    self.instance.ttl_expires_in = Some(ttl_expires_in);
    self
  }
  
  pub fn via_bot_user_id(&mut self, via_bot_user_id: i32) -> &mut Self {
    self.instance.via_bot_user_id = Some(via_bot_user_id);
    self
  }
  
  pub fn author_signature<S: AsRef<str>>(&mut self, author_signature: S) -> &mut Self {
    self.instance.author_signature = Some(author_signature.as_ref().to_string());
    self
  }
  
  pub fn views(&mut self, views: i32) -> &mut Self {
    self.instance.views = Some(views);
    self
  }
  
  pub fn media_album_id(&mut self, media_album_id: i64) -> &mut Self {
    self.instance.media_album_id = Some(media_album_id);
    self
  }
  
  pub fn content(&mut self, content: Box<MessageContent>) -> &mut Self {
    self.instance.content = Some(content);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}



/// This class is an abstract base class. Contains the content of a message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageContent: Object + RObject + Debug {}







impl MessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<MessageContent>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<MessageContent> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageContentType {
  MessageAnimation,
  MessageAudio,
  MessageBasicGroupChatCreate,
  MessageCall,
  MessageChatAddMembers,
  MessageChatChangePhoto,
  MessageChatChangeTitle,
  MessageChatDeleteMember,
  MessageChatDeletePhoto,
  MessageChatJoinByLink,
  MessageChatSetTtl,
  MessageChatUpgradeFrom,
  MessageChatUpgradeTo,
  MessageContact,
  MessageContactRegistered,
  MessageCustomServiceAction,
  MessageDocument,
  MessageExpiredPhoto,
  MessageExpiredVideo,
  MessageGame,
  MessageGameScore,
  MessageInvoice,
  MessageLocation,
  MessagePassportDataReceived,
  MessagePassportDataSent,
  MessagePaymentSuccessful,
  MessagePaymentSuccessfulBot,
  MessagePhoto,
  MessagePinMessage,
  MessagePoll,
  MessageScreenshotTaken,
  MessageSticker,
  MessageSupergroupChatCreate,
  MessageText,
  MessageUnsupported,
  MessageVenue,
  MessageVideo,
  MessageVideoNote,
  MessageVoiceNote,
  MessageWebsiteConnected,
  
}
impl RTDMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageText
  /// Text of the message.
  text: Option<FormattedText>,
  /// A preview of the web page that's mentioned in the text; may be null.
  web_page: Option<WebPage>,
  
}



impl Object for MessageText {}
impl RObject for MessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageText" }
  fn td_type(&self) -> RTDType { RTDType::MessageText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageText {}


impl MessageText {
  
  pub fn builder() -> RTDMessageTextBuilder {
    let instance = Self {
      td_name: "messageText".to_string(),
      text: None,
      web_page: None,
      
    };
    RTDMessageTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn web_page(&self) -> Option<WebPage> { self.web_page.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageTextBuilder { instance: MessageText }

impl RTDMessageTextBuilder {
  fn new(instance: MessageText) -> Self { Self { instance } }

  pub fn build(&self) -> MessageText { self.instance.clone() }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn web_page(&mut self, web_page: WebPage) -> &mut Self {
    self.instance.web_page = Some(web_page);
    self
  }
  
}



/// An animation message (GIF-style). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageAnimation
  /// Message content.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<FormattedText>,
  /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageAnimation {}
impl RObject for MessageAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageAnimation" }
  fn td_type(&self) -> RTDType { RTDType::MessageAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageAnimation {}


impl MessageAnimation {
  
  pub fn builder() -> RTDMessageAnimationBuilder {
    let instance = Self {
      td_name: "messageAnimation".to_string(),
      animation: None,
      caption: None,
      is_secret: None,
      
    };
    RTDMessageAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageAnimationBuilder { instance: MessageAnimation }

impl RTDMessageAnimationBuilder {
  fn new(instance: MessageAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> MessageAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}



/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageAudio
  /// Message content.
  audio: Option<Audio>,
  /// Audio caption.
  caption: Option<FormattedText>,
  
}



impl Object for MessageAudio {}
impl RObject for MessageAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageAudio" }
  fn td_type(&self) -> RTDType { RTDType::MessageAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageAudio {}


impl MessageAudio {
  
  pub fn builder() -> RTDMessageAudioBuilder {
    let instance = Self {
      td_name: "messageAudio".to_string(),
      audio: None,
      caption: None,
      
    };
    RTDMessageAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageAudioBuilder { instance: MessageAudio }

impl RTDMessageAudioBuilder {
  fn new(instance: MessageAudio) -> Self { Self { instance } }

  pub fn build(&self) -> MessageAudio { self.instance.clone() }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A document message (general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageDocument
  /// Message content.
  document: Option<Document>,
  /// Document caption.
  caption: Option<FormattedText>,
  
}



impl Object for MessageDocument {}
impl RObject for MessageDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageDocument" }
  fn td_type(&self) -> RTDType { RTDType::MessageDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageDocument {}


impl MessageDocument {
  
  pub fn builder() -> RTDMessageDocumentBuilder {
    let instance = Self {
      td_name: "messageDocument".to_string(),
      document: None,
      caption: None,
      
    };
    RTDMessageDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageDocumentBuilder { instance: MessageDocument }

impl RTDMessageDocumentBuilder {
  fn new(instance: MessageDocument) -> Self { Self { instance } }

  pub fn build(&self) -> MessageDocument { self.instance.clone() }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePhoto
  /// Message content.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<FormattedText>,
  /// True, if the photo must be blurred and must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessagePhoto {}
impl RObject for MessagePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessagePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePhoto {}


impl MessagePhoto {
  
  pub fn builder() -> RTDMessagePhotoBuilder {
    let instance = Self {
      td_name: "messagePhoto".to_string(),
      photo: None,
      caption: None,
      is_secret: None,
      
    };
    RTDMessagePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePhotoBuilder { instance: MessagePhoto }

impl RTDMessagePhotoBuilder {
  fn new(instance: MessagePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}



/// An expired photo message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageExpiredPhoto
  
}



impl Object for MessageExpiredPhoto {}
impl RObject for MessageExpiredPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageExpiredPhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageExpiredPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageExpiredPhoto {}


impl MessageExpiredPhoto {
  
  pub fn builder() -> RTDMessageExpiredPhotoBuilder {
    let instance = Self {
      td_name: "messageExpiredPhoto".to_string(),
      
    };
    RTDMessageExpiredPhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageExpiredPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageExpiredPhotoBuilder { instance: MessageExpiredPhoto }

impl RTDMessageExpiredPhotoBuilder {
  fn new(instance: MessageExpiredPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageExpiredPhoto { self.instance.clone() }
  
}



/// A sticker message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSticker
  /// Message content.
  sticker: Option<Sticker>,
  
}



impl Object for MessageSticker {}
impl RObject for MessageSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSticker" }
  fn td_type(&self) -> RTDType { RTDType::MessageSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageSticker {}


impl MessageSticker {
  
  pub fn builder() -> RTDMessageStickerBuilder {
    let instance = Self {
      td_name: "messageSticker".to_string(),
      sticker: None,
      
    };
    RTDMessageStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageStickerBuilder { instance: MessageSticker }

impl RTDMessageStickerBuilder {
  fn new(instance: MessageSticker) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSticker { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVideo
  /// Message content.
  video: Option<Video>,
  /// Video caption.
  caption: Option<FormattedText>,
  /// True, if the video thumbnail must be blurred and the video must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageVideo {}
impl RObject for MessageVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVideo" }
  fn td_type(&self) -> RTDType { RTDType::MessageVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageVideo {}


impl MessageVideo {
  
  pub fn builder() -> RTDMessageVideoBuilder {
    let instance = Self {
      td_name: "messageVideo".to_string(),
      video: None,
      caption: None,
      is_secret: None,
      
    };
    RTDMessageVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageVideoBuilder { instance: MessageVideo }

impl RTDMessageVideoBuilder {
  fn new(instance: MessageVideo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVideo { self.instance.clone() }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}



/// An expired video message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageExpiredVideo
  
}



impl Object for MessageExpiredVideo {}
impl RObject for MessageExpiredVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageExpiredVideo" }
  fn td_type(&self) -> RTDType { RTDType::MessageExpiredVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageExpiredVideo {}


impl MessageExpiredVideo {
  
  pub fn builder() -> RTDMessageExpiredVideoBuilder {
    let instance = Self {
      td_name: "messageExpiredVideo".to_string(),
      
    };
    RTDMessageExpiredVideoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageExpiredVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageExpiredVideoBuilder { instance: MessageExpiredVideo }

impl RTDMessageExpiredVideoBuilder {
  fn new(instance: MessageExpiredVideo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageExpiredVideo { self.instance.clone() }
  
}



/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVideoNote
  /// Message content.
  video_note: Option<VideoNote>,
  /// True, if at least one of the recipients has viewed the video note.
  is_viewed: Option<bool>,
  /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageVideoNote {}
impl RObject for MessageVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::MessageVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageVideoNote {}


impl MessageVideoNote {
  
  pub fn builder() -> RTDMessageVideoNoteBuilder {
    let instance = Self {
      td_name: "messageVideoNote".to_string(),
      video_note: None,
      is_viewed: None,
      is_secret: None,
      
    };
    RTDMessageVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageVideoNoteBuilder { instance: MessageVideoNote }

impl RTDMessageVideoNoteBuilder {
  fn new(instance: MessageVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVideoNote { self.instance.clone() }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}



/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVoiceNote
  /// Message content.
  voice_note: Option<VoiceNote>,
  /// Voice note caption.
  caption: Option<FormattedText>,
  /// True, if at least one of the recipients has listened to the voice note.
  is_listened: Option<bool>,
  
}



impl Object for MessageVoiceNote {}
impl RObject for MessageVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::MessageVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageVoiceNote {}


impl MessageVoiceNote {
  
  pub fn builder() -> RTDMessageVoiceNoteBuilder {
    let instance = Self {
      td_name: "messageVoiceNote".to_string(),
      voice_note: None,
      caption: None,
      is_listened: None,
      
    };
    RTDMessageVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_listened(&self) -> Option<bool> { self.is_listened.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageVoiceNoteBuilder { instance: MessageVoiceNote }

impl RTDMessageVoiceNoteBuilder {
  fn new(instance: MessageVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVoiceNote { self.instance.clone() }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_listened(&mut self, is_listened: bool) -> &mut Self {
    self.instance.is_listened = Some(is_listened);
    self
  }
  
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageLocation
  /// Message content.
  location: Option<Location>,
  /// Time relative to the message sent date until which the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes.
  expires_in: Option<i32>,
  
}



impl Object for MessageLocation {}
impl RObject for MessageLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageLocation" }
  fn td_type(&self) -> RTDType { RTDType::MessageLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageLocation {}


impl MessageLocation {
  
  pub fn builder() -> RTDMessageLocationBuilder {
    let instance = Self {
      td_name: "messageLocation".to_string(),
      location: None,
      live_period: None,
      expires_in: None,
      
    };
    RTDMessageLocationBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn expires_in(&self) -> Option<i32> { self.expires_in.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageLocationBuilder { instance: MessageLocation }

impl RTDMessageLocationBuilder {
  fn new(instance: MessageLocation) -> Self { Self { instance } }

  pub fn build(&self) -> MessageLocation { self.instance.clone() }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
  pub fn expires_in(&mut self, expires_in: i32) -> &mut Self {
    self.instance.expires_in = Some(expires_in);
    self
  }
  
}



/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVenue
  /// Message content.
  venue: Option<Venue>,
  
}



impl Object for MessageVenue {}
impl RObject for MessageVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVenue" }
  fn td_type(&self) -> RTDType { RTDType::MessageVenue }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageVenue {}


impl MessageVenue {
  
  pub fn builder() -> RTDMessageVenueBuilder {
    let instance = Self {
      td_name: "messageVenue".to_string(),
      venue: None,
      
    };
    RTDMessageVenueBuilder::new(instance)
  }
  
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageVenue> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageVenueBuilder { instance: MessageVenue }

impl RTDMessageVenueBuilder {
  fn new(instance: MessageVenue) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVenue { self.instance.clone() }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
}



/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageContact
  /// Message content.
  contact: Option<Contact>,
  
}



impl Object for MessageContact {}
impl RObject for MessageContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageContact" }
  fn td_type(&self) -> RTDType { RTDType::MessageContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageContact {}


impl MessageContact {
  
  pub fn builder() -> RTDMessageContactBuilder {
    let instance = Self {
      td_name: "messageContact".to_string(),
      contact: None,
      
    };
    RTDMessageContactBuilder::new(instance)
  }
  
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageContactBuilder { instance: MessageContact }

impl RTDMessageContactBuilder {
  fn new(instance: MessageContact) -> Self { Self { instance } }

  pub fn build(&self) -> MessageContact { self.instance.clone() }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
}



/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageGame
  /// Game.
  game: Option<Game>,
  
}



impl Object for MessageGame {}
impl RObject for MessageGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageGame" }
  fn td_type(&self) -> RTDType { RTDType::MessageGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageGame {}


impl MessageGame {
  
  pub fn builder() -> RTDMessageGameBuilder {
    let instance = Self {
      td_name: "messageGame".to_string(),
      game: None,
      
    };
    RTDMessageGameBuilder::new(instance)
  }
  
  
  pub fn game(&self) -> Option<Game> { self.game.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageGameBuilder { instance: MessageGame }

impl RTDMessageGameBuilder {
  fn new(instance: MessageGame) -> Self { Self { instance } }

  pub fn build(&self) -> MessageGame { self.instance.clone() }
  
  pub fn game(&mut self, game: Game) -> &mut Self {
    self.instance.game = Some(game);
    self
  }
  
}



/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePoll
  /// Poll.
  poll: Option<Poll>,
  
}



impl Object for MessagePoll {}
impl RObject for MessagePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePoll" }
  fn td_type(&self) -> RTDType { RTDType::MessagePoll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePoll {}


impl MessagePoll {
  
  pub fn builder() -> RTDMessagePollBuilder {
    let instance = Self {
      td_name: "messagePoll".to_string(),
      poll: None,
      
    };
    RTDMessagePollBuilder::new(instance)
  }
  
  
  pub fn poll(&self) -> Option<Poll> { self.poll.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePoll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePollBuilder { instance: MessagePoll }

impl RTDMessagePollBuilder {
  fn new(instance: MessagePoll) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePoll { self.instance.clone() }
  
  pub fn poll(&mut self, poll: Poll) -> &mut Self {
    self.instance.poll = Some(poll);
    self
  }
  
}



/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageInvoice
  /// Product title.
  title: Option<String>,
  /// Product description.
  description: Option<String>,
  /// Product photo; may be null.
  photo: Option<Photo>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Product total price in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}.
  start_parameter: Option<String>,
  /// True, if the invoice is a test invoice.
  is_test: Option<bool>,
  /// True, if the shipping address should be specified.
  need_shipping_address: Option<bool>,
  /// The identifier of the message with the receipt, after the product has been purchased.
  receipt_message_id: Option<i64>,
  
}



impl Object for MessageInvoice {}
impl RObject for MessageInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageInvoice" }
  fn td_type(&self) -> RTDType { RTDType::MessageInvoice }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageInvoice {}


impl MessageInvoice {
  
  pub fn builder() -> RTDMessageInvoiceBuilder {
    let instance = Self {
      td_name: "messageInvoice".to_string(),
      title: None,
      description: None,
      photo: None,
      currency: None,
      total_amount: None,
      start_parameter: None,
      is_test: None,
      need_shipping_address: None,
      receipt_message_id: None,
      
    };
    RTDMessageInvoiceBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn start_parameter(&self) -> Option<String> { self.start_parameter.clone() }
  
  pub fn is_test(&self) -> Option<bool> { self.is_test.clone() }
  
  pub fn need_shipping_address(&self) -> Option<bool> { self.need_shipping_address.clone() }
  
  pub fn receipt_message_id(&self) -> Option<i64> { self.receipt_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageInvoice> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageInvoiceBuilder { instance: MessageInvoice }

impl RTDMessageInvoiceBuilder {
  fn new(instance: MessageInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> MessageInvoice { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn currency<S: AsRef<str>>(&mut self, currency: S) -> &mut Self {
    self.instance.currency = Some(currency.as_ref().to_string());
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
  pub fn start_parameter<S: AsRef<str>>(&mut self, start_parameter: S) -> &mut Self {
    self.instance.start_parameter = Some(start_parameter.as_ref().to_string());
    self
  }
  
  pub fn is_test(&mut self, is_test: bool) -> &mut Self {
    self.instance.is_test = Some(is_test);
    self
  }
  
  pub fn need_shipping_address(&mut self, need_shipping_address: bool) -> &mut Self {
    self.instance.need_shipping_address = Some(need_shipping_address);
    self
  }
  
  pub fn receipt_message_id(&mut self, receipt_message_id: i64) -> &mut Self {
    self.instance.receipt_message_id = Some(receipt_message_id);
    self
  }
  
}



/// A message with information about an ended call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageCall
  /// Reason why the call was discarded.
  discard_reason: Option<Box<CallDiscardReason>>,
  /// Call duration, in seconds.
  duration: Option<i32>,
  
}


impl Clone for MessageCall {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for MessageCall {}
impl RObject for MessageCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageCall" }
  fn td_type(&self) -> RTDType { RTDType::MessageCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageCall {}


impl MessageCall {
  
  pub fn builder() -> RTDMessageCallBuilder {
    let instance = Self {
      td_name: "messageCall".to_string(),
      discard_reason: None,
      duration: None,
      
    };
    RTDMessageCallBuilder::new(instance)
  }
  
  
  pub fn discard_reason(&self) -> Option<Box<CallDiscardReason>> { self.discard_reason.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageCallBuilder { instance: MessageCall }

impl RTDMessageCallBuilder {
  fn new(instance: MessageCall) -> Self { Self { instance } }

  pub fn build(&self) -> MessageCall { self.instance.clone() }
  
  pub fn discard_reason(&mut self, discard_reason: Box<CallDiscardReason>) -> &mut Self {
    self.instance.discard_reason = Some(discard_reason);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
}



/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageBasicGroupChatCreate
  /// Title of the basic group.
  title: Option<String>,
  /// User identifiers of members in the basic group.
  member_user_ids: Option<Vec<i32>>,
  
}



impl Object for MessageBasicGroupChatCreate {}
impl RObject for MessageBasicGroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageBasicGroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::MessageBasicGroupChatCreate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageBasicGroupChatCreate {}


impl MessageBasicGroupChatCreate {
  
  pub fn builder() -> RTDMessageBasicGroupChatCreateBuilder {
    let instance = Self {
      td_name: "messageBasicGroupChatCreate".to_string(),
      title: None,
      member_user_ids: None,
      
    };
    RTDMessageBasicGroupChatCreateBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageBasicGroupChatCreate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageBasicGroupChatCreateBuilder { instance: MessageBasicGroupChatCreate }

impl RTDMessageBasicGroupChatCreateBuilder {
  fn new(instance: MessageBasicGroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> MessageBasicGroupChatCreate { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
}



/// A newly created supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSupergroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSupergroupChatCreate
  /// Title of the supergroup or channel.
  title: Option<String>,
  
}



impl Object for MessageSupergroupChatCreate {}
impl RObject for MessageSupergroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSupergroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::MessageSupergroupChatCreate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageSupergroupChatCreate {}


impl MessageSupergroupChatCreate {
  
  pub fn builder() -> RTDMessageSupergroupChatCreateBuilder {
    let instance = Self {
      td_name: "messageSupergroupChatCreate".to_string(),
      title: None,
      
    };
    RTDMessageSupergroupChatCreateBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageSupergroupChatCreate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageSupergroupChatCreateBuilder { instance: MessageSupergroupChatCreate }

impl RTDMessageSupergroupChatCreateBuilder {
  fn new(instance: MessageSupergroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSupergroupChatCreate { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// An updated chat title. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatChangeTitle
  /// New chat title.
  title: Option<String>,
  
}



impl Object for MessageChatChangeTitle {}
impl RObject for MessageChatChangeTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatChangeTitle" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatChangeTitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatChangeTitle {}


impl MessageChatChangeTitle {
  
  pub fn builder() -> RTDMessageChatChangeTitleBuilder {
    let instance = Self {
      td_name: "messageChatChangeTitle".to_string(),
      title: None,
      
    };
    RTDMessageChatChangeTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatChangeTitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatChangeTitleBuilder { instance: MessageChatChangeTitle }

impl RTDMessageChatChangeTitleBuilder {
  fn new(instance: MessageChatChangeTitle) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatChangeTitle { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// An updated chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatChangePhoto
  /// New chat photo.
  photo: Option<Photo>,
  
}



impl Object for MessageChatChangePhoto {}
impl RObject for MessageChatChangePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatChangePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatChangePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatChangePhoto {}


impl MessageChatChangePhoto {
  
  pub fn builder() -> RTDMessageChatChangePhotoBuilder {
    let instance = Self {
      td_name: "messageChatChangePhoto".to_string(),
      photo: None,
      
    };
    RTDMessageChatChangePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatChangePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatChangePhotoBuilder { instance: MessageChatChangePhoto }

impl RTDMessageChatChangePhotoBuilder {
  fn new(instance: MessageChatChangePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatChangePhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}



/// A deleted chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeletePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatDeletePhoto
  
}



impl Object for MessageChatDeletePhoto {}
impl RObject for MessageChatDeletePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatDeletePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatDeletePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatDeletePhoto {}


impl MessageChatDeletePhoto {
  
  pub fn builder() -> RTDMessageChatDeletePhotoBuilder {
    let instance = Self {
      td_name: "messageChatDeletePhoto".to_string(),
      
    };
    RTDMessageChatDeletePhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatDeletePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatDeletePhotoBuilder { instance: MessageChatDeletePhoto }

impl RTDMessageChatDeletePhotoBuilder {
  fn new(instance: MessageChatDeletePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatDeletePhoto { self.instance.clone() }
  
}



/// New chat members were added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatAddMembers
  /// User identifiers of the new members.
  member_user_ids: Option<Vec<i32>>,
  
}



impl Object for MessageChatAddMembers {}
impl RObject for MessageChatAddMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatAddMembers" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatAddMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatAddMembers {}


impl MessageChatAddMembers {
  
  pub fn builder() -> RTDMessageChatAddMembersBuilder {
    let instance = Self {
      td_name: "messageChatAddMembers".to_string(),
      member_user_ids: None,
      
    };
    RTDMessageChatAddMembersBuilder::new(instance)
  }
  
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatAddMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatAddMembersBuilder { instance: MessageChatAddMembers }

impl RTDMessageChatAddMembersBuilder {
  fn new(instance: MessageChatAddMembers) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatAddMembers { self.instance.clone() }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
}



/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatJoinByLink
  
}



impl Object for MessageChatJoinByLink {}
impl RObject for MessageChatJoinByLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatJoinByLink" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatJoinByLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatJoinByLink {}


impl MessageChatJoinByLink {
  
  pub fn builder() -> RTDMessageChatJoinByLinkBuilder {
    let instance = Self {
      td_name: "messageChatJoinByLink".to_string(),
      
    };
    RTDMessageChatJoinByLinkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatJoinByLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatJoinByLinkBuilder { instance: MessageChatJoinByLink }

impl RTDMessageChatJoinByLinkBuilder {
  fn new(instance: MessageChatJoinByLink) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatJoinByLink { self.instance.clone() }
  
}



/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatDeleteMember
  /// User identifier of the deleted chat member.
  user_id: Option<i32>,
  
}



impl Object for MessageChatDeleteMember {}
impl RObject for MessageChatDeleteMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatDeleteMember" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatDeleteMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatDeleteMember {}


impl MessageChatDeleteMember {
  
  pub fn builder() -> RTDMessageChatDeleteMemberBuilder {
    let instance = Self {
      td_name: "messageChatDeleteMember".to_string(),
      user_id: None,
      
    };
    RTDMessageChatDeleteMemberBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatDeleteMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatDeleteMemberBuilder { instance: MessageChatDeleteMember }

impl RTDMessageChatDeleteMemberBuilder {
  fn new(instance: MessageChatDeleteMember) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatDeleteMember { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// A basic group was upgraded to a supergroup and was deactivated as the result. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeTo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatUpgradeTo
  /// Identifier of the supergroup to which the basic group was upgraded.
  supergroup_id: Option<i32>,
  
}



impl Object for MessageChatUpgradeTo {}
impl RObject for MessageChatUpgradeTo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatUpgradeTo" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatUpgradeTo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatUpgradeTo {}


impl MessageChatUpgradeTo {
  
  pub fn builder() -> RTDMessageChatUpgradeToBuilder {
    let instance = Self {
      td_name: "messageChatUpgradeTo".to_string(),
      supergroup_id: None,
      
    };
    RTDMessageChatUpgradeToBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatUpgradeTo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatUpgradeToBuilder { instance: MessageChatUpgradeTo }

impl RTDMessageChatUpgradeToBuilder {
  fn new(instance: MessageChatUpgradeTo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatUpgradeTo { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}



/// A supergroup has been created from a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeFrom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatUpgradeFrom
  /// Title of the newly created supergroup.
  title: Option<String>,
  /// The identifier of the original basic group.
  basic_group_id: Option<i32>,
  
}



impl Object for MessageChatUpgradeFrom {}
impl RObject for MessageChatUpgradeFrom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatUpgradeFrom" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatUpgradeFrom }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatUpgradeFrom {}


impl MessageChatUpgradeFrom {
  
  pub fn builder() -> RTDMessageChatUpgradeFromBuilder {
    let instance = Self {
      td_name: "messageChatUpgradeFrom".to_string(),
      title: None,
      basic_group_id: None,
      
    };
    RTDMessageChatUpgradeFromBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatUpgradeFrom> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatUpgradeFromBuilder { instance: MessageChatUpgradeFrom }

impl RTDMessageChatUpgradeFromBuilder {
  fn new(instance: MessageChatUpgradeFrom) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatUpgradeFrom { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}



/// A message has been pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePinMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePinMessage
  /// Identifier of the pinned message, can be an identifier of a deleted message or 0.
  message_id: Option<i64>,
  
}



impl Object for MessagePinMessage {}
impl RObject for MessagePinMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePinMessage" }
  fn td_type(&self) -> RTDType { RTDType::MessagePinMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePinMessage {}


impl MessagePinMessage {
  
  pub fn builder() -> RTDMessagePinMessageBuilder {
    let instance = Self {
      td_name: "messagePinMessage".to_string(),
      message_id: None,
      
    };
    RTDMessagePinMessageBuilder::new(instance)
  }
  
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePinMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePinMessageBuilder { instance: MessagePinMessage }

impl RTDMessagePinMessageBuilder {
  fn new(instance: MessagePinMessage) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePinMessage { self.instance.clone() }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageScreenshotTaken
  
}



impl Object for MessageScreenshotTaken {}
impl RObject for MessageScreenshotTaken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageScreenshotTaken" }
  fn td_type(&self) -> RTDType { RTDType::MessageScreenshotTaken }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageScreenshotTaken {}


impl MessageScreenshotTaken {
  
  pub fn builder() -> RTDMessageScreenshotTakenBuilder {
    let instance = Self {
      td_name: "messageScreenshotTaken".to_string(),
      
    };
    RTDMessageScreenshotTakenBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageScreenshotTaken> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageScreenshotTakenBuilder { instance: MessageScreenshotTaken }

impl RTDMessageScreenshotTakenBuilder {
  fn new(instance: MessageScreenshotTaken) -> Self { Self { instance } }

  pub fn build(&self) -> MessageScreenshotTaken { self.instance.clone() }
  
}



/// The TTL (Time To Live) setting messages in a secret chat has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatSetTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatSetTtl
  /// New TTL.
  ttl: Option<i32>,
  
}



impl Object for MessageChatSetTtl {}
impl RObject for MessageChatSetTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatSetTtl" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatSetTtl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageChatSetTtl {}


impl MessageChatSetTtl {
  
  pub fn builder() -> RTDMessageChatSetTtlBuilder {
    let instance = Self {
      td_name: "messageChatSetTtl".to_string(),
      ttl: None,
      
    };
    RTDMessageChatSetTtlBuilder::new(instance)
  }
  
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageChatSetTtl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageChatSetTtlBuilder { instance: MessageChatSetTtl }

impl RTDMessageChatSetTtlBuilder {
  fn new(instance: MessageChatSetTtl) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatSetTtl { self.instance.clone() }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}



/// A non-standard action has happened in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageCustomServiceAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageCustomServiceAction
  /// Message text to be shown in the chat.
  text: Option<String>,
  
}



impl Object for MessageCustomServiceAction {}
impl RObject for MessageCustomServiceAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageCustomServiceAction" }
  fn td_type(&self) -> RTDType { RTDType::MessageCustomServiceAction }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageCustomServiceAction {}


impl MessageCustomServiceAction {
  
  pub fn builder() -> RTDMessageCustomServiceActionBuilder {
    let instance = Self {
      td_name: "messageCustomServiceAction".to_string(),
      text: None,
      
    };
    RTDMessageCustomServiceActionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageCustomServiceAction> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageCustomServiceActionBuilder { instance: MessageCustomServiceAction }

impl RTDMessageCustomServiceActionBuilder {
  fn new(instance: MessageCustomServiceAction) -> Self { Self { instance } }

  pub fn build(&self) -> MessageCustomServiceAction { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageGameScore
  /// Identifier of the message with the game, can be an identifier of a deleted message.
  game_message_id: Option<i64>,
  /// Identifier of the game; may be different from the games presented in the message with the game.
  game_id: Option<i64>,
  /// New score.
  score: Option<i32>,
  
}



impl Object for MessageGameScore {}
impl RObject for MessageGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageGameScore" }
  fn td_type(&self) -> RTDType { RTDType::MessageGameScore }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageGameScore {}


impl MessageGameScore {
  
  pub fn builder() -> RTDMessageGameScoreBuilder {
    let instance = Self {
      td_name: "messageGameScore".to_string(),
      game_message_id: None,
      game_id: None,
      score: None,
      
    };
    RTDMessageGameScoreBuilder::new(instance)
  }
  
  
  pub fn game_message_id(&self) -> Option<i64> { self.game_message_id.clone() }
  
  pub fn game_id(&self) -> Option<i64> { self.game_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageGameScore> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageGameScoreBuilder { instance: MessageGameScore }

impl RTDMessageGameScoreBuilder {
  fn new(instance: MessageGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> MessageGameScore { self.instance.clone() }
  
  pub fn game_message_id(&mut self, game_message_id: i64) -> &mut Self {
    self.instance.game_message_id = Some(game_message_id);
    self
  }
  
  pub fn game_id(&mut self, game_id: i64) -> &mut Self {
    self.instance.game_id = Some(game_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
}



/// A payment has been completed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessful {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePaymentSuccessful
  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for the price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  
}



impl Object for MessagePaymentSuccessful {}
impl RObject for MessagePaymentSuccessful {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePaymentSuccessful" }
  fn td_type(&self) -> RTDType { RTDType::MessagePaymentSuccessful }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePaymentSuccessful {}


impl MessagePaymentSuccessful {
  
  pub fn builder() -> RTDMessagePaymentSuccessfulBuilder {
    let instance = Self {
      td_name: "messagePaymentSuccessful".to_string(),
      invoice_message_id: None,
      currency: None,
      total_amount: None,
      
    };
    RTDMessagePaymentSuccessfulBuilder::new(instance)
  }
  
  
  pub fn invoice_message_id(&self) -> Option<i64> { self.invoice_message_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePaymentSuccessful> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePaymentSuccessfulBuilder { instance: MessagePaymentSuccessful }

impl RTDMessagePaymentSuccessfulBuilder {
  fn new(instance: MessagePaymentSuccessful) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePaymentSuccessful { self.instance.clone() }
  
  pub fn invoice_message_id(&mut self, invoice_message_id: i64) -> &mut Self {
    self.instance.invoice_message_id = Some(invoice_message_id);
    self
  }
  
  pub fn currency<S: AsRef<str>>(&mut self, currency: S) -> &mut Self {
    self.instance.currency = Some(currency.as_ref().to_string());
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
}



/// A payment has been completed; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessfulBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePaymentSuccessfulBot
  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of the shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,
  /// Telegram payment identifier.
  telegram_payment_charge_id: Option<String>,
  /// Provider payment identifier.
  provider_payment_charge_id: Option<String>,
  
}



impl Object for MessagePaymentSuccessfulBot {}
impl RObject for MessagePaymentSuccessfulBot {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePaymentSuccessfulBot" }
  fn td_type(&self) -> RTDType { RTDType::MessagePaymentSuccessfulBot }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePaymentSuccessfulBot {}


impl MessagePaymentSuccessfulBot {
  
  pub fn builder() -> RTDMessagePaymentSuccessfulBotBuilder {
    let instance = Self {
      td_name: "messagePaymentSuccessfulBot".to_string(),
      invoice_message_id: None,
      currency: None,
      total_amount: None,
      invoice_payload: None,
      shipping_option_id: None,
      order_info: None,
      telegram_payment_charge_id: None,
      provider_payment_charge_id: None,
      
    };
    RTDMessagePaymentSuccessfulBotBuilder::new(instance)
  }
  
  
  pub fn invoice_message_id(&self) -> Option<i64> { self.invoice_message_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn telegram_payment_charge_id(&self) -> Option<String> { self.telegram_payment_charge_id.clone() }
  
  pub fn provider_payment_charge_id(&self) -> Option<String> { self.provider_payment_charge_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePaymentSuccessfulBot> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePaymentSuccessfulBotBuilder { instance: MessagePaymentSuccessfulBot }

impl RTDMessagePaymentSuccessfulBotBuilder {
  fn new(instance: MessagePaymentSuccessfulBot) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePaymentSuccessfulBot { self.instance.clone() }
  
  pub fn invoice_message_id(&mut self, invoice_message_id: i64) -> &mut Self {
    self.instance.invoice_message_id = Some(invoice_message_id);
    self
  }
  
  pub fn currency<S: AsRef<str>>(&mut self, currency: S) -> &mut Self {
    self.instance.currency = Some(currency.as_ref().to_string());
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
  pub fn invoice_payload<S: AsRef<str>>(&mut self, invoice_payload: S) -> &mut Self {
    self.instance.invoice_payload = Some(invoice_payload.as_ref().to_string());
    self
  }
  
  pub fn shipping_option_id<S: AsRef<str>>(&mut self, shipping_option_id: S) -> &mut Self {
    self.instance.shipping_option_id = Some(shipping_option_id.as_ref().to_string());
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn telegram_payment_charge_id<S: AsRef<str>>(&mut self, telegram_payment_charge_id: S) -> &mut Self {
    self.instance.telegram_payment_charge_id = Some(telegram_payment_charge_id.as_ref().to_string());
    self
  }
  
  pub fn provider_payment_charge_id<S: AsRef<str>>(&mut self, provider_payment_charge_id: S) -> &mut Self {
    self.instance.provider_payment_charge_id = Some(provider_payment_charge_id.as_ref().to_string());
    self
  }
  
}



/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageContactRegistered
  
}



impl Object for MessageContactRegistered {}
impl RObject for MessageContactRegistered {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageContactRegistered" }
  fn td_type(&self) -> RTDType { RTDType::MessageContactRegistered }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageContactRegistered {}


impl MessageContactRegistered {
  
  pub fn builder() -> RTDMessageContactRegisteredBuilder {
    let instance = Self {
      td_name: "messageContactRegistered".to_string(),
      
    };
    RTDMessageContactRegisteredBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageContactRegistered> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageContactRegisteredBuilder { instance: MessageContactRegistered }

impl RTDMessageContactRegisteredBuilder {
  fn new(instance: MessageContactRegistered) -> Self { Self { instance } }

  pub fn build(&self) -> MessageContactRegistered { self.instance.clone() }
  
}



/// The current user has connected a website by logging in using Telegram Login Widget on it. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageWebsiteConnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageWebsiteConnected
  /// Domain name of the connected website.
  domain_name: Option<String>,
  
}



impl Object for MessageWebsiteConnected {}
impl RObject for MessageWebsiteConnected {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageWebsiteConnected" }
  fn td_type(&self) -> RTDType { RTDType::MessageWebsiteConnected }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageWebsiteConnected {}


impl MessageWebsiteConnected {
  
  pub fn builder() -> RTDMessageWebsiteConnectedBuilder {
    let instance = Self {
      td_name: "messageWebsiteConnected".to_string(),
      domain_name: None,
      
    };
    RTDMessageWebsiteConnectedBuilder::new(instance)
  }
  
  
  pub fn domain_name(&self) -> Option<String> { self.domain_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageWebsiteConnected> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageWebsiteConnectedBuilder { instance: MessageWebsiteConnected }

impl RTDMessageWebsiteConnectedBuilder {
  fn new(instance: MessageWebsiteConnected) -> Self { Self { instance } }

  pub fn build(&self) -> MessageWebsiteConnected { self.instance.clone() }
  
  pub fn domain_name<S: AsRef<str>>(&mut self, domain_name: S) -> &mut Self {
    self.instance.domain_name = Some(domain_name.as_ref().to_string());
    self
  }
  
}



/// Telegram Passport data has been sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessagePassportDataSent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePassportDataSent
  /// List of Telegram Passport element types sent.
  types: Option<Vec<Box<PassportElementType>>>,
  
}


impl Clone for MessagePassportDataSent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for MessagePassportDataSent {}
impl RObject for MessagePassportDataSent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePassportDataSent" }
  fn td_type(&self) -> RTDType { RTDType::MessagePassportDataSent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePassportDataSent {}


impl MessagePassportDataSent {
  
  pub fn builder() -> RTDMessagePassportDataSentBuilder {
    let instance = Self {
      td_name: "messagePassportDataSent".to_string(),
      types: None,
      
    };
    RTDMessagePassportDataSentBuilder::new(instance)
  }
  
  
  pub fn types(&self) -> Option<Vec<Box<PassportElementType>>> { self.types.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePassportDataSent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePassportDataSentBuilder { instance: MessagePassportDataSent }

impl RTDMessagePassportDataSentBuilder {
  fn new(instance: MessagePassportDataSent) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePassportDataSent { self.instance.clone() }
  
  pub fn types(&mut self, types: Vec<Box<PassportElementType>>) -> &mut Self {
    self.instance.types = Some(types);
    self
  }
  
}



/// Telegram Passport data has been received; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePassportDataReceived {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePassportDataReceived
  /// List of received Telegram Passport elements.
  elements: Option<Vec<EncryptedPassportElement>>,
  /// Encrypted data credentials.
  credentials: Option<EncryptedCredentials>,
  
}



impl Object for MessagePassportDataReceived {}
impl RObject for MessagePassportDataReceived {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePassportDataReceived" }
  fn td_type(&self) -> RTDType { RTDType::MessagePassportDataReceived }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessagePassportDataReceived {}


impl MessagePassportDataReceived {
  
  pub fn builder() -> RTDMessagePassportDataReceivedBuilder {
    let instance = Self {
      td_name: "messagePassportDataReceived".to_string(),
      elements: None,
      credentials: None,
      
    };
    RTDMessagePassportDataReceivedBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> Option<Vec<EncryptedPassportElement>> { self.elements.clone() }
  
  pub fn credentials(&self) -> Option<EncryptedCredentials> { self.credentials.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessagePassportDataReceived> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagePassportDataReceivedBuilder { instance: MessagePassportDataReceived }

impl RTDMessagePassportDataReceivedBuilder {
  fn new(instance: MessagePassportDataReceived) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePassportDataReceived { self.instance.clone() }
  
  pub fn elements(&mut self, elements: Vec<EncryptedPassportElement>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
  pub fn credentials(&mut self, credentials: EncryptedCredentials) -> &mut Self {
    self.instance.credentials = Some(credentials);
    self
  }
  
}



/// Message content that is not supported by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageUnsupported {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageUnsupported
  
}



impl Object for MessageUnsupported {}
impl RObject for MessageUnsupported {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageUnsupported" }
  fn td_type(&self) -> RTDType { RTDType::MessageUnsupported }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageContent for MessageUnsupported {}


impl MessageUnsupported {
  
  pub fn builder() -> RTDMessageUnsupportedBuilder {
    let instance = Self {
      td_name: "messageUnsupported".to_string(),
      
    };
    RTDMessageUnsupportedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageUnsupported> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageUnsupportedBuilder { instance: MessageUnsupported }

impl RTDMessageUnsupportedBuilder {
  fn new(instance: MessageUnsupported) -> Self { Self { instance } }

  pub fn build(&self) -> MessageUnsupported { self.instance.clone() }
  
}



/// Contains information about a forwarded message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageForwardInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardInfo
  /// Origin of a forwarded message.
  origin: Option<Box<MessageForwardOrigin>>,
  /// Point in time (Unix timestamp) when the message was originally sent.
  date: Option<i32>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the chat from which the message was forwarded last time; 0 if unknown.
  from_chat_id: Option<i64>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the original message from which the new message was forwarded last time; 0 if unknown.
  from_message_id: Option<i64>,
  
}


impl Clone for MessageForwardInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for MessageForwardInfo {}
impl RObject for MessageForwardInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardInfo" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl MessageForwardInfo {
  
  pub fn builder() -> RTDMessageForwardInfoBuilder {
    let instance = Self {
      td_name: "messageForwardInfo".to_string(),
      origin: None,
      date: None,
      from_chat_id: None,
      from_message_id: None,
      
    };
    RTDMessageForwardInfoBuilder::new(instance)
  }
  
  
  pub fn origin(&self) -> Option<Box<MessageForwardOrigin>> { self.origin.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageForwardInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageForwardInfoBuilder { instance: MessageForwardInfo }

impl RTDMessageForwardInfoBuilder {
  fn new(instance: MessageForwardInfo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardInfo { self.instance.clone() }
  
  pub fn origin(&mut self, origin: Box<MessageForwardOrigin>) -> &mut Self {
    self.instance.origin = Some(origin);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
}



/// This class is an abstract base class. Contains information about the origin of a forwarded message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageForwardOrigin: Object + RObject + Debug {}







impl MessageForwardOrigin {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<MessageForwardOrigin>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<MessageForwardOrigin> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageForwardOriginType {
  MessageForwardOriginChannel,
  MessageForwardOriginHiddenUser,
  MessageForwardOriginUser,
  
}
impl RTDMessageForwardOriginType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The message was originally written by a known user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginUser
  /// Identifier of the user that originally sent the message.
  sender_user_id: Option<i32>,
  
}



impl Object for MessageForwardOriginUser {}
impl RObject for MessageForwardOriginUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginUser" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginUser {}


impl MessageForwardOriginUser {
  
  pub fn builder() -> RTDMessageForwardOriginUserBuilder {
    let instance = Self {
      td_name: "messageForwardOriginUser".to_string(),
      sender_user_id: None,
      
    };
    RTDMessageForwardOriginUserBuilder::new(instance)
  }
  
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageForwardOriginUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageForwardOriginUserBuilder { instance: MessageForwardOriginUser }

impl RTDMessageForwardOriginUserBuilder {
  fn new(instance: MessageForwardOriginUser) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginUser { self.instance.clone() }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
}



/// The message was originally written by a user, which is hidden by his privacy settings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginHiddenUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginHiddenUser
  /// Name of the sender.
  sender_name: Option<String>,
  
}



impl Object for MessageForwardOriginHiddenUser {}
impl RObject for MessageForwardOriginHiddenUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginHiddenUser" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginHiddenUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginHiddenUser {}


impl MessageForwardOriginHiddenUser {
  
  pub fn builder() -> RTDMessageForwardOriginHiddenUserBuilder {
    let instance = Self {
      td_name: "messageForwardOriginHiddenUser".to_string(),
      sender_name: None,
      
    };
    RTDMessageForwardOriginHiddenUserBuilder::new(instance)
  }
  
  
  pub fn sender_name(&self) -> Option<String> { self.sender_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageForwardOriginHiddenUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageForwardOriginHiddenUserBuilder { instance: MessageForwardOriginHiddenUser }

impl RTDMessageForwardOriginHiddenUserBuilder {
  fn new(instance: MessageForwardOriginHiddenUser) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginHiddenUser { self.instance.clone() }
  
  pub fn sender_name<S: AsRef<str>>(&mut self, sender_name: S) -> &mut Self {
    self.instance.sender_name = Some(sender_name.as_ref().to_string());
    self
  }
  
}



/// The message was originally a post in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginChannel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginChannel
  /// Identifier of the chat from which the message was originally forwarded.
  chat_id: Option<i64>,
  /// Message identifier of the original message; 0 if unknown.
  message_id: Option<i64>,
  /// Original post author signature.
  author_signature: Option<String>,
  
}



impl Object for MessageForwardOriginChannel {}
impl RObject for MessageForwardOriginChannel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginChannel" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginChannel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginChannel {}


impl MessageForwardOriginChannel {
  
  pub fn builder() -> RTDMessageForwardOriginChannelBuilder {
    let instance = Self {
      td_name: "messageForwardOriginChannel".to_string(),
      chat_id: None,
      message_id: None,
      author_signature: None,
      
    };
    RTDMessageForwardOriginChannelBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn author_signature(&self) -> Option<String> { self.author_signature.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageForwardOriginChannel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageForwardOriginChannelBuilder { instance: MessageForwardOriginChannel }

impl RTDMessageForwardOriginChannelBuilder {
  fn new(instance: MessageForwardOriginChannel) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginChannel { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn author_signature<S: AsRef<str>>(&mut self, author_signature: S) -> &mut Self {
    self.instance.author_signature = Some(author_signature.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Contains information about the sending state of the message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageSendingState: Object + RObject + Debug {}







impl MessageSendingState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<MessageSendingState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<MessageSendingState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageSendingStateType {
  MessageSendingStateFailed,
  MessageSendingStatePending,
  
}
impl RTDMessageSendingStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The message is being sent now, but has not yet been delivered to the server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSendingStatePending
  
}



impl Object for MessageSendingStatePending {}
impl RObject for MessageSendingStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSendingStatePending" }
  fn td_type(&self) -> RTDType { RTDType::MessageSendingStatePending }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageSendingState for MessageSendingStatePending {}


impl MessageSendingStatePending {
  
  pub fn builder() -> RTDMessageSendingStatePendingBuilder {
    let instance = Self {
      td_name: "messageSendingStatePending".to_string(),
      
    };
    RTDMessageSendingStatePendingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageSendingStatePending> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageSendingStatePendingBuilder { instance: MessageSendingStatePending }

impl RTDMessageSendingStatePendingBuilder {
  fn new(instance: MessageSendingStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSendingStatePending { self.instance.clone() }
  
}



/// The message failed to be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStateFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSendingStateFailed
  
}



impl Object for MessageSendingStateFailed {}
impl RObject for MessageSendingStateFailed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSendingStateFailed" }
  fn td_type(&self) -> RTDType { RTDType::MessageSendingStateFailed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl MessageSendingState for MessageSendingStateFailed {}


impl MessageSendingStateFailed {
  
  pub fn builder() -> RTDMessageSendingStateFailedBuilder {
    let instance = Self {
      td_name: "messageSendingStateFailed".to_string(),
      
    };
    RTDMessageSendingStateFailedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<MessageSendingStateFailed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessageSendingStateFailedBuilder { instance: MessageSendingStateFailed }

impl RTDMessageSendingStateFailedBuilder {
  fn new(instance: MessageSendingStateFailed) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSendingStateFailed { self.instance.clone() }
  
}



/// Contains a list of messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Messages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messages
  /// Approximate total count of messages found.
  total_count: Option<i32>,
  /// List of messages; messages may be null.
  messages: Option<Vec<Message>>,
  
}



impl Object for Messages {}
impl RObject for Messages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messages" }
  fn td_type(&self) -> RTDType { RTDType::Messages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Messages {
  
  pub fn builder() -> RTDMessagesBuilder {
    let instance = Self {
      td_name: "messages".to_string(),
      total_count: None,
      messages: None,
      
    };
    RTDMessagesBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn messages(&self) -> Option<Vec<Message>> { self.messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Messages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDMessagesBuilder { instance: Messages }

impl RTDMessagesBuilder {
  fn new(instance: Messages) -> Self { Self { instance } }

  pub fn build(&self) -> Messages { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn messages(&mut self, messages: Vec<Message>) -> &mut Self {
    self.instance.messages = Some(messages);
    self
  }
  
}



/// A full list of available network statistic entries. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatistics
  /// Point in time (Unix timestamp) when the app began collecting statistics.
  since_date: Option<i32>,
  /// Network statistics entries.
  entries: Option<Vec<Box<NetworkStatisticsEntry>>>,
  
}


impl Clone for NetworkStatistics {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for NetworkStatistics {}
impl RObject for NetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl NetworkStatistics {
  
  pub fn builder() -> RTDNetworkStatisticsBuilder {
    let instance = Self {
      td_name: "networkStatistics".to_string(),
      since_date: None,
      entries: None,
      
    };
    RTDNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn since_date(&self) -> Option<i32> { self.since_date.clone() }
  
  pub fn entries(&self) -> Option<Vec<Box<NetworkStatisticsEntry>>> { self.entries.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkStatisticsBuilder { instance: NetworkStatistics }

impl RTDNetworkStatisticsBuilder {
  fn new(instance: NetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatistics { self.instance.clone() }
  
  pub fn since_date(&mut self, since_date: i32) -> &mut Self {
    self.instance.since_date = Some(since_date);
    self
  }
  
  pub fn entries(&mut self, entries: Vec<Box<NetworkStatisticsEntry>>) -> &mut Self {
    self.instance.entries = Some(entries);
    self
  }
  
}



/// This class is an abstract base class. Contains statistics about network usage. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkStatisticsEntry: Object + RObject + Debug {}







impl NetworkStatisticsEntry {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<NetworkStatisticsEntry>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<NetworkStatisticsEntry> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNetworkStatisticsEntryType {
  NetworkStatisticsEntryCall,
  NetworkStatisticsEntryFile,
  
}
impl RTDNetworkStatisticsEntryType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Contains information about the total amount of data that was used to send and receive files. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatisticsEntryFile
  /// Type of the file the data is part of.
  file_type: Option<Box<FileType>>,
  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,
  
}


impl Clone for NetworkStatisticsEntryFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for NetworkStatisticsEntryFile {}
impl RObject for NetworkStatisticsEntryFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatisticsEntryFile" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatisticsEntryFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkStatisticsEntry for NetworkStatisticsEntryFile {}


impl NetworkStatisticsEntryFile {
  
  pub fn builder() -> RTDNetworkStatisticsEntryFileBuilder {
    let instance = Self {
      td_name: "networkStatisticsEntryFile".to_string(),
      file_type: None,
      network_type: None,
      sent_bytes: None,
      received_bytes: None,
      
    };
    RTDNetworkStatisticsEntryFileBuilder::new(instance)
  }
  
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn network_type(&self) -> Option<Box<NetworkType>> { self.network_type.clone() }
  
  pub fn sent_bytes(&self) -> Option<i64> { self.sent_bytes.clone() }
  
  pub fn received_bytes(&self) -> Option<i64> { self.received_bytes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkStatisticsEntryFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkStatisticsEntryFileBuilder { instance: NetworkStatisticsEntryFile }

impl RTDNetworkStatisticsEntryFileBuilder {
  fn new(instance: NetworkStatisticsEntryFile) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatisticsEntryFile { self.instance.clone() }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn network_type(&mut self, network_type: Box<NetworkType>) -> &mut Self {
    self.instance.network_type = Some(network_type);
    self
  }
  
  pub fn sent_bytes(&mut self, sent_bytes: i64) -> &mut Self {
    self.instance.sent_bytes = Some(sent_bytes);
    self
  }
  
  pub fn received_bytes(&mut self, received_bytes: i64) -> &mut Self {
    self.instance.received_bytes = Some(received_bytes);
    self
  }
  
}



/// Contains information about the total amount of data that was used for calls. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatisticsEntryCall
  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,
  /// Total call duration, in seconds.
  duration: Option<f64>,
  
}


impl Clone for NetworkStatisticsEntryCall {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for NetworkStatisticsEntryCall {}
impl RObject for NetworkStatisticsEntryCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatisticsEntryCall" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatisticsEntryCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkStatisticsEntry for NetworkStatisticsEntryCall {}


impl NetworkStatisticsEntryCall {
  
  pub fn builder() -> RTDNetworkStatisticsEntryCallBuilder {
    let instance = Self {
      td_name: "networkStatisticsEntryCall".to_string(),
      network_type: None,
      sent_bytes: None,
      received_bytes: None,
      duration: None,
      
    };
    RTDNetworkStatisticsEntryCallBuilder::new(instance)
  }
  
  
  pub fn network_type(&self) -> Option<Box<NetworkType>> { self.network_type.clone() }
  
  pub fn sent_bytes(&self) -> Option<i64> { self.sent_bytes.clone() }
  
  pub fn received_bytes(&self) -> Option<i64> { self.received_bytes.clone() }
  
  pub fn duration(&self) -> Option<f64> { self.duration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkStatisticsEntryCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkStatisticsEntryCallBuilder { instance: NetworkStatisticsEntryCall }

impl RTDNetworkStatisticsEntryCallBuilder {
  fn new(instance: NetworkStatisticsEntryCall) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatisticsEntryCall { self.instance.clone() }
  
  pub fn network_type(&mut self, network_type: Box<NetworkType>) -> &mut Self {
    self.instance.network_type = Some(network_type);
    self
  }
  
  pub fn sent_bytes(&mut self, sent_bytes: i64) -> &mut Self {
    self.instance.sent_bytes = Some(sent_bytes);
    self
  }
  
  pub fn received_bytes(&mut self, received_bytes: i64) -> &mut Self {
    self.instance.received_bytes = Some(received_bytes);
    self
  }
  
  pub fn duration(&mut self, duration: f64) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
}



/// This class is an abstract base class. Represents the type of a network. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkType: Object + RObject + Debug {}







impl NetworkType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<NetworkType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<NetworkType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNetworkTypeType {
  NetworkTypeMobile,
  NetworkTypeMobileRoaming,
  NetworkTypeNone,
  NetworkTypeOther,
  NetworkTypeWiFi,
  
}
impl RTDNetworkTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The network is not available. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeNone
  
}



impl Object for NetworkTypeNone {}
impl RObject for NetworkTypeNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeNone" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeNone }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkType for NetworkTypeNone {}


impl NetworkTypeNone {
  
  pub fn builder() -> RTDNetworkTypeNoneBuilder {
    let instance = Self {
      td_name: "networkTypeNone".to_string(),
      
    };
    RTDNetworkTypeNoneBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkTypeNone> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkTypeNoneBuilder { instance: NetworkTypeNone }

impl RTDNetworkTypeNoneBuilder {
  fn new(instance: NetworkTypeNone) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeNone { self.instance.clone() }
  
}



/// A mobile network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeMobile
  
}



impl Object for NetworkTypeMobile {}
impl RObject for NetworkTypeMobile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeMobile" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeMobile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkType for NetworkTypeMobile {}


impl NetworkTypeMobile {
  
  pub fn builder() -> RTDNetworkTypeMobileBuilder {
    let instance = Self {
      td_name: "networkTypeMobile".to_string(),
      
    };
    RTDNetworkTypeMobileBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkTypeMobile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkTypeMobileBuilder { instance: NetworkTypeMobile }

impl RTDNetworkTypeMobileBuilder {
  fn new(instance: NetworkTypeMobile) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeMobile { self.instance.clone() }
  
}



/// A mobile roaming network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobileRoaming {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeMobileRoaming
  
}



impl Object for NetworkTypeMobileRoaming {}
impl RObject for NetworkTypeMobileRoaming {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeMobileRoaming" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeMobileRoaming }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkType for NetworkTypeMobileRoaming {}


impl NetworkTypeMobileRoaming {
  
  pub fn builder() -> RTDNetworkTypeMobileRoamingBuilder {
    let instance = Self {
      td_name: "networkTypeMobileRoaming".to_string(),
      
    };
    RTDNetworkTypeMobileRoamingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkTypeMobileRoaming> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkTypeMobileRoamingBuilder { instance: NetworkTypeMobileRoaming }

impl RTDNetworkTypeMobileRoamingBuilder {
  fn new(instance: NetworkTypeMobileRoaming) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeMobileRoaming { self.instance.clone() }
  
}



/// A Wi-Fi network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeWiFi {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeWiFi
  
}



impl Object for NetworkTypeWiFi {}
impl RObject for NetworkTypeWiFi {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeWiFi" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeWiFi }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkType for NetworkTypeWiFi {}


impl NetworkTypeWiFi {
  
  pub fn builder() -> RTDNetworkTypeWiFiBuilder {
    let instance = Self {
      td_name: "networkTypeWiFi".to_string(),
      
    };
    RTDNetworkTypeWiFiBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkTypeWiFi> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkTypeWiFiBuilder { instance: NetworkTypeWiFi }

impl RTDNetworkTypeWiFiBuilder {
  fn new(instance: NetworkTypeWiFi) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeWiFi { self.instance.clone() }
  
}



/// A different network type (e.g., Ethernet network). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeOther {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeOther
  
}



impl Object for NetworkTypeOther {}
impl RObject for NetworkTypeOther {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeOther" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeOther }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NetworkType for NetworkTypeOther {}


impl NetworkTypeOther {
  
  pub fn builder() -> RTDNetworkTypeOtherBuilder {
    let instance = Self {
      td_name: "networkTypeOther".to_string(),
      
    };
    RTDNetworkTypeOtherBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NetworkTypeOther> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNetworkTypeOtherBuilder { instance: NetworkTypeOther }

impl RTDNetworkTypeOtherBuilder {
  fn new(instance: NetworkTypeOther) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeOther { self.instance.clone() }
  
}



/// Contains information about a notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Notification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notification
  /// Unique persistent identifier of this notification.
  id: Option<i32>,
  /// Notification date.
  date: Option<i32>,
  /// Notification type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationType>>,
  
}


impl Clone for Notification {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Notification {}
impl RObject for Notification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notification" }
  fn td_type(&self) -> RTDType { RTDType::Notification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Notification {
  
  pub fn builder() -> RTDNotificationBuilder {
    let instance = Self {
      td_name: "notification".to_string(),
      id: None,
      date: None,
      type_: None,
      
    };
    RTDNotificationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Notification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationBuilder { instance: Notification }

impl RTDNotificationBuilder {
  fn new(instance: Notification) -> Self { Self { instance } }

  pub fn build(&self) -> Notification { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn type_(&mut self, type_: Box<NotificationType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// Describes a group of notifications. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroup
  /// Unique persistent auto-incremented from 1 identifier of the notification group.
  id: Option<i32>,
  /// Type of the group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Total number of active notifications in the group.
  total_count: Option<i32>,
  /// The list of active notifications.
  notifications: Option<Vec<Notification>>,
  
}


impl Clone for NotificationGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for NotificationGroup {}
impl RObject for NotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl NotificationGroup {
  
  pub fn builder() -> RTDNotificationGroupBuilder {
    let instance = Self {
      td_name: "notificationGroup".to_string(),
      id: None,
      type_: None,
      chat_id: None,
      total_count: None,
      notifications: None,
      
    };
    RTDNotificationGroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationGroupType>> { self.type_.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn notifications(&self) -> Option<Vec<Notification>> { self.notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationGroupBuilder { instance: NotificationGroup }

impl RTDNotificationGroupBuilder {
  fn new(instance: NotificationGroup) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroup { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<NotificationGroupType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn notifications(&mut self, notifications: Vec<Notification>) -> &mut Self {
    self.instance.notifications = Some(notifications);
    self
  }
  
}



/// This class is an abstract base class. Describes type of notifications in the group. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationGroupType: Object + RObject + Debug {}







impl NotificationGroupType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<NotificationGroupType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<NotificationGroupType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationGroupTypeType {
  NotificationGroupTypeCalls,
  NotificationGroupTypeMentions,
  NotificationGroupTypeMessages,
  NotificationGroupTypeSecretChat,
  
}
impl RTDNotificationGroupTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeMessages
  
}



impl Object for NotificationGroupTypeMessages {}
impl RObject for NotificationGroupTypeMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeMessages" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeMessages {}


impl NotificationGroupTypeMessages {
  
  pub fn builder() -> RTDNotificationGroupTypeMessagesBuilder {
    let instance = Self {
      td_name: "notificationGroupTypeMessages".to_string(),
      
    };
    RTDNotificationGroupTypeMessagesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationGroupTypeMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationGroupTypeMessagesBuilder { instance: NotificationGroupTypeMessages }

impl RTDNotificationGroupTypeMessagesBuilder {
  fn new(instance: NotificationGroupTypeMessages) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeMessages { self.instance.clone() }
  
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeMentions
  
}



impl Object for NotificationGroupTypeMentions {}
impl RObject for NotificationGroupTypeMentions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeMentions" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeMentions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeMentions {}


impl NotificationGroupTypeMentions {
  
  pub fn builder() -> RTDNotificationGroupTypeMentionsBuilder {
    let instance = Self {
      td_name: "notificationGroupTypeMentions".to_string(),
      
    };
    RTDNotificationGroupTypeMentionsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationGroupTypeMentions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationGroupTypeMentionsBuilder { instance: NotificationGroupTypeMentions }

impl RTDNotificationGroupTypeMentionsBuilder {
  fn new(instance: NotificationGroupTypeMentions) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeMentions { self.instance.clone() }
  
}



/// A group containing a notification of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeSecretChat
  
}



impl Object for NotificationGroupTypeSecretChat {}
impl RObject for NotificationGroupTypeSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeSecretChat {}


impl NotificationGroupTypeSecretChat {
  
  pub fn builder() -> RTDNotificationGroupTypeSecretChatBuilder {
    let instance = Self {
      td_name: "notificationGroupTypeSecretChat".to_string(),
      
    };
    RTDNotificationGroupTypeSecretChatBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationGroupTypeSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationGroupTypeSecretChatBuilder { instance: NotificationGroupTypeSecretChat }

impl RTDNotificationGroupTypeSecretChatBuilder {
  fn new(instance: NotificationGroupTypeSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeSecretChat { self.instance.clone() }
  
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeCalls
  
}



impl Object for NotificationGroupTypeCalls {}
impl RObject for NotificationGroupTypeCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeCalls" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeCalls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeCalls {}


impl NotificationGroupTypeCalls {
  
  pub fn builder() -> RTDNotificationGroupTypeCallsBuilder {
    let instance = Self {
      td_name: "notificationGroupTypeCalls".to_string(),
      
    };
    RTDNotificationGroupTypeCallsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationGroupTypeCalls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationGroupTypeCallsBuilder { instance: NotificationGroupTypeCalls }

impl RTDNotificationGroupTypeCallsBuilder {
  fn new(instance: NotificationGroupTypeCalls) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeCalls { self.instance.clone() }
  
}



/// This class is an abstract base class. Describes the types of chats to which notification settings are applied. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationSettingsScope: Object + RObject + Debug {}







impl NotificationSettingsScope {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<NotificationSettingsScope>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<NotificationSettingsScope> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationSettingsScopeType {
  NotificationSettingsScopeChannelChats,
  NotificationSettingsScopeGroupChats,
  NotificationSettingsScopePrivateChats,
  
}
impl RTDNotificationSettingsScopeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopePrivateChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopePrivateChats
  
}



impl Object for NotificationSettingsScopePrivateChats {}
impl RObject for NotificationSettingsScopePrivateChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopePrivateChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopePrivateChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopePrivateChats {}


impl NotificationSettingsScopePrivateChats {
  
  pub fn builder() -> RTDNotificationSettingsScopePrivateChatsBuilder {
    let instance = Self {
      td_name: "notificationSettingsScopePrivateChats".to_string(),
      
    };
    RTDNotificationSettingsScopePrivateChatsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationSettingsScopePrivateChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationSettingsScopePrivateChatsBuilder { instance: NotificationSettingsScopePrivateChats }

impl RTDNotificationSettingsScopePrivateChatsBuilder {
  fn new(instance: NotificationSettingsScopePrivateChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopePrivateChats { self.instance.clone() }
  
}



/// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeGroupChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopeGroupChats
  
}



impl Object for NotificationSettingsScopeGroupChats {}
impl RObject for NotificationSettingsScopeGroupChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopeGroupChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopeGroupChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopeGroupChats {}


impl NotificationSettingsScopeGroupChats {
  
  pub fn builder() -> RTDNotificationSettingsScopeGroupChatsBuilder {
    let instance = Self {
      td_name: "notificationSettingsScopeGroupChats".to_string(),
      
    };
    RTDNotificationSettingsScopeGroupChatsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationSettingsScopeGroupChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationSettingsScopeGroupChatsBuilder { instance: NotificationSettingsScopeGroupChats }

impl RTDNotificationSettingsScopeGroupChatsBuilder {
  fn new(instance: NotificationSettingsScopeGroupChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopeGroupChats { self.instance.clone() }
  
}



/// Notification settings applied to all channels when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeChannelChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopeChannelChats
  
}



impl Object for NotificationSettingsScopeChannelChats {}
impl RObject for NotificationSettingsScopeChannelChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopeChannelChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopeChannelChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopeChannelChats {}


impl NotificationSettingsScopeChannelChats {
  
  pub fn builder() -> RTDNotificationSettingsScopeChannelChatsBuilder {
    let instance = Self {
      td_name: "notificationSettingsScopeChannelChats".to_string(),
      
    };
    RTDNotificationSettingsScopeChannelChatsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationSettingsScopeChannelChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationSettingsScopeChannelChatsBuilder { instance: NotificationSettingsScopeChannelChats }

impl RTDNotificationSettingsScopeChannelChatsBuilder {
  fn new(instance: NotificationSettingsScopeChannelChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopeChannelChats { self.instance.clone() }
  
}



/// This class is an abstract base class. Contains detailed information about a notification. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationType: Object + RObject + Debug {}







impl NotificationType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<NotificationType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<NotificationType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationTypeType {
  NotificationTypeNewCall,
  NotificationTypeNewMessage,
  NotificationTypeNewPushMessage,
  NotificationTypeNewSecretChat,
  
}
impl RTDNotificationTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// New message was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewMessage
  /// The message.
  message: Option<Message>,
  
}



impl Object for NotificationTypeNewMessage {}
impl RObject for NotificationTypeNewMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewMessage" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewMessage {}


impl NotificationTypeNewMessage {
  
  pub fn builder() -> RTDNotificationTypeNewMessageBuilder {
    let instance = Self {
      td_name: "notificationTypeNewMessage".to_string(),
      message: None,
      
    };
    RTDNotificationTypeNewMessageBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationTypeNewMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationTypeNewMessageBuilder { instance: NotificationTypeNewMessage }

impl RTDNotificationTypeNewMessageBuilder {
  fn new(instance: NotificationTypeNewMessage) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewMessage { self.instance.clone() }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}



/// New secret chat was created. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewSecretChat
  
}



impl Object for NotificationTypeNewSecretChat {}
impl RObject for NotificationTypeNewSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewSecretChat {}


impl NotificationTypeNewSecretChat {
  
  pub fn builder() -> RTDNotificationTypeNewSecretChatBuilder {
    let instance = Self {
      td_name: "notificationTypeNewSecretChat".to_string(),
      
    };
    RTDNotificationTypeNewSecretChatBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationTypeNewSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationTypeNewSecretChatBuilder { instance: NotificationTypeNewSecretChat }

impl RTDNotificationTypeNewSecretChatBuilder {
  fn new(instance: NotificationTypeNewSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewSecretChat { self.instance.clone() }
  
}



/// New call was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewCall
  /// Call identifier.
  call_id: Option<i32>,
  
}



impl Object for NotificationTypeNewCall {}
impl RObject for NotificationTypeNewCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewCall" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewCall {}


impl NotificationTypeNewCall {
  
  pub fn builder() -> RTDNotificationTypeNewCallBuilder {
    let instance = Self {
      td_name: "notificationTypeNewCall".to_string(),
      call_id: None,
      
    };
    RTDNotificationTypeNewCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationTypeNewCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationTypeNewCallBuilder { instance: NotificationTypeNewCall }

impl RTDNotificationTypeNewCallBuilder {
  fn new(instance: NotificationTypeNewCall) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewCall { self.instance.clone() }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
}



/// New message was received through a push notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationTypeNewPushMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewPushMessage
  /// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages and as reply_to_message_id.
  message_id: Option<i64>,
  /// Sender of the message. Corresponding user may be inaccessible.
  sender_user_id: Option<i32>,
  /// Push message content.
  content: Option<Box<PushMessageContent>>,
  
}


impl Clone for NotificationTypeNewPushMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for NotificationTypeNewPushMessage {}
impl RObject for NotificationTypeNewPushMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewPushMessage" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewPushMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewPushMessage {}


impl NotificationTypeNewPushMessage {
  
  pub fn builder() -> RTDNotificationTypeNewPushMessageBuilder {
    let instance = Self {
      td_name: "notificationTypeNewPushMessage".to_string(),
      message_id: None,
      sender_user_id: None,
      content: None,
      
    };
    RTDNotificationTypeNewPushMessageBuilder::new(instance)
  }
  
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn content(&self) -> Option<Box<PushMessageContent>> { self.content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<NotificationTypeNewPushMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDNotificationTypeNewPushMessageBuilder { instance: NotificationTypeNewPushMessage }

impl RTDNotificationTypeNewPushMessageBuilder {
  fn new(instance: NotificationTypeNewPushMessage) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewPushMessage { self.instance.clone() }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn content(&mut self, content: Box<PushMessageContent>) -> &mut Self {
    self.instance.content = Some(content);
    self
  }
  
}



/// An object of this type is returned on a successful function call for certain functions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ok {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // ok
  
}



impl Object for Ok {}
impl RObject for Ok {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "ok" }
  fn td_type(&self) -> RTDType { RTDType::Ok }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Ok {
  
  pub fn builder() -> RTDOkBuilder {
    let instance = Self {
      td_name: "ok".to_string(),
      
    };
    RTDOkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Ok> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOkBuilder { instance: Ok }

impl RTDOkBuilder {
  fn new(instance: Ok) -> Self { Self { instance } }

  pub fn build(&self) -> Ok { self.instance.clone() }
  
}



/// This class is an abstract base class. Represents the value of an option. 
#[typetag::serde(tag = "@struct")]
pub trait OptionValue: Object + RObject + Debug {}







impl OptionValue {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<OptionValue>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<OptionValue> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDOptionValueType {
  OptionValueBoolean,
  OptionValueEmpty,
  OptionValueInteger,
  OptionValueString,
  
}
impl RTDOptionValueType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Represents a boolean option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueBoolean {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueBoolean
  /// The value of the option.
  value: Option<bool>,
  
}



impl Object for OptionValueBoolean {}
impl RObject for OptionValueBoolean {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueBoolean" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueBoolean }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl OptionValue for OptionValueBoolean {}


impl OptionValueBoolean {
  
  pub fn builder() -> RTDOptionValueBooleanBuilder {
    let instance = Self {
      td_name: "optionValueBoolean".to_string(),
      value: None,
      
    };
    RTDOptionValueBooleanBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<bool> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OptionValueBoolean> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOptionValueBooleanBuilder { instance: OptionValueBoolean }

impl RTDOptionValueBooleanBuilder {
  fn new(instance: OptionValueBoolean) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueBoolean { self.instance.clone() }
  
  pub fn value(&mut self, value: bool) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// Represents an unknown option or an option which has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueEmpty
  
}



impl Object for OptionValueEmpty {}
impl RObject for OptionValueEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueEmpty" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl OptionValue for OptionValueEmpty {}


impl OptionValueEmpty {
  
  pub fn builder() -> RTDOptionValueEmptyBuilder {
    let instance = Self {
      td_name: "optionValueEmpty".to_string(),
      
    };
    RTDOptionValueEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OptionValueEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOptionValueEmptyBuilder { instance: OptionValueEmpty }

impl RTDOptionValueEmptyBuilder {
  fn new(instance: OptionValueEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueEmpty { self.instance.clone() }
  
}



/// Represents an integer option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueInteger {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueInteger
  /// The value of the option.
  value: Option<i32>,
  
}



impl Object for OptionValueInteger {}
impl RObject for OptionValueInteger {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueInteger" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueInteger }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl OptionValue for OptionValueInteger {}


impl OptionValueInteger {
  
  pub fn builder() -> RTDOptionValueIntegerBuilder {
    let instance = Self {
      td_name: "optionValueInteger".to_string(),
      value: None,
      
    };
    RTDOptionValueIntegerBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<i32> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OptionValueInteger> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOptionValueIntegerBuilder { instance: OptionValueInteger }

impl RTDOptionValueIntegerBuilder {
  fn new(instance: OptionValueInteger) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueInteger { self.instance.clone() }
  
  pub fn value(&mut self, value: i32) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// Represents a string option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueString
  /// The value of the option.
  value: Option<String>,
  
}



impl Object for OptionValueString {}
impl RObject for OptionValueString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueString" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl OptionValue for OptionValueString {}


impl OptionValueString {
  
  pub fn builder() -> RTDOptionValueStringBuilder {
    let instance = Self {
      td_name: "optionValueString".to_string(),
      value: None,
      
    };
    RTDOptionValueStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OptionValueString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOptionValueStringBuilder { instance: OptionValueString }

impl RTDOptionValueStringBuilder {
  fn new(instance: OptionValueString) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueString { self.instance.clone() }
  
  pub fn value<S: AsRef<str>>(&mut self, value: S) -> &mut Self {
    self.instance.value = Some(value.as_ref().to_string());
    self
  }
  
}



/// Order information. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // orderInfo
  /// Name of the user.
  name: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Email address of the user.
  email_address: Option<String>,
  /// Shipping address for this order; may be null.
  shipping_address: Option<Address>,
  
}



impl Object for OrderInfo {}
impl RObject for OrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "orderInfo" }
  fn td_type(&self) -> RTDType { RTDType::OrderInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl OrderInfo {
  
  pub fn builder() -> RTDOrderInfoBuilder {
    let instance = Self {
      td_name: "orderInfo".to_string(),
      name: None,
      phone_number: None,
      email_address: None,
      shipping_address: None,
      
    };
    RTDOrderInfoBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn shipping_address(&self) -> Option<Address> { self.shipping_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OrderInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOrderInfoBuilder { instance: OrderInfo }

impl RTDOrderInfoBuilder {
  fn new(instance: OrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> OrderInfo { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn email_address<S: AsRef<str>>(&mut self, email_address: S) -> &mut Self {
    self.instance.email_address = Some(email_address.as_ref().to_string());
    self
  }
  
  pub fn shipping_address(&mut self, shipping_address: Address) -> &mut Self {
    self.instance.shipping_address = Some(shipping_address);
    self
  }
  
}



/// This class is an abstract base class. Describes a block of an instant view web page. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlock: Object + RObject + Debug {}







impl PageBlock {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PageBlock>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PageBlock> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockType {
  PageBlockAnchor,
  PageBlockAnimation,
  PageBlockAudio,
  PageBlockAuthorDate,
  PageBlockBlockQuote,
  PageBlockChatLink,
  PageBlockCollage,
  PageBlockCover,
  PageBlockDetails,
  PageBlockDivider,
  PageBlockEmbedded,
  PageBlockEmbeddedPost,
  PageBlockFooter,
  PageBlockHeader,
  PageBlockKicker,
  PageBlockList,
  PageBlockMap,
  PageBlockParagraph,
  PageBlockPhoto,
  PageBlockPreformatted,
  PageBlockPullQuote,
  PageBlockRelatedArticles,
  PageBlockSlideshow,
  PageBlockSubheader,
  PageBlockSubtitle,
  PageBlockTable,
  PageBlockTitle,
  PageBlockVideo,
  
}
impl RTDPageBlockType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The title of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTitle
  /// Title.
  title: Option<Box<RichText>>,
  
}


impl Clone for PageBlockTitle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockTitle {}
impl RObject for PageBlockTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTitle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockTitle {}


impl PageBlockTitle {
  
  pub fn builder() -> RTDPageBlockTitleBuilder {
    let instance = Self {
      td_name: "pageBlockTitle".to_string(),
      title: None,
      
    };
    RTDPageBlockTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<Box<RichText>> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockTitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockTitleBuilder { instance: PageBlockTitle }

impl RTDPageBlockTitleBuilder {
  fn new(instance: PageBlockTitle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTitle { self.instance.clone() }
  
  pub fn title(&mut self, title: Box<RichText>) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}



/// The subtitle of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubtitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSubtitle
  /// Subtitle.
  subtitle: Option<Box<RichText>>,
  
}


impl Clone for PageBlockSubtitle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockSubtitle {}
impl RObject for PageBlockSubtitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSubtitle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSubtitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockSubtitle {}


impl PageBlockSubtitle {
  
  pub fn builder() -> RTDPageBlockSubtitleBuilder {
    let instance = Self {
      td_name: "pageBlockSubtitle".to_string(),
      subtitle: None,
      
    };
    RTDPageBlockSubtitleBuilder::new(instance)
  }
  
  
  pub fn subtitle(&self) -> Option<Box<RichText>> { self.subtitle.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockSubtitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockSubtitleBuilder { instance: PageBlockSubtitle }

impl RTDPageBlockSubtitleBuilder {
  fn new(instance: PageBlockSubtitle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSubtitle { self.instance.clone() }
  
  pub fn subtitle(&mut self, subtitle: Box<RichText>) -> &mut Self {
    self.instance.subtitle = Some(subtitle);
    self
  }
  
}



/// The author and publishing date of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockAuthorDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAuthorDate
  /// Author.
  author: Option<Box<RichText>>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,
  
}


impl Clone for PageBlockAuthorDate {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockAuthorDate {}
impl RObject for PageBlockAuthorDate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAuthorDate" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAuthorDate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockAuthorDate {}


impl PageBlockAuthorDate {
  
  pub fn builder() -> RTDPageBlockAuthorDateBuilder {
    let instance = Self {
      td_name: "pageBlockAuthorDate".to_string(),
      author: None,
      publish_date: None,
      
    };
    RTDPageBlockAuthorDateBuilder::new(instance)
  }
  
  
  pub fn author(&self) -> Option<Box<RichText>> { self.author.clone() }
  
  pub fn publish_date(&self) -> Option<i32> { self.publish_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockAuthorDate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockAuthorDateBuilder { instance: PageBlockAuthorDate }

impl RTDPageBlockAuthorDateBuilder {
  fn new(instance: PageBlockAuthorDate) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAuthorDate { self.instance.clone() }
  
  pub fn author(&mut self, author: Box<RichText>) -> &mut Self {
    self.instance.author = Some(author);
    self
  }
  
  pub fn publish_date(&mut self, publish_date: i32) -> &mut Self {
    self.instance.publish_date = Some(publish_date);
    self
  }
  
}



/// A header. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockHeader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHeader
  /// Header.
  header: Option<Box<RichText>>,
  
}


impl Clone for PageBlockHeader {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockHeader {}
impl RObject for PageBlockHeader {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHeader" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHeader }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockHeader {}


impl PageBlockHeader {
  
  pub fn builder() -> RTDPageBlockHeaderBuilder {
    let instance = Self {
      td_name: "pageBlockHeader".to_string(),
      header: None,
      
    };
    RTDPageBlockHeaderBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockHeader> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockHeaderBuilder { instance: PageBlockHeader }

impl RTDPageBlockHeaderBuilder {
  fn new(instance: PageBlockHeader) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHeader { self.instance.clone() }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
}



/// A subheader. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubheader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSubheader
  /// Subheader.
  subheader: Option<Box<RichText>>,
  
}


impl Clone for PageBlockSubheader {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockSubheader {}
impl RObject for PageBlockSubheader {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSubheader" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSubheader }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockSubheader {}


impl PageBlockSubheader {
  
  pub fn builder() -> RTDPageBlockSubheaderBuilder {
    let instance = Self {
      td_name: "pageBlockSubheader".to_string(),
      subheader: None,
      
    };
    RTDPageBlockSubheaderBuilder::new(instance)
  }
  
  
  pub fn subheader(&self) -> Option<Box<RichText>> { self.subheader.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockSubheader> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockSubheaderBuilder { instance: PageBlockSubheader }

impl RTDPageBlockSubheaderBuilder {
  fn new(instance: PageBlockSubheader) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSubheader { self.instance.clone() }
  
  pub fn subheader(&mut self, subheader: Box<RichText>) -> &mut Self {
    self.instance.subheader = Some(subheader);
    self
  }
  
}



/// A kicker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockKicker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockKicker
  /// Kicker.
  kicker: Option<Box<RichText>>,
  
}


impl Clone for PageBlockKicker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockKicker {}
impl RObject for PageBlockKicker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockKicker" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockKicker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockKicker {}


impl PageBlockKicker {
  
  pub fn builder() -> RTDPageBlockKickerBuilder {
    let instance = Self {
      td_name: "pageBlockKicker".to_string(),
      kicker: None,
      
    };
    RTDPageBlockKickerBuilder::new(instance)
  }
  
  
  pub fn kicker(&self) -> Option<Box<RichText>> { self.kicker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockKicker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockKickerBuilder { instance: PageBlockKicker }

impl RTDPageBlockKickerBuilder {
  fn new(instance: PageBlockKicker) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockKicker { self.instance.clone() }
  
  pub fn kicker(&mut self, kicker: Box<RichText>) -> &mut Self {
    self.instance.kicker = Some(kicker);
    self
  }
  
}



/// A text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockParagraph {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockParagraph
  /// Paragraph text.
  text: Option<Box<RichText>>,
  
}


impl Clone for PageBlockParagraph {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockParagraph {}
impl RObject for PageBlockParagraph {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockParagraph" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockParagraph }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockParagraph {}


impl PageBlockParagraph {
  
  pub fn builder() -> RTDPageBlockParagraphBuilder {
    let instance = Self {
      td_name: "pageBlockParagraph".to_string(),
      text: None,
      
    };
    RTDPageBlockParagraphBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockParagraph> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockParagraphBuilder { instance: PageBlockParagraph }

impl RTDPageBlockParagraphBuilder {
  fn new(instance: PageBlockParagraph) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockParagraph { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A preformatted text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPreformatted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPreformatted
  /// Paragraph text.
  text: Option<Box<RichText>>,
  /// Programming language for which the text should be formatted.
  language: Option<String>,
  
}


impl Clone for PageBlockPreformatted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockPreformatted {}
impl RObject for PageBlockPreformatted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPreformatted" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPreformatted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockPreformatted {}


impl PageBlockPreformatted {
  
  pub fn builder() -> RTDPageBlockPreformattedBuilder {
    let instance = Self {
      td_name: "pageBlockPreformatted".to_string(),
      text: None,
      language: None,
      
    };
    RTDPageBlockPreformattedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn language(&self) -> Option<String> { self.language.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockPreformatted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockPreformattedBuilder { instance: PageBlockPreformatted }

impl RTDPageBlockPreformattedBuilder {
  fn new(instance: PageBlockPreformatted) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPreformatted { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn language<S: AsRef<str>>(&mut self, language: S) -> &mut Self {
    self.instance.language = Some(language.as_ref().to_string());
    self
  }
  
}



/// The footer of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockFooter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockFooter
  /// Footer.
  footer: Option<Box<RichText>>,
  
}


impl Clone for PageBlockFooter {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockFooter {}
impl RObject for PageBlockFooter {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockFooter" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockFooter }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockFooter {}


impl PageBlockFooter {
  
  pub fn builder() -> RTDPageBlockFooterBuilder {
    let instance = Self {
      td_name: "pageBlockFooter".to_string(),
      footer: None,
      
    };
    RTDPageBlockFooterBuilder::new(instance)
  }
  
  
  pub fn footer(&self) -> Option<Box<RichText>> { self.footer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockFooter> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockFooterBuilder { instance: PageBlockFooter }

impl RTDPageBlockFooterBuilder {
  fn new(instance: PageBlockFooter) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockFooter { self.instance.clone() }
  
  pub fn footer(&mut self, footer: Box<RichText>) -> &mut Self {
    self.instance.footer = Some(footer);
    self
  }
  
}



/// An empty block separating a page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockDivider {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockDivider
  
}



impl Object for PageBlockDivider {}
impl RObject for PageBlockDivider {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockDivider" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockDivider }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockDivider {}


impl PageBlockDivider {
  
  pub fn builder() -> RTDPageBlockDividerBuilder {
    let instance = Self {
      td_name: "pageBlockDivider".to_string(),
      
    };
    RTDPageBlockDividerBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockDivider> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockDividerBuilder { instance: PageBlockDivider }

impl RTDPageBlockDividerBuilder {
  fn new(instance: PageBlockDivider) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockDivider { self.instance.clone() }
  
}



/// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAnchor
  /// Name of the anchor.
  name: Option<String>,
  
}



impl Object for PageBlockAnchor {}
impl RObject for PageBlockAnchor {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAnchor" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAnchor }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockAnchor {}


impl PageBlockAnchor {
  
  pub fn builder() -> RTDPageBlockAnchorBuilder {
    let instance = Self {
      td_name: "pageBlockAnchor".to_string(),
      name: None,
      
    };
    RTDPageBlockAnchorBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockAnchor> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockAnchorBuilder { instance: PageBlockAnchor }

impl RTDPageBlockAnchorBuilder {
  fn new(instance: PageBlockAnchor) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAnchor { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
}



/// A list of data blocks. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockList {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockList
  /// The items of the list.
  items: Option<Vec<PageBlockListItem>>,
  
}



impl Object for PageBlockList {}
impl RObject for PageBlockList {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockList" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockList }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockList {}


impl PageBlockList {
  
  pub fn builder() -> RTDPageBlockListBuilder {
    let instance = Self {
      td_name: "pageBlockList".to_string(),
      items: None,
      
    };
    RTDPageBlockListBuilder::new(instance)
  }
  
  
  pub fn items(&self) -> Option<Vec<PageBlockListItem>> { self.items.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockList> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockListBuilder { instance: PageBlockList }

impl RTDPageBlockListBuilder {
  fn new(instance: PageBlockList) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockList { self.instance.clone() }
  
  pub fn items(&mut self, items: Vec<PageBlockListItem>) -> &mut Self {
    self.instance.items = Some(items);
    self
  }
  
}



/// A block quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockBlockQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockBlockQuote
  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockBlockQuote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockBlockQuote {}
impl RObject for PageBlockBlockQuote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockBlockQuote" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockBlockQuote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockBlockQuote {}


impl PageBlockBlockQuote {
  
  pub fn builder() -> RTDPageBlockBlockQuoteBuilder {
    let instance = Self {
      td_name: "pageBlockBlockQuote".to_string(),
      text: None,
      credit: None,
      
    };
    RTDPageBlockBlockQuoteBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockBlockQuote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockBlockQuoteBuilder { instance: PageBlockBlockQuote }

impl RTDPageBlockBlockQuoteBuilder {
  fn new(instance: PageBlockBlockQuote) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockBlockQuote { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}



/// A pull quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPullQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPullQuote
  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockPullQuote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockPullQuote {}
impl RObject for PageBlockPullQuote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPullQuote" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPullQuote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockPullQuote {}


impl PageBlockPullQuote {
  
  pub fn builder() -> RTDPageBlockPullQuoteBuilder {
    let instance = Self {
      td_name: "pageBlockPullQuote".to_string(),
      text: None,
      credit: None,
      
    };
    RTDPageBlockPullQuoteBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockPullQuote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockPullQuoteBuilder { instance: PageBlockPullQuote }

impl RTDPageBlockPullQuoteBuilder {
  fn new(instance: PageBlockPullQuote) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPullQuote { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}



/// An animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAnimation
  /// Animation file; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<PageBlockCaption>,
  /// True, if the animation should be played automatically.
  need_autoplay: Option<bool>,
  
}



impl Object for PageBlockAnimation {}
impl RObject for PageBlockAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAnimation" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockAnimation {}


impl PageBlockAnimation {
  
  pub fn builder() -> RTDPageBlockAnimationBuilder {
    let instance = Self {
      td_name: "pageBlockAnimation".to_string(),
      animation: None,
      caption: None,
      need_autoplay: None,
      
    };
    RTDPageBlockAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn need_autoplay(&self) -> Option<bool> { self.need_autoplay.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockAnimationBuilder { instance: PageBlockAnimation }

impl RTDPageBlockAnimationBuilder {
  fn new(instance: PageBlockAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn need_autoplay(&mut self, need_autoplay: bool) -> &mut Self {
    self.instance.need_autoplay = Some(need_autoplay);
    self
  }
  
}



/// An audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAudio
  /// Audio file; may be null.
  audio: Option<Audio>,
  /// Audio file caption.
  caption: Option<PageBlockCaption>,
  
}



impl Object for PageBlockAudio {}
impl RObject for PageBlockAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAudio" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockAudio {}


impl PageBlockAudio {
  
  pub fn builder() -> RTDPageBlockAudioBuilder {
    let instance = Self {
      td_name: "pageBlockAudio".to_string(),
      audio: None,
      caption: None,
      
    };
    RTDPageBlockAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockAudioBuilder { instance: PageBlockAudio }

impl RTDPageBlockAudioBuilder {
  fn new(instance: PageBlockAudio) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAudio { self.instance.clone() }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPhoto
  /// Photo file; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<PageBlockCaption>,
  /// URL that needs to be opened when the photo is clicked.
  url: Option<String>,
  
}



impl Object for PageBlockPhoto {}
impl RObject for PageBlockPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPhoto" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockPhoto {}


impl PageBlockPhoto {
  
  pub fn builder() -> RTDPageBlockPhotoBuilder {
    let instance = Self {
      td_name: "pageBlockPhoto".to_string(),
      photo: None,
      caption: None,
      url: None,
      
    };
    RTDPageBlockPhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockPhotoBuilder { instance: PageBlockPhoto }

impl RTDPageBlockPhotoBuilder {
  fn new(instance: PageBlockPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// A video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVideo
  /// Video file; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<PageBlockCaption>,
  /// True, if the video should be played automatically.
  need_autoplay: Option<bool>,
  /// True, if the video should be looped.
  is_looped: Option<bool>,
  
}



impl Object for PageBlockVideo {}
impl RObject for PageBlockVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVideo" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockVideo {}


impl PageBlockVideo {
  
  pub fn builder() -> RTDPageBlockVideoBuilder {
    let instance = Self {
      td_name: "pageBlockVideo".to_string(),
      video: None,
      caption: None,
      need_autoplay: None,
      is_looped: None,
      
    };
    RTDPageBlockVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn need_autoplay(&self) -> Option<bool> { self.need_autoplay.clone() }
  
  pub fn is_looped(&self) -> Option<bool> { self.is_looped.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockVideoBuilder { instance: PageBlockVideo }

impl RTDPageBlockVideoBuilder {
  fn new(instance: PageBlockVideo) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVideo { self.instance.clone() }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn need_autoplay(&mut self, need_autoplay: bool) -> &mut Self {
    self.instance.need_autoplay = Some(need_autoplay);
    self
  }
  
  pub fn is_looped(&mut self, is_looped: bool) -> &mut Self {
    self.instance.is_looped = Some(is_looped);
    self
  }
  
}



/// A page cover. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCover {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCover
  /// Cover.
  cover: Option<Box<PageBlock>>,
  
}


impl Clone for PageBlockCover {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockCover {}
impl RObject for PageBlockCover {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCover" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCover }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockCover {}


impl PageBlockCover {
  
  pub fn builder() -> RTDPageBlockCoverBuilder {
    let instance = Self {
      td_name: "pageBlockCover".to_string(),
      cover: None,
      
    };
    RTDPageBlockCoverBuilder::new(instance)
  }
  
  
  pub fn cover(&self) -> Option<Box<PageBlock>> { self.cover.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockCover> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockCoverBuilder { instance: PageBlockCover }

impl RTDPageBlockCoverBuilder {
  fn new(instance: PageBlockCover) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCover { self.instance.clone() }
  
  pub fn cover(&mut self, cover: Box<PageBlock>) -> &mut Self {
    self.instance.cover = Some(cover);
    self
  }
  
}



/// An embedded web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockEmbedded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockEmbedded
  /// Web page URL, if available.
  url: Option<String>,
  /// HTML-markup of the embedded page.
  html: Option<String>,
  /// Poster photo, if available; may be null.
  poster_photo: Option<Photo>,
  /// Block width, 0 if unknown.
  width: Option<i32>,
  /// Block height, 0 if unknown.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  /// True, if the block should be full width.
  is_full_width: Option<bool>,
  /// True, if scrolling should be allowed.
  allow_scrolling: Option<bool>,
  
}



impl Object for PageBlockEmbedded {}
impl RObject for PageBlockEmbedded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockEmbedded" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockEmbedded }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockEmbedded {}


impl PageBlockEmbedded {
  
  pub fn builder() -> RTDPageBlockEmbeddedBuilder {
    let instance = Self {
      td_name: "pageBlockEmbedded".to_string(),
      url: None,
      html: None,
      poster_photo: None,
      width: None,
      height: None,
      caption: None,
      is_full_width: None,
      allow_scrolling: None,
      
    };
    RTDPageBlockEmbeddedBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn html(&self) -> Option<String> { self.html.clone() }
  
  pub fn poster_photo(&self) -> Option<Photo> { self.poster_photo.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn is_full_width(&self) -> Option<bool> { self.is_full_width.clone() }
  
  pub fn allow_scrolling(&self) -> Option<bool> { self.allow_scrolling.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockEmbedded> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockEmbeddedBuilder { instance: PageBlockEmbedded }

impl RTDPageBlockEmbeddedBuilder {
  fn new(instance: PageBlockEmbedded) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockEmbedded { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn html<S: AsRef<str>>(&mut self, html: S) -> &mut Self {
    self.instance.html = Some(html.as_ref().to_string());
    self
  }
  
  pub fn poster_photo(&mut self, poster_photo: Photo) -> &mut Self {
    self.instance.poster_photo = Some(poster_photo);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_full_width(&mut self, is_full_width: bool) -> &mut Self {
    self.instance.is_full_width = Some(is_full_width);
    self
  }
  
  pub fn allow_scrolling(&mut self, allow_scrolling: bool) -> &mut Self {
    self.instance.allow_scrolling = Some(allow_scrolling);
    self
  }
  
}



/// An embedded post. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockEmbeddedPost {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockEmbeddedPost
  /// Web page URL.
  url: Option<String>,
  /// Post author.
  author: Option<String>,
  /// Post author photo.
  author_photo: Option<Photo>,
  /// Point in time (Unix timestamp) when the post was created; 0 if unknown.
  date: Option<i32>,
  /// Post content.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Post caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockEmbeddedPost {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockEmbeddedPost {}
impl RObject for PageBlockEmbeddedPost {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockEmbeddedPost" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockEmbeddedPost }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockEmbeddedPost {}


impl PageBlockEmbeddedPost {
  
  pub fn builder() -> RTDPageBlockEmbeddedPostBuilder {
    let instance = Self {
      td_name: "pageBlockEmbeddedPost".to_string(),
      url: None,
      author: None,
      author_photo: None,
      date: None,
      page_blocks: None,
      caption: None,
      
    };
    RTDPageBlockEmbeddedPostBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn author_photo(&self) -> Option<Photo> { self.author_photo.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockEmbeddedPost> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockEmbeddedPostBuilder { instance: PageBlockEmbeddedPost }

impl RTDPageBlockEmbeddedPostBuilder {
  fn new(instance: PageBlockEmbeddedPost) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockEmbeddedPost { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn author<S: AsRef<str>>(&mut self, author: S) -> &mut Self {
    self.instance.author = Some(author.as_ref().to_string());
    self
  }
  
  pub fn author_photo(&mut self, author_photo: Photo) -> &mut Self {
    self.instance.author_photo = Some(author_photo);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A collage. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCollage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCollage
  /// Collage item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockCollage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockCollage {}
impl RObject for PageBlockCollage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCollage" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCollage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockCollage {}


impl PageBlockCollage {
  
  pub fn builder() -> RTDPageBlockCollageBuilder {
    let instance = Self {
      td_name: "pageBlockCollage".to_string(),
      page_blocks: None,
      caption: None,
      
    };
    RTDPageBlockCollageBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockCollage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockCollageBuilder { instance: PageBlockCollage }

impl RTDPageBlockCollageBuilder {
  fn new(instance: PageBlockCollage) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCollage { self.instance.clone() }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A slideshow. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSlideshow {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSlideshow
  /// Slideshow item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockSlideshow {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockSlideshow {}
impl RObject for PageBlockSlideshow {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSlideshow" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSlideshow }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockSlideshow {}


impl PageBlockSlideshow {
  
  pub fn builder() -> RTDPageBlockSlideshowBuilder {
    let instance = Self {
      td_name: "pageBlockSlideshow".to_string(),
      page_blocks: None,
      caption: None,
      
    };
    RTDPageBlockSlideshowBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockSlideshow> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockSlideshowBuilder { instance: PageBlockSlideshow }

impl RTDPageBlockSlideshowBuilder {
  fn new(instance: PageBlockSlideshow) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSlideshow { self.instance.clone() }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// A link to a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockChatLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockChatLink
  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Chat username, by which all other information about the chat should be resolved.
  username: Option<String>,
  
}



impl Object for PageBlockChatLink {}
impl RObject for PageBlockChatLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockChatLink" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockChatLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockChatLink {}


impl PageBlockChatLink {
  
  pub fn builder() -> RTDPageBlockChatLinkBuilder {
    let instance = Self {
      td_name: "pageBlockChatLink".to_string(),
      title: None,
      photo: None,
      username: None,
      
    };
    RTDPageBlockChatLinkBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockChatLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockChatLinkBuilder { instance: PageBlockChatLink }

impl RTDPageBlockChatLinkBuilder {
  fn new(instance: PageBlockChatLink) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockChatLink { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
}



/// A table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTable
  /// Table caption.
  caption: Option<Box<RichText>>,
  /// Table cells.
  cells: Option<Vec<Vec<PageBlockTableCell>>>,
  /// True, if the table is bordered.
  is_bordered: Option<bool>,
  /// True, if the table is striped.
  is_striped: Option<bool>,
  
}


impl Clone for PageBlockTable {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockTable {}
impl RObject for PageBlockTable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTable" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTable }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockTable {}


impl PageBlockTable {
  
  pub fn builder() -> RTDPageBlockTableBuilder {
    let instance = Self {
      td_name: "pageBlockTable".to_string(),
      caption: None,
      cells: None,
      is_bordered: None,
      is_striped: None,
      
    };
    RTDPageBlockTableBuilder::new(instance)
  }
  
  
  pub fn caption(&self) -> Option<Box<RichText>> { self.caption.clone() }
  
  pub fn cells(&self) -> Option<Vec<Vec<PageBlockTableCell>>> { self.cells.clone() }
  
  pub fn is_bordered(&self) -> Option<bool> { self.is_bordered.clone() }
  
  pub fn is_striped(&self) -> Option<bool> { self.is_striped.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockTable> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockTableBuilder { instance: PageBlockTable }

impl RTDPageBlockTableBuilder {
  fn new(instance: PageBlockTable) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTable { self.instance.clone() }
  
  pub fn caption(&mut self, caption: Box<RichText>) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn cells(&mut self, cells: Vec<Vec<PageBlockTableCell>>) -> &mut Self {
    self.instance.cells = Some(cells);
    self
  }
  
  pub fn is_bordered(&mut self, is_bordered: bool) -> &mut Self {
    self.instance.is_bordered = Some(is_bordered);
    self
  }
  
  pub fn is_striped(&mut self, is_striped: bool) -> &mut Self {
    self.instance.is_striped = Some(is_striped);
    self
  }
  
}



/// A collapsible block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockDetails
  /// Always visible heading for the block.
  header: Option<Box<RichText>>,
  /// Block contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// True, if the block is open by default.
  is_open: Option<bool>,
  
}


impl Clone for PageBlockDetails {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockDetails {}
impl RObject for PageBlockDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockDetails" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockDetails }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockDetails {}


impl PageBlockDetails {
  
  pub fn builder() -> RTDPageBlockDetailsBuilder {
    let instance = Self {
      td_name: "pageBlockDetails".to_string(),
      header: None,
      page_blocks: None,
      is_open: None,
      
    };
    RTDPageBlockDetailsBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn is_open(&self) -> Option<bool> { self.is_open.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockDetails> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockDetailsBuilder { instance: PageBlockDetails }

impl RTDPageBlockDetailsBuilder {
  fn new(instance: PageBlockDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockDetails { self.instance.clone() }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn is_open(&mut self, is_open: bool) -> &mut Self {
    self.instance.is_open = Some(is_open);
    self
  }
  
}



/// Related articles. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockRelatedArticles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockRelatedArticles
  /// Block header.
  header: Option<Box<RichText>>,
  /// List of related articles.
  articles: Option<Vec<PageBlockRelatedArticle>>,
  
}


impl Clone for PageBlockRelatedArticles {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockRelatedArticles {}
impl RObject for PageBlockRelatedArticles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockRelatedArticles" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockRelatedArticles }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockRelatedArticles {}


impl PageBlockRelatedArticles {
  
  pub fn builder() -> RTDPageBlockRelatedArticlesBuilder {
    let instance = Self {
      td_name: "pageBlockRelatedArticles".to_string(),
      header: None,
      articles: None,
      
    };
    RTDPageBlockRelatedArticlesBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn articles(&self) -> Option<Vec<PageBlockRelatedArticle>> { self.articles.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockRelatedArticles> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockRelatedArticlesBuilder { instance: PageBlockRelatedArticles }

impl RTDPageBlockRelatedArticlesBuilder {
  fn new(instance: PageBlockRelatedArticles) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockRelatedArticles { self.instance.clone() }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
  pub fn articles(&mut self, articles: Vec<PageBlockRelatedArticle>) -> &mut Self {
    self.instance.articles = Some(articles);
    self
  }
  
}



/// A map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockMap {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockMap
  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level.
  zoom: Option<i32>,
  /// Map width.
  width: Option<i32>,
  /// Map height.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}



impl Object for PageBlockMap {}
impl RObject for PageBlockMap {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockMap" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockMap }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlock for PageBlockMap {}


impl PageBlockMap {
  
  pub fn builder() -> RTDPageBlockMapBuilder {
    let instance = Self {
      td_name: "pageBlockMap".to_string(),
      location: None,
      zoom: None,
      width: None,
      height: None,
      caption: None,
      
    };
    RTDPageBlockMapBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn zoom(&self) -> Option<i32> { self.zoom.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockMap> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockMapBuilder { instance: PageBlockMap }

impl RTDPageBlockMapBuilder {
  fn new(instance: PageBlockMap) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockMap { self.instance.clone() }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn zoom(&mut self, zoom: i32) -> &mut Self {
    self.instance.zoom = Some(zoom);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// Contains a caption of an instant view web page block, consisting of a text and a trailing credit. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCaption
  /// Content of the caption.
  text: Option<Box<RichText>>,
  /// Block credit (like HTML tag <cite>).
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockCaption {}
impl RObject for PageBlockCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCaption" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCaption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PageBlockCaption {
  
  pub fn builder() -> RTDPageBlockCaptionBuilder {
    let instance = Self {
      td_name: "pageBlockCaption".to_string(),
      text: None,
      credit: None,
      
    };
    RTDPageBlockCaptionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockCaption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockCaptionBuilder { instance: PageBlockCaption }

impl RTDPageBlockCaptionBuilder {
  fn new(instance: PageBlockCaption) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCaption { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}



/// This class is an abstract base class. Describes a horizontal alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockHorizontalAlignment: Object + RObject + Debug {}







impl PageBlockHorizontalAlignment {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PageBlockHorizontalAlignment>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PageBlockHorizontalAlignment> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockHorizontalAlignmentType {
  PageBlockHorizontalAlignmentCenter,
  PageBlockHorizontalAlignmentLeft,
  PageBlockHorizontalAlignmentRight,
  
}
impl RTDPageBlockHorizontalAlignmentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The content should be left-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentLeft
  
}



impl Object for PageBlockHorizontalAlignmentLeft {}
impl RObject for PageBlockHorizontalAlignmentLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentLeft" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentLeft }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentLeft {}


impl PageBlockHorizontalAlignmentLeft {
  
  pub fn builder() -> RTDPageBlockHorizontalAlignmentLeftBuilder {
    let instance = Self {
      td_name: "pageBlockHorizontalAlignmentLeft".to_string(),
      
    };
    RTDPageBlockHorizontalAlignmentLeftBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockHorizontalAlignmentLeft> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockHorizontalAlignmentLeftBuilder { instance: PageBlockHorizontalAlignmentLeft }

impl RTDPageBlockHorizontalAlignmentLeftBuilder {
  fn new(instance: PageBlockHorizontalAlignmentLeft) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentLeft { self.instance.clone() }
  
}



/// The content should be center-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentCenter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentCenter
  
}



impl Object for PageBlockHorizontalAlignmentCenter {}
impl RObject for PageBlockHorizontalAlignmentCenter {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentCenter" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentCenter }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentCenter {}


impl PageBlockHorizontalAlignmentCenter {
  
  pub fn builder() -> RTDPageBlockHorizontalAlignmentCenterBuilder {
    let instance = Self {
      td_name: "pageBlockHorizontalAlignmentCenter".to_string(),
      
    };
    RTDPageBlockHorizontalAlignmentCenterBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockHorizontalAlignmentCenter> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockHorizontalAlignmentCenterBuilder { instance: PageBlockHorizontalAlignmentCenter }

impl RTDPageBlockHorizontalAlignmentCenterBuilder {
  fn new(instance: PageBlockHorizontalAlignmentCenter) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentCenter { self.instance.clone() }
  
}



/// The content should be right-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentRight {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentRight
  
}



impl Object for PageBlockHorizontalAlignmentRight {}
impl RObject for PageBlockHorizontalAlignmentRight {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentRight" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentRight }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentRight {}


impl PageBlockHorizontalAlignmentRight {
  
  pub fn builder() -> RTDPageBlockHorizontalAlignmentRightBuilder {
    let instance = Self {
      td_name: "pageBlockHorizontalAlignmentRight".to_string(),
      
    };
    RTDPageBlockHorizontalAlignmentRightBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockHorizontalAlignmentRight> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockHorizontalAlignmentRightBuilder { instance: PageBlockHorizontalAlignmentRight }

impl RTDPageBlockHorizontalAlignmentRightBuilder {
  fn new(instance: PageBlockHorizontalAlignmentRight) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentRight { self.instance.clone() }
  
}



/// Describes an item of a list page block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockListItem {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockListItem
  /// Item label.
  label: Option<String>,
  /// Item blocks.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  
}


impl Clone for PageBlockListItem {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockListItem {}
impl RObject for PageBlockListItem {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockListItem" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockListItem }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PageBlockListItem {
  
  pub fn builder() -> RTDPageBlockListItemBuilder {
    let instance = Self {
      td_name: "pageBlockListItem".to_string(),
      label: None,
      page_blocks: None,
      
    };
    RTDPageBlockListItemBuilder::new(instance)
  }
  
  
  pub fn label(&self) -> Option<String> { self.label.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockListItem> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockListItemBuilder { instance: PageBlockListItem }

impl RTDPageBlockListItemBuilder {
  fn new(instance: PageBlockListItem) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockListItem { self.instance.clone() }
  
  pub fn label<S: AsRef<str>>(&mut self, label: S) -> &mut Self {
    self.instance.label = Some(label.as_ref().to_string());
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
}



/// Contains information about a related article. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockRelatedArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockRelatedArticle
  /// Related article URL.
  url: Option<String>,
  /// Article title; may be empty.
  title: Option<String>,
  /// Article description; may be empty.
  description: Option<String>,
  /// Article photo; may be null.
  photo: Option<Photo>,
  /// Article author; may be empty.
  author: Option<String>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,
  
}



impl Object for PageBlockRelatedArticle {}
impl RObject for PageBlockRelatedArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockRelatedArticle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockRelatedArticle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PageBlockRelatedArticle {
  
  pub fn builder() -> RTDPageBlockRelatedArticleBuilder {
    let instance = Self {
      td_name: "pageBlockRelatedArticle".to_string(),
      url: None,
      title: None,
      description: None,
      photo: None,
      author: None,
      publish_date: None,
      
    };
    RTDPageBlockRelatedArticleBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn publish_date(&self) -> Option<i32> { self.publish_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockRelatedArticle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockRelatedArticleBuilder { instance: PageBlockRelatedArticle }

impl RTDPageBlockRelatedArticleBuilder {
  fn new(instance: PageBlockRelatedArticle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockRelatedArticle { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn author<S: AsRef<str>>(&mut self, author: S) -> &mut Self {
    self.instance.author = Some(author.as_ref().to_string());
    self
  }
  
  pub fn publish_date(&mut self, publish_date: i32) -> &mut Self {
    self.instance.publish_date = Some(publish_date);
    self
  }
  
}



/// Represents a cell of a table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTableCell {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTableCell
  /// Cell text.
  text: Option<Box<RichText>>,
  /// True, if it is a header cell.
  is_header: Option<bool>,
  /// The number of columns the cell should span.
  colspan: Option<i32>,
  /// The number of rows the cell should span.
  rowspan: Option<i32>,
  /// Horizontal cell content alignment.
  align: Option<Box<PageBlockHorizontalAlignment>>,
  /// Vertical cell content alignment.
  valign: Option<Box<PageBlockVerticalAlignment>>,
  
}


impl Clone for PageBlockTableCell {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PageBlockTableCell {}
impl RObject for PageBlockTableCell {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTableCell" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTableCell }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PageBlockTableCell {
  
  pub fn builder() -> RTDPageBlockTableCellBuilder {
    let instance = Self {
      td_name: "pageBlockTableCell".to_string(),
      text: None,
      is_header: None,
      colspan: None,
      rowspan: None,
      align: None,
      valign: None,
      
    };
    RTDPageBlockTableCellBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn is_header(&self) -> Option<bool> { self.is_header.clone() }
  
  pub fn colspan(&self) -> Option<i32> { self.colspan.clone() }
  
  pub fn rowspan(&self) -> Option<i32> { self.rowspan.clone() }
  
  pub fn align(&self) -> Option<Box<PageBlockHorizontalAlignment>> { self.align.clone() }
  
  pub fn valign(&self) -> Option<Box<PageBlockVerticalAlignment>> { self.valign.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockTableCell> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockTableCellBuilder { instance: PageBlockTableCell }

impl RTDPageBlockTableCellBuilder {
  fn new(instance: PageBlockTableCell) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTableCell { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn is_header(&mut self, is_header: bool) -> &mut Self {
    self.instance.is_header = Some(is_header);
    self
  }
  
  pub fn colspan(&mut self, colspan: i32) -> &mut Self {
    self.instance.colspan = Some(colspan);
    self
  }
  
  pub fn rowspan(&mut self, rowspan: i32) -> &mut Self {
    self.instance.rowspan = Some(rowspan);
    self
  }
  
  pub fn align(&mut self, align: Box<PageBlockHorizontalAlignment>) -> &mut Self {
    self.instance.align = Some(align);
    self
  }
  
  pub fn valign(&mut self, valign: Box<PageBlockVerticalAlignment>) -> &mut Self {
    self.instance.valign = Some(valign);
    self
  }
  
}



/// This class is an abstract base class. Describes a Vertical alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockVerticalAlignment: Object + RObject + Debug {}







impl PageBlockVerticalAlignment {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PageBlockVerticalAlignment>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PageBlockVerticalAlignment> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockVerticalAlignmentType {
  PageBlockVerticalAlignmentBottom,
  PageBlockVerticalAlignmentMiddle,
  PageBlockVerticalAlignmentTop,
  
}
impl RTDPageBlockVerticalAlignmentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The content should be top-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentTop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentTop
  
}



impl Object for PageBlockVerticalAlignmentTop {}
impl RObject for PageBlockVerticalAlignmentTop {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentTop" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentTop }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentTop {}


impl PageBlockVerticalAlignmentTop {
  
  pub fn builder() -> RTDPageBlockVerticalAlignmentTopBuilder {
    let instance = Self {
      td_name: "pageBlockVerticalAlignmentTop".to_string(),
      
    };
    RTDPageBlockVerticalAlignmentTopBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockVerticalAlignmentTop> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockVerticalAlignmentTopBuilder { instance: PageBlockVerticalAlignmentTop }

impl RTDPageBlockVerticalAlignmentTopBuilder {
  fn new(instance: PageBlockVerticalAlignmentTop) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentTop { self.instance.clone() }
  
}



/// The content should be middle-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentMiddle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentMiddle
  
}



impl Object for PageBlockVerticalAlignmentMiddle {}
impl RObject for PageBlockVerticalAlignmentMiddle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentMiddle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentMiddle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentMiddle {}


impl PageBlockVerticalAlignmentMiddle {
  
  pub fn builder() -> RTDPageBlockVerticalAlignmentMiddleBuilder {
    let instance = Self {
      td_name: "pageBlockVerticalAlignmentMiddle".to_string(),
      
    };
    RTDPageBlockVerticalAlignmentMiddleBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockVerticalAlignmentMiddle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockVerticalAlignmentMiddleBuilder { instance: PageBlockVerticalAlignmentMiddle }

impl RTDPageBlockVerticalAlignmentMiddleBuilder {
  fn new(instance: PageBlockVerticalAlignmentMiddle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentMiddle { self.instance.clone() }
  
}



/// The content should be bottom-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentBottom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentBottom
  
}



impl Object for PageBlockVerticalAlignmentBottom {}
impl RObject for PageBlockVerticalAlignmentBottom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentBottom" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentBottom }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentBottom {}


impl PageBlockVerticalAlignmentBottom {
  
  pub fn builder() -> RTDPageBlockVerticalAlignmentBottomBuilder {
    let instance = Self {
      td_name: "pageBlockVerticalAlignmentBottom".to_string(),
      
    };
    RTDPageBlockVerticalAlignmentBottomBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PageBlockVerticalAlignmentBottom> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPageBlockVerticalAlignmentBottomBuilder { instance: PageBlockVerticalAlignmentBottom }

impl RTDPageBlockVerticalAlignmentBottomBuilder {
  fn new(instance: PageBlockVerticalAlignmentBottom) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentBottom { self.instance.clone() }
  
}



/// Contains information about a Telegram Passport authorization form that was requested. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportAuthorizationForm
  /// Unique identifier of the authorization form.
  id: Option<i32>,
  /// Information about the Telegram Passport elements that need to be provided to complete the form.
  required_elements: Option<Vec<PassportRequiredElement>>,
  /// URL for the privacy policy of the service; may be empty.
  privacy_policy_url: Option<String>,
  
}



impl Object for PassportAuthorizationForm {}
impl RObject for PassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::PassportAuthorizationForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportAuthorizationForm {
  
  pub fn builder() -> RTDPassportAuthorizationFormBuilder {
    let instance = Self {
      td_name: "passportAuthorizationForm".to_string(),
      id: None,
      required_elements: None,
      privacy_policy_url: None,
      
    };
    RTDPassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn required_elements(&self) -> Option<Vec<PassportRequiredElement>> { self.required_elements.clone() }
  
  pub fn privacy_policy_url(&self) -> Option<String> { self.privacy_policy_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportAuthorizationForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportAuthorizationFormBuilder { instance: PassportAuthorizationForm }

impl RTDPassportAuthorizationFormBuilder {
  fn new(instance: PassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> PassportAuthorizationForm { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn required_elements(&mut self, required_elements: Vec<PassportRequiredElement>) -> &mut Self {
    self.instance.required_elements = Some(required_elements);
    self
  }
  
  pub fn privacy_policy_url<S: AsRef<str>>(&mut self, privacy_policy_url: S) -> &mut Self {
    self.instance.privacy_policy_url = Some(privacy_policy_url.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Contains information about a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElement: Object + RObject + Debug {}







impl PassportElement {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PassportElement>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PassportElement> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementType {
  PassportElementAddress,
  PassportElementBankStatement,
  PassportElementDriverLicense,
  PassportElementEmailAddress,
  PassportElementIdentityCard,
  PassportElementInternalPassport,
  PassportElementPassport,
  PassportElementPassportRegistration,
  PassportElementPersonalDetails,
  PassportElementPhoneNumber,
  PassportElementRentalAgreement,
  PassportElementTemporaryRegistration,
  PassportElementUtilityBill,
  
}
impl RTDPassportElementType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPersonalDetails
  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,
  
}



impl Object for PassportElementPersonalDetails {}
impl RObject for PassportElementPersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPersonalDetails }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementPersonalDetails {}


impl PassportElementPersonalDetails {
  
  pub fn builder() -> RTDPassportElementPersonalDetailsBuilder {
    let instance = Self {
      td_name: "passportElementPersonalDetails".to_string(),
      personal_details: None,
      
    };
    RTDPassportElementPersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn personal_details(&self) -> Option<PersonalDetails> { self.personal_details.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementPersonalDetails> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementPersonalDetailsBuilder { instance: PassportElementPersonalDetails }

impl RTDPassportElementPersonalDetailsBuilder {
  fn new(instance: PassportElementPersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPersonalDetails { self.instance.clone() }
  
  pub fn personal_details(&mut self, personal_details: PersonalDetails) -> &mut Self {
    self.instance.personal_details = Some(personal_details);
    self
  }
  
}



/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPassport
  /// Passport.
  passport: Option<IdentityDocument>,
  
}



impl Object for PassportElementPassport {}
impl RObject for PassportElementPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementPassport {}


impl PassportElementPassport {
  
  pub fn builder() -> RTDPassportElementPassportBuilder {
    let instance = Self {
      td_name: "passportElementPassport".to_string(),
      passport: None,
      
    };
    RTDPassportElementPassportBuilder::new(instance)
  }
  
  
  pub fn passport(&self) -> Option<IdentityDocument> { self.passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementPassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementPassportBuilder { instance: PassportElementPassport }

impl RTDPassportElementPassportBuilder {
  fn new(instance: PassportElementPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPassport { self.instance.clone() }
  
  pub fn passport(&mut self, passport: IdentityDocument) -> &mut Self {
    self.instance.passport = Some(passport);
    self
  }
  
}



/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementDriverLicense
  /// Driver license.
  driver_license: Option<IdentityDocument>,
  
}



impl Object for PassportElementDriverLicense {}
impl RObject for PassportElementDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementDriverLicense }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementDriverLicense {}


impl PassportElementDriverLicense {
  
  pub fn builder() -> RTDPassportElementDriverLicenseBuilder {
    let instance = Self {
      td_name: "passportElementDriverLicense".to_string(),
      driver_license: None,
      
    };
    RTDPassportElementDriverLicenseBuilder::new(instance)
  }
  
  
  pub fn driver_license(&self) -> Option<IdentityDocument> { self.driver_license.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementDriverLicense> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementDriverLicenseBuilder { instance: PassportElementDriverLicense }

impl RTDPassportElementDriverLicenseBuilder {
  fn new(instance: PassportElementDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementDriverLicense { self.instance.clone() }
  
  pub fn driver_license(&mut self, driver_license: IdentityDocument) -> &mut Self {
    self.instance.driver_license = Some(driver_license);
    self
  }
  
}



/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementIdentityCard
  /// Identity card.
  identity_card: Option<IdentityDocument>,
  
}



impl Object for PassportElementIdentityCard {}
impl RObject for PassportElementIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementIdentityCard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementIdentityCard {}


impl PassportElementIdentityCard {
  
  pub fn builder() -> RTDPassportElementIdentityCardBuilder {
    let instance = Self {
      td_name: "passportElementIdentityCard".to_string(),
      identity_card: None,
      
    };
    RTDPassportElementIdentityCardBuilder::new(instance)
  }
  
  
  pub fn identity_card(&self) -> Option<IdentityDocument> { self.identity_card.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementIdentityCard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementIdentityCardBuilder { instance: PassportElementIdentityCard }

impl RTDPassportElementIdentityCardBuilder {
  fn new(instance: PassportElementIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementIdentityCard { self.instance.clone() }
  
  pub fn identity_card(&mut self, identity_card: IdentityDocument) -> &mut Self {
    self.instance.identity_card = Some(identity_card);
    self
  }
  
}



/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementInternalPassport
  /// Internal passport.
  internal_passport: Option<IdentityDocument>,
  
}



impl Object for PassportElementInternalPassport {}
impl RObject for PassportElementInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementInternalPassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementInternalPassport {}


impl PassportElementInternalPassport {
  
  pub fn builder() -> RTDPassportElementInternalPassportBuilder {
    let instance = Self {
      td_name: "passportElementInternalPassport".to_string(),
      internal_passport: None,
      
    };
    RTDPassportElementInternalPassportBuilder::new(instance)
  }
  
  
  pub fn internal_passport(&self) -> Option<IdentityDocument> { self.internal_passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementInternalPassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementInternalPassportBuilder { instance: PassportElementInternalPassport }

impl RTDPassportElementInternalPassportBuilder {
  fn new(instance: PassportElementInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementInternalPassport { self.instance.clone() }
  
  pub fn internal_passport(&mut self, internal_passport: IdentityDocument) -> &mut Self {
    self.instance.internal_passport = Some(internal_passport);
    self
  }
  
}



/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementAddress
  /// Address.
  address: Option<Address>,
  
}



impl Object for PassportElementAddress {}
impl RObject for PassportElementAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementAddress {}


impl PassportElementAddress {
  
  pub fn builder() -> RTDPassportElementAddressBuilder {
    let instance = Self {
      td_name: "passportElementAddress".to_string(),
      address: None,
      
    };
    RTDPassportElementAddressBuilder::new(instance)
  }
  
  
  pub fn address(&self) -> Option<Address> { self.address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementAddressBuilder { instance: PassportElementAddress }

impl RTDPassportElementAddressBuilder {
  fn new(instance: PassportElementAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementAddress { self.instance.clone() }
  
  pub fn address(&mut self, address: Address) -> &mut Self {
    self.instance.address = Some(address);
    self
  }
  
}



/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementUtilityBill
  /// Utility bill.
  utility_bill: Option<PersonalDocument>,
  
}



impl Object for PassportElementUtilityBill {}
impl RObject for PassportElementUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementUtilityBill }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementUtilityBill {}


impl PassportElementUtilityBill {
  
  pub fn builder() -> RTDPassportElementUtilityBillBuilder {
    let instance = Self {
      td_name: "passportElementUtilityBill".to_string(),
      utility_bill: None,
      
    };
    RTDPassportElementUtilityBillBuilder::new(instance)
  }
  
  
  pub fn utility_bill(&self) -> Option<PersonalDocument> { self.utility_bill.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementUtilityBill> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementUtilityBillBuilder { instance: PassportElementUtilityBill }

impl RTDPassportElementUtilityBillBuilder {
  fn new(instance: PassportElementUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementUtilityBill { self.instance.clone() }
  
  pub fn utility_bill(&mut self, utility_bill: PersonalDocument) -> &mut Self {
    self.instance.utility_bill = Some(utility_bill);
    self
  }
  
}



/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementBankStatement
  /// Bank statement.
  bank_statement: Option<PersonalDocument>,
  
}



impl Object for PassportElementBankStatement {}
impl RObject for PassportElementBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementBankStatement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementBankStatement {}


impl PassportElementBankStatement {
  
  pub fn builder() -> RTDPassportElementBankStatementBuilder {
    let instance = Self {
      td_name: "passportElementBankStatement".to_string(),
      bank_statement: None,
      
    };
    RTDPassportElementBankStatementBuilder::new(instance)
  }
  
  
  pub fn bank_statement(&self) -> Option<PersonalDocument> { self.bank_statement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementBankStatement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementBankStatementBuilder { instance: PassportElementBankStatement }

impl RTDPassportElementBankStatementBuilder {
  fn new(instance: PassportElementBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementBankStatement { self.instance.clone() }
  
  pub fn bank_statement(&mut self, bank_statement: PersonalDocument) -> &mut Self {
    self.instance.bank_statement = Some(bank_statement);
    self
  }
  
}



/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementRentalAgreement
  /// Rental agreement.
  rental_agreement: Option<PersonalDocument>,
  
}



impl Object for PassportElementRentalAgreement {}
impl RObject for PassportElementRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementRentalAgreement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementRentalAgreement {}


impl PassportElementRentalAgreement {
  
  pub fn builder() -> RTDPassportElementRentalAgreementBuilder {
    let instance = Self {
      td_name: "passportElementRentalAgreement".to_string(),
      rental_agreement: None,
      
    };
    RTDPassportElementRentalAgreementBuilder::new(instance)
  }
  
  
  pub fn rental_agreement(&self) -> Option<PersonalDocument> { self.rental_agreement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementRentalAgreement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementRentalAgreementBuilder { instance: PassportElementRentalAgreement }

impl RTDPassportElementRentalAgreementBuilder {
  fn new(instance: PassportElementRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementRentalAgreement { self.instance.clone() }
  
  pub fn rental_agreement(&mut self, rental_agreement: PersonalDocument) -> &mut Self {
    self.instance.rental_agreement = Some(rental_agreement);
    self
  }
  
}



/// A Telegram Passport element containing the user's passport registration pages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPassportRegistration
  /// Passport registration pages.
  passport_registration: Option<PersonalDocument>,
  
}



impl Object for PassportElementPassportRegistration {}
impl RObject for PassportElementPassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPassportRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementPassportRegistration {}


impl PassportElementPassportRegistration {
  
  pub fn builder() -> RTDPassportElementPassportRegistrationBuilder {
    let instance = Self {
      td_name: "passportElementPassportRegistration".to_string(),
      passport_registration: None,
      
    };
    RTDPassportElementPassportRegistrationBuilder::new(instance)
  }
  
  
  pub fn passport_registration(&self) -> Option<PersonalDocument> { self.passport_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementPassportRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementPassportRegistrationBuilder { instance: PassportElementPassportRegistration }

impl RTDPassportElementPassportRegistrationBuilder {
  fn new(instance: PassportElementPassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPassportRegistration { self.instance.clone() }
  
  pub fn passport_registration(&mut self, passport_registration: PersonalDocument) -> &mut Self {
    self.instance.passport_registration = Some(passport_registration);
    self
  }
  
}



/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTemporaryRegistration
  /// Temporary registration.
  temporary_registration: Option<PersonalDocument>,
  
}



impl Object for PassportElementTemporaryRegistration {}
impl RObject for PassportElementTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTemporaryRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementTemporaryRegistration {}


impl PassportElementTemporaryRegistration {
  
  pub fn builder() -> RTDPassportElementTemporaryRegistrationBuilder {
    let instance = Self {
      td_name: "passportElementTemporaryRegistration".to_string(),
      temporary_registration: None,
      
    };
    RTDPassportElementTemporaryRegistrationBuilder::new(instance)
  }
  
  
  pub fn temporary_registration(&self) -> Option<PersonalDocument> { self.temporary_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTemporaryRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTemporaryRegistrationBuilder { instance: PassportElementTemporaryRegistration }

impl RTDPassportElementTemporaryRegistrationBuilder {
  fn new(instance: PassportElementTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTemporaryRegistration { self.instance.clone() }
  
  pub fn temporary_registration(&mut self, temporary_registration: PersonalDocument) -> &mut Self {
    self.instance.temporary_registration = Some(temporary_registration);
    self
  }
  
}



/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPhoneNumber
  /// Phone number.
  phone_number: Option<String>,
  
}



impl Object for PassportElementPhoneNumber {}
impl RObject for PassportElementPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementPhoneNumber {}


impl PassportElementPhoneNumber {
  
  pub fn builder() -> RTDPassportElementPhoneNumberBuilder {
    let instance = Self {
      td_name: "passportElementPhoneNumber".to_string(),
      phone_number: None,
      
    };
    RTDPassportElementPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementPhoneNumberBuilder { instance: PassportElementPhoneNumber }

impl RTDPassportElementPhoneNumberBuilder {
  fn new(instance: PassportElementPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPhoneNumber { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
}



/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementEmailAddress
  /// Email address.
  email_address: Option<String>,
  
}



impl Object for PassportElementEmailAddress {}
impl RObject for PassportElementEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElement for PassportElementEmailAddress {}


impl PassportElementEmailAddress {
  
  pub fn builder() -> RTDPassportElementEmailAddressBuilder {
    let instance = Self {
      td_name: "passportElementEmailAddress".to_string(),
      email_address: None,
      
    };
    RTDPassportElementEmailAddressBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementEmailAddressBuilder { instance: PassportElementEmailAddress }

impl RTDPassportElementEmailAddressBuilder {
  fn new(instance: PassportElementEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementEmailAddress { self.instance.clone() }
  
  pub fn email_address<S: AsRef<str>>(&mut self, email_address: S) -> &mut Self {
    self.instance.email_address = Some(email_address.as_ref().to_string());
    self
  }
  
}



/// Contains the description of an error in a Telegram Passport element. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementError
  /// Type of the Telegram Passport element which has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<PassportElementErrorSource>>,
  
}


impl Clone for PassportElementError {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PassportElementError {}
impl RObject for PassportElementError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementError" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementError }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportElementError {
  
  pub fn builder() -> RTDPassportElementErrorBuilder {
    let instance = Self {
      td_name: "passportElementError".to_string(),
      type_: None,
      message: None,
      source: None,
      
    };
    RTDPassportElementErrorBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn source(&self) -> Option<Box<PassportElementErrorSource>> { self.source.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementError> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorBuilder { instance: PassportElementError }

impl RTDPassportElementErrorBuilder {
  fn new(instance: PassportElementError) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementError { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn message<S: AsRef<str>>(&mut self, message: S) -> &mut Self {
    self.instance.message = Some(message.as_ref().to_string());
    self
  }
  
  pub fn source(&mut self, source: Box<PassportElementErrorSource>) -> &mut Self {
    self.instance.source = Some(source);
    self
  }
  
}



/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementErrorSource: Object + RObject + Debug {}







impl PassportElementErrorSource {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PassportElementErrorSource>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PassportElementErrorSource> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementErrorSourceType {
  PassportElementErrorSourceDataField,
  PassportElementErrorSourceFile,
  PassportElementErrorSourceFiles,
  PassportElementErrorSourceFrontSide,
  PassportElementErrorSourceReverseSide,
  PassportElementErrorSourceSelfie,
  PassportElementErrorSourceTranslationFile,
  PassportElementErrorSourceTranslationFiles,
  PassportElementErrorSourceUnspecified,
  
}
impl RTDPassportElementErrorSourceType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceUnspecified
  
}



impl Object for PassportElementErrorSourceUnspecified {}
impl RObject for PassportElementErrorSourceUnspecified {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceUnspecified" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceUnspecified }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceUnspecified {}


impl PassportElementErrorSourceUnspecified {
  
  pub fn builder() -> RTDPassportElementErrorSourceUnspecifiedBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceUnspecified".to_string(),
      
    };
    RTDPassportElementErrorSourceUnspecifiedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceUnspecified> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceUnspecifiedBuilder { instance: PassportElementErrorSourceUnspecified }

impl RTDPassportElementErrorSourceUnspecifiedBuilder {
  fn new(instance: PassportElementErrorSourceUnspecified) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceUnspecified { self.instance.clone() }
  
}



/// One of the data fields contains an error. The error will be considered resolved when the value of the field changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceDataField
  /// Field name.
  field_name: Option<String>,
  
}



impl Object for PassportElementErrorSourceDataField {}
impl RObject for PassportElementErrorSourceDataField {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceDataField" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceDataField }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceDataField {}


impl PassportElementErrorSourceDataField {
  
  pub fn builder() -> RTDPassportElementErrorSourceDataFieldBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceDataField".to_string(),
      field_name: None,
      
    };
    RTDPassportElementErrorSourceDataFieldBuilder::new(instance)
  }
  
  
  pub fn field_name(&self) -> Option<String> { self.field_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceDataField> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceDataFieldBuilder { instance: PassportElementErrorSourceDataField }

impl RTDPassportElementErrorSourceDataFieldBuilder {
  fn new(instance: PassportElementErrorSourceDataField) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceDataField { self.instance.clone() }
  
  pub fn field_name<S: AsRef<str>>(&mut self, field_name: S) -> &mut Self {
    self.instance.field_name = Some(field_name.as_ref().to_string());
    self
  }
  
}



/// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFrontSide
  
}



impl Object for PassportElementErrorSourceFrontSide {}
impl RObject for PassportElementErrorSourceFrontSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFrontSide" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFrontSide }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFrontSide {}


impl PassportElementErrorSourceFrontSide {
  
  pub fn builder() -> RTDPassportElementErrorSourceFrontSideBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceFrontSide".to_string(),
      
    };
    RTDPassportElementErrorSourceFrontSideBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceFrontSide> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceFrontSideBuilder { instance: PassportElementErrorSourceFrontSide }

impl RTDPassportElementErrorSourceFrontSideBuilder {
  fn new(instance: PassportElementErrorSourceFrontSide) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFrontSide { self.instance.clone() }
  
}



/// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceReverseSide
  
}



impl Object for PassportElementErrorSourceReverseSide {}
impl RObject for PassportElementErrorSourceReverseSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceReverseSide" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceReverseSide }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceReverseSide {}


impl PassportElementErrorSourceReverseSide {
  
  pub fn builder() -> RTDPassportElementErrorSourceReverseSideBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceReverseSide".to_string(),
      
    };
    RTDPassportElementErrorSourceReverseSideBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceReverseSide> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceReverseSideBuilder { instance: PassportElementErrorSourceReverseSide }

impl RTDPassportElementErrorSourceReverseSideBuilder {
  fn new(instance: PassportElementErrorSourceReverseSide) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceReverseSide { self.instance.clone() }
  
}



/// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceSelfie
  
}



impl Object for PassportElementErrorSourceSelfie {}
impl RObject for PassportElementErrorSourceSelfie {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceSelfie" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceSelfie }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceSelfie {}


impl PassportElementErrorSourceSelfie {
  
  pub fn builder() -> RTDPassportElementErrorSourceSelfieBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceSelfie".to_string(),
      
    };
    RTDPassportElementErrorSourceSelfieBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceSelfie> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceSelfieBuilder { instance: PassportElementErrorSourceSelfie }

impl RTDPassportElementErrorSourceSelfieBuilder {
  fn new(instance: PassportElementErrorSourceSelfie) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceSelfie { self.instance.clone() }
  
}



/// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceTranslationFile
  /// Index of a file with the error.
  file_index: Option<i32>,
  
}



impl Object for PassportElementErrorSourceTranslationFile {}
impl RObject for PassportElementErrorSourceTranslationFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceTranslationFile" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceTranslationFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceTranslationFile {}


impl PassportElementErrorSourceTranslationFile {
  
  pub fn builder() -> RTDPassportElementErrorSourceTranslationFileBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceTranslationFile".to_string(),
      file_index: None,
      
    };
    RTDPassportElementErrorSourceTranslationFileBuilder::new(instance)
  }
  
  
  pub fn file_index(&self) -> Option<i32> { self.file_index.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceTranslationFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceTranslationFileBuilder { instance: PassportElementErrorSourceTranslationFile }

impl RTDPassportElementErrorSourceTranslationFileBuilder {
  fn new(instance: PassportElementErrorSourceTranslationFile) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceTranslationFile { self.instance.clone() }
  
  pub fn file_index(&mut self, file_index: i32) -> &mut Self {
    self.instance.file_index = Some(file_index);
    self
  }
  
}



/// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceTranslationFiles
  
}



impl Object for PassportElementErrorSourceTranslationFiles {}
impl RObject for PassportElementErrorSourceTranslationFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceTranslationFiles" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceTranslationFiles }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceTranslationFiles {}


impl PassportElementErrorSourceTranslationFiles {
  
  pub fn builder() -> RTDPassportElementErrorSourceTranslationFilesBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceTranslationFiles".to_string(),
      
    };
    RTDPassportElementErrorSourceTranslationFilesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceTranslationFiles> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceTranslationFilesBuilder { instance: PassportElementErrorSourceTranslationFiles }

impl RTDPassportElementErrorSourceTranslationFilesBuilder {
  fn new(instance: PassportElementErrorSourceTranslationFiles) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceTranslationFiles { self.instance.clone() }
  
}



/// The file contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFile
  /// Index of a file with the error.
  file_index: Option<i32>,
  
}



impl Object for PassportElementErrorSourceFile {}
impl RObject for PassportElementErrorSourceFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFile" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFile {}


impl PassportElementErrorSourceFile {
  
  pub fn builder() -> RTDPassportElementErrorSourceFileBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceFile".to_string(),
      file_index: None,
      
    };
    RTDPassportElementErrorSourceFileBuilder::new(instance)
  }
  
  
  pub fn file_index(&self) -> Option<i32> { self.file_index.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceFileBuilder { instance: PassportElementErrorSourceFile }

impl RTDPassportElementErrorSourceFileBuilder {
  fn new(instance: PassportElementErrorSourceFile) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFile { self.instance.clone() }
  
  pub fn file_index(&mut self, file_index: i32) -> &mut Self {
    self.instance.file_index = Some(file_index);
    self
  }
  
}



/// The list of attached files contains an error. The error will be considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFiles
  
}



impl Object for PassportElementErrorSourceFiles {}
impl RObject for PassportElementErrorSourceFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFiles" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFiles }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFiles {}


impl PassportElementErrorSourceFiles {
  
  pub fn builder() -> RTDPassportElementErrorSourceFilesBuilder {
    let instance = Self {
      td_name: "passportElementErrorSourceFiles".to_string(),
      
    };
    RTDPassportElementErrorSourceFilesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementErrorSourceFiles> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementErrorSourceFilesBuilder { instance: PassportElementErrorSourceFiles }

impl RTDPassportElementErrorSourceFilesBuilder {
  fn new(instance: PassportElementErrorSourceFiles) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFiles { self.instance.clone() }
  
}



/// This class is an abstract base class. Contains the type of a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementType: Object + RObject + Debug {}







impl PassportElementType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PassportElementType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PassportElementType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementTypeType {
  PassportElementTypeAddress,
  PassportElementTypeBankStatement,
  PassportElementTypeDriverLicense,
  PassportElementTypeEmailAddress,
  PassportElementTypeIdentityCard,
  PassportElementTypeInternalPassport,
  PassportElementTypePassport,
  PassportElementTypePassportRegistration,
  PassportElementTypePersonalDetails,
  PassportElementTypePhoneNumber,
  PassportElementTypeRentalAgreement,
  PassportElementTypeTemporaryRegistration,
  PassportElementTypeUtilityBill,
  
}
impl RTDPassportElementTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePersonalDetails
  
}



impl Object for PassportElementTypePersonalDetails {}
impl RObject for PassportElementTypePersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePersonalDetails }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePersonalDetails {}


impl PassportElementTypePersonalDetails {
  
  pub fn builder() -> RTDPassportElementTypePersonalDetailsBuilder {
    let instance = Self {
      td_name: "passportElementTypePersonalDetails".to_string(),
      
    };
    RTDPassportElementTypePersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypePersonalDetails> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypePersonalDetailsBuilder { instance: PassportElementTypePersonalDetails }

impl RTDPassportElementTypePersonalDetailsBuilder {
  fn new(instance: PassportElementTypePersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePersonalDetails { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePassport
  
}



impl Object for PassportElementTypePassport {}
impl RObject for PassportElementTypePassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePassport {}


impl PassportElementTypePassport {
  
  pub fn builder() -> RTDPassportElementTypePassportBuilder {
    let instance = Self {
      td_name: "passportElementTypePassport".to_string(),
      
    };
    RTDPassportElementTypePassportBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypePassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypePassportBuilder { instance: PassportElementTypePassport }

impl RTDPassportElementTypePassportBuilder {
  fn new(instance: PassportElementTypePassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePassport { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeDriverLicense
  
}



impl Object for PassportElementTypeDriverLicense {}
impl RObject for PassportElementTypeDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeDriverLicense }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeDriverLicense {}


impl PassportElementTypeDriverLicense {
  
  pub fn builder() -> RTDPassportElementTypeDriverLicenseBuilder {
    let instance = Self {
      td_name: "passportElementTypeDriverLicense".to_string(),
      
    };
    RTDPassportElementTypeDriverLicenseBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeDriverLicense> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeDriverLicenseBuilder { instance: PassportElementTypeDriverLicense }

impl RTDPassportElementTypeDriverLicenseBuilder {
  fn new(instance: PassportElementTypeDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeDriverLicense { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeIdentityCard
  
}



impl Object for PassportElementTypeIdentityCard {}
impl RObject for PassportElementTypeIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeIdentityCard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeIdentityCard {}


impl PassportElementTypeIdentityCard {
  
  pub fn builder() -> RTDPassportElementTypeIdentityCardBuilder {
    let instance = Self {
      td_name: "passportElementTypeIdentityCard".to_string(),
      
    };
    RTDPassportElementTypeIdentityCardBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeIdentityCard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeIdentityCardBuilder { instance: PassportElementTypeIdentityCard }

impl RTDPassportElementTypeIdentityCardBuilder {
  fn new(instance: PassportElementTypeIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeIdentityCard { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeInternalPassport
  
}



impl Object for PassportElementTypeInternalPassport {}
impl RObject for PassportElementTypeInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeInternalPassport }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeInternalPassport {}


impl PassportElementTypeInternalPassport {
  
  pub fn builder() -> RTDPassportElementTypeInternalPassportBuilder {
    let instance = Self {
      td_name: "passportElementTypeInternalPassport".to_string(),
      
    };
    RTDPassportElementTypeInternalPassportBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeInternalPassport> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeInternalPassportBuilder { instance: PassportElementTypeInternalPassport }

impl RTDPassportElementTypeInternalPassportBuilder {
  fn new(instance: PassportElementTypeInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeInternalPassport { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeAddress
  
}



impl Object for PassportElementTypeAddress {}
impl RObject for PassportElementTypeAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeAddress {}


impl PassportElementTypeAddress {
  
  pub fn builder() -> RTDPassportElementTypeAddressBuilder {
    let instance = Self {
      td_name: "passportElementTypeAddress".to_string(),
      
    };
    RTDPassportElementTypeAddressBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeAddressBuilder { instance: PassportElementTypeAddress }

impl RTDPassportElementTypeAddressBuilder {
  fn new(instance: PassportElementTypeAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeAddress { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeUtilityBill
  
}



impl Object for PassportElementTypeUtilityBill {}
impl RObject for PassportElementTypeUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeUtilityBill }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeUtilityBill {}


impl PassportElementTypeUtilityBill {
  
  pub fn builder() -> RTDPassportElementTypeUtilityBillBuilder {
    let instance = Self {
      td_name: "passportElementTypeUtilityBill".to_string(),
      
    };
    RTDPassportElementTypeUtilityBillBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeUtilityBill> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeUtilityBillBuilder { instance: PassportElementTypeUtilityBill }

impl RTDPassportElementTypeUtilityBillBuilder {
  fn new(instance: PassportElementTypeUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeUtilityBill { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeBankStatement
  
}



impl Object for PassportElementTypeBankStatement {}
impl RObject for PassportElementTypeBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeBankStatement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeBankStatement {}


impl PassportElementTypeBankStatement {
  
  pub fn builder() -> RTDPassportElementTypeBankStatementBuilder {
    let instance = Self {
      td_name: "passportElementTypeBankStatement".to_string(),
      
    };
    RTDPassportElementTypeBankStatementBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeBankStatement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeBankStatementBuilder { instance: PassportElementTypeBankStatement }

impl RTDPassportElementTypeBankStatementBuilder {
  fn new(instance: PassportElementTypeBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeBankStatement { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeRentalAgreement
  
}



impl Object for PassportElementTypeRentalAgreement {}
impl RObject for PassportElementTypeRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeRentalAgreement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeRentalAgreement {}


impl PassportElementTypeRentalAgreement {
  
  pub fn builder() -> RTDPassportElementTypeRentalAgreementBuilder {
    let instance = Self {
      td_name: "passportElementTypeRentalAgreement".to_string(),
      
    };
    RTDPassportElementTypeRentalAgreementBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeRentalAgreement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeRentalAgreementBuilder { instance: PassportElementTypeRentalAgreement }

impl RTDPassportElementTypeRentalAgreementBuilder {
  fn new(instance: PassportElementTypeRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeRentalAgreement { self.instance.clone() }
  
}



/// A Telegram Passport element containing the registration page of the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePassportRegistration
  
}



impl Object for PassportElementTypePassportRegistration {}
impl RObject for PassportElementTypePassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePassportRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePassportRegistration {}


impl PassportElementTypePassportRegistration {
  
  pub fn builder() -> RTDPassportElementTypePassportRegistrationBuilder {
    let instance = Self {
      td_name: "passportElementTypePassportRegistration".to_string(),
      
    };
    RTDPassportElementTypePassportRegistrationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypePassportRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypePassportRegistrationBuilder { instance: PassportElementTypePassportRegistration }

impl RTDPassportElementTypePassportRegistrationBuilder {
  fn new(instance: PassportElementTypePassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePassportRegistration { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeTemporaryRegistration
  
}



impl Object for PassportElementTypeTemporaryRegistration {}
impl RObject for PassportElementTypeTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeTemporaryRegistration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeTemporaryRegistration {}


impl PassportElementTypeTemporaryRegistration {
  
  pub fn builder() -> RTDPassportElementTypeTemporaryRegistrationBuilder {
    let instance = Self {
      td_name: "passportElementTypeTemporaryRegistration".to_string(),
      
    };
    RTDPassportElementTypeTemporaryRegistrationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeTemporaryRegistration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeTemporaryRegistrationBuilder { instance: PassportElementTypeTemporaryRegistration }

impl RTDPassportElementTypeTemporaryRegistrationBuilder {
  fn new(instance: PassportElementTypeTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeTemporaryRegistration { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePhoneNumber
  
}



impl Object for PassportElementTypePhoneNumber {}
impl RObject for PassportElementTypePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePhoneNumber {}


impl PassportElementTypePhoneNumber {
  
  pub fn builder() -> RTDPassportElementTypePhoneNumberBuilder {
    let instance = Self {
      td_name: "passportElementTypePhoneNumber".to_string(),
      
    };
    RTDPassportElementTypePhoneNumberBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypePhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypePhoneNumberBuilder { instance: PassportElementTypePhoneNumber }

impl RTDPassportElementTypePhoneNumberBuilder {
  fn new(instance: PassportElementTypePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePhoneNumber { self.instance.clone() }
  
}



/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeEmailAddress
  
}



impl Object for PassportElementTypeEmailAddress {}
impl RObject for PassportElementTypeEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeEmailAddress {}


impl PassportElementTypeEmailAddress {
  
  pub fn builder() -> RTDPassportElementTypeEmailAddressBuilder {
    let instance = Self {
      td_name: "passportElementTypeEmailAddress".to_string(),
      
    };
    RTDPassportElementTypeEmailAddressBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementTypeEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementTypeEmailAddressBuilder { instance: PassportElementTypeEmailAddress }

impl RTDPassportElementTypeEmailAddressBuilder {
  fn new(instance: PassportElementTypeEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeEmailAddress { self.instance.clone() }
  
}



/// Contains information about saved Telegram Passport elements. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElements
  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,
  
}


impl Clone for PassportElements {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PassportElements {}
impl RObject for PassportElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElements" }
  fn td_type(&self) -> RTDType { RTDType::PassportElements }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportElements {
  
  pub fn builder() -> RTDPassportElementsBuilder {
    let instance = Self {
      td_name: "passportElements".to_string(),
      elements: None,
      
    };
    RTDPassportElementsBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> Option<Vec<Box<PassportElement>>> { self.elements.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElements> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementsBuilder { instance: PassportElements }

impl RTDPassportElementsBuilder {
  fn new(instance: PassportElements) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElements { self.instance.clone() }
  
  pub fn elements(&mut self, elements: Vec<Box<PassportElement>>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
}



/// Contains information about a Telegram Passport elements and corresponding errors. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementsWithErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementsWithErrors
  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,
  /// Errors in the elements that are already available.
  errors: Option<Vec<PassportElementError>>,
  
}


impl Clone for PassportElementsWithErrors {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PassportElementsWithErrors {}
impl RObject for PassportElementsWithErrors {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementsWithErrors" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementsWithErrors }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportElementsWithErrors {
  
  pub fn builder() -> RTDPassportElementsWithErrorsBuilder {
    let instance = Self {
      td_name: "passportElementsWithErrors".to_string(),
      elements: None,
      errors: None,
      
    };
    RTDPassportElementsWithErrorsBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> Option<Vec<Box<PassportElement>>> { self.elements.clone() }
  
  pub fn errors(&self) -> Option<Vec<PassportElementError>> { self.errors.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportElementsWithErrors> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportElementsWithErrorsBuilder { instance: PassportElementsWithErrors }

impl RTDPassportElementsWithErrorsBuilder {
  fn new(instance: PassportElementsWithErrors) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementsWithErrors { self.instance.clone() }
  
  pub fn elements(&mut self, elements: Vec<Box<PassportElement>>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
  pub fn errors(&mut self, errors: Vec<PassportElementError>) -> &mut Self {
    self.instance.errors = Some(errors);
    self
  }
  
}



/// Contains a description of the required Telegram Passport element that was requested by a service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportRequiredElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportRequiredElement
  /// List of Telegram Passport elements any of which is enough to provide.
  suitable_elements: Option<Vec<PassportSuitableElement>>,
  
}



impl Object for PassportRequiredElement {}
impl RObject for PassportRequiredElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportRequiredElement" }
  fn td_type(&self) -> RTDType { RTDType::PassportRequiredElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportRequiredElement {
  
  pub fn builder() -> RTDPassportRequiredElementBuilder {
    let instance = Self {
      td_name: "passportRequiredElement".to_string(),
      suitable_elements: None,
      
    };
    RTDPassportRequiredElementBuilder::new(instance)
  }
  
  
  pub fn suitable_elements(&self) -> Option<Vec<PassportSuitableElement>> { self.suitable_elements.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportRequiredElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportRequiredElementBuilder { instance: PassportRequiredElement }

impl RTDPassportRequiredElementBuilder {
  fn new(instance: PassportRequiredElement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportRequiredElement { self.instance.clone() }
  
  pub fn suitable_elements(&mut self, suitable_elements: Vec<PassportSuitableElement>) -> &mut Self {
    self.instance.suitable_elements = Some(suitable_elements);
    self
  }
  
}



/// Contains information about a Telegram Passport element that was requested by a service. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportSuitableElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportSuitableElement
  /// Type of the element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// True, if a selfie is required with the identity document.
  is_selfie_required: Option<bool>,
  /// True, if a certified English translation is required with the document.
  is_translation_required: Option<bool>,
  /// True, if personal details must include the user's name in the language of their country of residence.
  is_native_name_required: Option<bool>,
  
}


impl Clone for PassportSuitableElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for PassportSuitableElement {}
impl RObject for PassportSuitableElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportSuitableElement" }
  fn td_type(&self) -> RTDType { RTDType::PassportSuitableElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PassportSuitableElement {
  
  pub fn builder() -> RTDPassportSuitableElementBuilder {
    let instance = Self {
      td_name: "passportSuitableElement".to_string(),
      type_: None,
      is_selfie_required: None,
      is_translation_required: None,
      is_native_name_required: None,
      
    };
    RTDPassportSuitableElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn is_selfie_required(&self) -> Option<bool> { self.is_selfie_required.clone() }
  
  pub fn is_translation_required(&self) -> Option<bool> { self.is_translation_required.clone() }
  
  pub fn is_native_name_required(&self) -> Option<bool> { self.is_native_name_required.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PassportSuitableElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPassportSuitableElementBuilder { instance: PassportSuitableElement }

impl RTDPassportSuitableElementBuilder {
  fn new(instance: PassportSuitableElement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportSuitableElement { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn is_selfie_required(&mut self, is_selfie_required: bool) -> &mut Self {
    self.instance.is_selfie_required = Some(is_selfie_required);
    self
  }
  
  pub fn is_translation_required(&mut self, is_translation_required: bool) -> &mut Self {
    self.instance.is_translation_required = Some(is_translation_required);
    self
  }
  
  pub fn is_native_name_required(&mut self, is_native_name_required: bool) -> &mut Self {
    self.instance.is_native_name_required = Some(is_native_name_required);
    self
  }
  
}



/// Represents the current state of 2-step verification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passwordState
  /// True, if a 2-step verification password is set.
  has_password: Option<bool>,
  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True, if a recovery email is set.
  has_recovery_email_address: Option<bool>,
  /// True, if some Telegram Passport elements were saved.
  has_passport_data: Option<bool>,
  /// Information about the recovery email address to which the confirmation email was sent; may be null.
  recovery_email_address_code_info: Option<EmailAddressAuthenticationCodeInfo>,
  
}



impl Object for PasswordState {}
impl RObject for PasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passwordState" }
  fn td_type(&self) -> RTDType { RTDType::PasswordState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PasswordState {
  
  pub fn builder() -> RTDPasswordStateBuilder {
    let instance = Self {
      td_name: "passwordState".to_string(),
      has_password: None,
      password_hint: None,
      has_recovery_email_address: None,
      has_passport_data: None,
      recovery_email_address_code_info: None,
      
    };
    RTDPasswordStateBuilder::new(instance)
  }
  
  
  pub fn has_password(&self) -> Option<bool> { self.has_password.clone() }
  
  pub fn password_hint(&self) -> Option<String> { self.password_hint.clone() }
  
  pub fn has_recovery_email_address(&self) -> Option<bool> { self.has_recovery_email_address.clone() }
  
  pub fn has_passport_data(&self) -> Option<bool> { self.has_passport_data.clone() }
  
  pub fn recovery_email_address_code_info(&self) -> Option<EmailAddressAuthenticationCodeInfo> { self.recovery_email_address_code_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PasswordState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPasswordStateBuilder { instance: PasswordState }

impl RTDPasswordStateBuilder {
  fn new(instance: PasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> PasswordState { self.instance.clone() }
  
  pub fn has_password(&mut self, has_password: bool) -> &mut Self {
    self.instance.has_password = Some(has_password);
    self
  }
  
  pub fn password_hint<S: AsRef<str>>(&mut self, password_hint: S) -> &mut Self {
    self.instance.password_hint = Some(password_hint.as_ref().to_string());
    self
  }
  
  pub fn has_recovery_email_address(&mut self, has_recovery_email_address: bool) -> &mut Self {
    self.instance.has_recovery_email_address = Some(has_recovery_email_address);
    self
  }
  
  pub fn has_passport_data(&mut self, has_passport_data: bool) -> &mut Self {
    self.instance.has_passport_data = Some(has_passport_data);
    self
  }
  
  pub fn recovery_email_address_code_info(&mut self, recovery_email_address_code_info: EmailAddressAuthenticationCodeInfo) -> &mut Self {
    self.instance.recovery_email_address_code_info = Some(recovery_email_address_code_info);
    self
  }
  
}



/// Contains information about an invoice payment form. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentForm
  /// Full information of the invoice.
  invoice: Option<Invoice>,
  /// Payment form URL.
  url: Option<String>,
  /// Contains information about the payment provider, if available, to support it natively without the need for opening the URL; may be null.
  payments_provider: Option<PaymentsProviderStripe>,
  /// Saved server-side order information; may be null.
  saved_order_info: Option<OrderInfo>,
  /// Contains information about saved card credentials; may be null.
  saved_credentials: Option<SavedCredentials>,
  /// True, if the user can choose to save credentials.
  can_save_credentials: Option<bool>,
  /// True, if the user will be able to save credentials protected by a password they set up.
  need_password: Option<bool>,
  
}



impl Object for PaymentForm {}
impl RObject for PaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentForm" }
  fn td_type(&self) -> RTDType { RTDType::PaymentForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PaymentForm {
  
  pub fn builder() -> RTDPaymentFormBuilder {
    let instance = Self {
      td_name: "paymentForm".to_string(),
      invoice: None,
      url: None,
      payments_provider: None,
      saved_order_info: None,
      saved_credentials: None,
      can_save_credentials: None,
      need_password: None,
      
    };
    RTDPaymentFormBuilder::new(instance)
  }
  
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn payments_provider(&self) -> Option<PaymentsProviderStripe> { self.payments_provider.clone() }
  
  pub fn saved_order_info(&self) -> Option<OrderInfo> { self.saved_order_info.clone() }
  
  pub fn saved_credentials(&self) -> Option<SavedCredentials> { self.saved_credentials.clone() }
  
  pub fn can_save_credentials(&self) -> Option<bool> { self.can_save_credentials.clone() }
  
  pub fn need_password(&self) -> Option<bool> { self.need_password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PaymentForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPaymentFormBuilder { instance: PaymentForm }

impl RTDPaymentFormBuilder {
  fn new(instance: PaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentForm { self.instance.clone() }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn payments_provider(&mut self, payments_provider: PaymentsProviderStripe) -> &mut Self {
    self.instance.payments_provider = Some(payments_provider);
    self
  }
  
  pub fn saved_order_info(&mut self, saved_order_info: OrderInfo) -> &mut Self {
    self.instance.saved_order_info = Some(saved_order_info);
    self
  }
  
  pub fn saved_credentials(&mut self, saved_credentials: SavedCredentials) -> &mut Self {
    self.instance.saved_credentials = Some(saved_credentials);
    self
  }
  
  pub fn can_save_credentials(&mut self, can_save_credentials: bool) -> &mut Self {
    self.instance.can_save_credentials = Some(can_save_credentials);
    self
  }
  
  pub fn need_password(&mut self, need_password: bool) -> &mut Self {
    self.instance.need_password = Some(need_password);
    self
  }
  
}



/// Contains information about a successful payment. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentReceipt
  /// Point in time (Unix timestamp) when the payment was made.
  date: Option<i32>,
  /// User identifier of the payment provider bot.
  payments_provider_user_id: Option<i32>,
  /// Contains information about the invoice.
  invoice: Option<Invoice>,
  /// Contains order information; may be null.
  order_info: Option<OrderInfo>,
  /// Chosen shipping option; may be null.
  shipping_option: Option<ShippingOption>,
  /// Title of the saved credentials.
  credentials_title: Option<String>,
  
}



impl Object for PaymentReceipt {}
impl RObject for PaymentReceipt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentReceipt" }
  fn td_type(&self) -> RTDType { RTDType::PaymentReceipt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PaymentReceipt {
  
  pub fn builder() -> RTDPaymentReceiptBuilder {
    let instance = Self {
      td_name: "paymentReceipt".to_string(),
      date: None,
      payments_provider_user_id: None,
      invoice: None,
      order_info: None,
      shipping_option: None,
      credentials_title: None,
      
    };
    RTDPaymentReceiptBuilder::new(instance)
  }
  
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn payments_provider_user_id(&self) -> Option<i32> { self.payments_provider_user_id.clone() }
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn shipping_option(&self) -> Option<ShippingOption> { self.shipping_option.clone() }
  
  pub fn credentials_title(&self) -> Option<String> { self.credentials_title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PaymentReceipt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPaymentReceiptBuilder { instance: PaymentReceipt }

impl RTDPaymentReceiptBuilder {
  fn new(instance: PaymentReceipt) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentReceipt { self.instance.clone() }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn payments_provider_user_id(&mut self, payments_provider_user_id: i32) -> &mut Self {
    self.instance.payments_provider_user_id = Some(payments_provider_user_id);
    self
  }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn shipping_option(&mut self, shipping_option: ShippingOption) -> &mut Self {
    self.instance.shipping_option = Some(shipping_option);
    self
  }
  
  pub fn credentials_title<S: AsRef<str>>(&mut self, credentials_title: S) -> &mut Self {
    self.instance.credentials_title = Some(credentials_title.as_ref().to_string());
    self
  }
  
}



/// Contains the result of a payment request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentResult
  /// True, if the payment request was successful; otherwise the verification_url will be not empty.
  success: Option<bool>,
  /// URL for additional payment credentials verification.
  verification_url: Option<String>,
  
}



impl Object for PaymentResult {}
impl RObject for PaymentResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentResult" }
  fn td_type(&self) -> RTDType { RTDType::PaymentResult }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PaymentResult {
  
  pub fn builder() -> RTDPaymentResultBuilder {
    let instance = Self {
      td_name: "paymentResult".to_string(),
      success: None,
      verification_url: None,
      
    };
    RTDPaymentResultBuilder::new(instance)
  }
  
  
  pub fn success(&self) -> Option<bool> { self.success.clone() }
  
  pub fn verification_url(&self) -> Option<String> { self.verification_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PaymentResult> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPaymentResultBuilder { instance: PaymentResult }

impl RTDPaymentResultBuilder {
  fn new(instance: PaymentResult) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentResult { self.instance.clone() }
  
  pub fn success(&mut self, success: bool) -> &mut Self {
    self.instance.success = Some(success);
    self
  }
  
  pub fn verification_url<S: AsRef<str>>(&mut self, verification_url: S) -> &mut Self {
    self.instance.verification_url = Some(verification_url.as_ref().to_string());
    self
  }
  
}



/// Stripe payment provider. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentsProviderStripe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentsProviderStripe
  /// Stripe API publishable key.
  publishable_key: Option<String>,
  /// True, if the user country must be provided.
  need_country: Option<bool>,
  /// True, if the user ZIP/postal code must be provided.
  need_postal_code: Option<bool>,
  /// True, if the cardholder name must be provided.
  need_cardholder_name: Option<bool>,
  
}



impl Object for PaymentsProviderStripe {}
impl RObject for PaymentsProviderStripe {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentsProviderStripe" }
  fn td_type(&self) -> RTDType { RTDType::PaymentsProviderStripe }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PaymentsProviderStripe {
  
  pub fn builder() -> RTDPaymentsProviderStripeBuilder {
    let instance = Self {
      td_name: "paymentsProviderStripe".to_string(),
      publishable_key: None,
      need_country: None,
      need_postal_code: None,
      need_cardholder_name: None,
      
    };
    RTDPaymentsProviderStripeBuilder::new(instance)
  }
  
  
  pub fn publishable_key(&self) -> Option<String> { self.publishable_key.clone() }
  
  pub fn need_country(&self) -> Option<bool> { self.need_country.clone() }
  
  pub fn need_postal_code(&self) -> Option<bool> { self.need_postal_code.clone() }
  
  pub fn need_cardholder_name(&self) -> Option<bool> { self.need_cardholder_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PaymentsProviderStripe> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPaymentsProviderStripeBuilder { instance: PaymentsProviderStripe }

impl RTDPaymentsProviderStripeBuilder {
  fn new(instance: PaymentsProviderStripe) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentsProviderStripe { self.instance.clone() }
  
  pub fn publishable_key<S: AsRef<str>>(&mut self, publishable_key: S) -> &mut Self {
    self.instance.publishable_key = Some(publishable_key.as_ref().to_string());
    self
  }
  
  pub fn need_country(&mut self, need_country: bool) -> &mut Self {
    self.instance.need_country = Some(need_country);
    self
  }
  
  pub fn need_postal_code(&mut self, need_postal_code: bool) -> &mut Self {
    self.instance.need_postal_code = Some(need_postal_code);
    self
  }
  
  pub fn need_cardholder_name(&mut self, need_cardholder_name: bool) -> &mut Self {
    self.instance.need_cardholder_name = Some(need_cardholder_name);
    self
  }
  
}



/// Contains the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // personalDetails
  /// First name of the user written in English; 1-255 characters.
  first_name: Option<String>,
  /// Middle name of the user written in English; 0-255 characters.
  middle_name: Option<String>,
  /// Last name of the user written in English; 1-255 characters.
  last_name: Option<String>,
  /// Native first name of the user; 1-255 characters.
  native_first_name: Option<String>,
  /// Native middle name of the user; 0-255 characters.
  native_middle_name: Option<String>,
  /// Native last name of the user; 1-255 characters.
  native_last_name: Option<String>,
  /// Birthdate of the user.
  birthdate: Option<Date>,
  /// Gender of the user, "male" or "female".
  gender: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's country.
  country_code: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country.
  residence_country_code: Option<String>,
  
}



impl Object for PersonalDetails {}
impl RObject for PersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "personalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PersonalDetails }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PersonalDetails {
  
  pub fn builder() -> RTDPersonalDetailsBuilder {
    let instance = Self {
      td_name: "personalDetails".to_string(),
      first_name: None,
      middle_name: None,
      last_name: None,
      native_first_name: None,
      native_middle_name: None,
      native_last_name: None,
      birthdate: None,
      gender: None,
      country_code: None,
      residence_country_code: None,
      
    };
    RTDPersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn middle_name(&self) -> Option<String> { self.middle_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn native_first_name(&self) -> Option<String> { self.native_first_name.clone() }
  
  pub fn native_middle_name(&self) -> Option<String> { self.native_middle_name.clone() }
  
  pub fn native_last_name(&self) -> Option<String> { self.native_last_name.clone() }
  
  pub fn birthdate(&self) -> Option<Date> { self.birthdate.clone() }
  
  pub fn gender(&self) -> Option<String> { self.gender.clone() }
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn residence_country_code(&self) -> Option<String> { self.residence_country_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PersonalDetails> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPersonalDetailsBuilder { instance: PersonalDetails }

impl RTDPersonalDetailsBuilder {
  fn new(instance: PersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PersonalDetails { self.instance.clone() }
  
  pub fn first_name<S: AsRef<str>>(&mut self, first_name: S) -> &mut Self {
    self.instance.first_name = Some(first_name.as_ref().to_string());
    self
  }
  
  pub fn middle_name<S: AsRef<str>>(&mut self, middle_name: S) -> &mut Self {
    self.instance.middle_name = Some(middle_name.as_ref().to_string());
    self
  }
  
  pub fn last_name<S: AsRef<str>>(&mut self, last_name: S) -> &mut Self {
    self.instance.last_name = Some(last_name.as_ref().to_string());
    self
  }
  
  pub fn native_first_name<S: AsRef<str>>(&mut self, native_first_name: S) -> &mut Self {
    self.instance.native_first_name = Some(native_first_name.as_ref().to_string());
    self
  }
  
  pub fn native_middle_name<S: AsRef<str>>(&mut self, native_middle_name: S) -> &mut Self {
    self.instance.native_middle_name = Some(native_middle_name.as_ref().to_string());
    self
  }
  
  pub fn native_last_name<S: AsRef<str>>(&mut self, native_last_name: S) -> &mut Self {
    self.instance.native_last_name = Some(native_last_name.as_ref().to_string());
    self
  }
  
  pub fn birthdate(&mut self, birthdate: Date) -> &mut Self {
    self.instance.birthdate = Some(birthdate);
    self
  }
  
  pub fn gender<S: AsRef<str>>(&mut self, gender: S) -> &mut Self {
    self.instance.gender = Some(gender.as_ref().to_string());
    self
  }
  
  pub fn country_code<S: AsRef<str>>(&mut self, country_code: S) -> &mut Self {
    self.instance.country_code = Some(country_code.as_ref().to_string());
    self
  }
  
  pub fn residence_country_code<S: AsRef<str>>(&mut self, residence_country_code: S) -> &mut Self {
    self.instance.residence_country_code = Some(residence_country_code.as_ref().to_string());
    self
  }
  
}



/// A personal document, containing some information about a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // personalDocument
  /// List of files containing the pages of the document.
  files: Option<Vec<DatedFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  
}



impl Object for PersonalDocument {}
impl RObject for PersonalDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "personalDocument" }
  fn td_type(&self) -> RTDType { RTDType::PersonalDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PersonalDocument {
  
  pub fn builder() -> RTDPersonalDocumentBuilder {
    let instance = Self {
      td_name: "personalDocument".to_string(),
      files: None,
      translation: None,
      
    };
    RTDPersonalDocumentBuilder::new(instance)
  }
  
  
  pub fn files(&self) -> Option<Vec<DatedFile>> { self.files.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PersonalDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPersonalDocumentBuilder { instance: PersonalDocument }

impl RTDPersonalDocumentBuilder {
  fn new(instance: PersonalDocument) -> Self { Self { instance } }

  pub fn build(&self) -> PersonalDocument { self.instance.clone() }
  
  pub fn files(&mut self, files: Vec<DatedFile>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}



/// Describes a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Photo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // photo
  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// Available variants of the photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,
  
}



impl Object for Photo {}
impl RObject for Photo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "photo" }
  fn td_type(&self) -> RTDType { RTDType::Photo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Photo {
  
  pub fn builder() -> RTDPhotoBuilder {
    let instance = Self {
      td_name: "photo".to_string(),
      has_stickers: None,
      sizes: None,
      
    };
    RTDPhotoBuilder::new(instance)
  }
  
  
  pub fn has_stickers(&self) -> Option<bool> { self.has_stickers.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Photo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPhotoBuilder { instance: Photo }

impl RTDPhotoBuilder {
  fn new(instance: Photo) -> Self { Self { instance } }

  pub fn build(&self) -> Photo { self.instance.clone() }
  
  pub fn has_stickers(&mut self, has_stickers: bool) -> &mut Self {
    self.instance.has_stickers = Some(has_stickers);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
}



/// Photo description. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhotoSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // photoSize
  /// Thumbnail type (see https://core.telegram.org/constructor/photoSize).
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Information about the photo file.
  photo: Option<File>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,
  
}



impl Object for PhotoSize {}
impl RObject for PhotoSize {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "photoSize" }
  fn td_type(&self) -> RTDType { RTDType::PhotoSize }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PhotoSize {
  
  pub fn builder() -> RTDPhotoSizeBuilder {
    let instance = Self {
      td_name: "photoSize".to_string(),
      type_: None,
      photo: None,
      width: None,
      height: None,
      
    };
    RTDPhotoSizeBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn photo(&self) -> Option<File> { self.photo.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PhotoSize> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPhotoSizeBuilder { instance: PhotoSize }

impl RTDPhotoSizeBuilder {
  fn new(instance: PhotoSize) -> Self { Self { instance } }

  pub fn build(&self) -> PhotoSize { self.instance.clone() }
  
  pub fn type_<S: AsRef<str>>(&mut self, type_: S) -> &mut Self {
    self.instance.type_ = Some(type_.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: File) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}



/// Describes a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Poll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // poll
  /// Unique poll identifier.
  id: Option<i64>,
  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options.
  options: Option<Vec<PollOption>>,
  /// Total number of voters, participating in the poll.
  total_voter_count: Option<i32>,
  /// True, if the poll is closed.
  is_closed: Option<bool>,
  
}



impl Object for Poll {}
impl RObject for Poll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "poll" }
  fn td_type(&self) -> RTDType { RTDType::Poll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Poll {
  
  pub fn builder() -> RTDPollBuilder {
    let instance = Self {
      td_name: "poll".to_string(),
      id: None,
      question: None,
      options: None,
      total_voter_count: None,
      is_closed: None,
      
    };
    RTDPollBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn options(&self) -> Option<Vec<PollOption>> { self.options.clone() }
  
  pub fn total_voter_count(&self) -> Option<i32> { self.total_voter_count.clone() }
  
  pub fn is_closed(&self) -> Option<bool> { self.is_closed.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Poll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPollBuilder { instance: Poll }

impl RTDPollBuilder {
  fn new(instance: Poll) -> Self { Self { instance } }

  pub fn build(&self) -> Poll { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn question<S: AsRef<str>>(&mut self, question: S) -> &mut Self {
    self.instance.question = Some(question.as_ref().to_string());
    self
  }
  
  pub fn options(&mut self, options: Vec<PollOption>) -> &mut Self {
    self.instance.options = Some(options);
    self
  }
  
  pub fn total_voter_count(&mut self, total_voter_count: i32) -> &mut Self {
    self.instance.total_voter_count = Some(total_voter_count);
    self
  }
  
  pub fn is_closed(&mut self, is_closed: bool) -> &mut Self {
    self.instance.is_closed = Some(is_closed);
    self
  }
  
}



/// Describes one answer option of a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PollOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pollOption
  /// Option text, 1-100 characters.
  text: Option<String>,
  /// Number of voters for this option, available only for closed or voted polls.
  voter_count: Option<i32>,
  /// The percentage of votes for this option, 0-100.
  vote_percentage: Option<i32>,
  /// True, if the option was chosen by the user.
  is_chosen: Option<bool>,
  /// True, if the option is being chosen by a pending setPollAnswer request.
  is_being_chosen: Option<bool>,
  
}



impl Object for PollOption {}
impl RObject for PollOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pollOption" }
  fn td_type(&self) -> RTDType { RTDType::PollOption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PollOption {
  
  pub fn builder() -> RTDPollOptionBuilder {
    let instance = Self {
      td_name: "pollOption".to_string(),
      text: None,
      voter_count: None,
      vote_percentage: None,
      is_chosen: None,
      is_being_chosen: None,
      
    };
    RTDPollOptionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn voter_count(&self) -> Option<i32> { self.voter_count.clone() }
  
  pub fn vote_percentage(&self) -> Option<i32> { self.vote_percentage.clone() }
  
  pub fn is_chosen(&self) -> Option<bool> { self.is_chosen.clone() }
  
  pub fn is_being_chosen(&self) -> Option<bool> { self.is_being_chosen.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PollOption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPollOptionBuilder { instance: PollOption }

impl RTDPollOptionBuilder {
  fn new(instance: PollOption) -> Self { Self { instance } }

  pub fn build(&self) -> PollOption { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn voter_count(&mut self, voter_count: i32) -> &mut Self {
    self.instance.voter_count = Some(voter_count);
    self
  }
  
  pub fn vote_percentage(&mut self, vote_percentage: i32) -> &mut Self {
    self.instance.vote_percentage = Some(vote_percentage);
    self
  }
  
  pub fn is_chosen(&mut self, is_chosen: bool) -> &mut Self {
    self.instance.is_chosen = Some(is_chosen);
    self
  }
  
  pub fn is_being_chosen(&mut self, is_being_chosen: bool) -> &mut Self {
    self.instance.is_being_chosen = Some(is_being_chosen);
    self
  }
  
}



/// Describes a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // profilePhoto
  /// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of userProfilePhotos.
  id: Option<i64>,
  /// A small (160x160) user profile photo.
  small: Option<File>,
  /// A big (640x640) user profile photo.
  big: Option<File>,
  
}



impl Object for ProfilePhoto {}
impl RObject for ProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "profilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::ProfilePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ProfilePhoto {
  
  pub fn builder() -> RTDProfilePhotoBuilder {
    let instance = Self {
      td_name: "profilePhoto".to_string(),
      id: None,
      small: None,
      big: None,
      
    };
    RTDProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn small(&self) -> Option<File> { self.small.clone() }
  
  pub fn big(&self) -> Option<File> { self.big.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ProfilePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProfilePhotoBuilder { instance: ProfilePhoto }

impl RTDProfilePhotoBuilder {
  fn new(instance: ProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ProfilePhoto { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn small(&mut self, small: File) -> &mut Self {
    self.instance.small = Some(small);
    self
  }
  
  pub fn big(&mut self, big: File) -> &mut Self {
    self.instance.big = Some(big);
    self
  }
  
}



/// Represents a list of proxy servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxies
  /// List of proxy servers.
  proxies: Option<Vec<Proxy>>,
  
}



impl Object for Proxies {}
impl RObject for Proxies {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxies" }
  fn td_type(&self) -> RTDType { RTDType::Proxies }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Proxies {
  
  pub fn builder() -> RTDProxiesBuilder {
    let instance = Self {
      td_name: "proxies".to_string(),
      proxies: None,
      
    };
    RTDProxiesBuilder::new(instance)
  }
  
  
  pub fn proxies(&self) -> Option<Vec<Proxy>> { self.proxies.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Proxies> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProxiesBuilder { instance: Proxies }

impl RTDProxiesBuilder {
  fn new(instance: Proxies) -> Self { Self { instance } }

  pub fn build(&self) -> Proxies { self.instance.clone() }
  
  pub fn proxies(&mut self, proxies: Vec<Proxy>) -> &mut Self {
    self.instance.proxies = Some(proxies);
    self
  }
  
}



/// Contains information about a proxy server. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Proxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxy
  /// Unique identifier of the proxy.
  id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// Point in time (Unix timestamp) when the proxy was last used; 0 if never.
  last_used_date: Option<i32>,
  /// True, if the proxy is enabled now.
  is_enabled: Option<bool>,
  /// Type of the proxy.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for Proxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Proxy {}
impl RObject for Proxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxy" }
  fn td_type(&self) -> RTDType { RTDType::Proxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Proxy {
  
  pub fn builder() -> RTDProxyBuilder {
    let instance = Self {
      td_name: "proxy".to_string(),
      id: None,
      server: None,
      port: None,
      last_used_date: None,
      is_enabled: None,
      type_: None,
      
    };
    RTDProxyBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn last_used_date(&self) -> Option<i32> { self.last_used_date.clone() }
  
  pub fn is_enabled(&self) -> Option<bool> { self.is_enabled.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Proxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProxyBuilder { instance: Proxy }

impl RTDProxyBuilder {
  fn new(instance: Proxy) -> Self { Self { instance } }

  pub fn build(&self) -> Proxy { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn server<S: AsRef<str>>(&mut self, server: S) -> &mut Self {
    self.instance.server = Some(server.as_ref().to_string());
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn last_used_date(&mut self, last_used_date: i32) -> &mut Self {
    self.instance.last_used_date = Some(last_used_date);
    self
  }
  
  pub fn is_enabled(&mut self, is_enabled: bool) -> &mut Self {
    self.instance.is_enabled = Some(is_enabled);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// This class is an abstract base class. Describes the type of the proxy server. 
#[typetag::serde(tag = "@struct")]
pub trait ProxyType: Object + RObject + Debug {}







impl ProxyType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ProxyType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ProxyType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDProxyTypeType {
  ProxyTypeHttp,
  ProxyTypeMtproto,
  ProxyTypeSocks5,
  
}
impl RTDProxyTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A SOCKS5 proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeSocks5 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeSocks5
  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,
  
}



impl Object for ProxyTypeSocks5 {}
impl RObject for ProxyTypeSocks5 {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeSocks5" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeSocks5 }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ProxyType for ProxyTypeSocks5 {}


impl ProxyTypeSocks5 {
  
  pub fn builder() -> RTDProxyTypeSocks5Builder {
    let instance = Self {
      td_name: "proxyTypeSocks5".to_string(),
      username: None,
      password: None,
      
    };
    RTDProxyTypeSocks5Builder::new(instance)
  }
  
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ProxyTypeSocks5> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProxyTypeSocks5Builder { instance: ProxyTypeSocks5 }

impl RTDProxyTypeSocks5Builder {
  fn new(instance: ProxyTypeSocks5) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeSocks5 { self.instance.clone() }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// A HTTP transparent proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeHttp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeHttp
  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,
  /// Pass true, if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method.
  http_only: Option<bool>,
  
}



impl Object for ProxyTypeHttp {}
impl RObject for ProxyTypeHttp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeHttp" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeHttp }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ProxyType for ProxyTypeHttp {}


impl ProxyTypeHttp {
  
  pub fn builder() -> RTDProxyTypeHttpBuilder {
    let instance = Self {
      td_name: "proxyTypeHttp".to_string(),
      username: None,
      password: None,
      http_only: None,
      
    };
    RTDProxyTypeHttpBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn http_only(&self) -> Option<bool> { self.http_only.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ProxyTypeHttp> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProxyTypeHttpBuilder { instance: ProxyTypeHttp }

impl RTDProxyTypeHttpBuilder {
  fn new(instance: ProxyTypeHttp) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeHttp { self.instance.clone() }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
  pub fn http_only(&mut self, http_only: bool) -> &mut Self {
    self.instance.http_only = Some(http_only);
    self
  }
  
}



/// An MTProto proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeMtproto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeMtproto
  /// The proxy's secret in hexadecimal encoding.
  secret: Option<String>,
  
}



impl Object for ProxyTypeMtproto {}
impl RObject for ProxyTypeMtproto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeMtproto" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeMtproto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ProxyType for ProxyTypeMtproto {}


impl ProxyTypeMtproto {
  
  pub fn builder() -> RTDProxyTypeMtprotoBuilder {
    let instance = Self {
      td_name: "proxyTypeMtproto".to_string(),
      secret: None,
      
    };
    RTDProxyTypeMtprotoBuilder::new(instance)
  }
  
  
  pub fn secret(&self) -> Option<String> { self.secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ProxyTypeMtproto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProxyTypeMtprotoBuilder { instance: ProxyTypeMtproto }

impl RTDProxyTypeMtprotoBuilder {
  fn new(instance: ProxyTypeMtproto) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeMtproto { self.instance.clone() }
  
  pub fn secret<S: AsRef<str>>(&mut self, secret: S) -> &mut Self {
    self.instance.secret = Some(secret.as_ref().to_string());
    self
  }
  
}



/// Contains a public HTTPS link to a message in a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // publicMessageLink
  /// Message link.
  link: Option<String>,
  /// HTML-code for embedding the message.
  html: Option<String>,
  
}



impl Object for PublicMessageLink {}
impl RObject for PublicMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "publicMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::PublicMessageLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PublicMessageLink {
  
  pub fn builder() -> RTDPublicMessageLinkBuilder {
    let instance = Self {
      td_name: "publicMessageLink".to_string(),
      link: None,
      html: None,
      
    };
    RTDPublicMessageLinkBuilder::new(instance)
  }
  
  
  pub fn link(&self) -> Option<String> { self.link.clone() }
  
  pub fn html(&self) -> Option<String> { self.html.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PublicMessageLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPublicMessageLinkBuilder { instance: PublicMessageLink }

impl RTDPublicMessageLinkBuilder {
  fn new(instance: PublicMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> PublicMessageLink { self.instance.clone() }
  
  pub fn link<S: AsRef<str>>(&mut self, link: S) -> &mut Self {
    self.instance.link = Some(link.as_ref().to_string());
    self
  }
  
  pub fn html<S: AsRef<str>>(&mut self, html: S) -> &mut Self {
    self.instance.html = Some(html.as_ref().to_string());
    self
  }
  
}



/// This class is an abstract base class. Contains content of a push message notification. 
#[typetag::serde(tag = "@struct")]
pub trait PushMessageContent: Object + RObject + Debug {}







impl PushMessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<PushMessageContent>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<PushMessageContent> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPushMessageContentType {
  PushMessageContentAnimation,
  PushMessageContentAudio,
  PushMessageContentBasicGroupChatCreate,
  PushMessageContentChatAddMembers,
  PushMessageContentChatChangePhoto,
  PushMessageContentChatChangeTitle,
  PushMessageContentChatDeleteMember,
  PushMessageContentChatJoinByLink,
  PushMessageContentContact,
  PushMessageContentContactRegistered,
  PushMessageContentDocument,
  PushMessageContentGame,
  PushMessageContentGameScore,
  PushMessageContentHidden,
  PushMessageContentInvoice,
  PushMessageContentLocation,
  PushMessageContentMediaAlbum,
  PushMessageContentMessageForwards,
  PushMessageContentPhoto,
  PushMessageContentPoll,
  PushMessageContentScreenshotTaken,
  PushMessageContentSticker,
  PushMessageContentText,
  PushMessageContentVideo,
  PushMessageContentVideoNote,
  PushMessageContentVoiceNote,
  
}
impl RTDPushMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A general message with hidden content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentHidden {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentHidden
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentHidden {}
impl RObject for PushMessageContentHidden {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentHidden" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentHidden }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentHidden {}


impl PushMessageContentHidden {
  
  pub fn builder() -> RTDPushMessageContentHiddenBuilder {
    let instance = Self {
      td_name: "pushMessageContentHidden".to_string(),
      is_pinned: None,
      
    };
    RTDPushMessageContentHiddenBuilder::new(instance)
  }
  
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentHidden> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentHiddenBuilder { instance: PushMessageContentHidden }

impl RTDPushMessageContentHiddenBuilder {
  fn new(instance: PushMessageContentHidden) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentHidden { self.instance.clone() }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// An animation message (GIF-style.) 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentAnimation
  /// Message content; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentAnimation {}
impl RObject for PushMessageContentAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentAnimation" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentAnimation {}


impl PushMessageContentAnimation {
  
  pub fn builder() -> RTDPushMessageContentAnimationBuilder {
    let instance = Self {
      td_name: "pushMessageContentAnimation".to_string(),
      animation: None,
      caption: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentAnimationBuilder { instance: PushMessageContentAnimation }

impl RTDPushMessageContentAnimationBuilder {
  fn new(instance: PushMessageContentAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption<S: AsRef<str>>(&mut self, caption: S) -> &mut Self {
    self.instance.caption = Some(caption.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentAudio
  /// Message content; may be null.
  audio: Option<Audio>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentAudio {}
impl RObject for PushMessageContentAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentAudio" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentAudio {}


impl PushMessageContentAudio {
  
  pub fn builder() -> RTDPushMessageContentAudioBuilder {
    let instance = Self {
      td_name: "pushMessageContentAudio".to_string(),
      audio: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentAudioBuilder { instance: PushMessageContentAudio }

impl RTDPushMessageContentAudioBuilder {
  fn new(instance: PushMessageContentAudio) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentAudio { self.instance.clone() }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentContact
  /// Contact's name.
  name: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentContact {}
impl RObject for PushMessageContentContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentContact" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentContact }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentContact {}


impl PushMessageContentContact {
  
  pub fn builder() -> RTDPushMessageContentContactBuilder {
    let instance = Self {
      td_name: "pushMessageContentContact".to_string(),
      name: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentContactBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentContact> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentContactBuilder { instance: PushMessageContentContact }

impl RTDPushMessageContentContactBuilder {
  fn new(instance: PushMessageContentContact) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentContact { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentContactRegistered
  
}



impl Object for PushMessageContentContactRegistered {}
impl RObject for PushMessageContentContactRegistered {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentContactRegistered" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentContactRegistered }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentContactRegistered {}


impl PushMessageContentContactRegistered {
  
  pub fn builder() -> RTDPushMessageContentContactRegisteredBuilder {
    let instance = Self {
      td_name: "pushMessageContentContactRegistered".to_string(),
      
    };
    RTDPushMessageContentContactRegisteredBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentContactRegistered> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentContactRegisteredBuilder { instance: PushMessageContentContactRegistered }

impl RTDPushMessageContentContactRegisteredBuilder {
  fn new(instance: PushMessageContentContactRegistered) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentContactRegistered { self.instance.clone() }
  
}



/// A document message (a general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentDocument
  /// Message content; may be null.
  document: Option<Document>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentDocument {}
impl RObject for PushMessageContentDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentDocument" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentDocument {}


impl PushMessageContentDocument {
  
  pub fn builder() -> RTDPushMessageContentDocumentBuilder {
    let instance = Self {
      td_name: "pushMessageContentDocument".to_string(),
      document: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentDocumentBuilder { instance: PushMessageContentDocument }

impl RTDPushMessageContentDocumentBuilder {
  fn new(instance: PushMessageContentDocument) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentDocument { self.instance.clone() }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentGame
  /// Game title, empty for pinned game message.
  title: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentGame {}
impl RObject for PushMessageContentGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentGame" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentGame }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentGame {}


impl PushMessageContentGame {
  
  pub fn builder() -> RTDPushMessageContentGameBuilder {
    let instance = Self {
      td_name: "pushMessageContentGame".to_string(),
      title: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentGameBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentGame> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentGameBuilder { instance: PushMessageContentGame }

impl RTDPushMessageContentGameBuilder {
  fn new(instance: PushMessageContentGame) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentGame { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentGameScore
  /// Game title, empty for pinned message.
  title: Option<String>,
  /// New score, 0 for pinned message.
  score: Option<i32>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentGameScore {}
impl RObject for PushMessageContentGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentGameScore" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentGameScore }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentGameScore {}


impl PushMessageContentGameScore {
  
  pub fn builder() -> RTDPushMessageContentGameScoreBuilder {
    let instance = Self {
      td_name: "pushMessageContentGameScore".to_string(),
      title: None,
      score: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentGameScoreBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentGameScore> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentGameScoreBuilder { instance: PushMessageContentGameScore }

impl RTDPushMessageContentGameScoreBuilder {
  fn new(instance: PushMessageContentGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentGameScore { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentInvoice
  /// Product price.
  price: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentInvoice {}
impl RObject for PushMessageContentInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentInvoice" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentInvoice }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentInvoice {}


impl PushMessageContentInvoice {
  
  pub fn builder() -> RTDPushMessageContentInvoiceBuilder {
    let instance = Self {
      td_name: "pushMessageContentInvoice".to_string(),
      price: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentInvoiceBuilder::new(instance)
  }
  
  
  pub fn price(&self) -> Option<String> { self.price.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentInvoice> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentInvoiceBuilder { instance: PushMessageContentInvoice }

impl RTDPushMessageContentInvoiceBuilder {
  fn new(instance: PushMessageContentInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentInvoice { self.instance.clone() }
  
  pub fn price<S: AsRef<str>>(&mut self, price: S) -> &mut Self {
    self.instance.price = Some(price.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentLocation
  /// True, if the location is live.
  is_live: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentLocation {}
impl RObject for PushMessageContentLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentLocation" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentLocation {}


impl PushMessageContentLocation {
  
  pub fn builder() -> RTDPushMessageContentLocationBuilder {
    let instance = Self {
      td_name: "pushMessageContentLocation".to_string(),
      is_live: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentLocationBuilder::new(instance)
  }
  
  
  pub fn is_live(&self) -> Option<bool> { self.is_live.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentLocationBuilder { instance: PushMessageContentLocation }

impl RTDPushMessageContentLocationBuilder {
  fn new(instance: PushMessageContentLocation) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentLocation { self.instance.clone() }
  
  pub fn is_live(&mut self, is_live: bool) -> &mut Self {
    self.instance.is_live = Some(is_live);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentPhoto
  /// Message content; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<String>,
  /// True, if the photo is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentPhoto {}
impl RObject for PushMessageContentPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentPhoto" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentPhoto {}


impl PushMessageContentPhoto {
  
  pub fn builder() -> RTDPushMessageContentPhotoBuilder {
    let instance = Self {
      td_name: "pushMessageContentPhoto".to_string(),
      photo: None,
      caption: None,
      is_secret: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentPhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentPhotoBuilder { instance: PushMessageContentPhoto }

impl RTDPushMessageContentPhotoBuilder {
  fn new(instance: PushMessageContentPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentPhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption<S: AsRef<str>>(&mut self, caption: S) -> &mut Self {
    self.instance.caption = Some(caption.as_ref().to_string());
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentPoll
  /// Poll question.
  question: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentPoll {}
impl RObject for PushMessageContentPoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentPoll" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentPoll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentPoll {}


impl PushMessageContentPoll {
  
  pub fn builder() -> RTDPushMessageContentPollBuilder {
    let instance = Self {
      td_name: "pushMessageContentPoll".to_string(),
      question: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentPollBuilder::new(instance)
  }
  
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentPoll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentPollBuilder { instance: PushMessageContentPoll }

impl RTDPushMessageContentPollBuilder {
  fn new(instance: PushMessageContentPoll) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentPoll { self.instance.clone() }
  
  pub fn question<S: AsRef<str>>(&mut self, question: S) -> &mut Self {
    self.instance.question = Some(question.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentScreenshotTaken
  
}



impl Object for PushMessageContentScreenshotTaken {}
impl RObject for PushMessageContentScreenshotTaken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentScreenshotTaken" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentScreenshotTaken }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentScreenshotTaken {}


impl PushMessageContentScreenshotTaken {
  
  pub fn builder() -> RTDPushMessageContentScreenshotTakenBuilder {
    let instance = Self {
      td_name: "pushMessageContentScreenshotTaken".to_string(),
      
    };
    RTDPushMessageContentScreenshotTakenBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentScreenshotTaken> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentScreenshotTakenBuilder { instance: PushMessageContentScreenshotTaken }

impl RTDPushMessageContentScreenshotTakenBuilder {
  fn new(instance: PushMessageContentScreenshotTaken) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentScreenshotTaken { self.instance.clone() }
  
}



/// A message with a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentSticker
  /// Message content; may be null.
  sticker: Option<Sticker>,
  /// Emoji corresponding to the sticker; may be empty.
  emoji: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentSticker {}
impl RObject for PushMessageContentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentSticker" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentSticker {}


impl PushMessageContentSticker {
  
  pub fn builder() -> RTDPushMessageContentStickerBuilder {
    let instance = Self {
      td_name: "pushMessageContentSticker".to_string(),
      sticker: None,
      emoji: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentStickerBuilder { instance: PushMessageContentSticker }

impl RTDPushMessageContentStickerBuilder {
  fn new(instance: PushMessageContentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentSticker { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn emoji<S: AsRef<str>>(&mut self, emoji: S) -> &mut Self {
    self.instance.emoji = Some(emoji.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentText
  /// Message text.
  text: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentText {}
impl RObject for PushMessageContentText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentText" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentText {}


impl PushMessageContentText {
  
  pub fn builder() -> RTDPushMessageContentTextBuilder {
    let instance = Self {
      td_name: "pushMessageContentText".to_string(),
      text: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentTextBuilder { instance: PushMessageContentText }

impl RTDPushMessageContentTextBuilder {
  fn new(instance: PushMessageContentText) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentText { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVideo
  /// Message content; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<String>,
  /// True, if the video is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVideo {}
impl RObject for PushMessageContentVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVideo" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVideo {}


impl PushMessageContentVideo {
  
  pub fn builder() -> RTDPushMessageContentVideoBuilder {
    let instance = Self {
      td_name: "pushMessageContentVideo".to_string(),
      video: None,
      caption: None,
      is_secret: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentVideoBuilder { instance: PushMessageContentVideo }

impl RTDPushMessageContentVideoBuilder {
  fn new(instance: PushMessageContentVideo) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVideo { self.instance.clone() }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption<S: AsRef<str>>(&mut self, caption: S) -> &mut Self {
    self.instance.caption = Some(caption.as_ref().to_string());
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVideoNote
  /// Message content; may be null.
  video_note: Option<VideoNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVideoNote {}
impl RObject for PushMessageContentVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVideoNote {}


impl PushMessageContentVideoNote {
  
  pub fn builder() -> RTDPushMessageContentVideoNoteBuilder {
    let instance = Self {
      td_name: "pushMessageContentVideoNote".to_string(),
      video_note: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentVideoNoteBuilder { instance: PushMessageContentVideoNote }

impl RTDPushMessageContentVideoNoteBuilder {
  fn new(instance: PushMessageContentVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVideoNote { self.instance.clone() }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVoiceNote
  /// Message content; may be null.
  voice_note: Option<VoiceNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVoiceNote {}
impl RObject for PushMessageContentVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVoiceNote {}


impl PushMessageContentVoiceNote {
  
  pub fn builder() -> RTDPushMessageContentVoiceNoteBuilder {
    let instance = Self {
      td_name: "pushMessageContentVoiceNote".to_string(),
      voice_note: None,
      is_pinned: None,
      
    };
    RTDPushMessageContentVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentVoiceNoteBuilder { instance: PushMessageContentVoiceNote }

impl RTDPushMessageContentVoiceNoteBuilder {
  fn new(instance: PushMessageContentVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVoiceNote { self.instance.clone() }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentBasicGroupChatCreate
  
}



impl Object for PushMessageContentBasicGroupChatCreate {}
impl RObject for PushMessageContentBasicGroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentBasicGroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentBasicGroupChatCreate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentBasicGroupChatCreate {}


impl PushMessageContentBasicGroupChatCreate {
  
  pub fn builder() -> RTDPushMessageContentBasicGroupChatCreateBuilder {
    let instance = Self {
      td_name: "pushMessageContentBasicGroupChatCreate".to_string(),
      
    };
    RTDPushMessageContentBasicGroupChatCreateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentBasicGroupChatCreate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentBasicGroupChatCreateBuilder { instance: PushMessageContentBasicGroupChatCreate }

impl RTDPushMessageContentBasicGroupChatCreateBuilder {
  fn new(instance: PushMessageContentBasicGroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentBasicGroupChatCreate { self.instance.clone() }
  
}



/// New chat members were invited to a group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatAddMembers
  /// Name of the added member.
  member_name: Option<String>,
  /// True, if the current user was added to the group.
  is_current_user: Option<bool>,
  /// True, if the user has returned to the group himself.
  is_returned: Option<bool>,
  
}



impl Object for PushMessageContentChatAddMembers {}
impl RObject for PushMessageContentChatAddMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatAddMembers" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatAddMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatAddMembers {}


impl PushMessageContentChatAddMembers {
  
  pub fn builder() -> RTDPushMessageContentChatAddMembersBuilder {
    let instance = Self {
      td_name: "pushMessageContentChatAddMembers".to_string(),
      member_name: None,
      is_current_user: None,
      is_returned: None,
      
    };
    RTDPushMessageContentChatAddMembersBuilder::new(instance)
  }
  
  
  pub fn member_name(&self) -> Option<String> { self.member_name.clone() }
  
  pub fn is_current_user(&self) -> Option<bool> { self.is_current_user.clone() }
  
  pub fn is_returned(&self) -> Option<bool> { self.is_returned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentChatAddMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentChatAddMembersBuilder { instance: PushMessageContentChatAddMembers }

impl RTDPushMessageContentChatAddMembersBuilder {
  fn new(instance: PushMessageContentChatAddMembers) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatAddMembers { self.instance.clone() }
  
  pub fn member_name<S: AsRef<str>>(&mut self, member_name: S) -> &mut Self {
    self.instance.member_name = Some(member_name.as_ref().to_string());
    self
  }
  
  pub fn is_current_user(&mut self, is_current_user: bool) -> &mut Self {
    self.instance.is_current_user = Some(is_current_user);
    self
  }
  
  pub fn is_returned(&mut self, is_returned: bool) -> &mut Self {
    self.instance.is_returned = Some(is_returned);
    self
  }
  
}



/// A chat photo was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatChangePhoto
  
}



impl Object for PushMessageContentChatChangePhoto {}
impl RObject for PushMessageContentChatChangePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatChangePhoto" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatChangePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatChangePhoto {}


impl PushMessageContentChatChangePhoto {
  
  pub fn builder() -> RTDPushMessageContentChatChangePhotoBuilder {
    let instance = Self {
      td_name: "pushMessageContentChatChangePhoto".to_string(),
      
    };
    RTDPushMessageContentChatChangePhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentChatChangePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentChatChangePhotoBuilder { instance: PushMessageContentChatChangePhoto }

impl RTDPushMessageContentChatChangePhotoBuilder {
  fn new(instance: PushMessageContentChatChangePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatChangePhoto { self.instance.clone() }
  
}



/// A chat title was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatChangeTitle
  /// New chat title.
  title: Option<String>,
  
}



impl Object for PushMessageContentChatChangeTitle {}
impl RObject for PushMessageContentChatChangeTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatChangeTitle" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatChangeTitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatChangeTitle {}


impl PushMessageContentChatChangeTitle {
  
  pub fn builder() -> RTDPushMessageContentChatChangeTitleBuilder {
    let instance = Self {
      td_name: "pushMessageContentChatChangeTitle".to_string(),
      title: None,
      
    };
    RTDPushMessageContentChatChangeTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentChatChangeTitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentChatChangeTitleBuilder { instance: PushMessageContentChatChangeTitle }

impl RTDPushMessageContentChatChangeTitleBuilder {
  fn new(instance: PushMessageContentChatChangeTitle) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatChangeTitle { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatDeleteMember
  /// Name of the deleted member.
  member_name: Option<String>,
  /// True, if the current user was deleted from the group.
  is_current_user: Option<bool>,
  /// True, if the user has left the group himself.
  is_left: Option<bool>,
  
}



impl Object for PushMessageContentChatDeleteMember {}
impl RObject for PushMessageContentChatDeleteMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatDeleteMember" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatDeleteMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatDeleteMember {}


impl PushMessageContentChatDeleteMember {
  
  pub fn builder() -> RTDPushMessageContentChatDeleteMemberBuilder {
    let instance = Self {
      td_name: "pushMessageContentChatDeleteMember".to_string(),
      member_name: None,
      is_current_user: None,
      is_left: None,
      
    };
    RTDPushMessageContentChatDeleteMemberBuilder::new(instance)
  }
  
  
  pub fn member_name(&self) -> Option<String> { self.member_name.clone() }
  
  pub fn is_current_user(&self) -> Option<bool> { self.is_current_user.clone() }
  
  pub fn is_left(&self) -> Option<bool> { self.is_left.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentChatDeleteMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentChatDeleteMemberBuilder { instance: PushMessageContentChatDeleteMember }

impl RTDPushMessageContentChatDeleteMemberBuilder {
  fn new(instance: PushMessageContentChatDeleteMember) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatDeleteMember { self.instance.clone() }
  
  pub fn member_name<S: AsRef<str>>(&mut self, member_name: S) -> &mut Self {
    self.instance.member_name = Some(member_name.as_ref().to_string());
    self
  }
  
  pub fn is_current_user(&mut self, is_current_user: bool) -> &mut Self {
    self.instance.is_current_user = Some(is_current_user);
    self
  }
  
  pub fn is_left(&mut self, is_left: bool) -> &mut Self {
    self.instance.is_left = Some(is_left);
    self
  }
  
}



/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatJoinByLink
  
}



impl Object for PushMessageContentChatJoinByLink {}
impl RObject for PushMessageContentChatJoinByLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatJoinByLink" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatJoinByLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatJoinByLink {}


impl PushMessageContentChatJoinByLink {
  
  pub fn builder() -> RTDPushMessageContentChatJoinByLinkBuilder {
    let instance = Self {
      td_name: "pushMessageContentChatJoinByLink".to_string(),
      
    };
    RTDPushMessageContentChatJoinByLinkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentChatJoinByLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentChatJoinByLinkBuilder { instance: PushMessageContentChatJoinByLink }

impl RTDPushMessageContentChatJoinByLinkBuilder {
  fn new(instance: PushMessageContentChatJoinByLink) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatJoinByLink { self.instance.clone() }
  
}



/// A forwarded messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMessageForwards {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentMessageForwards
  /// Number of forwarded messages.
  total_count: Option<i32>,
  
}



impl Object for PushMessageContentMessageForwards {}
impl RObject for PushMessageContentMessageForwards {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentMessageForwards" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentMessageForwards }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentMessageForwards {}


impl PushMessageContentMessageForwards {
  
  pub fn builder() -> RTDPushMessageContentMessageForwardsBuilder {
    let instance = Self {
      td_name: "pushMessageContentMessageForwards".to_string(),
      total_count: None,
      
    };
    RTDPushMessageContentMessageForwardsBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentMessageForwards> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentMessageForwardsBuilder { instance: PushMessageContentMessageForwards }

impl RTDPushMessageContentMessageForwardsBuilder {
  fn new(instance: PushMessageContentMessageForwards) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentMessageForwards { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
}



/// A media album. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMediaAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentMediaAlbum
  /// Number of messages in the album.
  total_count: Option<i32>,
  /// True, if the album has at least one photo.
  has_photos: Option<bool>,
  /// True, if the album has at least one video.
  has_videos: Option<bool>,
  
}



impl Object for PushMessageContentMediaAlbum {}
impl RObject for PushMessageContentMediaAlbum {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentMediaAlbum" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentMediaAlbum }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentMediaAlbum {}


impl PushMessageContentMediaAlbum {
  
  pub fn builder() -> RTDPushMessageContentMediaAlbumBuilder {
    let instance = Self {
      td_name: "pushMessageContentMediaAlbum".to_string(),
      total_count: None,
      has_photos: None,
      has_videos: None,
      
    };
    RTDPushMessageContentMediaAlbumBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn has_photos(&self) -> Option<bool> { self.has_photos.clone() }
  
  pub fn has_videos(&self) -> Option<bool> { self.has_videos.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushMessageContentMediaAlbum> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushMessageContentMediaAlbumBuilder { instance: PushMessageContentMediaAlbum }

impl RTDPushMessageContentMediaAlbumBuilder {
  fn new(instance: PushMessageContentMediaAlbum) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentMediaAlbum { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn has_photos(&mut self, has_photos: bool) -> &mut Self {
    self.instance.has_photos = Some(has_photos);
    self
  }
  
  pub fn has_videos(&mut self, has_videos: bool) -> &mut Self {
    self.instance.has_videos = Some(has_videos);
    self
  }
  
}



/// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushReceiverId
  /// The globally unique identifier of push notification subscription.
  id: Option<i64>,
  
}



impl Object for PushReceiverId {}
impl RObject for PushReceiverId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushReceiverId" }
  fn td_type(&self) -> RTDType { RTDType::PushReceiverId }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl PushReceiverId {
  
  pub fn builder() -> RTDPushReceiverIdBuilder {
    let instance = Self {
      td_name: "pushReceiverId".to_string(),
      id: None,
      
    };
    RTDPushReceiverIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PushReceiverId> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPushReceiverIdBuilder { instance: PushReceiverId }

impl RTDPushReceiverIdBuilder {
  fn new(instance: PushReceiverId) -> Self { Self { instance } }

  pub fn build(&self) -> PushReceiverId { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}



/// Contains information about the current recovery email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoveryEmailAddress
  /// Recovery email address.
  recovery_email_address: Option<String>,
  
}



impl Object for RecoveryEmailAddress {}
impl RObject for RecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::RecoveryEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl RecoveryEmailAddress {
  
  pub fn builder() -> RTDRecoveryEmailAddressBuilder {
    let instance = Self {
      td_name: "recoveryEmailAddress".to_string(),
      recovery_email_address: None,
      
    };
    RTDRecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn recovery_email_address(&self) -> Option<String> { self.recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RecoveryEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRecoveryEmailAddressBuilder { instance: RecoveryEmailAddress }

impl RTDRecoveryEmailAddressBuilder {
  fn new(instance: RecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> RecoveryEmailAddress { self.instance.clone() }
  
  pub fn recovery_email_address<S: AsRef<str>>(&mut self, recovery_email_address: S) -> &mut Self {
    self.instance.recovery_email_address = Some(recovery_email_address.as_ref().to_string());
    self
  }
  
}



/// Represents a remote file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // remoteFile
  /// Remote file identifier; may be empty. Can be used across application restarts or even from other devices for the current user. If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and "#url#" as the conversion string. Clients should generate the file by downloading it to the specified location.
  id: Option<String>,
  /// True, if the file is currently being uploaded (or a remote copy is being generated by some other means).
  is_uploading_active: Option<bool>,
  /// True, if a remote copy is fully available.
  is_uploading_completed: Option<bool>,
  /// Size of the remote available part of the file; 0 if unknown.
  uploaded_size: Option<i32>,
  
}



impl Object for RemoteFile {}
impl RObject for RemoteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "remoteFile" }
  fn td_type(&self) -> RTDType { RTDType::RemoteFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl RemoteFile {
  
  pub fn builder() -> RTDRemoteFileBuilder {
    let instance = Self {
      td_name: "remoteFile".to_string(),
      id: None,
      is_uploading_active: None,
      is_uploading_completed: None,
      uploaded_size: None,
      
    };
    RTDRemoteFileBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn is_uploading_active(&self) -> Option<bool> { self.is_uploading_active.clone() }
  
  pub fn is_uploading_completed(&self) -> Option<bool> { self.is_uploading_completed.clone() }
  
  pub fn uploaded_size(&self) -> Option<i32> { self.uploaded_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoteFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoteFileBuilder { instance: RemoteFile }

impl RTDRemoteFileBuilder {
  fn new(instance: RemoteFile) -> Self { Self { instance } }

  pub fn build(&self) -> RemoteFile { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn is_uploading_active(&mut self, is_uploading_active: bool) -> &mut Self {
    self.instance.is_uploading_active = Some(is_uploading_active);
    self
  }
  
  pub fn is_uploading_completed(&mut self, is_uploading_completed: bool) -> &mut Self {
    self.instance.is_uploading_completed = Some(is_uploading_completed);
    self
  }
  
  pub fn uploaded_size(&mut self, uploaded_size: i32) -> &mut Self {
    self.instance.uploaded_size = Some(uploaded_size);
    self
  }
  
}



/// This class is an abstract base class. Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots. 
#[typetag::serde(tag = "@struct")]
pub trait ReplyMarkup: Object + RObject + Debug {}







impl ReplyMarkup {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<ReplyMarkup>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<ReplyMarkup> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDReplyMarkupType {
  ReplyMarkupForceReply,
  ReplyMarkupInlineKeyboard,
  ReplyMarkupRemoveKeyboard,
  ReplyMarkupShowKeyboard,
  
}
impl RTDReplyMarkupType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Instructs clients to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupRemoveKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupRemoveKeyboard
  /// True, if the keyboard is removed only for the mentioned users or the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupRemoveKeyboard {}
impl RObject for ReplyMarkupRemoveKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupRemoveKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupRemoveKeyboard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupRemoveKeyboard {}


impl ReplyMarkupRemoveKeyboard {
  
  pub fn builder() -> RTDReplyMarkupRemoveKeyboardBuilder {
    let instance = Self {
      td_name: "replyMarkupRemoveKeyboard".to_string(),
      is_personal: None,
      
    };
    RTDReplyMarkupRemoveKeyboardBuilder::new(instance)
  }
  
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReplyMarkupRemoveKeyboard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReplyMarkupRemoveKeyboardBuilder { instance: ReplyMarkupRemoveKeyboard }

impl RTDReplyMarkupRemoveKeyboardBuilder {
  fn new(instance: ReplyMarkupRemoveKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupRemoveKeyboard { self.instance.clone() }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}



/// Instructs clients to force a reply to this message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupForceReply {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupForceReply
  /// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupForceReply {}
impl RObject for ReplyMarkupForceReply {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupForceReply" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupForceReply }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupForceReply {}


impl ReplyMarkupForceReply {
  
  pub fn builder() -> RTDReplyMarkupForceReplyBuilder {
    let instance = Self {
      td_name: "replyMarkupForceReply".to_string(),
      is_personal: None,
      
    };
    RTDReplyMarkupForceReplyBuilder::new(instance)
  }
  
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReplyMarkupForceReply> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReplyMarkupForceReplyBuilder { instance: ReplyMarkupForceReply }

impl RTDReplyMarkupForceReplyBuilder {
  fn new(instance: ReplyMarkupForceReply) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupForceReply { self.instance.clone() }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}



/// Contains a custom keyboard layout to quickly reply to bots. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupShowKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupShowKeyboard
  /// A list of rows of bot keyboard buttons.
  rows: Option<Vec<Vec<KeyboardButton>>>,
  /// True, if the client needs to resize the keyboard vertically.
  resize_keyboard: Option<bool>,
  /// True, if the client needs to hide the keyboard after use.
  one_time: Option<bool>,
  /// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupShowKeyboard {}
impl RObject for ReplyMarkupShowKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupShowKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupShowKeyboard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupShowKeyboard {}


impl ReplyMarkupShowKeyboard {
  
  pub fn builder() -> RTDReplyMarkupShowKeyboardBuilder {
    let instance = Self {
      td_name: "replyMarkupShowKeyboard".to_string(),
      rows: None,
      resize_keyboard: None,
      one_time: None,
      is_personal: None,
      
    };
    RTDReplyMarkupShowKeyboardBuilder::new(instance)
  }
  
  
  pub fn rows(&self) -> Option<Vec<Vec<KeyboardButton>>> { self.rows.clone() }
  
  pub fn resize_keyboard(&self) -> Option<bool> { self.resize_keyboard.clone() }
  
  pub fn one_time(&self) -> Option<bool> { self.one_time.clone() }
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReplyMarkupShowKeyboard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReplyMarkupShowKeyboardBuilder { instance: ReplyMarkupShowKeyboard }

impl RTDReplyMarkupShowKeyboardBuilder {
  fn new(instance: ReplyMarkupShowKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupShowKeyboard { self.instance.clone() }
  
  pub fn rows(&mut self, rows: Vec<Vec<KeyboardButton>>) -> &mut Self {
    self.instance.rows = Some(rows);
    self
  }
  
  pub fn resize_keyboard(&mut self, resize_keyboard: bool) -> &mut Self {
    self.instance.resize_keyboard = Some(resize_keyboard);
    self
  }
  
  pub fn one_time(&mut self, one_time: bool) -> &mut Self {
    self.instance.one_time = Some(one_time);
    self
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}



/// Contains an inline keyboard layout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupInlineKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupInlineKeyboard
  /// A list of rows of inline keyboard buttons.
  rows: Option<Vec<Vec<InlineKeyboardButton>>>,
  
}



impl Object for ReplyMarkupInlineKeyboard {}
impl RObject for ReplyMarkupInlineKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupInlineKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupInlineKeyboard }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupInlineKeyboard {}


impl ReplyMarkupInlineKeyboard {
  
  pub fn builder() -> RTDReplyMarkupInlineKeyboardBuilder {
    let instance = Self {
      td_name: "replyMarkupInlineKeyboard".to_string(),
      rows: None,
      
    };
    RTDReplyMarkupInlineKeyboardBuilder::new(instance)
  }
  
  
  pub fn rows(&self) -> Option<Vec<Vec<InlineKeyboardButton>>> { self.rows.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReplyMarkupInlineKeyboard> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReplyMarkupInlineKeyboardBuilder { instance: ReplyMarkupInlineKeyboard }

impl RTDReplyMarkupInlineKeyboardBuilder {
  fn new(instance: ReplyMarkupInlineKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupInlineKeyboard { self.instance.clone() }
  
  pub fn rows(&mut self, rows: Vec<Vec<InlineKeyboardButton>>) -> &mut Self {
    self.instance.rows = Some(rows);
    self
  }
  
}



/// This class is an abstract base class. Describes a text object inside an instant-view web page. 
#[typetag::serde(tag = "@struct")]
pub trait RichText: Object + RObject + Debug {}







impl RichText {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<RichText>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<RichText> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDRichTextType {
  RichTextAnchor,
  RichTextBold,
  RichTextEmailAddress,
  RichTextFixed,
  RichTextIcon,
  RichTextItalic,
  RichTextMarked,
  RichTextPhoneNumber,
  RichTextPlain,
  RichTexts,
  RichTextStrikethrough,
  RichTextSubscript,
  RichTextSuperscript,
  RichTextUnderline,
  RichTextUrl,
  
}
impl RTDRichTextType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A plain text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextPlain {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextPlain
  /// Text.
  text: Option<String>,
  
}



impl Object for RichTextPlain {}
impl RObject for RichTextPlain {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextPlain" }
  fn td_type(&self) -> RTDType { RTDType::RichTextPlain }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextPlain {}


impl RichTextPlain {
  
  pub fn builder() -> RTDRichTextPlainBuilder {
    let instance = Self {
      td_name: "richTextPlain".to_string(),
      text: None,
      
    };
    RTDRichTextPlainBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextPlain> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextPlainBuilder { instance: RichTextPlain }

impl RTDRichTextPlainBuilder {
  fn new(instance: RichTextPlain) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextPlain { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// A bold rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextBold
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextBold {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextBold {}
impl RObject for RichTextBold {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextBold" }
  fn td_type(&self) -> RTDType { RTDType::RichTextBold }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextBold {}


impl RichTextBold {
  
  pub fn builder() -> RTDRichTextBoldBuilder {
    let instance = Self {
      td_name: "richTextBold".to_string(),
      text: None,
      
    };
    RTDRichTextBoldBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextBold> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextBoldBuilder { instance: RichTextBold }

impl RTDRichTextBoldBuilder {
  fn new(instance: RichTextBold) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextBold { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// An italicized rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextItalic
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextItalic {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextItalic {}
impl RObject for RichTextItalic {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextItalic" }
  fn td_type(&self) -> RTDType { RTDType::RichTextItalic }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextItalic {}


impl RichTextItalic {
  
  pub fn builder() -> RTDRichTextItalicBuilder {
    let instance = Self {
      td_name: "richTextItalic".to_string(),
      text: None,
      
    };
    RTDRichTextItalicBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextItalic> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextItalicBuilder { instance: RichTextItalic }

impl RTDRichTextItalicBuilder {
  fn new(instance: RichTextItalic) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextItalic { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// An underlined rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUnderline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextUnderline
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextUnderline {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextUnderline {}
impl RObject for RichTextUnderline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextUnderline" }
  fn td_type(&self) -> RTDType { RTDType::RichTextUnderline }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextUnderline {}


impl RichTextUnderline {
  
  pub fn builder() -> RTDRichTextUnderlineBuilder {
    let instance = Self {
      td_name: "richTextUnderline".to_string(),
      text: None,
      
    };
    RTDRichTextUnderlineBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextUnderline> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextUnderlineBuilder { instance: RichTextUnderline }

impl RTDRichTextUnderlineBuilder {
  fn new(instance: RichTextUnderline) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextUnderline { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A strike-through rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextStrikethrough {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextStrikethrough
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextStrikethrough {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextStrikethrough {}
impl RObject for RichTextStrikethrough {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextStrikethrough" }
  fn td_type(&self) -> RTDType { RTDType::RichTextStrikethrough }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextStrikethrough {}


impl RichTextStrikethrough {
  
  pub fn builder() -> RTDRichTextStrikethroughBuilder {
    let instance = Self {
      td_name: "richTextStrikethrough".to_string(),
      text: None,
      
    };
    RTDRichTextStrikethroughBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextStrikethrough> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextStrikethroughBuilder { instance: RichTextStrikethrough }

impl RTDRichTextStrikethroughBuilder {
  fn new(instance: RichTextStrikethrough) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextStrikethrough { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A fixed-width rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextFixed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextFixed
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextFixed {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextFixed {}
impl RObject for RichTextFixed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextFixed" }
  fn td_type(&self) -> RTDType { RTDType::RichTextFixed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextFixed {}


impl RichTextFixed {
  
  pub fn builder() -> RTDRichTextFixedBuilder {
    let instance = Self {
      td_name: "richTextFixed".to_string(),
      text: None,
      
    };
    RTDRichTextFixedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextFixed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextFixedBuilder { instance: RichTextFixed }

impl RTDRichTextFixedBuilder {
  fn new(instance: RichTextFixed) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextFixed { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A rich text URL link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextUrl
  /// Text.
  text: Option<Box<RichText>>,
  /// URL.
  url: Option<String>,
  
}


impl Clone for RichTextUrl {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextUrl {}
impl RObject for RichTextUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextUrl" }
  fn td_type(&self) -> RTDType { RTDType::RichTextUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextUrl {}


impl RichTextUrl {
  
  pub fn builder() -> RTDRichTextUrlBuilder {
    let instance = Self {
      td_name: "richTextUrl".to_string(),
      text: None,
      url: None,
      
    };
    RTDRichTextUrlBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextUrlBuilder { instance: RichTextUrl }

impl RTDRichTextUrlBuilder {
  fn new(instance: RichTextUrl) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextUrl { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// A rich text email link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextEmailAddress
  /// Text.
  text: Option<Box<RichText>>,
  /// Email address.
  email_address: Option<String>,
  
}


impl Clone for RichTextEmailAddress {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextEmailAddress {}
impl RObject for RichTextEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::RichTextEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextEmailAddress {}


impl RichTextEmailAddress {
  
  pub fn builder() -> RTDRichTextEmailAddressBuilder {
    let instance = Self {
      td_name: "richTextEmailAddress".to_string(),
      text: None,
      email_address: None,
      
    };
    RTDRichTextEmailAddressBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextEmailAddressBuilder { instance: RichTextEmailAddress }

impl RTDRichTextEmailAddressBuilder {
  fn new(instance: RichTextEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextEmailAddress { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn email_address<S: AsRef<str>>(&mut self, email_address: S) -> &mut Self {
    self.instance.email_address = Some(email_address.as_ref().to_string());
    self
  }
  
}



/// A subscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSubscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextSubscript
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextSubscript {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextSubscript {}
impl RObject for RichTextSubscript {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextSubscript" }
  fn td_type(&self) -> RTDType { RTDType::RichTextSubscript }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextSubscript {}


impl RichTextSubscript {
  
  pub fn builder() -> RTDRichTextSubscriptBuilder {
    let instance = Self {
      td_name: "richTextSubscript".to_string(),
      text: None,
      
    };
    RTDRichTextSubscriptBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextSubscript> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextSubscriptBuilder { instance: RichTextSubscript }

impl RTDRichTextSubscriptBuilder {
  fn new(instance: RichTextSubscript) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextSubscript { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A superscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSuperscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextSuperscript
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextSuperscript {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextSuperscript {}
impl RObject for RichTextSuperscript {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextSuperscript" }
  fn td_type(&self) -> RTDType { RTDType::RichTextSuperscript }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextSuperscript {}


impl RichTextSuperscript {
  
  pub fn builder() -> RTDRichTextSuperscriptBuilder {
    let instance = Self {
      td_name: "richTextSuperscript".to_string(),
      text: None,
      
    };
    RTDRichTextSuperscriptBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextSuperscript> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextSuperscriptBuilder { instance: RichTextSuperscript }

impl RTDRichTextSuperscriptBuilder {
  fn new(instance: RichTextSuperscript) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextSuperscript { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A marked rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextMarked {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextMarked
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextMarked {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextMarked {}
impl RObject for RichTextMarked {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextMarked" }
  fn td_type(&self) -> RTDType { RTDType::RichTextMarked }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextMarked {}


impl RichTextMarked {
  
  pub fn builder() -> RTDRichTextMarkedBuilder {
    let instance = Self {
      td_name: "richTextMarked".to_string(),
      text: None,
      
    };
    RTDRichTextMarkedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextMarked> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextMarkedBuilder { instance: RichTextMarked }

impl RTDRichTextMarkedBuilder {
  fn new(instance: RichTextMarked) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextMarked { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// A rich text phone number. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextPhoneNumber
  /// Text.
  text: Option<Box<RichText>>,
  /// Phone number.
  phone_number: Option<String>,
  
}


impl Clone for RichTextPhoneNumber {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextPhoneNumber {}
impl RObject for RichTextPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::RichTextPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextPhoneNumber {}


impl RichTextPhoneNumber {
  
  pub fn builder() -> RTDRichTextPhoneNumberBuilder {
    let instance = Self {
      td_name: "richTextPhoneNumber".to_string(),
      text: None,
      phone_number: None,
      
    };
    RTDRichTextPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextPhoneNumberBuilder { instance: RichTextPhoneNumber }

impl RTDRichTextPhoneNumberBuilder {
  fn new(instance: RichTextPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextPhoneNumber { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
}



/// A small image inside the text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextIcon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextIcon
  /// The image represented as a document. The image can be in GIF, JPEG or PNG format.
  document: Option<Document>,
  /// Width of a bounding box in which the image should be shown, 0 if unknown.
  width: Option<i32>,
  /// Height of a bounding box in which the image should be shown, 0 if unknown.
  height: Option<i32>,
  
}



impl Object for RichTextIcon {}
impl RObject for RichTextIcon {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextIcon" }
  fn td_type(&self) -> RTDType { RTDType::RichTextIcon }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextIcon {}


impl RichTextIcon {
  
  pub fn builder() -> RTDRichTextIconBuilder {
    let instance = Self {
      td_name: "richTextIcon".to_string(),
      document: None,
      width: None,
      height: None,
      
    };
    RTDRichTextIconBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextIcon> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextIconBuilder { instance: RichTextIcon }

impl RTDRichTextIconBuilder {
  fn new(instance: RichTextIcon) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextIcon { self.instance.clone() }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}



/// A rich text anchor. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextAnchor
  /// Text.
  text: Option<Box<RichText>>,
  /// Anchor name.
  name: Option<String>,
  
}


impl Clone for RichTextAnchor {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTextAnchor {}
impl RObject for RichTextAnchor {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextAnchor" }
  fn td_type(&self) -> RTDType { RTDType::RichTextAnchor }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTextAnchor {}


impl RichTextAnchor {
  
  pub fn builder() -> RTDRichTextAnchorBuilder {
    let instance = Self {
      td_name: "richTextAnchor".to_string(),
      text: None,
      name: None,
      
    };
    RTDRichTextAnchorBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTextAnchor> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextAnchorBuilder { instance: RichTextAnchor }

impl RTDRichTextAnchorBuilder {
  fn new(instance: RichTextAnchor) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextAnchor { self.instance.clone() }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
}



/// A concatenation of rich texts. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTexts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTexts
  /// Texts.
  texts: Option<Vec<Box<RichText>>>,
  
}


impl Clone for RichTexts {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RichTexts {}
impl RObject for RichTexts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTexts" }
  fn td_type(&self) -> RTDType { RTDType::RichTexts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl RichText for RichTexts {}


impl RichTexts {
  
  pub fn builder() -> RTDRichTextsBuilder {
    let instance = Self {
      td_name: "richTexts".to_string(),
      texts: None,
      
    };
    RTDRichTextsBuilder::new(instance)
  }
  
  
  pub fn texts(&self) -> Option<Vec<Box<RichText>>> { self.texts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RichTexts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRichTextsBuilder { instance: RichTexts }

impl RTDRichTextsBuilder {
  fn new(instance: RichTexts) -> Self { Self { instance } }

  pub fn build(&self) -> RichTexts { self.instance.clone() }
  
  pub fn texts(&mut self, texts: Vec<Box<RichText>>) -> &mut Self {
    self.instance.texts = Some(texts);
    self
  }
  
}



/// Contains information about saved card credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // savedCredentials
  /// Unique identifier of the saved credentials.
  id: Option<String>,
  /// Title of the saved credentials.
  title: Option<String>,
  
}



impl Object for SavedCredentials {}
impl RObject for SavedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "savedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::SavedCredentials }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl SavedCredentials {
  
  pub fn builder() -> RTDSavedCredentialsBuilder {
    let instance = Self {
      td_name: "savedCredentials".to_string(),
      id: None,
      title: None,
      
    };
    RTDSavedCredentialsBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SavedCredentials> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSavedCredentialsBuilder { instance: SavedCredentials }

impl RTDSavedCredentialsBuilder {
  fn new(instance: SavedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> SavedCredentials { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// Contains information about notification settings for several chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // scopeNotificationSettings
  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// True, if notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// True, if notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,
  
}



impl Object for ScopeNotificationSettings {}
impl RObject for ScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "scopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ScopeNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ScopeNotificationSettings {
  
  pub fn builder() -> RTDScopeNotificationSettingsBuilder {
    let instance = Self {
      td_name: "scopeNotificationSettings".to_string(),
      mute_for: None,
      sound: None,
      show_preview: None,
      disable_pinned_message_notifications: None,
      disable_mention_notifications: None,
      
    };
    RTDScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn mute_for(&self) -> Option<i32> { self.mute_for.clone() }
  
  pub fn sound(&self) -> Option<String> { self.sound.clone() }
  
  pub fn show_preview(&self) -> Option<bool> { self.show_preview.clone() }
  
  pub fn disable_pinned_message_notifications(&self) -> Option<bool> { self.disable_pinned_message_notifications.clone() }
  
  pub fn disable_mention_notifications(&self) -> Option<bool> { self.disable_mention_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ScopeNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDScopeNotificationSettingsBuilder { instance: ScopeNotificationSettings }

impl RTDScopeNotificationSettingsBuilder {
  fn new(instance: ScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ScopeNotificationSettings { self.instance.clone() }
  
  pub fn mute_for(&mut self, mute_for: i32) -> &mut Self {
    self.instance.mute_for = Some(mute_for);
    self
  }
  
  pub fn sound<S: AsRef<str>>(&mut self, sound: S) -> &mut Self {
    self.instance.sound = Some(sound.as_ref().to_string());
    self
  }
  
  pub fn show_preview(&mut self, show_preview: bool) -> &mut Self {
    self.instance.show_preview = Some(show_preview);
    self
  }
  
  pub fn disable_pinned_message_notifications(&mut self, disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.disable_pinned_message_notifications = Some(disable_pinned_message_notifications);
    self
  }
  
  pub fn disable_mention_notifications(&mut self, disable_mention_notifications: bool) -> &mut Self {
    self.instance.disable_mention_notifications = Some(disable_mention_notifications);
    self
  }
  
}



/// This class is an abstract base class. Represents a filter for message search results. 
#[typetag::serde(tag = "@struct")]
pub trait SearchMessagesFilter: Object + RObject + Debug {}







impl SearchMessagesFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<SearchMessagesFilter>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<SearchMessagesFilter> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSearchMessagesFilterType {
  SearchMessagesFilterAnimation,
  SearchMessagesFilterAudio,
  SearchMessagesFilterCall,
  SearchMessagesFilterChatPhoto,
  SearchMessagesFilterDocument,
  SearchMessagesFilterEmpty,
  SearchMessagesFilterMention,
  SearchMessagesFilterMissedCall,
  SearchMessagesFilterPhoto,
  SearchMessagesFilterPhotoAndVideo,
  SearchMessagesFilterUnreadMention,
  SearchMessagesFilterUrl,
  SearchMessagesFilterVideo,
  SearchMessagesFilterVideoNote,
  SearchMessagesFilterVoiceAndVideoNote,
  SearchMessagesFilterVoiceNote,
  
}
impl RTDSearchMessagesFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Returns all found messages, no filter is applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterEmpty
  
}



impl Object for SearchMessagesFilterEmpty {}
impl RObject for SearchMessagesFilterEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterEmpty" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterEmpty {}


impl SearchMessagesFilterEmpty {
  
  pub fn builder() -> RTDSearchMessagesFilterEmptyBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterEmpty".to_string(),
      
    };
    RTDSearchMessagesFilterEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterEmptyBuilder { instance: SearchMessagesFilterEmpty }

impl RTDSearchMessagesFilterEmptyBuilder {
  fn new(instance: SearchMessagesFilterEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterEmpty { self.instance.clone() }
  
}



/// Returns only animation messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterAnimation
  
}



impl Object for SearchMessagesFilterAnimation {}
impl RObject for SearchMessagesFilterAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterAnimation" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterAnimation {}


impl SearchMessagesFilterAnimation {
  
  pub fn builder() -> RTDSearchMessagesFilterAnimationBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterAnimation".to_string(),
      
    };
    RTDSearchMessagesFilterAnimationBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterAnimationBuilder { instance: SearchMessagesFilterAnimation }

impl RTDSearchMessagesFilterAnimationBuilder {
  fn new(instance: SearchMessagesFilterAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterAnimation { self.instance.clone() }
  
}



/// Returns only audio messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterAudio
  
}



impl Object for SearchMessagesFilterAudio {}
impl RObject for SearchMessagesFilterAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterAudio" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterAudio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterAudio {}


impl SearchMessagesFilterAudio {
  
  pub fn builder() -> RTDSearchMessagesFilterAudioBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterAudio".to_string(),
      
    };
    RTDSearchMessagesFilterAudioBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterAudio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterAudioBuilder { instance: SearchMessagesFilterAudio }

impl RTDSearchMessagesFilterAudioBuilder {
  fn new(instance: SearchMessagesFilterAudio) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterAudio { self.instance.clone() }
  
}



/// Returns only document messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterDocument
  
}



impl Object for SearchMessagesFilterDocument {}
impl RObject for SearchMessagesFilterDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterDocument" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterDocument }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterDocument {}


impl SearchMessagesFilterDocument {
  
  pub fn builder() -> RTDSearchMessagesFilterDocumentBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterDocument".to_string(),
      
    };
    RTDSearchMessagesFilterDocumentBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterDocument> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterDocumentBuilder { instance: SearchMessagesFilterDocument }

impl RTDSearchMessagesFilterDocumentBuilder {
  fn new(instance: SearchMessagesFilterDocument) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterDocument { self.instance.clone() }
  
}



/// Returns only photo messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterPhoto
  
}



impl Object for SearchMessagesFilterPhoto {}
impl RObject for SearchMessagesFilterPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterPhoto {}


impl SearchMessagesFilterPhoto {
  
  pub fn builder() -> RTDSearchMessagesFilterPhotoBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterPhoto".to_string(),
      
    };
    RTDSearchMessagesFilterPhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterPhotoBuilder { instance: SearchMessagesFilterPhoto }

impl RTDSearchMessagesFilterPhotoBuilder {
  fn new(instance: SearchMessagesFilterPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterPhoto { self.instance.clone() }
  
}



/// Returns only video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVideo
  
}



impl Object for SearchMessagesFilterVideo {}
impl RObject for SearchMessagesFilterVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVideo" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVideo {}


impl SearchMessagesFilterVideo {
  
  pub fn builder() -> RTDSearchMessagesFilterVideoBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterVideo".to_string(),
      
    };
    RTDSearchMessagesFilterVideoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterVideoBuilder { instance: SearchMessagesFilterVideo }

impl RTDSearchMessagesFilterVideoBuilder {
  fn new(instance: SearchMessagesFilterVideo) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVideo { self.instance.clone() }
  
}



/// Returns only voice note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVoiceNote
  
}



impl Object for SearchMessagesFilterVoiceNote {}
impl RObject for SearchMessagesFilterVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVoiceNote {}


impl SearchMessagesFilterVoiceNote {
  
  pub fn builder() -> RTDSearchMessagesFilterVoiceNoteBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterVoiceNote".to_string(),
      
    };
    RTDSearchMessagesFilterVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterVoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterVoiceNoteBuilder { instance: SearchMessagesFilterVoiceNote }

impl RTDSearchMessagesFilterVoiceNoteBuilder {
  fn new(instance: SearchMessagesFilterVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVoiceNote { self.instance.clone() }
  
}



/// Returns only photo and video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhotoAndVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterPhotoAndVideo
  
}



impl Object for SearchMessagesFilterPhotoAndVideo {}
impl RObject for SearchMessagesFilterPhotoAndVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterPhotoAndVideo" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterPhotoAndVideo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterPhotoAndVideo {}


impl SearchMessagesFilterPhotoAndVideo {
  
  pub fn builder() -> RTDSearchMessagesFilterPhotoAndVideoBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterPhotoAndVideo".to_string(),
      
    };
    RTDSearchMessagesFilterPhotoAndVideoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterPhotoAndVideo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterPhotoAndVideoBuilder { instance: SearchMessagesFilterPhotoAndVideo }

impl RTDSearchMessagesFilterPhotoAndVideoBuilder {
  fn new(instance: SearchMessagesFilterPhotoAndVideo) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterPhotoAndVideo { self.instance.clone() }
  
}



/// Returns only messages containing URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterUrl
  
}



impl Object for SearchMessagesFilterUrl {}
impl RObject for SearchMessagesFilterUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterUrl" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterUrl {}


impl SearchMessagesFilterUrl {
  
  pub fn builder() -> RTDSearchMessagesFilterUrlBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterUrl".to_string(),
      
    };
    RTDSearchMessagesFilterUrlBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterUrlBuilder { instance: SearchMessagesFilterUrl }

impl RTDSearchMessagesFilterUrlBuilder {
  fn new(instance: SearchMessagesFilterUrl) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterUrl { self.instance.clone() }
  
}



/// Returns only messages containing chat photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterChatPhoto
  
}



impl Object for SearchMessagesFilterChatPhoto {}
impl RObject for SearchMessagesFilterChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterChatPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterChatPhoto {}


impl SearchMessagesFilterChatPhoto {
  
  pub fn builder() -> RTDSearchMessagesFilterChatPhotoBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterChatPhoto".to_string(),
      
    };
    RTDSearchMessagesFilterChatPhotoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterChatPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterChatPhotoBuilder { instance: SearchMessagesFilterChatPhoto }

impl RTDSearchMessagesFilterChatPhotoBuilder {
  fn new(instance: SearchMessagesFilterChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterChatPhoto { self.instance.clone() }
  
}



/// Returns only call messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterCall
  
}



impl Object for SearchMessagesFilterCall {}
impl RObject for SearchMessagesFilterCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterCall" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterCall {}


impl SearchMessagesFilterCall {
  
  pub fn builder() -> RTDSearchMessagesFilterCallBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterCall".to_string(),
      
    };
    RTDSearchMessagesFilterCallBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterCallBuilder { instance: SearchMessagesFilterCall }

impl RTDSearchMessagesFilterCallBuilder {
  fn new(instance: SearchMessagesFilterCall) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterCall { self.instance.clone() }
  
}



/// Returns only incoming call messages with missed/declined discard reasons. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMissedCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterMissedCall
  
}



impl Object for SearchMessagesFilterMissedCall {}
impl RObject for SearchMessagesFilterMissedCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterMissedCall" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterMissedCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterMissedCall {}


impl SearchMessagesFilterMissedCall {
  
  pub fn builder() -> RTDSearchMessagesFilterMissedCallBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterMissedCall".to_string(),
      
    };
    RTDSearchMessagesFilterMissedCallBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterMissedCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterMissedCallBuilder { instance: SearchMessagesFilterMissedCall }

impl RTDSearchMessagesFilterMissedCallBuilder {
  fn new(instance: SearchMessagesFilterMissedCall) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterMissedCall { self.instance.clone() }
  
}



/// Returns only video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVideoNote
  
}



impl Object for SearchMessagesFilterVideoNote {}
impl RObject for SearchMessagesFilterVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVideoNote {}


impl SearchMessagesFilterVideoNote {
  
  pub fn builder() -> RTDSearchMessagesFilterVideoNoteBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterVideoNote".to_string(),
      
    };
    RTDSearchMessagesFilterVideoNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterVideoNoteBuilder { instance: SearchMessagesFilterVideoNote }

impl RTDSearchMessagesFilterVideoNoteBuilder {
  fn new(instance: SearchMessagesFilterVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVideoNote { self.instance.clone() }
  
}



/// Returns only voice and video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceAndVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVoiceAndVideoNote
  
}



impl Object for SearchMessagesFilterVoiceAndVideoNote {}
impl RObject for SearchMessagesFilterVoiceAndVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVoiceAndVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVoiceAndVideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVoiceAndVideoNote {}


impl SearchMessagesFilterVoiceAndVideoNote {
  
  pub fn builder() -> RTDSearchMessagesFilterVoiceAndVideoNoteBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterVoiceAndVideoNote".to_string(),
      
    };
    RTDSearchMessagesFilterVoiceAndVideoNoteBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterVoiceAndVideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterVoiceAndVideoNoteBuilder { instance: SearchMessagesFilterVoiceAndVideoNote }

impl RTDSearchMessagesFilterVoiceAndVideoNoteBuilder {
  fn new(instance: SearchMessagesFilterVoiceAndVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVoiceAndVideoNote { self.instance.clone() }
  
}



/// Returns only messages with mentions of the current user, or messages that are replies to their messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterMention
  
}



impl Object for SearchMessagesFilterMention {}
impl RObject for SearchMessagesFilterMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterMention" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterMention }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterMention {}


impl SearchMessagesFilterMention {
  
  pub fn builder() -> RTDSearchMessagesFilterMentionBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterMention".to_string(),
      
    };
    RTDSearchMessagesFilterMentionBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterMention> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterMentionBuilder { instance: SearchMessagesFilterMention }

impl RTDSearchMessagesFilterMentionBuilder {
  fn new(instance: SearchMessagesFilterMention) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterMention { self.instance.clone() }
  
}



/// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query or by the sending user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUnreadMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterUnreadMention
  
}



impl Object for SearchMessagesFilterUnreadMention {}
impl RObject for SearchMessagesFilterUnreadMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterUnreadMention" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterUnreadMention }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterUnreadMention {}


impl SearchMessagesFilterUnreadMention {
  
  pub fn builder() -> RTDSearchMessagesFilterUnreadMentionBuilder {
    let instance = Self {
      td_name: "searchMessagesFilterUnreadMention".to_string(),
      
    };
    RTDSearchMessagesFilterUnreadMentionBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessagesFilterUnreadMention> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesFilterUnreadMentionBuilder { instance: SearchMessagesFilterUnreadMention }

impl RTDSearchMessagesFilterUnreadMentionBuilder {
  fn new(instance: SearchMessagesFilterUnreadMention) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterUnreadMention { self.instance.clone() }
  
}



/// Contains a value representing a number of seconds. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Seconds {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // seconds
  /// Number of seconds.
  seconds: Option<f64>,
  
}



impl Object for Seconds {}
impl RObject for Seconds {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "seconds" }
  fn td_type(&self) -> RTDType { RTDType::Seconds }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Seconds {
  
  pub fn builder() -> RTDSecondsBuilder {
    let instance = Self {
      td_name: "seconds".to_string(),
      seconds: None,
      
    };
    RTDSecondsBuilder::new(instance)
  }
  
  
  pub fn seconds(&self) -> Option<f64> { self.seconds.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Seconds> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSecondsBuilder { instance: Seconds }

impl RTDSecondsBuilder {
  fn new(instance: Seconds) -> Self { Self { instance } }

  pub fn build(&self) -> Seconds { self.instance.clone() }
  
  pub fn seconds(&mut self, seconds: f64) -> &mut Self {
    self.instance.seconds = Some(seconds);
    self
  }
  
}



/// Represents a secret chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct SecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChat
  /// Secret chat identifier.
  id: Option<i32>,
  /// Identifier of the chat partner.
  user_id: Option<i32>,
  /// State of the secret chat.
  state: Option<Box<SecretChatState>>,
  /// True, if the chat was created by the current user; otherwise false.
  is_outbound: Option<bool>,
  /// Current message Time To Live setting (self-destruct timer) for the chat, in seconds.
  ttl: Option<i32>,
  /// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 bytes, which must be used to make a 12x12 square image with a color depth of 4. The first 16 bytes should be used to make a central 8x8 square, while the remaining 20 bytes should be used to construct a 2-pixel-wide border around that square. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers.
  key_hash: Option<String>,
  /// Secret chat layer; determines features supported by the other client. Video notes are supported if the layer >= 66.
  layer: Option<i32>,
  
}


impl Clone for SecretChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SecretChat {}
impl RObject for SecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChat" }
  fn td_type(&self) -> RTDType { RTDType::SecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl SecretChat {
  
  pub fn builder() -> RTDSecretChatBuilder {
    let instance = Self {
      td_name: "secretChat".to_string(),
      id: None,
      user_id: None,
      state: None,
      is_outbound: None,
      ttl: None,
      key_hash: None,
      layer: None,
      
    };
    RTDSecretChatBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn state(&self) -> Option<Box<SecretChatState>> { self.state.clone() }
  
  pub fn is_outbound(&self) -> Option<bool> { self.is_outbound.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn key_hash(&self) -> Option<String> { self.key_hash.clone() }
  
  pub fn layer(&self) -> Option<i32> { self.layer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSecretChatBuilder { instance: SecretChat }

impl RTDSecretChatBuilder {
  fn new(instance: SecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChat { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn state(&mut self, state: Box<SecretChatState>) -> &mut Self {
    self.instance.state = Some(state);
    self
  }
  
  pub fn is_outbound(&mut self, is_outbound: bool) -> &mut Self {
    self.instance.is_outbound = Some(is_outbound);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn key_hash<S: AsRef<str>>(&mut self, key_hash: S) -> &mut Self {
    self.instance.key_hash = Some(key_hash.as_ref().to_string());
    self
  }
  
  pub fn layer(&mut self, layer: i32) -> &mut Self {
    self.instance.layer = Some(layer);
    self
  }
  
}



/// This class is an abstract base class. Describes the current secret chat state. 
#[typetag::serde(tag = "@struct")]
pub trait SecretChatState: Object + RObject + Debug {}







impl SecretChatState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<SecretChatState>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<SecretChatState> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSecretChatStateType {
  SecretChatStateClosed,
  SecretChatStatePending,
  SecretChatStateReady,
  
}
impl RTDSecretChatStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The secret chat is not yet created; waiting for the other user to get online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStatePending
  
}



impl Object for SecretChatStatePending {}
impl RObject for SecretChatStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStatePending" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStatePending }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SecretChatState for SecretChatStatePending {}


impl SecretChatStatePending {
  
  pub fn builder() -> RTDSecretChatStatePendingBuilder {
    let instance = Self {
      td_name: "secretChatStatePending".to_string(),
      
    };
    RTDSecretChatStatePendingBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SecretChatStatePending> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSecretChatStatePendingBuilder { instance: SecretChatStatePending }

impl RTDSecretChatStatePendingBuilder {
  fn new(instance: SecretChatStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStatePending { self.instance.clone() }
  
}



/// The secret chat is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStateReady
  
}



impl Object for SecretChatStateReady {}
impl RObject for SecretChatStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStateReady" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStateReady }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SecretChatState for SecretChatStateReady {}


impl SecretChatStateReady {
  
  pub fn builder() -> RTDSecretChatStateReadyBuilder {
    let instance = Self {
      td_name: "secretChatStateReady".to_string(),
      
    };
    RTDSecretChatStateReadyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SecretChatStateReady> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSecretChatStateReadyBuilder { instance: SecretChatStateReady }

impl RTDSecretChatStateReadyBuilder {
  fn new(instance: SecretChatStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStateReady { self.instance.clone() }
  
}



/// The secret chat is closed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStateClosed
  
}



impl Object for SecretChatStateClosed {}
impl RObject for SecretChatStateClosed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStateClosed" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStateClosed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SecretChatState for SecretChatStateClosed {}


impl SecretChatStateClosed {
  
  pub fn builder() -> RTDSecretChatStateClosedBuilder {
    let instance = Self {
      td_name: "secretChatStateClosed".to_string(),
      
    };
    RTDSecretChatStateClosedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SecretChatStateClosed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSecretChatStateClosedBuilder { instance: SecretChatStateClosed }

impl RTDSecretChatStateClosedBuilder {
  fn new(instance: SecretChatStateClosed) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStateClosed { self.instance.clone() }
  
}



/// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Session {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // session
  /// Session identifier.
  id: Option<i64>,
  /// True, if this session is the current session.
  is_current: Option<bool>,
  /// True, if a password is needed to complete authorization of the session.
  is_password_pending: Option<bool>,
  /// Telegram API identifier, as provided by the application.
  api_id: Option<i32>,
  /// Name of the application, as provided by the application.
  application_name: Option<String>,
  /// The version of the application, as provided by the application.
  application_version: Option<String>,
  /// True, if the application is an official application or uses the api_id of an official application.
  is_official_application: Option<bool>,
  /// Model of the device the application has been run or is running on, as provided by the application.
  device_model: Option<String>,
  /// Operating system the application has been run or is running on, as provided by the application.
  platform: Option<String>,
  /// Version of the operating system the application has been run or is running on, as provided by the application.
  system_version: Option<String>,
  /// Point in time (Unix timestamp) when the user has logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when the session was last used.
  last_active_date: Option<i32>,
  /// IP address from which the session was created, in human-readable format.
  ip: Option<String>,
  /// A two-letter country code for the country from which the session was created, based on the IP address.
  country: Option<String>,
  /// Region code from which the session was created, based on the IP address.
  region: Option<String>,
  
}



impl Object for Session {}
impl RObject for Session {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "session" }
  fn td_type(&self) -> RTDType { RTDType::Session }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Session {
  
  pub fn builder() -> RTDSessionBuilder {
    let instance = Self {
      td_name: "session".to_string(),
      id: None,
      is_current: None,
      is_password_pending: None,
      api_id: None,
      application_name: None,
      application_version: None,
      is_official_application: None,
      device_model: None,
      platform: None,
      system_version: None,
      log_in_date: None,
      last_active_date: None,
      ip: None,
      country: None,
      region: None,
      
    };
    RTDSessionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn is_current(&self) -> Option<bool> { self.is_current.clone() }
  
  pub fn is_password_pending(&self) -> Option<bool> { self.is_password_pending.clone() }
  
  pub fn api_id(&self) -> Option<i32> { self.api_id.clone() }
  
  pub fn application_name(&self) -> Option<String> { self.application_name.clone() }
  
  pub fn application_version(&self) -> Option<String> { self.application_version.clone() }
  
  pub fn is_official_application(&self) -> Option<bool> { self.is_official_application.clone() }
  
  pub fn device_model(&self) -> Option<String> { self.device_model.clone() }
  
  pub fn platform(&self) -> Option<String> { self.platform.clone() }
  
  pub fn system_version(&self) -> Option<String> { self.system_version.clone() }
  
  pub fn log_in_date(&self) -> Option<i32> { self.log_in_date.clone() }
  
  pub fn last_active_date(&self) -> Option<i32> { self.last_active_date.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn country(&self) -> Option<String> { self.country.clone() }
  
  pub fn region(&self) -> Option<String> { self.region.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Session> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSessionBuilder { instance: Session }

impl RTDSessionBuilder {
  fn new(instance: Session) -> Self { Self { instance } }

  pub fn build(&self) -> Session { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn is_current(&mut self, is_current: bool) -> &mut Self {
    self.instance.is_current = Some(is_current);
    self
  }
  
  pub fn is_password_pending(&mut self, is_password_pending: bool) -> &mut Self {
    self.instance.is_password_pending = Some(is_password_pending);
    self
  }
  
  pub fn api_id(&mut self, api_id: i32) -> &mut Self {
    self.instance.api_id = Some(api_id);
    self
  }
  
  pub fn application_name<S: AsRef<str>>(&mut self, application_name: S) -> &mut Self {
    self.instance.application_name = Some(application_name.as_ref().to_string());
    self
  }
  
  pub fn application_version<S: AsRef<str>>(&mut self, application_version: S) -> &mut Self {
    self.instance.application_version = Some(application_version.as_ref().to_string());
    self
  }
  
  pub fn is_official_application(&mut self, is_official_application: bool) -> &mut Self {
    self.instance.is_official_application = Some(is_official_application);
    self
  }
  
  pub fn device_model<S: AsRef<str>>(&mut self, device_model: S) -> &mut Self {
    self.instance.device_model = Some(device_model.as_ref().to_string());
    self
  }
  
  pub fn platform<S: AsRef<str>>(&mut self, platform: S) -> &mut Self {
    self.instance.platform = Some(platform.as_ref().to_string());
    self
  }
  
  pub fn system_version<S: AsRef<str>>(&mut self, system_version: S) -> &mut Self {
    self.instance.system_version = Some(system_version.as_ref().to_string());
    self
  }
  
  pub fn log_in_date(&mut self, log_in_date: i32) -> &mut Self {
    self.instance.log_in_date = Some(log_in_date);
    self
  }
  
  pub fn last_active_date(&mut self, last_active_date: i32) -> &mut Self {
    self.instance.last_active_date = Some(last_active_date);
    self
  }
  
  pub fn ip<S: AsRef<str>>(&mut self, ip: S) -> &mut Self {
    self.instance.ip = Some(ip.as_ref().to_string());
    self
  }
  
  pub fn country<S: AsRef<str>>(&mut self, country: S) -> &mut Self {
    self.instance.country = Some(country.as_ref().to_string());
    self
  }
  
  pub fn region<S: AsRef<str>>(&mut self, region: S) -> &mut Self {
    self.instance.region = Some(region.as_ref().to_string());
    self
  }
  
}



/// Contains a list of sessions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sessions
  /// List of sessions.
  sessions: Option<Vec<Session>>,
  
}



impl Object for Sessions {}
impl RObject for Sessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sessions" }
  fn td_type(&self) -> RTDType { RTDType::Sessions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Sessions {
  
  pub fn builder() -> RTDSessionsBuilder {
    let instance = Self {
      td_name: "sessions".to_string(),
      sessions: None,
      
    };
    RTDSessionsBuilder::new(instance)
  }
  
  
  pub fn sessions(&self) -> Option<Vec<Session>> { self.sessions.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Sessions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSessionsBuilder { instance: Sessions }

impl RTDSessionsBuilder {
  fn new(instance: Sessions) -> Self { Self { instance } }

  pub fn build(&self) -> Sessions { self.instance.clone() }
  
  pub fn sessions(&mut self, sessions: Vec<Session>) -> &mut Self {
    self.instance.sessions = Some(sessions);
    self
  }
  
}



/// One shipping option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // shippingOption
  /// Shipping option identifier.
  id: Option<String>,
  /// Option title.
  title: Option<String>,
  /// A list of objects used to calculate the total shipping costs.
  price_parts: Option<Vec<LabeledPricePart>>,
  
}



impl Object for ShippingOption {}
impl RObject for ShippingOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "shippingOption" }
  fn td_type(&self) -> RTDType { RTDType::ShippingOption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ShippingOption {
  
  pub fn builder() -> RTDShippingOptionBuilder {
    let instance = Self {
      td_name: "shippingOption".to_string(),
      id: None,
      title: None,
      price_parts: None,
      
    };
    RTDShippingOptionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn price_parts(&self) -> Option<Vec<LabeledPricePart>> { self.price_parts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ShippingOption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDShippingOptionBuilder { instance: ShippingOption }

impl RTDShippingOptionBuilder {
  fn new(instance: ShippingOption) -> Self { Self { instance } }

  pub fn build(&self) -> ShippingOption { self.instance.clone() }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn price_parts(&mut self, price_parts: Vec<LabeledPricePart>) -> &mut Self {
    self.instance.price_parts = Some(price_parts);
    self
  }
  
}



/// Describes a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sticker
  /// The identifier of the sticker set to which the sticker belongs; 0 if none.
  set_id: Option<i64>,
  /// Sticker width; as defined by the sender.
  width: Option<i32>,
  /// Sticker height; as defined by the sender.
  height: Option<i32>,
  /// Emoji corresponding to the sticker.
  emoji: Option<String>,
  /// True, if the sticker is a mask.
  is_mask: Option<bool>,
  /// Position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,
  /// Sticker thumbnail in WEBP or JPEG format; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the sticker.
  sticker: Option<File>,
  
}



impl Object for Sticker {}
impl RObject for Sticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sticker" }
  fn td_type(&self) -> RTDType { RTDType::Sticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Sticker {
  
  pub fn builder() -> RTDStickerBuilder {
    let instance = Self {
      td_name: "sticker".to_string(),
      set_id: None,
      width: None,
      height: None,
      emoji: None,
      is_mask: None,
      mask_position: None,
      thumbnail: None,
      sticker: None,
      
    };
    RTDStickerBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn is_mask(&self) -> Option<bool> { self.is_mask.clone() }
  
  pub fn mask_position(&self) -> Option<MaskPosition> { self.mask_position.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn sticker(&self) -> Option<File> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Sticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickerBuilder { instance: Sticker }

impl RTDStickerBuilder {
  fn new(instance: Sticker) -> Self { Self { instance } }

  pub fn build(&self) -> Sticker { self.instance.clone() }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn emoji<S: AsRef<str>>(&mut self, emoji: S) -> &mut Self {
    self.instance.emoji = Some(emoji.as_ref().to_string());
    self
  }
  
  pub fn is_mask(&mut self, is_mask: bool) -> &mut Self {
    self.instance.is_mask = Some(is_mask);
    self
  }
  
  pub fn mask_position(&mut self, mask_position: MaskPosition) -> &mut Self {
    self.instance.mask_position = Some(mask_position);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn sticker(&mut self, sticker: File) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Represents a list of all emoji corresponding to a sticker in a sticker set. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerEmojis
  /// List of emojis.
  emojis: Option<Vec<String>>,
  
}



impl Object for StickerEmojis {}
impl RObject for StickerEmojis {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerEmojis" }
  fn td_type(&self) -> RTDType { RTDType::StickerEmojis }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StickerEmojis {
  
  pub fn builder() -> RTDStickerEmojisBuilder {
    let instance = Self {
      td_name: "stickerEmojis".to_string(),
      emojis: None,
      
    };
    RTDStickerEmojisBuilder::new(instance)
  }
  
  
  pub fn emojis(&self) -> Option<Vec<String>> { self.emojis.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StickerEmojis> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickerEmojisBuilder { instance: StickerEmojis }

impl RTDStickerEmojisBuilder {
  fn new(instance: StickerEmojis) -> Self { Self { instance } }

  pub fn build(&self) -> StickerEmojis { self.instance.clone() }
  
  pub fn emojis(&mut self, emojis: Vec<String>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
}



/// Represents a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSet
  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by the current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// List of stickers in this set.
  stickers: Option<Vec<Sticker>>,
  /// A list of emoji corresponding to the stickers in the same order.
  emojis: Option<Vec<StickerEmojis>>,
  
}



impl Object for StickerSet {}
impl RObject for StickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSet" }
  fn td_type(&self) -> RTDType { RTDType::StickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StickerSet {
  
  pub fn builder() -> RTDStickerSetBuilder {
    let instance = Self {
      td_name: "stickerSet".to_string(),
      id: None,
      title: None,
      name: None,
      is_installed: None,
      is_archived: None,
      is_official: None,
      is_masks: None,
      is_viewed: None,
      stickers: None,
      emojis: None,
      
    };
    RTDStickerSetBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn stickers(&self) -> Option<Vec<Sticker>> { self.stickers.clone() }
  
  pub fn emojis(&self) -> Option<Vec<StickerEmojis>> { self.emojis.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickerSetBuilder { instance: StickerSet }

impl RTDStickerSetBuilder {
  fn new(instance: StickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSet { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn stickers(&mut self, stickers: Vec<Sticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
  pub fn emojis(&mut self, emojis: Vec<StickerEmojis>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
}



/// Represents short information about a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSetInfo
  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// Total number of stickers in the set.
  size: Option<i32>,
  /// Contains up to the first 5 stickers from the set, depending on the context. If the client needs more stickers the full set should be requested.
  covers: Option<Vec<Sticker>>,
  
}



impl Object for StickerSetInfo {}
impl RObject for StickerSetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSetInfo" }
  fn td_type(&self) -> RTDType { RTDType::StickerSetInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StickerSetInfo {
  
  pub fn builder() -> RTDStickerSetInfoBuilder {
    let instance = Self {
      td_name: "stickerSetInfo".to_string(),
      id: None,
      title: None,
      name: None,
      is_installed: None,
      is_archived: None,
      is_official: None,
      is_masks: None,
      is_viewed: None,
      size: None,
      covers: None,
      
    };
    RTDStickerSetInfoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn size(&self) -> Option<i32> { self.size.clone() }
  
  pub fn covers(&self) -> Option<Vec<Sticker>> { self.covers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StickerSetInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickerSetInfoBuilder { instance: StickerSetInfo }

impl RTDStickerSetInfoBuilder {
  fn new(instance: StickerSetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSetInfo { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn size(&mut self, size: i32) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn covers(&mut self, covers: Vec<Sticker>) -> &mut Self {
    self.instance.covers = Some(covers);
    self
  }
  
}



/// Represents a list of sticker sets. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSets
  /// Approximate total number of sticker sets found.
  total_count: Option<i32>,
  /// List of sticker sets.
  sets: Option<Vec<StickerSetInfo>>,
  
}



impl Object for StickerSets {}
impl RObject for StickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSets" }
  fn td_type(&self) -> RTDType { RTDType::StickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StickerSets {
  
  pub fn builder() -> RTDStickerSetsBuilder {
    let instance = Self {
      td_name: "stickerSets".to_string(),
      total_count: None,
      sets: None,
      
    };
    RTDStickerSetsBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn sets(&self) -> Option<Vec<StickerSetInfo>> { self.sets.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickerSetsBuilder { instance: StickerSets }

impl RTDStickerSetsBuilder {
  fn new(instance: StickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSets { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn sets(&mut self, sets: Vec<StickerSetInfo>) -> &mut Self {
    self.instance.sets = Some(sets);
    self
  }
  
}



/// Represents a list of stickers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Stickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickers
  /// List of stickers.
  stickers: Option<Vec<Sticker>>,
  
}



impl Object for Stickers {}
impl RObject for Stickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickers" }
  fn td_type(&self) -> RTDType { RTDType::Stickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Stickers {
  
  pub fn builder() -> RTDStickersBuilder {
    let instance = Self {
      td_name: "stickers".to_string(),
      stickers: None,
      
    };
    RTDStickersBuilder::new(instance)
  }
  
  
  pub fn stickers(&self) -> Option<Vec<Sticker>> { self.stickers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Stickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStickersBuilder { instance: Stickers }

impl RTDStickersBuilder {
  fn new(instance: Stickers) -> Self { Self { instance } }

  pub fn build(&self) -> Stickers { self.instance.clone() }
  
  pub fn stickers(&mut self, stickers: Vec<Sticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
}



/// Contains the exact storage usage statistics split by chats and file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatistics
  /// Total size of files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,
  /// Statistics split by chats.
  by_chat: Option<Vec<StorageStatisticsByChat>>,
  
}



impl Object for StorageStatistics {}
impl RObject for StorageStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatistics" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StorageStatistics {
  
  pub fn builder() -> RTDStorageStatisticsBuilder {
    let instance = Self {
      td_name: "storageStatistics".to_string(),
      size: None,
      count: None,
      by_chat: None,
      
    };
    RTDStorageStatisticsBuilder::new(instance)
  }
  
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn by_chat(&self) -> Option<Vec<StorageStatisticsByChat>> { self.by_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StorageStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStorageStatisticsBuilder { instance: StorageStatistics }

impl RTDStorageStatisticsBuilder {
  fn new(instance: StorageStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatistics { self.instance.clone() }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn by_chat(&mut self, by_chat: Vec<StorageStatisticsByChat>) -> &mut Self {
    self.instance.by_chat = Some(by_chat);
    self
  }
  
}



/// Contains the storage usage statistics for a specific chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsByChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsByChat
  /// Chat identifier; 0 if none.
  chat_id: Option<i64>,
  /// Total size of the files in the chat.
  size: Option<i64>,
  /// Total number of files in the chat.
  count: Option<i32>,
  /// Statistics split by file types.
  by_file_type: Option<Vec<StorageStatisticsByFileType>>,
  
}



impl Object for StorageStatisticsByChat {}
impl RObject for StorageStatisticsByChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsByChat" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsByChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StorageStatisticsByChat {
  
  pub fn builder() -> RTDStorageStatisticsByChatBuilder {
    let instance = Self {
      td_name: "storageStatisticsByChat".to_string(),
      chat_id: None,
      size: None,
      count: None,
      by_file_type: None,
      
    };
    RTDStorageStatisticsByChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn by_file_type(&self) -> Option<Vec<StorageStatisticsByFileType>> { self.by_file_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StorageStatisticsByChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStorageStatisticsByChatBuilder { instance: StorageStatisticsByChat }

impl RTDStorageStatisticsByChatBuilder {
  fn new(instance: StorageStatisticsByChat) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsByChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn by_file_type(&mut self, by_file_type: Vec<StorageStatisticsByFileType>) -> &mut Self {
    self.instance.by_file_type = Some(by_file_type);
    self
  }
  
}



/// Contains the storage usage statistics for a specific file type. 
#[derive(Debug, Serialize, Deserialize)]
pub struct StorageStatisticsByFileType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsByFileType
  /// File type.
  file_type: Option<Box<FileType>>,
  /// Total size of the files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,
  
}


impl Clone for StorageStatisticsByFileType {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for StorageStatisticsByFileType {}
impl RObject for StorageStatisticsByFileType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsByFileType" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsByFileType }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StorageStatisticsByFileType {
  
  pub fn builder() -> RTDStorageStatisticsByFileTypeBuilder {
    let instance = Self {
      td_name: "storageStatisticsByFileType".to_string(),
      file_type: None,
      size: None,
      count: None,
      
    };
    RTDStorageStatisticsByFileTypeBuilder::new(instance)
  }
  
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StorageStatisticsByFileType> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStorageStatisticsByFileTypeBuilder { instance: StorageStatisticsByFileType }

impl RTDStorageStatisticsByFileTypeBuilder {
  fn new(instance: StorageStatisticsByFileType) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsByFileType { self.instance.clone() }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}



/// Contains approximate storage usage statistics, excluding files of unknown file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsFast
  /// Approximate total size of files.
  files_size: Option<i64>,
  /// Approximate number of files.
  file_count: Option<i32>,
  /// Size of the database.
  database_size: Option<i64>,
  /// Size of the language pack database.
  language_pack_database_size: Option<i64>,
  /// Size of the TDLib internal log.
  log_size: Option<i64>,
  
}



impl Object for StorageStatisticsFast {}
impl RObject for StorageStatisticsFast {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsFast" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsFast }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl StorageStatisticsFast {
  
  pub fn builder() -> RTDStorageStatisticsFastBuilder {
    let instance = Self {
      td_name: "storageStatisticsFast".to_string(),
      files_size: None,
      file_count: None,
      database_size: None,
      language_pack_database_size: None,
      log_size: None,
      
    };
    RTDStorageStatisticsFastBuilder::new(instance)
  }
  
  
  pub fn files_size(&self) -> Option<i64> { self.files_size.clone() }
  
  pub fn file_count(&self) -> Option<i32> { self.file_count.clone() }
  
  pub fn database_size(&self) -> Option<i64> { self.database_size.clone() }
  
  pub fn language_pack_database_size(&self) -> Option<i64> { self.language_pack_database_size.clone() }
  
  pub fn log_size(&self) -> Option<i64> { self.log_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StorageStatisticsFast> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStorageStatisticsFastBuilder { instance: StorageStatisticsFast }

impl RTDStorageStatisticsFastBuilder {
  fn new(instance: StorageStatisticsFast) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsFast { self.instance.clone() }
  
  pub fn files_size(&mut self, files_size: i64) -> &mut Self {
    self.instance.files_size = Some(files_size);
    self
  }
  
  pub fn file_count(&mut self, file_count: i32) -> &mut Self {
    self.instance.file_count = Some(file_count);
    self
  }
  
  pub fn database_size(&mut self, database_size: i64) -> &mut Self {
    self.instance.database_size = Some(database_size);
    self
  }
  
  pub fn language_pack_database_size(&mut self, language_pack_database_size: i64) -> &mut Self {
    self.instance.language_pack_database_size = Some(language_pack_database_size);
    self
  }
  
  pub fn log_size(&mut self, log_size: i64) -> &mut Self {
    self.instance.log_size = Some(log_size);
    self
  }
  
}



/// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Supergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroup
  /// Supergroup or channel identifier.
  id: Option<i32>,
  /// Username of the supergroup or channel; empty for private supergroups or channels.
  username: Option<String>,
  /// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member.
  date: Option<i32>,
  /// Status of the current user in the supergroup or channel.
  status: Option<Box<ChatMemberStatus>>,
  /// Member count; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was found through SearchPublicChats.
  member_count: Option<i32>,
  /// True, if any member of the supergroup can invite other members. This field has no meaning for channels.
  anyone_can_invite: Option<bool>,
  /// True, if messages sent to the channel should contain information about the sender. This field is only applicable to channels.
  sign_messages: Option<bool>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,
  /// True, if the supergroup or channel is verified.
  is_verified: Option<bool>,
  /// If non-empty, contains the reason why access to this supergroup or channel must be restricted. Format of the string is "{type}: {description}". {type} Contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,
  
}


impl Clone for Supergroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Supergroup {}
impl RObject for Supergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroup" }
  fn td_type(&self) -> RTDType { RTDType::Supergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Supergroup {
  
  pub fn builder() -> RTDSupergroupBuilder {
    let instance = Self {
      td_name: "supergroup".to_string(),
      id: None,
      username: None,
      date: None,
      status: None,
      member_count: None,
      anyone_can_invite: None,
      sign_messages: None,
      is_channel: None,
      is_verified: None,
      restriction_reason: None,
      
    };
    RTDSupergroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn is_verified(&self) -> Option<bool> { self.is_verified.clone() }
  
  pub fn restriction_reason(&self) -> Option<String> { self.restriction_reason.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Supergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupBuilder { instance: Supergroup }

impl RTDSupergroupBuilder {
  fn new(instance: Supergroup) -> Self { Self { instance } }

  pub fn build(&self) -> Supergroup { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
  pub fn is_verified(&mut self, is_verified: bool) -> &mut Self {
    self.instance.is_verified = Some(is_verified);
    self
  }
  
  pub fn restriction_reason<S: AsRef<str>>(&mut self, restriction_reason: S) -> &mut Self {
    self.instance.restriction_reason = Some(restriction_reason.as_ref().to_string());
    self
  }
  
}



/// Contains full information about a supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupFullInfo
  /// Supergroup or channel description.
  description: Option<String>,
  /// Number of members in the supergroup or channel; 0 if unknown.
  member_count: Option<i32>,
  /// Number of privileged users in the supergroup or channel; 0 if unknown.
  administrator_count: Option<i32>,
  /// Number of restricted users in the supergroup; 0 if unknown.
  restricted_count: Option<i32>,
  /// Number of users banned from chat; 0 if unknown.
  banned_count: Option<i32>,
  /// True, if members of the chat can be retrieved.
  can_get_members: Option<bool>,
  /// True, if the chat can be made public.
  can_set_username: Option<bool>,
  /// True, if the supergroup sticker set can be changed.
  can_set_sticker_set: Option<bool>,
  /// True, if the channel statistics is available through getChatStatisticsUrl.
  can_view_statistics: Option<bool>,
  /// True, if new chat members will have access to old messages. In public supergroups and both public and private channels, old messages are always available, so this option affects only private supergroups. The value of this field is only available for chat administrators.
  is_all_history_available: Option<bool>,
  /// Identifier of the supergroup sticker set; 0 if none.
  sticker_set_id: Option<i64>,
  /// Invite link for this chat.
  invite_link: Option<String>,
  /// Identifier of the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_basic_group_id: Option<i32>,
  /// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_max_message_id: Option<i64>,
  
}



impl Object for SupergroupFullInfo {}
impl RObject for SupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl SupergroupFullInfo {
  
  pub fn builder() -> RTDSupergroupFullInfoBuilder {
    let instance = Self {
      td_name: "supergroupFullInfo".to_string(),
      description: None,
      member_count: None,
      administrator_count: None,
      restricted_count: None,
      banned_count: None,
      can_get_members: None,
      can_set_username: None,
      can_set_sticker_set: None,
      can_view_statistics: None,
      is_all_history_available: None,
      sticker_set_id: None,
      invite_link: None,
      upgraded_from_basic_group_id: None,
      upgraded_from_max_message_id: None,
      
    };
    RTDSupergroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn administrator_count(&self) -> Option<i32> { self.administrator_count.clone() }
  
  pub fn restricted_count(&self) -> Option<i32> { self.restricted_count.clone() }
  
  pub fn banned_count(&self) -> Option<i32> { self.banned_count.clone() }
  
  pub fn can_get_members(&self) -> Option<bool> { self.can_get_members.clone() }
  
  pub fn can_set_username(&self) -> Option<bool> { self.can_set_username.clone() }
  
  pub fn can_set_sticker_set(&self) -> Option<bool> { self.can_set_sticker_set.clone() }
  
  pub fn can_view_statistics(&self) -> Option<bool> { self.can_view_statistics.clone() }
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn upgraded_from_basic_group_id(&self) -> Option<i32> { self.upgraded_from_basic_group_id.clone() }
  
  pub fn upgraded_from_max_message_id(&self) -> Option<i64> { self.upgraded_from_max_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupFullInfoBuilder { instance: SupergroupFullInfo }

impl RTDSupergroupFullInfoBuilder {
  fn new(instance: SupergroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupFullInfo { self.instance.clone() }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn administrator_count(&mut self, administrator_count: i32) -> &mut Self {
    self.instance.administrator_count = Some(administrator_count);
    self
  }
  
  pub fn restricted_count(&mut self, restricted_count: i32) -> &mut Self {
    self.instance.restricted_count = Some(restricted_count);
    self
  }
  
  pub fn banned_count(&mut self, banned_count: i32) -> &mut Self {
    self.instance.banned_count = Some(banned_count);
    self
  }
  
  pub fn can_get_members(&mut self, can_get_members: bool) -> &mut Self {
    self.instance.can_get_members = Some(can_get_members);
    self
  }
  
  pub fn can_set_username(&mut self, can_set_username: bool) -> &mut Self {
    self.instance.can_set_username = Some(can_set_username);
    self
  }
  
  pub fn can_set_sticker_set(&mut self, can_set_sticker_set: bool) -> &mut Self {
    self.instance.can_set_sticker_set = Some(can_set_sticker_set);
    self
  }
  
  pub fn can_view_statistics(&mut self, can_view_statistics: bool) -> &mut Self {
    self.instance.can_view_statistics = Some(can_view_statistics);
    self
  }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
  pub fn invite_link<S: AsRef<str>>(&mut self, invite_link: S) -> &mut Self {
    self.instance.invite_link = Some(invite_link.as_ref().to_string());
    self
  }
  
  pub fn upgraded_from_basic_group_id(&mut self, upgraded_from_basic_group_id: i32) -> &mut Self {
    self.instance.upgraded_from_basic_group_id = Some(upgraded_from_basic_group_id);
    self
  }
  
  pub fn upgraded_from_max_message_id(&mut self, upgraded_from_max_message_id: i64) -> &mut Self {
    self.instance.upgraded_from_max_message_id = Some(upgraded_from_max_message_id);
    self
  }
  
}



/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait SupergroupMembersFilter: Object + RObject + Debug {}







impl SupergroupMembersFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<SupergroupMembersFilter>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<SupergroupMembersFilter> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSupergroupMembersFilterType {
  SupergroupMembersFilterAdministrators,
  SupergroupMembersFilterBanned,
  SupergroupMembersFilterBots,
  SupergroupMembersFilterRecent,
  SupergroupMembersFilterRestricted,
  SupergroupMembersFilterSearch,
  
}
impl RTDSupergroupMembersFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// Returns recently active users in reverse chronological order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRecent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterRecent
  
}



impl Object for SupergroupMembersFilterRecent {}
impl RObject for SupergroupMembersFilterRecent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterRecent" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterRecent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterRecent {}


impl SupergroupMembersFilterRecent {
  
  pub fn builder() -> RTDSupergroupMembersFilterRecentBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterRecent".to_string(),
      
    };
    RTDSupergroupMembersFilterRecentBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterRecent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterRecentBuilder { instance: SupergroupMembersFilterRecent }

impl RTDSupergroupMembersFilterRecentBuilder {
  fn new(instance: SupergroupMembersFilterRecent) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterRecent { self.instance.clone() }
  
}



/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterAdministrators
  
}



impl Object for SupergroupMembersFilterAdministrators {}
impl RObject for SupergroupMembersFilterAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterAdministrators }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterAdministrators {}


impl SupergroupMembersFilterAdministrators {
  
  pub fn builder() -> RTDSupergroupMembersFilterAdministratorsBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterAdministrators".to_string(),
      
    };
    RTDSupergroupMembersFilterAdministratorsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterAdministrators> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterAdministratorsBuilder { instance: SupergroupMembersFilterAdministrators }

impl RTDSupergroupMembersFilterAdministratorsBuilder {
  fn new(instance: SupergroupMembersFilterAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterAdministrators { self.instance.clone() }
  
}



/// Used to search for supergroup or channel members via a (string) query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterSearch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterSearch
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterSearch {}
impl RObject for SupergroupMembersFilterSearch {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterSearch" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterSearch }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterSearch {}


impl SupergroupMembersFilterSearch {
  
  pub fn builder() -> RTDSupergroupMembersFilterSearchBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterSearch".to_string(),
      query: None,
      
    };
    RTDSupergroupMembersFilterSearchBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterSearch> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterSearchBuilder { instance: SupergroupMembersFilterSearch }

impl RTDSupergroupMembersFilterSearchBuilder {
  fn new(instance: SupergroupMembersFilterSearch) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterSearch { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
}



/// Returns restricted supergroup members; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterRestricted
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterRestricted {}
impl RObject for SupergroupMembersFilterRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterRestricted" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterRestricted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterRestricted {}


impl SupergroupMembersFilterRestricted {
  
  pub fn builder() -> RTDSupergroupMembersFilterRestrictedBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterRestricted".to_string(),
      query: None,
      
    };
    RTDSupergroupMembersFilterRestrictedBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterRestricted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterRestrictedBuilder { instance: SupergroupMembersFilterRestricted }

impl RTDSupergroupMembersFilterRestrictedBuilder {
  fn new(instance: SupergroupMembersFilterRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterRestricted { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
}



/// Returns users banned from the supergroup or channel; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterBanned
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterBanned {}
impl RObject for SupergroupMembersFilterBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterBanned" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterBanned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterBanned {}


impl SupergroupMembersFilterBanned {
  
  pub fn builder() -> RTDSupergroupMembersFilterBannedBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterBanned".to_string(),
      query: None,
      
    };
    RTDSupergroupMembersFilterBannedBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterBanned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterBannedBuilder { instance: SupergroupMembersFilterBanned }

impl RTDSupergroupMembersFilterBannedBuilder {
  fn new(instance: SupergroupMembersFilterBanned) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterBanned { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
}



/// Returns bot members of the supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterBots
  
}



impl Object for SupergroupMembersFilterBots {}
impl RObject for SupergroupMembersFilterBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterBots" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterBots }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterBots {}


impl SupergroupMembersFilterBots {
  
  pub fn builder() -> RTDSupergroupMembersFilterBotsBuilder {
    let instance = Self {
      td_name: "supergroupMembersFilterBots".to_string(),
      
    };
    RTDSupergroupMembersFilterBotsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SupergroupMembersFilterBots> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSupergroupMembersFilterBotsBuilder { instance: SupergroupMembersFilterBots }

impl RTDSupergroupMembersFilterBotsBuilder {
  fn new(instance: SupergroupMembersFilterBots) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterBots { self.instance.clone() }
  
}



/// Represents a URL linking to an internal Telegram entity. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TMeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrl
  /// URL.
  url: Option<String>,
  /// Type of the URL.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TMeUrlType>>,
  
}


impl Clone for TMeUrl {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for TMeUrl {}
impl RObject for TMeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrl" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TMeUrl {
  
  pub fn builder() -> RTDTMeUrlBuilder {
    let instance = Self {
      td_name: "tMeUrl".to_string(),
      url: None,
      type_: None,
      
    };
    RTDTMeUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn type_(&self) -> Option<Box<TMeUrlType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlBuilder { instance: TMeUrl }

impl RTDTMeUrlBuilder {
  fn new(instance: TMeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrl { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn type_(&mut self, type_: Box<TMeUrlType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// This class is an abstract base class. Describes the type of a URL linking to an internal Telegram entity. 
#[typetag::serde(tag = "@struct")]
pub trait TMeUrlType: Object + RObject + Debug {}







impl TMeUrlType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<TMeUrlType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<TMeUrlType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTMeUrlTypeType {
  TMeUrlTypeChatInvite,
  TMeUrlTypeStickerSet,
  TMeUrlTypeSupergroup,
  TMeUrlTypeUser,
  
}
impl RTDTMeUrlTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A URL linking to a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeUser
  /// Identifier of the user.
  user_id: Option<i32>,
  
}



impl Object for TMeUrlTypeUser {}
impl RObject for TMeUrlTypeUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeUser" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeUser {}


impl TMeUrlTypeUser {
  
  pub fn builder() -> RTDTMeUrlTypeUserBuilder {
    let instance = Self {
      td_name: "tMeUrlTypeUser".to_string(),
      user_id: None,
      
    };
    RTDTMeUrlTypeUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrlTypeUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlTypeUserBuilder { instance: TMeUrlTypeUser }

impl RTDTMeUrlTypeUserBuilder {
  fn new(instance: TMeUrlTypeUser) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeUser { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// A URL linking to a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeSupergroup
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i64>,
  
}



impl Object for TMeUrlTypeSupergroup {}
impl RObject for TMeUrlTypeSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeSupergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeSupergroup {}


impl TMeUrlTypeSupergroup {
  
  pub fn builder() -> RTDTMeUrlTypeSupergroupBuilder {
    let instance = Self {
      td_name: "tMeUrlTypeSupergroup".to_string(),
      supergroup_id: None,
      
    };
    RTDTMeUrlTypeSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i64> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrlTypeSupergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlTypeSupergroupBuilder { instance: TMeUrlTypeSupergroup }

impl RTDTMeUrlTypeSupergroupBuilder {
  fn new(instance: TMeUrlTypeSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeSupergroup { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i64) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}



/// A chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeChatInvite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeChatInvite
  /// Chat invite link info.
  info: Option<ChatInviteLinkInfo>,
  
}



impl Object for TMeUrlTypeChatInvite {}
impl RObject for TMeUrlTypeChatInvite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeChatInvite" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeChatInvite }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeChatInvite {}


impl TMeUrlTypeChatInvite {
  
  pub fn builder() -> RTDTMeUrlTypeChatInviteBuilder {
    let instance = Self {
      td_name: "tMeUrlTypeChatInvite".to_string(),
      info: None,
      
    };
    RTDTMeUrlTypeChatInviteBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> Option<ChatInviteLinkInfo> { self.info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrlTypeChatInvite> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlTypeChatInviteBuilder { instance: TMeUrlTypeChatInvite }

impl RTDTMeUrlTypeChatInviteBuilder {
  fn new(instance: TMeUrlTypeChatInvite) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeChatInvite { self.instance.clone() }
  
  pub fn info(&mut self, info: ChatInviteLinkInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
}



/// A URL linking to a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeStickerSet
  /// Identifier of the sticker set.
  sticker_set_id: Option<i64>,
  
}



impl Object for TMeUrlTypeStickerSet {}
impl RObject for TMeUrlTypeStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeStickerSet {}


impl TMeUrlTypeStickerSet {
  
  pub fn builder() -> RTDTMeUrlTypeStickerSetBuilder {
    let instance = Self {
      td_name: "tMeUrlTypeStickerSet".to_string(),
      sticker_set_id: None,
      
    };
    RTDTMeUrlTypeStickerSetBuilder::new(instance)
  }
  
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrlTypeStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlTypeStickerSetBuilder { instance: TMeUrlTypeStickerSet }

impl RTDTMeUrlTypeStickerSetBuilder {
  fn new(instance: TMeUrlTypeStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeStickerSet { self.instance.clone() }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
}



/// Contains a list of t.me URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrls
  /// List of URLs.
  urls: Option<Vec<TMeUrl>>,
  
}



impl Object for TMeUrls {}
impl RObject for TMeUrls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrls" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TMeUrls {
  
  pub fn builder() -> RTDTMeUrlsBuilder {
    let instance = Self {
      td_name: "tMeUrls".to_string(),
      urls: None,
      
    };
    RTDTMeUrlsBuilder::new(instance)
  }
  
  
  pub fn urls(&self) -> Option<Vec<TMeUrl>> { self.urls.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TMeUrls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTMeUrlsBuilder { instance: TMeUrls }

impl RTDTMeUrlsBuilder {
  fn new(instance: TMeUrls) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrls { self.instance.clone() }
  
  pub fn urls(&mut self, urls: Vec<TMeUrl>) -> &mut Self {
    self.instance.urls = Some(urls);
    self
  }
  
}



/// Contains parameters for TDLib initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tdlibParameters
  /// If set to true, the Telegram test environment will be used instead of the production environment.
  use_test_dc: Option<bool>,
  /// The path to the directory for the persistent database; if empty, the current working directory will be used.
  database_directory: Option<String>,
  /// The path to the directory for storing files; if empty, database_directory will be used.
  files_directory: Option<String>,
  /// If set to true, information about downloaded and uploaded files will be saved between application restarts.
  use_file_database: Option<bool>,
  /// If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database.
  use_chat_info_database: Option<bool>,
  /// If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database.
  use_message_database: Option<bool>,
  /// If set to true, support for secret chats will be enabled.
  use_secret_chats: Option<bool>,
  /// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org.
  api_id: Option<i32>,
  /// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org.
  api_hash: Option<String>,
  /// IETF language tag of the user's operating system language; must be non-empty.
  system_language_code: Option<String>,
  /// Model of the device the application is being run on; must be non-empty.
  device_model: Option<String>,
  /// Version of the operating system the application is being run on; must be non-empty.
  system_version: Option<String>,
  /// Application version; must be non-empty.
  application_version: Option<String>,
  /// If set to true, old files will automatically be deleted.
  enable_storage_optimizer: Option<bool>,
  /// If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name.
  ignore_file_names: Option<bool>,
  
}



impl Object for TdlibParameters {}
impl RObject for TdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::TdlibParameters }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TdlibParameters {
  
  pub fn builder() -> RTDTdlibParametersBuilder {
    let instance = Self {
      td_name: "tdlibParameters".to_string(),
      use_test_dc: None,
      database_directory: None,
      files_directory: None,
      use_file_database: None,
      use_chat_info_database: None,
      use_message_database: None,
      use_secret_chats: None,
      api_id: None,
      api_hash: None,
      system_language_code: None,
      device_model: None,
      system_version: None,
      application_version: None,
      enable_storage_optimizer: None,
      ignore_file_names: None,
      
    };
    RTDTdlibParametersBuilder::new(instance)
  }
  
  
  pub fn use_test_dc(&self) -> Option<bool> { self.use_test_dc.clone() }
  
  pub fn database_directory(&self) -> Option<String> { self.database_directory.clone() }
  
  pub fn files_directory(&self) -> Option<String> { self.files_directory.clone() }
  
  pub fn use_file_database(&self) -> Option<bool> { self.use_file_database.clone() }
  
  pub fn use_chat_info_database(&self) -> Option<bool> { self.use_chat_info_database.clone() }
  
  pub fn use_message_database(&self) -> Option<bool> { self.use_message_database.clone() }
  
  pub fn use_secret_chats(&self) -> Option<bool> { self.use_secret_chats.clone() }
  
  pub fn api_id(&self) -> Option<i32> { self.api_id.clone() }
  
  pub fn api_hash(&self) -> Option<String> { self.api_hash.clone() }
  
  pub fn system_language_code(&self) -> Option<String> { self.system_language_code.clone() }
  
  pub fn device_model(&self) -> Option<String> { self.device_model.clone() }
  
  pub fn system_version(&self) -> Option<String> { self.system_version.clone() }
  
  pub fn application_version(&self) -> Option<String> { self.application_version.clone() }
  
  pub fn enable_storage_optimizer(&self) -> Option<bool> { self.enable_storage_optimizer.clone() }
  
  pub fn ignore_file_names(&self) -> Option<bool> { self.ignore_file_names.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TdlibParameters> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTdlibParametersBuilder { instance: TdlibParameters }

impl RTDTdlibParametersBuilder {
  fn new(instance: TdlibParameters) -> Self { Self { instance } }

  pub fn build(&self) -> TdlibParameters { self.instance.clone() }
  
  pub fn use_test_dc(&mut self, use_test_dc: bool) -> &mut Self {
    self.instance.use_test_dc = Some(use_test_dc);
    self
  }
  
  pub fn database_directory<S: AsRef<str>>(&mut self, database_directory: S) -> &mut Self {
    self.instance.database_directory = Some(database_directory.as_ref().to_string());
    self
  }
  
  pub fn files_directory<S: AsRef<str>>(&mut self, files_directory: S) -> &mut Self {
    self.instance.files_directory = Some(files_directory.as_ref().to_string());
    self
  }
  
  pub fn use_file_database(&mut self, use_file_database: bool) -> &mut Self {
    self.instance.use_file_database = Some(use_file_database);
    self
  }
  
  pub fn use_chat_info_database(&mut self, use_chat_info_database: bool) -> &mut Self {
    self.instance.use_chat_info_database = Some(use_chat_info_database);
    self
  }
  
  pub fn use_message_database(&mut self, use_message_database: bool) -> &mut Self {
    self.instance.use_message_database = Some(use_message_database);
    self
  }
  
  pub fn use_secret_chats(&mut self, use_secret_chats: bool) -> &mut Self {
    self.instance.use_secret_chats = Some(use_secret_chats);
    self
  }
  
  pub fn api_id(&mut self, api_id: i32) -> &mut Self {
    self.instance.api_id = Some(api_id);
    self
  }
  
  pub fn api_hash<S: AsRef<str>>(&mut self, api_hash: S) -> &mut Self {
    self.instance.api_hash = Some(api_hash.as_ref().to_string());
    self
  }
  
  pub fn system_language_code<S: AsRef<str>>(&mut self, system_language_code: S) -> &mut Self {
    self.instance.system_language_code = Some(system_language_code.as_ref().to_string());
    self
  }
  
  pub fn device_model<S: AsRef<str>>(&mut self, device_model: S) -> &mut Self {
    self.instance.device_model = Some(device_model.as_ref().to_string());
    self
  }
  
  pub fn system_version<S: AsRef<str>>(&mut self, system_version: S) -> &mut Self {
    self.instance.system_version = Some(system_version.as_ref().to_string());
    self
  }
  
  pub fn application_version<S: AsRef<str>>(&mut self, application_version: S) -> &mut Self {
    self.instance.application_version = Some(application_version.as_ref().to_string());
    self
  }
  
  pub fn enable_storage_optimizer(&mut self, enable_storage_optimizer: bool) -> &mut Self {
    self.instance.enable_storage_optimizer = Some(enable_storage_optimizer);
    self
  }
  
  pub fn ignore_file_names(&mut self, ignore_file_names: bool) -> &mut Self {
    self.instance.ignore_file_names = Some(ignore_file_names);
    self
  }
  
}



/// Returns information about the availability of a temporary password, which can be used for payments. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // temporaryPasswordState
  /// True, if a temporary password is available.
  has_password: Option<bool>,
  /// Time left before the temporary password expires, in seconds.
  valid_for: Option<i32>,
  
}



impl Object for TemporaryPasswordState {}
impl RObject for TemporaryPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "temporaryPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::TemporaryPasswordState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TemporaryPasswordState {
  
  pub fn builder() -> RTDTemporaryPasswordStateBuilder {
    let instance = Self {
      td_name: "temporaryPasswordState".to_string(),
      has_password: None,
      valid_for: None,
      
    };
    RTDTemporaryPasswordStateBuilder::new(instance)
  }
  
  
  pub fn has_password(&self) -> Option<bool> { self.has_password.clone() }
  
  pub fn valid_for(&self) -> Option<i32> { self.valid_for.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TemporaryPasswordState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTemporaryPasswordStateBuilder { instance: TemporaryPasswordState }

impl RTDTemporaryPasswordStateBuilder {
  fn new(instance: TemporaryPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> TemporaryPasswordState { self.instance.clone() }
  
  pub fn has_password(&mut self, has_password: bool) -> &mut Self {
    self.instance.has_password = Some(has_password);
    self
  }
  
  pub fn valid_for(&mut self, valid_for: i32) -> &mut Self {
    self.instance.valid_for = Some(valid_for);
    self
  }
  
}



/// Contains Telegram terms of service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // termsOfService
  /// Text of the terms of service.
  text: Option<FormattedText>,
  /// Mininum age of a user to be able to accept the terms; 0 if any.
  min_user_age: Option<i32>,
  /// True, if a blocking popup with terms of service must be shown to the user.
  show_popup: Option<bool>,
  
}



impl Object for TermsOfService {}
impl RObject for TermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "termsOfService" }
  fn td_type(&self) -> RTDType { RTDType::TermsOfService }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TermsOfService {
  
  pub fn builder() -> RTDTermsOfServiceBuilder {
    let instance = Self {
      td_name: "termsOfService".to_string(),
      text: None,
      min_user_age: None,
      show_popup: None,
      
    };
    RTDTermsOfServiceBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn min_user_age(&self) -> Option<i32> { self.min_user_age.clone() }
  
  pub fn show_popup(&self) -> Option<bool> { self.show_popup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TermsOfService> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTermsOfServiceBuilder { instance: TermsOfService }

impl RTDTermsOfServiceBuilder {
  fn new(instance: TermsOfService) -> Self { Self { instance } }

  pub fn build(&self) -> TermsOfService { self.instance.clone() }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn min_user_age(&mut self, min_user_age: i32) -> &mut Self {
    self.instance.min_user_age = Some(min_user_age);
    self
  }
  
  pub fn show_popup(&mut self, show_popup: bool) -> &mut Self {
    self.instance.show_popup = Some(show_popup);
    self
  }
  
}



/// A simple object containing a sequence of bytes; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testBytes
  /// Bytes.
  value: Option<String>,
  
}



impl Object for TestBytes {}
impl RObject for TestBytes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testBytes" }
  fn td_type(&self) -> RTDType { RTDType::TestBytes }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestBytes {
  
  pub fn builder() -> RTDTestBytesBuilder {
    let instance = Self {
      td_name: "testBytes".to_string(),
      value: None,
      
    };
    RTDTestBytesBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestBytes> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestBytesBuilder { instance: TestBytes }

impl RTDTestBytesBuilder {
  fn new(instance: TestBytes) -> Self { Self { instance } }

  pub fn build(&self) -> TestBytes { self.instance.clone() }
  
  pub fn value<S: AsRef<str>>(&mut self, value: S) -> &mut Self {
    self.instance.value = Some(value.as_ref().to_string());
    self
  }
  
}



/// A simple object containing a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testInt
  /// Number.
  value: Option<i32>,
  
}



impl Object for TestInt {}
impl RObject for TestInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testInt" }
  fn td_type(&self) -> RTDType { RTDType::TestInt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestInt {
  
  pub fn builder() -> RTDTestIntBuilder {
    let instance = Self {
      td_name: "testInt".to_string(),
      value: None,
      
    };
    RTDTestIntBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<i32> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestInt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestIntBuilder { instance: TestInt }

impl RTDTestIntBuilder {
  fn new(instance: TestInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestInt { self.instance.clone() }
  
  pub fn value(&mut self, value: i32) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// A simple object containing a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testString
  /// String.
  value: Option<String>,
  
}



impl Object for TestString {}
impl RObject for TestString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testString" }
  fn td_type(&self) -> RTDType { RTDType::TestString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestString {
  
  pub fn builder() -> RTDTestStringBuilder {
    let instance = Self {
      td_name: "testString".to_string(),
      value: None,
      
    };
    RTDTestStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestStringBuilder { instance: TestString }

impl RTDTestStringBuilder {
  fn new(instance: TestString) -> Self { Self { instance } }

  pub fn build(&self) -> TestString { self.instance.clone() }
  
  pub fn value<S: AsRef<str>>(&mut self, value: S) -> &mut Self {
    self.instance.value = Some(value.as_ref().to_string());
    self
  }
  
}



/// A simple object containing a vector of numbers; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorInt
  /// Vector of numbers.
  value: Option<Vec<i32>>,
  
}



impl Object for TestVectorInt {}
impl RObject for TestVectorInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorInt" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorInt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestVectorInt {
  
  pub fn builder() -> RTDTestVectorIntBuilder {
    let instance = Self {
      td_name: "testVectorInt".to_string(),
      value: None,
      
    };
    RTDTestVectorIntBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<Vec<i32>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestVectorInt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestVectorIntBuilder { instance: TestVectorInt }

impl RTDTestVectorIntBuilder {
  fn new(instance: TestVectorInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorInt { self.instance.clone() }
  
  pub fn value(&mut self, value: Vec<i32>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// A simple object containing a vector of objects that hold a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorIntObject
  /// Vector of objects.
  value: Option<Vec<TestInt>>,
  
}



impl Object for TestVectorIntObject {}
impl RObject for TestVectorIntObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorIntObject" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorIntObject }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestVectorIntObject {
  
  pub fn builder() -> RTDTestVectorIntObjectBuilder {
    let instance = Self {
      td_name: "testVectorIntObject".to_string(),
      value: None,
      
    };
    RTDTestVectorIntObjectBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<Vec<TestInt>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestVectorIntObject> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestVectorIntObjectBuilder { instance: TestVectorIntObject }

impl RTDTestVectorIntObjectBuilder {
  fn new(instance: TestVectorIntObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorIntObject { self.instance.clone() }
  
  pub fn value(&mut self, value: Vec<TestInt>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// A simple object containing a vector of strings; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorString
  /// Vector of strings.
  value: Option<Vec<String>>,
  
}



impl Object for TestVectorString {}
impl RObject for TestVectorString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorString" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestVectorString {
  
  pub fn builder() -> RTDTestVectorStringBuilder {
    let instance = Self {
      td_name: "testVectorString".to_string(),
      value: None,
      
    };
    RTDTestVectorStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<Vec<String>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestVectorString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestVectorStringBuilder { instance: TestVectorString }

impl RTDTestVectorStringBuilder {
  fn new(instance: TestVectorString) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorString { self.instance.clone() }
  
  pub fn value(&mut self, value: Vec<String>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// A simple object containing a vector of objects that hold a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorStringObject
  /// Vector of objects.
  value: Option<Vec<TestString>>,
  
}



impl Object for TestVectorStringObject {}
impl RObject for TestVectorStringObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorStringObject" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorStringObject }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TestVectorStringObject {
  
  pub fn builder() -> RTDTestVectorStringObjectBuilder {
    let instance = Self {
      td_name: "testVectorStringObject".to_string(),
      value: None,
      
    };
    RTDTestVectorStringObjectBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> Option<Vec<TestString>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestVectorStringObject> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestVectorStringObjectBuilder { instance: TestVectorStringObject }

impl RTDTestVectorStringObjectBuilder {
  fn new(instance: TestVectorStringObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorStringObject { self.instance.clone() }
  
  pub fn value(&mut self, value: Vec<TestString>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// Contains some text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Text {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // text
  /// Text.
  text: Option<String>,
  
}



impl Object for Text {}
impl RObject for Text {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "text" }
  fn td_type(&self) -> RTDType { RTDType::Text }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Text {
  
  pub fn builder() -> RTDTextBuilder {
    let instance = Self {
      td_name: "text".to_string(),
      text: None,
      
    };
    RTDTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Text> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextBuilder { instance: Text }

impl RTDTextBuilder {
  fn new(instance: Text) -> Self { Self { instance } }

  pub fn build(&self) -> Text { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// Contains a list of text entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntities
  /// List of text entities.
  entities: Option<Vec<TextEntity>>,
  
}



impl Object for TextEntities {}
impl RObject for TextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntities" }
  fn td_type(&self) -> RTDType { RTDType::TextEntities }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TextEntities {
  
  pub fn builder() -> RTDTextEntitiesBuilder {
    let instance = Self {
      td_name: "textEntities".to_string(),
      entities: None,
      
    };
    RTDTextEntitiesBuilder::new(instance)
  }
  
  
  pub fn entities(&self) -> Option<Vec<TextEntity>> { self.entities.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntities> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntitiesBuilder { instance: TextEntities }

impl RTDTextEntitiesBuilder {
  fn new(instance: TextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntities { self.instance.clone() }
  
  pub fn entities(&mut self, entities: Vec<TextEntity>) -> &mut Self {
    self.instance.entities = Some(entities);
    self
  }
  
}



/// Represents a part of the text that needs to be formatted in some unusual way. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TextEntity {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntity
  /// Offset of the entity in UTF-16 code points.
  offset: Option<i32>,
  /// Length of the entity, in UTF-16 code points.
  length: Option<i32>,
  /// Type of the entity.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TextEntityType>>,
  
}


impl Clone for TextEntity {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for TextEntity {}
impl RObject for TextEntity {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntity" }
  fn td_type(&self) -> RTDType { RTDType::TextEntity }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl TextEntity {
  
  pub fn builder() -> RTDTextEntityBuilder {
    let instance = Self {
      td_name: "textEntity".to_string(),
      offset: None,
      length: None,
      type_: None,
      
    };
    RTDTextEntityBuilder::new(instance)
  }
  
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn type_(&self) -> Option<Box<TextEntityType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntity> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityBuilder { instance: TextEntity }

impl RTDTextEntityBuilder {
  fn new(instance: TextEntity) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntity { self.instance.clone() }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
  pub fn type_(&mut self, type_: Box<TextEntityType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// This class is an abstract base class. Represents a part of the text which must be formatted differently. 
#[typetag::serde(tag = "@struct")]
pub trait TextEntityType: Object + RObject + Debug {}







impl TextEntityType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<TextEntityType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<TextEntityType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTextEntityTypeType {
  TextEntityTypeBold,
  TextEntityTypeBotCommand,
  TextEntityTypeCashtag,
  TextEntityTypeCode,
  TextEntityTypeEmailAddress,
  TextEntityTypeHashtag,
  TextEntityTypeItalic,
  TextEntityTypeMention,
  TextEntityTypeMentionName,
  TextEntityTypePhoneNumber,
  TextEntityTypePre,
  TextEntityTypePreCode,
  TextEntityTypeTextUrl,
  TextEntityTypeUrl,
  
}
impl RTDTextEntityTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A mention of a user by their username. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeMention
  
}



impl Object for TextEntityTypeMention {}
impl RObject for TextEntityTypeMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeMention" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeMention }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeMention {}


impl TextEntityTypeMention {
  
  pub fn builder() -> RTDTextEntityTypeMentionBuilder {
    let instance = Self {
      td_name: "textEntityTypeMention".to_string(),
      
    };
    RTDTextEntityTypeMentionBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeMention> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeMentionBuilder { instance: TextEntityTypeMention }

impl RTDTextEntityTypeMentionBuilder {
  fn new(instance: TextEntityTypeMention) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeMention { self.instance.clone() }
  
}



/// A hashtag text, beginning with "#". 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeHashtag
  
}



impl Object for TextEntityTypeHashtag {}
impl RObject for TextEntityTypeHashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeHashtag" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeHashtag }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeHashtag {}


impl TextEntityTypeHashtag {
  
  pub fn builder() -> RTDTextEntityTypeHashtagBuilder {
    let instance = Self {
      td_name: "textEntityTypeHashtag".to_string(),
      
    };
    RTDTextEntityTypeHashtagBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeHashtag> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeHashtagBuilder { instance: TextEntityTypeHashtag }

impl RTDTextEntityTypeHashtagBuilder {
  fn new(instance: TextEntityTypeHashtag) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeHashtag { self.instance.clone() }
  
}



/// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeCashtag
  
}



impl Object for TextEntityTypeCashtag {}
impl RObject for TextEntityTypeCashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeCashtag" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeCashtag }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeCashtag {}


impl TextEntityTypeCashtag {
  
  pub fn builder() -> RTDTextEntityTypeCashtagBuilder {
    let instance = Self {
      td_name: "textEntityTypeCashtag".to_string(),
      
    };
    RTDTextEntityTypeCashtagBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeCashtag> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeCashtagBuilder { instance: TextEntityTypeCashtag }

impl RTDTextEntityTypeCashtagBuilder {
  fn new(instance: TextEntityTypeCashtag) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeCashtag { self.instance.clone() }
  
}



/// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeBotCommand
  
}



impl Object for TextEntityTypeBotCommand {}
impl RObject for TextEntityTypeBotCommand {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeBotCommand" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeBotCommand }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeBotCommand {}


impl TextEntityTypeBotCommand {
  
  pub fn builder() -> RTDTextEntityTypeBotCommandBuilder {
    let instance = Self {
      td_name: "textEntityTypeBotCommand".to_string(),
      
    };
    RTDTextEntityTypeBotCommandBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeBotCommand> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeBotCommandBuilder { instance: TextEntityTypeBotCommand }

impl RTDTextEntityTypeBotCommandBuilder {
  fn new(instance: TextEntityTypeBotCommand) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeBotCommand { self.instance.clone() }
  
}



/// An HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeUrl
  
}



impl Object for TextEntityTypeUrl {}
impl RObject for TextEntityTypeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeUrl" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeUrl {}


impl TextEntityTypeUrl {
  
  pub fn builder() -> RTDTextEntityTypeUrlBuilder {
    let instance = Self {
      td_name: "textEntityTypeUrl".to_string(),
      
    };
    RTDTextEntityTypeUrlBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeUrlBuilder { instance: TextEntityTypeUrl }

impl RTDTextEntityTypeUrlBuilder {
  fn new(instance: TextEntityTypeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeUrl { self.instance.clone() }
  
}



/// An email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeEmailAddress
  
}



impl Object for TextEntityTypeEmailAddress {}
impl RObject for TextEntityTypeEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeEmailAddress {}


impl TextEntityTypeEmailAddress {
  
  pub fn builder() -> RTDTextEntityTypeEmailAddressBuilder {
    let instance = Self {
      td_name: "textEntityTypeEmailAddress".to_string(),
      
    };
    RTDTextEntityTypeEmailAddressBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeEmailAddressBuilder { instance: TextEntityTypeEmailAddress }

impl RTDTextEntityTypeEmailAddressBuilder {
  fn new(instance: TextEntityTypeEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeEmailAddress { self.instance.clone() }
  
}



/// A bold text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeBold
  
}



impl Object for TextEntityTypeBold {}
impl RObject for TextEntityTypeBold {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeBold" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeBold }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeBold {}


impl TextEntityTypeBold {
  
  pub fn builder() -> RTDTextEntityTypeBoldBuilder {
    let instance = Self {
      td_name: "textEntityTypeBold".to_string(),
      
    };
    RTDTextEntityTypeBoldBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeBold> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeBoldBuilder { instance: TextEntityTypeBold }

impl RTDTextEntityTypeBoldBuilder {
  fn new(instance: TextEntityTypeBold) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeBold { self.instance.clone() }
  
}



/// An italic text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeItalic
  
}



impl Object for TextEntityTypeItalic {}
impl RObject for TextEntityTypeItalic {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeItalic" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeItalic }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeItalic {}


impl TextEntityTypeItalic {
  
  pub fn builder() -> RTDTextEntityTypeItalicBuilder {
    let instance = Self {
      td_name: "textEntityTypeItalic".to_string(),
      
    };
    RTDTextEntityTypeItalicBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeItalic> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeItalicBuilder { instance: TextEntityTypeItalic }

impl RTDTextEntityTypeItalicBuilder {
  fn new(instance: TextEntityTypeItalic) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeItalic { self.instance.clone() }
  
}



/// Text that must be formatted as if inside a code HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeCode
  
}



impl Object for TextEntityTypeCode {}
impl RObject for TextEntityTypeCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeCode" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeCode {}


impl TextEntityTypeCode {
  
  pub fn builder() -> RTDTextEntityTypeCodeBuilder {
    let instance = Self {
      td_name: "textEntityTypeCode".to_string(),
      
    };
    RTDTextEntityTypeCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeCodeBuilder { instance: TextEntityTypeCode }

impl RTDTextEntityTypeCodeBuilder {
  fn new(instance: TextEntityTypeCode) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeCode { self.instance.clone() }
  
}



/// Text that must be formatted as if inside a pre HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePre {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePre
  
}



impl Object for TextEntityTypePre {}
impl RObject for TextEntityTypePre {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePre" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePre }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePre {}


impl TextEntityTypePre {
  
  pub fn builder() -> RTDTextEntityTypePreBuilder {
    let instance = Self {
      td_name: "textEntityTypePre".to_string(),
      
    };
    RTDTextEntityTypePreBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypePre> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypePreBuilder { instance: TextEntityTypePre }

impl RTDTextEntityTypePreBuilder {
  fn new(instance: TextEntityTypePre) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePre { self.instance.clone() }
  
}



/// Text that must be formatted as if inside pre, and code HTML tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePreCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePreCode
  /// Programming language of the code; as defined by the sender.
  language: Option<String>,
  
}



impl Object for TextEntityTypePreCode {}
impl RObject for TextEntityTypePreCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePreCode" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePreCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePreCode {}


impl TextEntityTypePreCode {
  
  pub fn builder() -> RTDTextEntityTypePreCodeBuilder {
    let instance = Self {
      td_name: "textEntityTypePreCode".to_string(),
      language: None,
      
    };
    RTDTextEntityTypePreCodeBuilder::new(instance)
  }
  
  
  pub fn language(&self) -> Option<String> { self.language.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypePreCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypePreCodeBuilder { instance: TextEntityTypePreCode }

impl RTDTextEntityTypePreCodeBuilder {
  fn new(instance: TextEntityTypePreCode) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePreCode { self.instance.clone() }
  
  pub fn language<S: AsRef<str>>(&mut self, language: S) -> &mut Self {
    self.instance.language = Some(language.as_ref().to_string());
    self
  }
  
}



/// A text description shown instead of a raw URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeTextUrl
  /// HTTP or tg:// URL to be opened when the link is clicked.
  url: Option<String>,
  
}



impl Object for TextEntityTypeTextUrl {}
impl RObject for TextEntityTypeTextUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeTextUrl" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeTextUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeTextUrl {}


impl TextEntityTypeTextUrl {
  
  pub fn builder() -> RTDTextEntityTypeTextUrlBuilder {
    let instance = Self {
      td_name: "textEntityTypeTextUrl".to_string(),
      url: None,
      
    };
    RTDTextEntityTypeTextUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeTextUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeTextUrlBuilder { instance: TextEntityTypeTextUrl }

impl RTDTextEntityTypeTextUrlBuilder {
  fn new(instance: TextEntityTypeTextUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeTextUrl { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
}



/// A text shows instead of a raw mention of the user (e.g., when the user has no username). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMentionName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeMentionName
  /// Identifier of the mentioned user.
  user_id: Option<i32>,
  
}



impl Object for TextEntityTypeMentionName {}
impl RObject for TextEntityTypeMentionName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeMentionName" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeMentionName }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeMentionName {}


impl TextEntityTypeMentionName {
  
  pub fn builder() -> RTDTextEntityTypeMentionNameBuilder {
    let instance = Self {
      td_name: "textEntityTypeMentionName".to_string(),
      user_id: None,
      
    };
    RTDTextEntityTypeMentionNameBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypeMentionName> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypeMentionNameBuilder { instance: TextEntityTypeMentionName }

impl RTDTextEntityTypeMentionNameBuilder {
  fn new(instance: TextEntityTypeMentionName) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeMentionName { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// A phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePhoneNumber
  
}



impl Object for TextEntityTypePhoneNumber {}
impl RObject for TextEntityTypePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePhoneNumber {}


impl TextEntityTypePhoneNumber {
  
  pub fn builder() -> RTDTextEntityTypePhoneNumberBuilder {
    let instance = Self {
      td_name: "textEntityTypePhoneNumber".to_string(),
      
    };
    RTDTextEntityTypePhoneNumberBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextEntityTypePhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextEntityTypePhoneNumberBuilder { instance: TextEntityTypePhoneNumber }

impl RTDTextEntityTypePhoneNumberBuilder {
  fn new(instance: TextEntityTypePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePhoneNumber { self.instance.clone() }
  
}



/// This class is an abstract base class. Describes the way the text should be parsed for TextEntities. 
#[typetag::serde(tag = "@struct")]
pub trait TextParseMode: Object + RObject + Debug {}







impl TextParseMode {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<TextParseMode>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<TextParseMode> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTextParseModeType {
  TextParseModeHTML,
  TextParseModeMarkdown,
  
}
impl RTDTextParseModeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The text should be parsed in markdown-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeMarkdown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textParseModeMarkdown
  
}



impl Object for TextParseModeMarkdown {}
impl RObject for TextParseModeMarkdown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textParseModeMarkdown" }
  fn td_type(&self) -> RTDType { RTDType::TextParseModeMarkdown }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextParseMode for TextParseModeMarkdown {}


impl TextParseModeMarkdown {
  
  pub fn builder() -> RTDTextParseModeMarkdownBuilder {
    let instance = Self {
      td_name: "textParseModeMarkdown".to_string(),
      
    };
    RTDTextParseModeMarkdownBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextParseModeMarkdown> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextParseModeMarkdownBuilder { instance: TextParseModeMarkdown }

impl RTDTextParseModeMarkdownBuilder {
  fn new(instance: TextParseModeMarkdown) -> Self { Self { instance } }

  pub fn build(&self) -> TextParseModeMarkdown { self.instance.clone() }
  
}



/// The text should be parsed in HTML-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeHTML {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textParseModeHTML
  
}



impl Object for TextParseModeHTML {}
impl RObject for TextParseModeHTML {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textParseModeHTML" }
  fn td_type(&self) -> RTDType { RTDType::TextParseModeHTML }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TextParseMode for TextParseModeHTML {}


impl TextParseModeHTML {
  
  pub fn builder() -> RTDTextParseModeHTMLBuilder {
    let instance = Self {
      td_name: "textParseModeHTML".to_string(),
      
    };
    RTDTextParseModeHTMLBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TextParseModeHTML> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTextParseModeHTMLBuilder { instance: TextParseModeHTML }

impl RTDTextParseModeHTMLBuilder {
  fn new(instance: TextParseModeHTML) -> Self { Self { instance } }

  pub fn build(&self) -> TextParseModeHTML { self.instance.clone() }
  
}



/// This class is an abstract base class. Represents the categories of chats for which a list of frequently used chats can be retrieved. 
#[typetag::serde(tag = "@struct")]
pub trait TopChatCategory: Object + RObject + Debug {}







impl TopChatCategory {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<TopChatCategory>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<TopChatCategory> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTopChatCategoryType {
  TopChatCategoryBots,
  TopChatCategoryCalls,
  TopChatCategoryChannels,
  TopChatCategoryGroups,
  TopChatCategoryInlineBots,
  TopChatCategoryUsers,
  
}
impl RTDTopChatCategoryType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A category containing frequently used private chats with non-bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryUsers
  
}



impl Object for TopChatCategoryUsers {}
impl RObject for TopChatCategoryUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryUsers" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryUsers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryUsers {}


impl TopChatCategoryUsers {
  
  pub fn builder() -> RTDTopChatCategoryUsersBuilder {
    let instance = Self {
      td_name: "topChatCategoryUsers".to_string(),
      
    };
    RTDTopChatCategoryUsersBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryUsers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryUsersBuilder { instance: TopChatCategoryUsers }

impl RTDTopChatCategoryUsersBuilder {
  fn new(instance: TopChatCategoryUsers) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryUsers { self.instance.clone() }
  
}



/// A category containing frequently used private chats with bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryBots
  
}



impl Object for TopChatCategoryBots {}
impl RObject for TopChatCategoryBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryBots" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryBots }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryBots {}


impl TopChatCategoryBots {
  
  pub fn builder() -> RTDTopChatCategoryBotsBuilder {
    let instance = Self {
      td_name: "topChatCategoryBots".to_string(),
      
    };
    RTDTopChatCategoryBotsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryBots> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryBotsBuilder { instance: TopChatCategoryBots }

impl RTDTopChatCategoryBotsBuilder {
  fn new(instance: TopChatCategoryBots) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryBots { self.instance.clone() }
  
}



/// A category containing frequently used basic groups and supergroups. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryGroups {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryGroups
  
}



impl Object for TopChatCategoryGroups {}
impl RObject for TopChatCategoryGroups {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryGroups" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryGroups }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryGroups {}


impl TopChatCategoryGroups {
  
  pub fn builder() -> RTDTopChatCategoryGroupsBuilder {
    let instance = Self {
      td_name: "topChatCategoryGroups".to_string(),
      
    };
    RTDTopChatCategoryGroupsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryGroups> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryGroupsBuilder { instance: TopChatCategoryGroups }

impl RTDTopChatCategoryGroupsBuilder {
  fn new(instance: TopChatCategoryGroups) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryGroups { self.instance.clone() }
  
}



/// A category containing frequently used channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryChannels {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryChannels
  
}



impl Object for TopChatCategoryChannels {}
impl RObject for TopChatCategoryChannels {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryChannels" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryChannels }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryChannels {}


impl TopChatCategoryChannels {
  
  pub fn builder() -> RTDTopChatCategoryChannelsBuilder {
    let instance = Self {
      td_name: "topChatCategoryChannels".to_string(),
      
    };
    RTDTopChatCategoryChannelsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryChannels> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryChannelsBuilder { instance: TopChatCategoryChannels }

impl RTDTopChatCategoryChannelsBuilder {
  fn new(instance: TopChatCategoryChannels) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryChannels { self.instance.clone() }
  
}



/// A category containing frequently used chats with inline bots sorted by their usage in inline mode. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryInlineBots
  
}



impl Object for TopChatCategoryInlineBots {}
impl RObject for TopChatCategoryInlineBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryInlineBots" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryInlineBots }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryInlineBots {}


impl TopChatCategoryInlineBots {
  
  pub fn builder() -> RTDTopChatCategoryInlineBotsBuilder {
    let instance = Self {
      td_name: "topChatCategoryInlineBots".to_string(),
      
    };
    RTDTopChatCategoryInlineBotsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryInlineBots> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryInlineBotsBuilder { instance: TopChatCategoryInlineBots }

impl RTDTopChatCategoryInlineBotsBuilder {
  fn new(instance: TopChatCategoryInlineBots) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryInlineBots { self.instance.clone() }
  
}



/// A category containing frequently used chats used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryCalls
  
}



impl Object for TopChatCategoryCalls {}
impl RObject for TopChatCategoryCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryCalls" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryCalls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryCalls {}


impl TopChatCategoryCalls {
  
  pub fn builder() -> RTDTopChatCategoryCallsBuilder {
    let instance = Self {
      td_name: "topChatCategoryCalls".to_string(),
      
    };
    RTDTopChatCategoryCallsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TopChatCategoryCalls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTopChatCategoryCallsBuilder { instance: TopChatCategoryCalls }

impl RTDTopChatCategoryCallsBuilder {
  fn new(instance: TopChatCategoryCalls) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryCalls { self.instance.clone() }
  
}



/// This class is an abstract base class. Contains notifications about data changes. 
#[typetag::serde(tag = "@struct")]
pub trait Update: Object + RObject + Debug {}







impl Update {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Update>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<Update> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUpdateType {
  UpdateActiveNotifications,
  UpdateAuthorizationState,
  UpdateBasicGroup,
  UpdateBasicGroupFullInfo,
  UpdateCall,
  UpdateChatDefaultDisableNotification,
  UpdateChatDraftMessage,
  UpdateChatIsMarkedAsUnread,
  UpdateChatIsPinned,
  UpdateChatIsSponsored,
  UpdateChatLastMessage,
  UpdateChatNotificationSettings,
  UpdateChatOnlineMemberCount,
  UpdateChatOrder,
  UpdateChatPhoto,
  UpdateChatPinnedMessage,
  UpdateChatReadInbox,
  UpdateChatReadOutbox,
  UpdateChatReplyMarkup,
  UpdateChatTitle,
  UpdateChatUnreadMentionCount,
  UpdateConnectionState,
  UpdateDeleteMessages,
  UpdateFavoriteStickers,
  UpdateFile,
  UpdateFileGenerationStart,
  UpdateFileGenerationStop,
  UpdateHavePendingNotifications,
  UpdateInstalledStickerSets,
  UpdateLanguagePackStrings,
  UpdateMessageContent,
  UpdateMessageContentOpened,
  UpdateMessageEdited,
  UpdateMessageMentionRead,
  UpdateMessageSendAcknowledged,
  UpdateMessageSendFailed,
  UpdateMessageSendSucceeded,
  UpdateMessageViews,
  UpdateNewCallbackQuery,
  UpdateNewChat,
  UpdateNewChosenInlineResult,
  UpdateNewCustomEvent,
  UpdateNewCustomQuery,
  UpdateNewInlineCallbackQuery,
  UpdateNewInlineQuery,
  UpdateNewMessage,
  UpdateNewPreCheckoutQuery,
  UpdateNewShippingQuery,
  UpdateNotification,
  UpdateNotificationGroup,
  UpdateOption,
  UpdatePoll,
  UpdateRecentStickers,
  UpdateSavedAnimations,
  UpdateScopeNotificationSettings,
  UpdateSecretChat,
  UpdateServiceNotification,
  UpdateSupergroup,
  UpdateSupergroupFullInfo,
  UpdateTermsOfService,
  UpdateTrendingStickerSets,
  UpdateUnreadChatCount,
  UpdateUnreadMessageCount,
  UpdateUser,
  UpdateUserChatAction,
  UpdateUserFullInfo,
  UpdateUserPrivacySettingRules,
  UpdateUserStatus,
  
}
impl RTDUpdateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The user authorization state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateAuthorizationState
  /// New authorization state.
  authorization_state: Option<Box<AuthorizationState>>,
  
}


impl Clone for UpdateAuthorizationState {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateAuthorizationState {}
impl RObject for UpdateAuthorizationState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateAuthorizationState" }
  fn td_type(&self) -> RTDType { RTDType::UpdateAuthorizationState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateAuthorizationState {}


impl UpdateAuthorizationState {
  
  
  pub fn authorization_state(&self) -> Option<Box<AuthorizationState>> { self.authorization_state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateAuthorizationState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new message was received; can also be an outgoing message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewMessage
  /// The new message.
  message: Option<Message>,
  
}



impl Object for UpdateNewMessage {}
impl RObject for UpdateNewMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewMessage {}


impl UpdateNewMessage {
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendAcknowledged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendAcknowledged
  /// The chat identifier of the sent message.
  chat_id: Option<i64>,
  /// A temporary message identifier.
  message_id: Option<i64>,
  
}



impl Object for UpdateMessageSendAcknowledged {}
impl RObject for UpdateMessageSendAcknowledged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendAcknowledged" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendAcknowledged }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageSendAcknowledged {}


impl UpdateMessageSendAcknowledged {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageSendAcknowledged> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A message has been successfully sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendSucceeded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendSucceeded
  /// Information about the sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,
  
}



impl Object for UpdateMessageSendSucceeded {}
impl RObject for UpdateMessageSendSucceeded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendSucceeded" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendSucceeded }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageSendSucceeded {}


impl UpdateMessageSendSucceeded {
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn old_message_id(&self) -> Option<i64> { self.old_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageSendSucceeded> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendFailed
  /// Contains information about the message that failed to send.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,
  /// An error code.
  error_code: Option<i32>,
  /// Error message.
  error_message: Option<String>,
  
}



impl Object for UpdateMessageSendFailed {}
impl RObject for UpdateMessageSendFailed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendFailed" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendFailed }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageSendFailed {}


impl UpdateMessageSendFailed {
  
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn old_message_id(&self) -> Option<i64> { self.old_message_id.clone() }
  
  pub fn error_code(&self) -> Option<i32> { self.error_code.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageSendFailed> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The message content has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageContent
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New message content.
  new_content: Option<Box<MessageContent>>,
  
}


impl Clone for UpdateMessageContent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateMessageContent {}
impl RObject for UpdateMessageContent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageContent" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageContent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageContent {}


impl UpdateMessageContent {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn new_content(&self) -> Option<Box<MessageContent>> { self.new_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageContent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A message was edited. Changes in the message content will come in a separate 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageEdited
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Point in time (Unix timestamp) when the message was edited.
  edit_date: Option<i32>,
  /// New message reply markup; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for UpdateMessageEdited {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateMessageEdited {}
impl RObject for UpdateMessageEdited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageEdited" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageEdited }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageEdited {}


impl UpdateMessageEdited {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn edit_date(&self) -> Option<i32> { self.edit_date.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageEdited> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The view count of the message has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageViews {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageViews
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New value of the view count.
  views: Option<i32>,
  
}



impl Object for UpdateMessageViews {}
impl RObject for UpdateMessageViews {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageViews" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageViews }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageViews {}


impl UpdateMessageViews {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn views(&self) -> Option<i32> { self.views.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageViews> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageContentOpened {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageContentOpened
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for UpdateMessageContentOpened {}
impl RObject for UpdateMessageContentOpened {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageContentOpened" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageContentOpened }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageContentOpened {}


impl UpdateMessageContentOpened {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageContentOpened> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A message with an unread mention was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageMentionRead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageMentionRead
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The new number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,
  
}



impl Object for UpdateMessageMentionRead {}
impl RObject for UpdateMessageMentionRead {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageMentionRead" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageMentionRead }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateMessageMentionRead {}


impl UpdateMessageMentionRead {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateMessageMentionRead> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the client. The chat field changes will be reported through separate updates. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewChat
  /// The chat.
  chat: Option<Chat>,
  
}



impl Object for UpdateNewChat {}
impl RObject for UpdateNewChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewChat" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewChat {}


impl UpdateNewChat {
  
  
  pub fn chat(&self) -> Option<Chat> { self.chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The title of a chat was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatTitle
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat title.
  title: Option<String>,
  
}



impl Object for UpdateChatTitle {}
impl RObject for UpdateChatTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatTitle" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatTitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatTitle {}


impl UpdateChatTitle {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatTitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatPhoto
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat photo; may be null.
  photo: Option<ChatPhoto>,
  
}



impl Object for UpdateChatPhoto {}
impl RObject for UpdateChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatPhoto {}


impl UpdateChatPhoto {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The last message of a chat was changed. If last_message is null then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatLastMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatLastMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new last message in the chat; may be null.
  last_message: Option<Message>,
  /// New value of the chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatLastMessage {}
impl RObject for UpdateChatLastMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatLastMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatLastMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatLastMessage {}


impl UpdateChatLastMessage {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_message(&self) -> Option<Message> { self.last_message.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatLastMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The order of the chat in the chat list has changed. Instead of this update 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOrder {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatOrder
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of the order.
  order: Option<i64>,
  
}



impl Object for UpdateChatOrder {}
impl RObject for UpdateChatOrder {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatOrder" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatOrder }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatOrder {}


impl UpdateChatOrder {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatOrder> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A chat was pinned or unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsPinned
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,
  /// New value of the chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatIsPinned {}
impl RObject for UpdateChatIsPinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsPinned" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsPinned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatIsPinned {}


impl UpdateChatIsPinned {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatIsPinned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A chat was marked as unread or was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsMarkedAsUnread
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,
  
}



impl Object for UpdateChatIsMarkedAsUnread {}
impl RObject for UpdateChatIsMarkedAsUnread {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsMarkedAsUnread" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsMarkedAsUnread }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatIsMarkedAsUnread {}


impl UpdateChatIsMarkedAsUnread {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatIsMarkedAsUnread> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A chat's is_sponsored field has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsSponsored {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsSponsored
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_sponsored.
  is_sponsored: Option<bool>,
  /// New value of chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatIsSponsored {}
impl RObject for UpdateChatIsSponsored {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsSponsored" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsSponsored }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatIsSponsored {}


impl UpdateChatIsSponsored {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_sponsored(&self) -> Option<bool> { self.is_sponsored.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatIsSponsored> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatDefaultDisableNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new default_disable_notification value.
  default_disable_notification: Option<bool>,
  
}



impl Object for UpdateChatDefaultDisableNotification {}
impl RObject for UpdateChatDefaultDisableNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatDefaultDisableNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatDefaultDisableNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatDefaultDisableNotification {}


impl UpdateChatDefaultDisableNotification {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatDefaultDisableNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Incoming messages were read or number of unread messages has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadInbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReadInbox
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// The number of unread messages left in the chat.
  unread_count: Option<i32>,
  
}



impl Object for UpdateChatReadInbox {}
impl RObject for UpdateChatReadInbox {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReadInbox" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReadInbox }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatReadInbox {}


impl UpdateChatReadInbox {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_read_inbox_message_id(&self) -> Option<i64> { self.last_read_inbox_message_id.clone() }
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatReadInbox> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Outgoing messages were read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadOutbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReadOutbox
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of last read outgoing message.
  last_read_outbox_message_id: Option<i64>,
  
}



impl Object for UpdateChatReadOutbox {}
impl RObject for UpdateChatReadOutbox {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReadOutbox" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReadOutbox }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatReadOutbox {}


impl UpdateChatReadOutbox {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_read_outbox_message_id(&self) -> Option<i64> { self.last_read_outbox_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatReadOutbox> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The chat unread_mention_count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatUnreadMentionCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatUnreadMentionCount
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,
  
}



impl Object for UpdateChatUnreadMentionCount {}
impl RObject for UpdateChatUnreadMentionCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatUnreadMentionCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatUnreadMentionCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatUnreadMentionCount {}


impl UpdateChatUnreadMentionCount {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatUnreadMentionCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Notification settings for a chat were changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatNotificationSettings
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new notification settings.
  notification_settings: Option<ChatNotificationSettings>,
  
}



impl Object for UpdateChatNotificationSettings {}
impl RObject for UpdateChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatNotificationSettings {}


impl UpdateChatNotificationSettings {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Notification settings for some type of chats were updated. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateScopeNotificationSettings
  /// Types of chats for which notification settings were updated.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings.
  notification_settings: Option<ScopeNotificationSettings>,
  
}


impl Clone for UpdateScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateScopeNotificationSettings {}
impl RObject for UpdateScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateScopeNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateScopeNotificationSettings {}


impl UpdateScopeNotificationSettings {
  
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn notification_settings(&self) -> Option<ScopeNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateScopeNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The chat pinned message was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatPinnedMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new identifier of the pinned message; 0 if there is no pinned message in the chat.
  pinned_message_id: Option<i64>,
  
}



impl Object for UpdateChatPinnedMessage {}
impl RObject for UpdateChatPinnedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatPinnedMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatPinnedMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatPinnedMessage {}


impl UpdateChatPinnedMessage {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn pinned_message_id(&self) -> Option<i64> { self.pinned_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatPinnedMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReplyMarkup
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,
  
}



impl Object for UpdateChatReplyMarkup {}
impl RObject for UpdateChatReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReplyMarkup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatReplyMarkup {}


impl UpdateChatReplyMarkup {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_markup_message_id(&self) -> Option<i64> { self.reply_markup_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatReplyMarkup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatDraftMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new draft message; may be null.
  draft_message: Option<DraftMessage>,
  /// New value of the chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatDraftMessage {}
impl RObject for UpdateChatDraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatDraftMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatDraftMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatDraftMessage {}


impl UpdateChatDraftMessage {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatDraftMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOnlineMemberCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatOnlineMemberCount
  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// New number of online members in the chat, or 0 if unknown.
  online_member_count: Option<i32>,
  
}



impl Object for UpdateChatOnlineMemberCount {}
impl RObject for UpdateChatOnlineMemberCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatOnlineMemberCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatOnlineMemberCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateChatOnlineMemberCount {}


impl UpdateChatOnlineMemberCount {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn online_member_count(&self) -> Option<i32> { self.online_member_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateChatOnlineMemberCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A notification was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNotification
  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// Changed notification.
  notification: Option<Notification>,
  
}



impl Object for UpdateNotification {}
impl RObject for UpdateNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNotification {}


impl UpdateNotification {
  
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn notification(&self) -> Option<Notification> { self.notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A list of active notifications in a notification group has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNotificationGroup
  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// New type of the notification group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Chat identifier, which notification settings must be applied to the added notifications.
  notification_settings_chat_id: Option<i64>,
  /// True, if the notifications should be shown without sound.
  is_silent: Option<bool>,
  /// Total number of unread notifications in the group, can be bigger than number of active notifications.
  total_count: Option<i32>,
  /// List of added group notifications, sorted by notification ID.
  added_notifications: Option<Vec<Notification>>,
  /// Identifiers of removed group notifications, sorted by notification ID.
  removed_notification_ids: Option<Vec<i32>>,
  
}


impl Clone for UpdateNotificationGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateNotificationGroup {}
impl RObject for UpdateNotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNotificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNotificationGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNotificationGroup {}


impl UpdateNotificationGroup {
  
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationGroupType>> { self.type_.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings_chat_id(&self) -> Option<i64> { self.notification_settings_chat_id.clone() }
  
  pub fn is_silent(&self) -> Option<bool> { self.is_silent.clone() }
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn added_notifications(&self) -> Option<Vec<Notification>> { self.added_notifications.clone() }
  
  pub fn removed_notification_ids(&self) -> Option<Vec<i32>> { self.removed_notification_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNotificationGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Contains active notifications that was shown on previous application launches. This update is sent only if a message database is used. In that case it comes once before any 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateActiveNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateActiveNotifications
  /// Lists of active notification groups.
  groups: Option<Vec<NotificationGroup>>,
  
}



impl Object for UpdateActiveNotifications {}
impl RObject for UpdateActiveNotifications {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateActiveNotifications" }
  fn td_type(&self) -> RTDType { RTDType::UpdateActiveNotifications }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateActiveNotifications {}


impl UpdateActiveNotifications {
  
  
  pub fn groups(&self) -> Option<Vec<NotificationGroup>> { self.groups.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateActiveNotifications> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Describes, whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateHavePendingNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateHavePendingNotifications
  /// True, if there are some delayed notification updates, which will be sent soon.
  have_delayed_notifications: Option<bool>,
  /// True, if there can be some yet unreceived notifications, which are being fetched from the server.
  have_unreceived_notifications: Option<bool>,
  
}



impl Object for UpdateHavePendingNotifications {}
impl RObject for UpdateHavePendingNotifications {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateHavePendingNotifications" }
  fn td_type(&self) -> RTDType { RTDType::UpdateHavePendingNotifications }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateHavePendingNotifications {}


impl UpdateHavePendingNotifications {
  
  
  pub fn have_delayed_notifications(&self) -> Option<bool> { self.have_delayed_notifications.clone() }
  
  pub fn have_unreceived_notifications(&self) -> Option<bool> { self.have_unreceived_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateHavePendingNotifications> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some messages were deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateDeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateDeleteMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the deleted messages.
  message_ids: Option<Vec<i64>>,
  /// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible).
  is_permanent: Option<bool>,
  /// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future.
  from_cache: Option<bool>,
  
}



impl Object for UpdateDeleteMessages {}
impl RObject for UpdateDeleteMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateDeleteMessages" }
  fn td_type(&self) -> RTDType { RTDType::UpdateDeleteMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateDeleteMessages {}


impl UpdateDeleteMessages {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn is_permanent(&self) -> Option<bool> { self.is_permanent.clone() }
  
  pub fn from_cache(&self) -> Option<bool> { self.from_cache.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateDeleteMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// User activity in the chat has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserChatAction
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of a user performing an action.
  user_id: Option<i32>,
  /// The action description.
  action: Option<Box<ChatAction>>,
  
}


impl Clone for UpdateUserChatAction {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateUserChatAction {}
impl RObject for UpdateUserChatAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserChatAction" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserChatAction }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUserChatAction {}


impl UpdateUserChatAction {
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUserChatAction> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The user went online or offline. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserStatus
  /// User identifier.
  user_id: Option<i32>,
  /// New status of the user.
  status: Option<Box<UserStatus>>,
  
}


impl Clone for UpdateUserStatus {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateUserStatus {}
impl RObject for UpdateUserStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserStatus" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserStatus }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUserStatus {}


impl UpdateUserStatus {
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<UserStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUserStatus> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUser
  /// New data about the user.
  user: Option<User>,
  
}



impl Object for UpdateUser {}
impl RObject for UpdateUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUser" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUser {}


impl UpdateUser {
  
  
  pub fn user(&self) -> Option<User> { self.user.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateBasicGroup
  /// New data about the group.
  basic_group: Option<BasicGroup>,
  
}



impl Object for UpdateBasicGroup {}
impl RObject for UpdateBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateBasicGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateBasicGroup {}


impl UpdateBasicGroup {
  
  
  pub fn basic_group(&self) -> Option<BasicGroup> { self.basic_group.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateBasicGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSupergroup
  /// New data about the supergroup.
  supergroup: Option<Supergroup>,
  
}



impl Object for UpdateSupergroup {}
impl RObject for UpdateSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSupergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateSupergroup {}


impl UpdateSupergroup {
  
  
  pub fn supergroup(&self) -> Option<Supergroup> { self.supergroup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateSupergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSecretChat
  /// New data about the secret chat.
  secret_chat: Option<SecretChat>,
  
}



impl Object for UpdateSecretChat {}
impl RObject for UpdateSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateSecretChat {}


impl UpdateSecretChat {
  
  
  pub fn secret_chat(&self) -> Option<SecretChat> { self.secret_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserFullInfo
  /// User identifier.
  user_id: Option<i32>,
  /// New full information about the user.
  user_full_info: Option<UserFullInfo>,
  
}



impl Object for UpdateUserFullInfo {}
impl RObject for UpdateUserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUserFullInfo {}


impl UpdateUserFullInfo {
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn user_full_info(&self) -> Option<UserFullInfo> { self.user_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUserFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateBasicGroupFullInfo
  /// Identifier of a basic group.
  basic_group_id: Option<i32>,
  /// New full information about the group.
  basic_group_full_info: Option<BasicGroupFullInfo>,
  
}



impl Object for UpdateBasicGroupFullInfo {}
impl RObject for UpdateBasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateBasicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateBasicGroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateBasicGroupFullInfo {}


impl UpdateBasicGroupFullInfo {
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn basic_group_full_info(&self) -> Option<BasicGroupFullInfo> { self.basic_group_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateBasicGroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSupergroupFullInfo
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New full information about the supergroup.
  supergroup_full_info: Option<SupergroupFullInfo>,
  
}



impl Object for UpdateSupergroupFullInfo {}
impl RObject for UpdateSupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSupergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSupergroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateSupergroupFullInfo {}


impl UpdateSupergroupFullInfo {
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn supergroup_full_info(&self) -> Option<SupergroupFullInfo> { self.supergroup_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateSupergroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Service notification from the server. Upon receiving this the client must show a popup with the content of the notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateServiceNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateServiceNotification
  /// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" should be shown under notification; if user presses the second, all local data should be destroyed using Destroy method.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Notification content.
  content: Option<Box<MessageContent>>,
  
}


impl Clone for UpdateServiceNotification {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateServiceNotification {}
impl RObject for UpdateServiceNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateServiceNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateServiceNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateServiceNotification {}


impl UpdateServiceNotification {
  
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn content(&self) -> Option<Box<MessageContent>> { self.content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateServiceNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Information about a file was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFile
  /// New data about the file.
  file: Option<File>,
  
}



impl Object for UpdateFile {}
impl RObject for UpdateFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFile" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateFile {}


impl UpdateFile {
  
  
  pub fn file(&self) -> Option<File> { self.file.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The file generation process needs to be started by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFileGenerationStart
  /// Unique identifier for the generation process.
  generation_id: Option<i64>,
  /// The path to a file from which a new file is generated; may be empty.
  original_path: Option<String>,
  /// The path to a file that should be created and where the new file should be generated.
  destination_path: Option<String>,
  /// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which should be downloaded by the client.
  conversion: Option<String>,
  
}



impl Object for UpdateFileGenerationStart {}
impl RObject for UpdateFileGenerationStart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFileGenerationStart" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFileGenerationStart }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateFileGenerationStart {}


impl UpdateFileGenerationStart {
  
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn original_path(&self) -> Option<String> { self.original_path.clone() }
  
  pub fn destination_path(&self) -> Option<String> { self.destination_path.clone() }
  
  pub fn conversion(&self) -> Option<String> { self.conversion.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateFileGenerationStart> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// File generation is no longer needed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFileGenerationStop
  /// Unique identifier for the generation process.
  generation_id: Option<i64>,
  
}



impl Object for UpdateFileGenerationStop {}
impl RObject for UpdateFileGenerationStop {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFileGenerationStop" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFileGenerationStop }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateFileGenerationStop {}


impl UpdateFileGenerationStop {
  
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateFileGenerationStop> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// New call was created or information about a call was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateCall
  /// New data about a call.
  call: Option<Call>,
  
}



impl Object for UpdateCall {}
impl RObject for UpdateCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateCall" }
  fn td_type(&self) -> RTDType { RTDType::UpdateCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateCall {}


impl UpdateCall {
  
  
  pub fn call(&self) -> Option<Call> { self.call.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some privacy setting rules have been changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// New privacy rules.
  rules: Option<UserPrivacySettingRules>,
  
}


impl Clone for UpdateUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateUserPrivacySettingRules {}
impl RObject for UpdateUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserPrivacySettingRules }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUserPrivacySettingRules {}


impl UpdateUserPrivacySettingRules {
  
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn rules(&self) -> Option<UserPrivacySettingRules> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUserPrivacySettingRules> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Number of unread messages has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUnreadMessageCount
  /// Total number of unread messages.
  unread_count: Option<i32>,
  /// Total number of unread messages in unmuted chats.
  unread_unmuted_count: Option<i32>,
  
}



impl Object for UpdateUnreadMessageCount {}
impl RObject for UpdateUnreadMessageCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUnreadMessageCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUnreadMessageCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUnreadMessageCount {}


impl UpdateUnreadMessageCount {
  
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn unread_unmuted_count(&self) -> Option<i32> { self.unread_unmuted_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUnreadMessageCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadChatCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUnreadChatCount
  /// Total number of unread chats.
  unread_count: Option<i32>,
  /// Total number of unread unmuted chats.
  unread_unmuted_count: Option<i32>,
  /// Total number of chats marked as unread.
  marked_as_unread_count: Option<i32>,
  /// Total number of unmuted chats marked as unread.
  marked_as_unread_unmuted_count: Option<i32>,
  
}



impl Object for UpdateUnreadChatCount {}
impl RObject for UpdateUnreadChatCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUnreadChatCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUnreadChatCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateUnreadChatCount {}


impl UpdateUnreadChatCount {
  
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn unread_unmuted_count(&self) -> Option<i32> { self.unread_unmuted_count.clone() }
  
  pub fn marked_as_unread_count(&self) -> Option<i32> { self.marked_as_unread_count.clone() }
  
  pub fn marked_as_unread_unmuted_count(&self) -> Option<i32> { self.marked_as_unread_unmuted_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateUnreadChatCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// An option changed its value. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateOption
  /// The option name.
  name: Option<String>,
  /// The new option value.
  value: Option<Box<OptionValue>>,
  
}


impl Clone for UpdateOption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateOption {}
impl RObject for UpdateOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateOption" }
  fn td_type(&self) -> RTDType { RTDType::UpdateOption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateOption {}


impl UpdateOption {
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn value(&self) -> Option<Box<OptionValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateOption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The list of installed sticker sets was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateInstalledStickerSets
  /// True, if the list of installed mask sticker sets was updated.
  is_masks: Option<bool>,
  /// The new list of installed ordinary sticker sets.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for UpdateInstalledStickerSets {}
impl RObject for UpdateInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::UpdateInstalledStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateInstalledStickerSets {}


impl UpdateInstalledStickerSets {
  
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateInstalledStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The list of trending sticker sets was updated or some of them were viewed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateTrendingStickerSets
  /// The new list of trending sticker sets.
  sticker_sets: Option<StickerSets>,
  
}



impl Object for UpdateTrendingStickerSets {}
impl RObject for UpdateTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::UpdateTrendingStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateTrendingStickerSets {}


impl UpdateTrendingStickerSets {
  
  
  pub fn sticker_sets(&self) -> Option<StickerSets> { self.sticker_sets.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateTrendingStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The list of recently used stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateRecentStickers
  /// True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated.
  is_attached: Option<bool>,
  /// The new list of file identifiers of recently used stickers.
  sticker_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateRecentStickers {}
impl RObject for UpdateRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::UpdateRecentStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateRecentStickers {}


impl UpdateRecentStickers {
  
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker_ids(&self) -> Option<Vec<i32>> { self.sticker_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateRecentStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The list of favorite stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFavoriteStickers
  /// The new list of file identifiers of favorite stickers.
  sticker_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateFavoriteStickers {}
impl RObject for UpdateFavoriteStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFavoriteStickers" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFavoriteStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateFavoriteStickers {}


impl UpdateFavoriteStickers {
  
  
  pub fn sticker_ids(&self) -> Option<Vec<i32>> { self.sticker_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateFavoriteStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The list of saved animations was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSavedAnimations
  /// The new list of file identifiers of saved animations.
  animation_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateSavedAnimations {}
impl RObject for UpdateSavedAnimations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSavedAnimations" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSavedAnimations }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateSavedAnimations {}


impl UpdateSavedAnimations {
  
  
  pub fn animation_ids(&self) -> Option<Vec<i32>> { self.animation_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateSavedAnimations> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Some language pack strings have been updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateLanguagePackStrings
  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Identifier of the updated language pack.
  language_pack_id: Option<String>,
  /// List of changed language pack strings.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for UpdateLanguagePackStrings {}
impl RObject for UpdateLanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateLanguagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateLanguagePackStrings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateLanguagePackStrings {}


impl UpdateLanguagePackStrings {
  
  
  pub fn localization_target(&self) -> Option<String> { self.localization_target.clone() }
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateLanguagePackStrings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The connection state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateConnectionState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateConnectionState
  /// The new connection state.
  state: Option<Box<ConnectionState>>,
  
}


impl Clone for UpdateConnectionState {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateConnectionState {}
impl RObject for UpdateConnectionState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateConnectionState" }
  fn td_type(&self) -> RTDType { RTDType::UpdateConnectionState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateConnectionState {}


impl UpdateConnectionState {
  
  
  pub fn state(&self) -> Option<Box<ConnectionState>> { self.state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateConnectionState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// New terms of service must be accepted by the user. If the terms of service are declined, then the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateTermsOfService
  /// Identifier of the terms of service.
  terms_of_service_id: Option<String>,
  /// The new terms of service.
  terms_of_service: Option<TermsOfService>,
  
}



impl Object for UpdateTermsOfService {}
impl RObject for UpdateTermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateTermsOfService" }
  fn td_type(&self) -> RTDType { RTDType::UpdateTermsOfService }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateTermsOfService {}


impl UpdateTermsOfService {
  
  
  pub fn terms_of_service_id(&self) -> Option<String> { self.terms_of_service_id.clone() }
  
  pub fn terms_of_service(&self) -> Option<TermsOfService> { self.terms_of_service.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateTermsOfService> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewInlineQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,
  
}



impl Object for UpdateNewInlineQuery {}
impl RObject for UpdateNewInlineQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewInlineQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewInlineQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewInlineQuery {}


impl UpdateNewInlineQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset(&self) -> Option<String> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewInlineQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// The user has chosen a result of an inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChosenInlineResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewChosenInlineResult
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Identifier of the chosen result.
  result_id: Option<String>,
  /// Identifier of the sent inline message, if known.
  inline_message_id: Option<String>,
  
}



impl Object for UpdateNewChosenInlineResult {}
impl RObject for UpdateNewChosenInlineResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewChosenInlineResult" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewChosenInlineResult }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewChosenInlineResult {}


impl UpdateNewChosenInlineResult {
  
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn result_id(&self) -> Option<String> { self.result_id.clone() }
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewChosenInlineResult> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming callback query; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCallbackQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the chat, in which the query was sent.
  chat_id: Option<i64>,
  /// Identifier of the message, from which the query originated.
  message_id: Option<i64>,
  /// Identifier that uniquely corresponds to the chat to which the message was sent.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for UpdateNewCallbackQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateNewCallbackQuery {}
impl RObject for UpdateNewCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCallbackQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewCallbackQuery {}


impl UpdateNewCallbackQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn chat_instance(&self) -> Option<i64> { self.chat_instance.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewCallbackQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming callback query from a message sent via a bot; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewInlineCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewInlineCallbackQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the inline message, from which the query originated.
  inline_message_id: Option<String>,
  /// An identifier uniquely corresponding to the chat a message was sent to.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for UpdateNewInlineCallbackQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UpdateNewInlineCallbackQuery {}
impl RObject for UpdateNewInlineCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewInlineCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewInlineCallbackQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewInlineCallbackQuery {}


impl UpdateNewInlineCallbackQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn chat_instance(&self) -> Option<i64> { self.chat_instance.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewInlineCallbackQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming shipping query; for bots only. Only for invoices with flexible price. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewShippingQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// User shipping address.
  shipping_address: Option<Address>,
  
}



impl Object for UpdateNewShippingQuery {}
impl RObject for UpdateNewShippingQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewShippingQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewShippingQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewShippingQuery {}


impl UpdateNewShippingQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_address(&self) -> Option<Address> { self.shipping_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewShippingQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming pre-checkout query; for bots only. Contains full information about a checkout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewPreCheckoutQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of a shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,
  
}



impl Object for UpdateNewPreCheckoutQuery {}
impl RObject for UpdateNewPreCheckoutQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewPreCheckoutQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewPreCheckoutQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewPreCheckoutQuery {}


impl UpdateNewPreCheckoutQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewPreCheckoutQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming event; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCustomEvent
  /// A JSON-serialized event.
  event: Option<String>,
  
}



impl Object for UpdateNewCustomEvent {}
impl RObject for UpdateNewCustomEvent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCustomEvent" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCustomEvent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewCustomEvent {}


impl UpdateNewCustomEvent {
  
  
  pub fn event(&self) -> Option<String> { self.event.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewCustomEvent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// A new incoming query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCustomQuery
  /// The query identifier.
  id: Option<i64>,
  /// JSON-serialized query data.
  data: Option<String>,
  /// Query timeout.
  timeout: Option<i32>,
  
}



impl Object for UpdateNewCustomQuery {}
impl RObject for UpdateNewCustomQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCustomQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCustomQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdateNewCustomQuery {}


impl UpdateNewCustomQuery {
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn timeout(&self) -> Option<i32> { self.timeout.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdateNewCustomQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Information about a poll was updated; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdatePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updatePoll
  /// New data about the poll.
  poll: Option<Poll>,
  
}



impl Object for UpdatePoll {}
impl RObject for UpdatePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updatePoll" }
  fn td_type(&self) -> RTDType { RTDType::UpdatePoll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl Update for UpdatePoll {}


impl UpdatePoll {
  
  
  pub fn poll(&self) -> Option<Poll> { self.poll.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpdatePoll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}




/// Contains a list of updates. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Updates {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updates
  /// List of updates.
  updates: Option<Vec<Box<Update>>>,
  
}


impl Clone for Updates {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for Updates {}
impl RObject for Updates {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updates" }
  fn td_type(&self) -> RTDType { RTDType::Updates }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Updates {
  
  pub fn builder() -> RTDUpdatesBuilder {
    let instance = Self {
      td_name: "updates".to_string(),
      updates: None,
      
    };
    RTDUpdatesBuilder::new(instance)
  }
  
  
  pub fn updates(&self) -> Option<Vec<Box<Update>>> { self.updates.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Updates> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUpdatesBuilder { instance: Updates }

impl RTDUpdatesBuilder {
  fn new(instance: Updates) -> Self { Self { instance } }

  pub fn build(&self) -> Updates { self.instance.clone() }
  
  pub fn updates(&mut self, updates: Vec<Box<Update>>) -> &mut Self {
    self.instance.updates = Some(updates);
    self
  }
  
}



/// Represents a user. 
#[derive(Debug, Serialize, Deserialize)]
pub struct User {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // user
  /// User identifier.
  id: Option<i32>,
  /// First name of the user.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Username of the user.
  username: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Current online status of the user.
  status: Option<Box<UserStatus>>,
  /// Profile photo of the user; may be null.
  profile_photo: Option<ProfilePhoto>,
  /// Relationship from the current user to the other user.
  outgoing_link: Option<Box<LinkState>>,
  /// Relationship from the other user to the current user.
  incoming_link: Option<Box<LinkState>>,
  /// True, if the user is verified.
  is_verified: Option<bool>,
  /// True, if the user is Telegram support account.
  is_support: Option<bool>,
  /// If non-empty, it contains the reason why access to this user must be restricted. The format of the string is "{type}: {description}". {type} contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,
  /// If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser.
  have_access: Option<bool>,
  /// Type of the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<UserType>>,
  /// IETF language tag of the user's language; only available to bots.
  language_code: Option<String>,
  
}


impl Clone for User {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for User {}
impl RObject for User {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "user" }
  fn td_type(&self) -> RTDType { RTDType::User }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl User {
  
  pub fn builder() -> RTDUserBuilder {
    let instance = Self {
      td_name: "user".to_string(),
      id: None,
      first_name: None,
      last_name: None,
      username: None,
      phone_number: None,
      status: None,
      profile_photo: None,
      outgoing_link: None,
      incoming_link: None,
      is_verified: None,
      is_support: None,
      restriction_reason: None,
      have_access: None,
      type_: None,
      language_code: None,
      
    };
    RTDUserBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn status(&self) -> Option<Box<UserStatus>> { self.status.clone() }
  
  pub fn profile_photo(&self) -> Option<ProfilePhoto> { self.profile_photo.clone() }
  
  pub fn outgoing_link(&self) -> Option<Box<LinkState>> { self.outgoing_link.clone() }
  
  pub fn incoming_link(&self) -> Option<Box<LinkState>> { self.incoming_link.clone() }
  
  pub fn is_verified(&self) -> Option<bool> { self.is_verified.clone() }
  
  pub fn is_support(&self) -> Option<bool> { self.is_support.clone() }
  
  pub fn restriction_reason(&self) -> Option<String> { self.restriction_reason.clone() }
  
  pub fn have_access(&self) -> Option<bool> { self.have_access.clone() }
  
  pub fn type_(&self) -> Option<Box<UserType>> { self.type_.clone() }
  
  pub fn language_code(&self) -> Option<String> { self.language_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<User> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserBuilder { instance: User }

impl RTDUserBuilder {
  fn new(instance: User) -> Self { Self { instance } }

  pub fn build(&self) -> User { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn first_name<S: AsRef<str>>(&mut self, first_name: S) -> &mut Self {
    self.instance.first_name = Some(first_name.as_ref().to_string());
    self
  }
  
  pub fn last_name<S: AsRef<str>>(&mut self, last_name: S) -> &mut Self {
    self.instance.last_name = Some(last_name.as_ref().to_string());
    self
  }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn status(&mut self, status: Box<UserStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn profile_photo(&mut self, profile_photo: ProfilePhoto) -> &mut Self {
    self.instance.profile_photo = Some(profile_photo);
    self
  }
  
  pub fn outgoing_link(&mut self, outgoing_link: Box<LinkState>) -> &mut Self {
    self.instance.outgoing_link = Some(outgoing_link);
    self
  }
  
  pub fn incoming_link(&mut self, incoming_link: Box<LinkState>) -> &mut Self {
    self.instance.incoming_link = Some(incoming_link);
    self
  }
  
  pub fn is_verified(&mut self, is_verified: bool) -> &mut Self {
    self.instance.is_verified = Some(is_verified);
    self
  }
  
  pub fn is_support(&mut self, is_support: bool) -> &mut Self {
    self.instance.is_support = Some(is_support);
    self
  }
  
  pub fn restriction_reason<S: AsRef<str>>(&mut self, restriction_reason: S) -> &mut Self {
    self.instance.restriction_reason = Some(restriction_reason.as_ref().to_string());
    self
  }
  
  pub fn have_access(&mut self, have_access: bool) -> &mut Self {
    self.instance.have_access = Some(have_access);
    self
  }
  
  pub fn type_(&mut self, type_: Box<UserType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn language_code<S: AsRef<str>>(&mut self, language_code: S) -> &mut Self {
    self.instance.language_code = Some(language_code.as_ref().to_string());
    self
  }
  
}



/// Contains full information about a user (except the full list of profile photos). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userFullInfo
  /// True, if the user is blacklisted by the current user.
  is_blocked: Option<bool>,
  /// True, if the user can be called.
  can_be_called: Option<bool>,
  /// True, if the user can't be called due to their privacy settings.
  has_private_calls: Option<bool>,
  /// A short user bio.
  bio: Option<String>,
  /// For bots, the text that is included with the link when users share the bot.
  share_text: Option<String>,
  /// Number of group chats where both the other user and the current user are a member; 0 for the current user.
  group_in_common_count: Option<i32>,
  /// If the user is a bot, information about the bot; may be null.
  bot_info: Option<BotInfo>,
  
}



impl Object for UserFullInfo {}
impl RObject for UserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UserFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl UserFullInfo {
  
  pub fn builder() -> RTDUserFullInfoBuilder {
    let instance = Self {
      td_name: "userFullInfo".to_string(),
      is_blocked: None,
      can_be_called: None,
      has_private_calls: None,
      bio: None,
      share_text: None,
      group_in_common_count: None,
      bot_info: None,
      
    };
    RTDUserFullInfoBuilder::new(instance)
  }
  
  
  pub fn is_blocked(&self) -> Option<bool> { self.is_blocked.clone() }
  
  pub fn can_be_called(&self) -> Option<bool> { self.can_be_called.clone() }
  
  pub fn has_private_calls(&self) -> Option<bool> { self.has_private_calls.clone() }
  
  pub fn bio(&self) -> Option<String> { self.bio.clone() }
  
  pub fn share_text(&self) -> Option<String> { self.share_text.clone() }
  
  pub fn group_in_common_count(&self) -> Option<i32> { self.group_in_common_count.clone() }
  
  pub fn bot_info(&self) -> Option<BotInfo> { self.bot_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserFullInfoBuilder { instance: UserFullInfo }

impl RTDUserFullInfoBuilder {
  fn new(instance: UserFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> UserFullInfo { self.instance.clone() }
  
  pub fn is_blocked(&mut self, is_blocked: bool) -> &mut Self {
    self.instance.is_blocked = Some(is_blocked);
    self
  }
  
  pub fn can_be_called(&mut self, can_be_called: bool) -> &mut Self {
    self.instance.can_be_called = Some(can_be_called);
    self
  }
  
  pub fn has_private_calls(&mut self, has_private_calls: bool) -> &mut Self {
    self.instance.has_private_calls = Some(has_private_calls);
    self
  }
  
  pub fn bio<S: AsRef<str>>(&mut self, bio: S) -> &mut Self {
    self.instance.bio = Some(bio.as_ref().to_string());
    self
  }
  
  pub fn share_text<S: AsRef<str>>(&mut self, share_text: S) -> &mut Self {
    self.instance.share_text = Some(share_text.as_ref().to_string());
    self
  }
  
  pub fn group_in_common_count(&mut self, group_in_common_count: i32) -> &mut Self {
    self.instance.group_in_common_count = Some(group_in_common_count);
    self
  }
  
  pub fn bot_info(&mut self, bot_info: BotInfo) -> &mut Self {
    self.instance.bot_info = Some(bot_info);
    self
  }
  
}



/// This class is an abstract base class. Describes available user privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySetting: Object + RObject + Debug {}







impl UserPrivacySetting {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<UserPrivacySetting>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<UserPrivacySetting> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserPrivacySettingType {
  UserPrivacySettingAllowCalls,
  UserPrivacySettingAllowChatInvites,
  UserPrivacySettingAllowPeerToPeerCalls,
  UserPrivacySettingShowStatus,
  
}
impl RTDUserPrivacySettingType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A privacy setting for managing whether the user's online status is visible. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingShowStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingShowStatus
  
}



impl Object for UserPrivacySettingShowStatus {}
impl RObject for UserPrivacySettingShowStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingShowStatus" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingShowStatus }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingShowStatus {}


impl UserPrivacySettingShowStatus {
  
  pub fn builder() -> RTDUserPrivacySettingShowStatusBuilder {
    let instance = Self {
      td_name: "userPrivacySettingShowStatus".to_string(),
      
    };
    RTDUserPrivacySettingShowStatusBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingShowStatus> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingShowStatusBuilder { instance: UserPrivacySettingShowStatus }

impl RTDUserPrivacySettingShowStatusBuilder {
  fn new(instance: UserPrivacySettingShowStatus) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingShowStatus { self.instance.clone() }
  
}



/// A privacy setting for managing whether the user can be invited to chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowChatInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowChatInvites
  
}



impl Object for UserPrivacySettingAllowChatInvites {}
impl RObject for UserPrivacySettingAllowChatInvites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowChatInvites" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowChatInvites }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowChatInvites {}


impl UserPrivacySettingAllowChatInvites {
  
  pub fn builder() -> RTDUserPrivacySettingAllowChatInvitesBuilder {
    let instance = Self {
      td_name: "userPrivacySettingAllowChatInvites".to_string(),
      
    };
    RTDUserPrivacySettingAllowChatInvitesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingAllowChatInvites> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingAllowChatInvitesBuilder { instance: UserPrivacySettingAllowChatInvites }

impl RTDUserPrivacySettingAllowChatInvitesBuilder {
  fn new(instance: UserPrivacySettingAllowChatInvites) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowChatInvites { self.instance.clone() }
  
}



/// A privacy setting for managing whether the user can be called. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowCalls
  
}



impl Object for UserPrivacySettingAllowCalls {}
impl RObject for UserPrivacySettingAllowCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowCalls" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowCalls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowCalls {}


impl UserPrivacySettingAllowCalls {
  
  pub fn builder() -> RTDUserPrivacySettingAllowCallsBuilder {
    let instance = Self {
      td_name: "userPrivacySettingAllowCalls".to_string(),
      
    };
    RTDUserPrivacySettingAllowCallsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingAllowCalls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingAllowCallsBuilder { instance: UserPrivacySettingAllowCalls }

impl RTDUserPrivacySettingAllowCallsBuilder {
  fn new(instance: UserPrivacySettingAllowCalls) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowCalls { self.instance.clone() }
  
}



/// A privacy setting for managing whether peer-to-peer connections can be used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowPeerToPeerCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowPeerToPeerCalls
  
}



impl Object for UserPrivacySettingAllowPeerToPeerCalls {}
impl RObject for UserPrivacySettingAllowPeerToPeerCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowPeerToPeerCalls" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowPeerToPeerCalls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowPeerToPeerCalls {}


impl UserPrivacySettingAllowPeerToPeerCalls {
  
  pub fn builder() -> RTDUserPrivacySettingAllowPeerToPeerCallsBuilder {
    let instance = Self {
      td_name: "userPrivacySettingAllowPeerToPeerCalls".to_string(),
      
    };
    RTDUserPrivacySettingAllowPeerToPeerCallsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingAllowPeerToPeerCalls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingAllowPeerToPeerCallsBuilder { instance: UserPrivacySettingAllowPeerToPeerCalls }

impl RTDUserPrivacySettingAllowPeerToPeerCallsBuilder {
  fn new(instance: UserPrivacySettingAllowPeerToPeerCalls) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowPeerToPeerCalls { self.instance.clone() }
  
}



/// This class is an abstract base class. Represents a single rule for managing privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySettingRule: Object + RObject + Debug {}







impl UserPrivacySettingRule {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<UserPrivacySettingRule>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<UserPrivacySettingRule> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserPrivacySettingRuleType {
  UserPrivacySettingRuleAllowAll,
  UserPrivacySettingRuleAllowContacts,
  UserPrivacySettingRuleAllowUsers,
  UserPrivacySettingRuleRestrictAll,
  UserPrivacySettingRuleRestrictContacts,
  UserPrivacySettingRuleRestrictUsers,
  
}
impl RTDUserPrivacySettingRuleType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A rule to allow all users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowAll
  
}



impl Object for UserPrivacySettingRuleAllowAll {}
impl RObject for UserPrivacySettingRuleAllowAll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowAll" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowAll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowAll {}


impl UserPrivacySettingRuleAllowAll {
  
  pub fn builder() -> RTDUserPrivacySettingRuleAllowAllBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleAllowAll".to_string(),
      
    };
    RTDUserPrivacySettingRuleAllowAllBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleAllowAll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleAllowAllBuilder { instance: UserPrivacySettingRuleAllowAll }

impl RTDUserPrivacySettingRuleAllowAllBuilder {
  fn new(instance: UserPrivacySettingRuleAllowAll) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowAll { self.instance.clone() }
  
}



/// A rule to allow all of a user's contacts to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowContacts
  
}



impl Object for UserPrivacySettingRuleAllowContacts {}
impl RObject for UserPrivacySettingRuleAllowContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowContacts" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowContacts {}


impl UserPrivacySettingRuleAllowContacts {
  
  pub fn builder() -> RTDUserPrivacySettingRuleAllowContactsBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleAllowContacts".to_string(),
      
    };
    RTDUserPrivacySettingRuleAllowContactsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleAllowContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleAllowContactsBuilder { instance: UserPrivacySettingRuleAllowContacts }

impl RTDUserPrivacySettingRuleAllowContactsBuilder {
  fn new(instance: UserPrivacySettingRuleAllowContacts) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowContacts { self.instance.clone() }
  
}



/// A rule to allow certain specified users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowUsers
  /// The user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for UserPrivacySettingRuleAllowUsers {}
impl RObject for UserPrivacySettingRuleAllowUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowUsers" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowUsers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowUsers {}


impl UserPrivacySettingRuleAllowUsers {
  
  pub fn builder() -> RTDUserPrivacySettingRuleAllowUsersBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleAllowUsers".to_string(),
      user_ids: None,
      
    };
    RTDUserPrivacySettingRuleAllowUsersBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleAllowUsers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleAllowUsersBuilder { instance: UserPrivacySettingRuleAllowUsers }

impl RTDUserPrivacySettingRuleAllowUsersBuilder {
  fn new(instance: UserPrivacySettingRuleAllowUsers) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowUsers { self.instance.clone() }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// A rule to restrict all users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictAll
  
}



impl Object for UserPrivacySettingRuleRestrictAll {}
impl RObject for UserPrivacySettingRuleRestrictAll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictAll" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictAll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictAll {}


impl UserPrivacySettingRuleRestrictAll {
  
  pub fn builder() -> RTDUserPrivacySettingRuleRestrictAllBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleRestrictAll".to_string(),
      
    };
    RTDUserPrivacySettingRuleRestrictAllBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleRestrictAll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleRestrictAllBuilder { instance: UserPrivacySettingRuleRestrictAll }

impl RTDUserPrivacySettingRuleRestrictAllBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictAll) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictAll { self.instance.clone() }
  
}



/// A rule to restrict all contacts of a user from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictContacts
  
}



impl Object for UserPrivacySettingRuleRestrictContacts {}
impl RObject for UserPrivacySettingRuleRestrictContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictContacts" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictContacts {}


impl UserPrivacySettingRuleRestrictContacts {
  
  pub fn builder() -> RTDUserPrivacySettingRuleRestrictContactsBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleRestrictContacts".to_string(),
      
    };
    RTDUserPrivacySettingRuleRestrictContactsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleRestrictContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleRestrictContactsBuilder { instance: UserPrivacySettingRuleRestrictContacts }

impl RTDUserPrivacySettingRuleRestrictContactsBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictContacts) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictContacts { self.instance.clone() }
  
}



/// A rule to restrict all specified users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictUsers
  /// The user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for UserPrivacySettingRuleRestrictUsers {}
impl RObject for UserPrivacySettingRuleRestrictUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictUsers" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictUsers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictUsers {}


impl UserPrivacySettingRuleRestrictUsers {
  
  pub fn builder() -> RTDUserPrivacySettingRuleRestrictUsersBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRuleRestrictUsers".to_string(),
      user_ids: None,
      
    };
    RTDUserPrivacySettingRuleRestrictUsersBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRuleRestrictUsers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRuleRestrictUsersBuilder { instance: UserPrivacySettingRuleRestrictUsers }

impl RTDUserPrivacySettingRuleRestrictUsersBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictUsers) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictUsers { self.instance.clone() }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRules
  /// A list of rules.
  rules: Option<Vec<Box<UserPrivacySettingRule>>>,
  
}


impl Clone for UserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UserPrivacySettingRules {}
impl RObject for UserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRules }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl UserPrivacySettingRules {
  
  pub fn builder() -> RTDUserPrivacySettingRulesBuilder {
    let instance = Self {
      td_name: "userPrivacySettingRules".to_string(),
      rules: None,
      
    };
    RTDUserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn rules(&self) -> Option<Vec<Box<UserPrivacySettingRule>>> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserPrivacySettingRules> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserPrivacySettingRulesBuilder { instance: UserPrivacySettingRules }

impl RTDUserPrivacySettingRulesBuilder {
  fn new(instance: UserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRules { self.instance.clone() }
  
  pub fn rules(&mut self, rules: Vec<Box<UserPrivacySettingRule>>) -> &mut Self {
    self.instance.rules = Some(rules);
    self
  }
  
}



/// Contains full information about a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userProfilePhoto
  /// Unique user profile photo identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the photo has been added.
  added_date: Option<i32>,
  /// Available variants of the user photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,
  
}



impl Object for UserProfilePhoto {}
impl RObject for UserProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::UserProfilePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl UserProfilePhoto {
  
  pub fn builder() -> RTDUserProfilePhotoBuilder {
    let instance = Self {
      td_name: "userProfilePhoto".to_string(),
      id: None,
      added_date: None,
      sizes: None,
      
    };
    RTDUserProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn added_date(&self) -> Option<i32> { self.added_date.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserProfilePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserProfilePhotoBuilder { instance: UserProfilePhoto }

impl RTDUserProfilePhotoBuilder {
  fn new(instance: UserProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> UserProfilePhoto { self.instance.clone() }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn added_date(&mut self, added_date: i32) -> &mut Self {
    self.instance.added_date = Some(added_date);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
}



/// Contains part of the list of user photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userProfilePhotos
  /// Total number of user profile photos.
  total_count: Option<i32>,
  /// A list of photos.
  photos: Option<Vec<UserProfilePhoto>>,
  
}



impl Object for UserProfilePhotos {}
impl RObject for UserProfilePhotos {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userProfilePhotos" }
  fn td_type(&self) -> RTDType { RTDType::UserProfilePhotos }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl UserProfilePhotos {
  
  pub fn builder() -> RTDUserProfilePhotosBuilder {
    let instance = Self {
      td_name: "userProfilePhotos".to_string(),
      total_count: None,
      photos: None,
      
    };
    RTDUserProfilePhotosBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn photos(&self) -> Option<Vec<UserProfilePhoto>> { self.photos.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserProfilePhotos> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserProfilePhotosBuilder { instance: UserProfilePhotos }

impl RTDUserProfilePhotosBuilder {
  fn new(instance: UserProfilePhotos) -> Self { Self { instance } }

  pub fn build(&self) -> UserProfilePhotos { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn photos(&mut self, photos: Vec<UserProfilePhoto>) -> &mut Self {
    self.instance.photos = Some(photos);
    self
  }
  
}



/// This class is an abstract base class. Describes the last time the user was online. 
#[typetag::serde(tag = "@struct")]
pub trait UserStatus: Object + RObject + Debug {}







impl UserStatus {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<UserStatus>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<UserStatus> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserStatusType {
  UserStatusEmpty,
  UserStatusLastMonth,
  UserStatusLastWeek,
  UserStatusOffline,
  UserStatusOnline,
  UserStatusRecently,
  
}
impl RTDUserStatusType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// The user status was never changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusEmpty
  
}



impl Object for UserStatusEmpty {}
impl RObject for UserStatusEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusEmpty" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusEmpty {}


impl UserStatusEmpty {
  
  pub fn builder() -> RTDUserStatusEmptyBuilder {
    let instance = Self {
      td_name: "userStatusEmpty".to_string(),
      
    };
    RTDUserStatusEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusEmptyBuilder { instance: UserStatusEmpty }

impl RTDUserStatusEmptyBuilder {
  fn new(instance: UserStatusEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusEmpty { self.instance.clone() }
  
}



/// The user is online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOnline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusOnline
  /// Point in time (Unix timestamp) when the user's online status will expire.
  expires: Option<i32>,
  
}



impl Object for UserStatusOnline {}
impl RObject for UserStatusOnline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusOnline" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusOnline }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusOnline {}


impl UserStatusOnline {
  
  pub fn builder() -> RTDUserStatusOnlineBuilder {
    let instance = Self {
      td_name: "userStatusOnline".to_string(),
      expires: None,
      
    };
    RTDUserStatusOnlineBuilder::new(instance)
  }
  
  
  pub fn expires(&self) -> Option<i32> { self.expires.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusOnline> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusOnlineBuilder { instance: UserStatusOnline }

impl RTDUserStatusOnlineBuilder {
  fn new(instance: UserStatusOnline) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusOnline { self.instance.clone() }
  
  pub fn expires(&mut self, expires: i32) -> &mut Self {
    self.instance.expires = Some(expires);
    self
  }
  
}



/// The user is offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOffline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusOffline
  /// Point in time (Unix timestamp) when the user was last online.
  was_online: Option<i32>,
  
}



impl Object for UserStatusOffline {}
impl RObject for UserStatusOffline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusOffline" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusOffline }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusOffline {}


impl UserStatusOffline {
  
  pub fn builder() -> RTDUserStatusOfflineBuilder {
    let instance = Self {
      td_name: "userStatusOffline".to_string(),
      was_online: None,
      
    };
    RTDUserStatusOfflineBuilder::new(instance)
  }
  
  
  pub fn was_online(&self) -> Option<i32> { self.was_online.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusOffline> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusOfflineBuilder { instance: UserStatusOffline }

impl RTDUserStatusOfflineBuilder {
  fn new(instance: UserStatusOffline) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusOffline { self.instance.clone() }
  
  pub fn was_online(&mut self, was_online: i32) -> &mut Self {
    self.instance.was_online = Some(was_online);
    self
  }
  
}



/// The user was online recently. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusRecently {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusRecently
  
}



impl Object for UserStatusRecently {}
impl RObject for UserStatusRecently {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusRecently" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusRecently }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusRecently {}


impl UserStatusRecently {
  
  pub fn builder() -> RTDUserStatusRecentlyBuilder {
    let instance = Self {
      td_name: "userStatusRecently".to_string(),
      
    };
    RTDUserStatusRecentlyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusRecently> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusRecentlyBuilder { instance: UserStatusRecently }

impl RTDUserStatusRecentlyBuilder {
  fn new(instance: UserStatusRecently) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusRecently { self.instance.clone() }
  
}



/// The user is offline, but was online last week. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastWeek {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusLastWeek
  
}



impl Object for UserStatusLastWeek {}
impl RObject for UserStatusLastWeek {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusLastWeek" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusLastWeek }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusLastWeek {}


impl UserStatusLastWeek {
  
  pub fn builder() -> RTDUserStatusLastWeekBuilder {
    let instance = Self {
      td_name: "userStatusLastWeek".to_string(),
      
    };
    RTDUserStatusLastWeekBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusLastWeek> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusLastWeekBuilder { instance: UserStatusLastWeek }

impl RTDUserStatusLastWeekBuilder {
  fn new(instance: UserStatusLastWeek) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusLastWeek { self.instance.clone() }
  
}



/// The user is offline, but was online last month. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastMonth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusLastMonth
  
}



impl Object for UserStatusLastMonth {}
impl RObject for UserStatusLastMonth {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusLastMonth" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusLastMonth }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserStatus for UserStatusLastMonth {}


impl UserStatusLastMonth {
  
  pub fn builder() -> RTDUserStatusLastMonthBuilder {
    let instance = Self {
      td_name: "userStatusLastMonth".to_string(),
      
    };
    RTDUserStatusLastMonthBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserStatusLastMonth> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserStatusLastMonthBuilder { instance: UserStatusLastMonth }

impl RTDUserStatusLastMonthBuilder {
  fn new(instance: UserStatusLastMonth) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusLastMonth { self.instance.clone() }
  
}



/// This class is an abstract base class. Represents the type of the user. The following types are possible: regular users, deleted users and bots. 
#[typetag::serde(tag = "@struct")]
pub trait UserType: Object + RObject + Debug {}







impl UserType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<UserType>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<UserType> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserTypeType {
  UserTypeBot,
  UserTypeDeleted,
  UserTypeRegular,
  UserTypeUnknown,
  
}
impl RTDUserTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}



/// A regular user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeRegular {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeRegular
  
}



impl Object for UserTypeRegular {}
impl RObject for UserTypeRegular {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeRegular" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeRegular }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserType for UserTypeRegular {}


impl UserTypeRegular {
  
  pub fn builder() -> RTDUserTypeRegularBuilder {
    let instance = Self {
      td_name: "userTypeRegular".to_string(),
      
    };
    RTDUserTypeRegularBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserTypeRegular> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserTypeRegularBuilder { instance: UserTypeRegular }

impl RTDUserTypeRegularBuilder {
  fn new(instance: UserTypeRegular) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeRegular { self.instance.clone() }
  
}



/// A deleted user or deleted bot. No information on the user besides the user_id is available. It is not possible to perform any active actions on this type of user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeDeleted
  
}



impl Object for UserTypeDeleted {}
impl RObject for UserTypeDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeDeleted" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeDeleted }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserType for UserTypeDeleted {}


impl UserTypeDeleted {
  
  pub fn builder() -> RTDUserTypeDeletedBuilder {
    let instance = Self {
      td_name: "userTypeDeleted".to_string(),
      
    };
    RTDUserTypeDeletedBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserTypeDeleted> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserTypeDeletedBuilder { instance: UserTypeDeleted }

impl RTDUserTypeDeletedBuilder {
  fn new(instance: UserTypeDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeDeleted { self.instance.clone() }
  
}



/// A bot (see 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeBot
  /// True, if the bot can be invited to basic group and supergroup chats.
  can_join_groups: Option<bool>,
  /// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages.
  can_read_all_group_messages: Option<bool>,
  /// True, if the bot supports inline queries.
  is_inline: Option<bool>,
  /// Placeholder for inline queries (displayed on the client input field).
  inline_query_placeholder: Option<String>,
  /// True, if the location of the user should be sent with every inline query to this bot.
  need_location: Option<bool>,
  
}



impl Object for UserTypeBot {}
impl RObject for UserTypeBot {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeBot" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeBot }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserType for UserTypeBot {}


impl UserTypeBot {
  
  pub fn builder() -> RTDUserTypeBotBuilder {
    let instance = Self {
      td_name: "userTypeBot".to_string(),
      can_join_groups: None,
      can_read_all_group_messages: None,
      is_inline: None,
      inline_query_placeholder: None,
      need_location: None,
      
    };
    RTDUserTypeBotBuilder::new(instance)
  }
  
  
  pub fn can_join_groups(&self) -> Option<bool> { self.can_join_groups.clone() }
  
  pub fn can_read_all_group_messages(&self) -> Option<bool> { self.can_read_all_group_messages.clone() }
  
  pub fn is_inline(&self) -> Option<bool> { self.is_inline.clone() }
  
  pub fn inline_query_placeholder(&self) -> Option<String> { self.inline_query_placeholder.clone() }
  
  pub fn need_location(&self) -> Option<bool> { self.need_location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserTypeBot> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserTypeBotBuilder { instance: UserTypeBot }

impl RTDUserTypeBotBuilder {
  fn new(instance: UserTypeBot) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeBot { self.instance.clone() }
  
  pub fn can_join_groups(&mut self, can_join_groups: bool) -> &mut Self {
    self.instance.can_join_groups = Some(can_join_groups);
    self
  }
  
  pub fn can_read_all_group_messages(&mut self, can_read_all_group_messages: bool) -> &mut Self {
    self.instance.can_read_all_group_messages = Some(can_read_all_group_messages);
    self
  }
  
  pub fn is_inline(&mut self, is_inline: bool) -> &mut Self {
    self.instance.is_inline = Some(is_inline);
    self
  }
  
  pub fn inline_query_placeholder<S: AsRef<str>>(&mut self, inline_query_placeholder: S) -> &mut Self {
    self.instance.inline_query_placeholder = Some(inline_query_placeholder.as_ref().to_string());
    self
  }
  
  pub fn need_location(&mut self, need_location: bool) -> &mut Self {
    self.instance.need_location = Some(need_location);
    self
  }
  
}



/// No information on the user besides the user_id is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeUnknown
  
}



impl Object for UserTypeUnknown {}
impl RObject for UserTypeUnknown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeUnknown" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeUnknown }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


#[typetag::serde] impl UserType for UserTypeUnknown {}


impl UserTypeUnknown {
  
  pub fn builder() -> RTDUserTypeUnknownBuilder {
    let instance = Self {
      td_name: "userTypeUnknown".to_string(),
      
    };
    RTDUserTypeUnknownBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UserTypeUnknown> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUserTypeUnknownBuilder { instance: UserTypeUnknown }

impl RTDUserTypeUnknownBuilder {
  fn new(instance: UserTypeUnknown) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeUnknown { self.instance.clone() }
  
}



/// Represents a list of users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Users {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // users
  /// Approximate total count of users found.
  total_count: Option<i32>,
  /// A list of user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for Users {}
impl RObject for Users {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "users" }
  fn td_type(&self) -> RTDType { RTDType::Users }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Users {
  
  pub fn builder() -> RTDUsersBuilder {
    let instance = Self {
      td_name: "users".to_string(),
      total_count: None,
      user_ids: None,
      
    };
    RTDUsersBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Users> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUsersBuilder { instance: Users }

impl RTDUsersBuilder {
  fn new(instance: Users) -> Self { Self { instance } }

  pub fn build(&self) -> Users { self.instance.clone() }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // validatedOrderInfo
  /// Temporary identifier of the order information.
  order_info_id: Option<String>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,
  
}



impl Object for ValidatedOrderInfo {}
impl RObject for ValidatedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "validatedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::ValidatedOrderInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl ValidatedOrderInfo {
  
  pub fn builder() -> RTDValidatedOrderInfoBuilder {
    let instance = Self {
      td_name: "validatedOrderInfo".to_string(),
      order_info_id: None,
      shipping_options: None,
      
    };
    RTDValidatedOrderInfoBuilder::new(instance)
  }
  
  
  pub fn order_info_id(&self) -> Option<String> { self.order_info_id.clone() }
  
  pub fn shipping_options(&self) -> Option<Vec<ShippingOption>> { self.shipping_options.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ValidatedOrderInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDValidatedOrderInfoBuilder { instance: ValidatedOrderInfo }

impl RTDValidatedOrderInfoBuilder {
  fn new(instance: ValidatedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ValidatedOrderInfo { self.instance.clone() }
  
  pub fn order_info_id<S: AsRef<str>>(&mut self, order_info_id: S) -> &mut Self {
    self.instance.order_info_id = Some(order_info_id.as_ref().to_string());
    self
  }
  
  pub fn shipping_options(&mut self, shipping_options: Vec<ShippingOption>) -> &mut Self {
    self.instance.shipping_options = Some(shipping_options);
    self
  }
  
}



/// Describes a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Venue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // venue
  /// Venue location; as defined by the sender.
  location: Option<Location>,
  /// Venue name; as defined by the sender.
  title: Option<String>,
  /// Venue address; as defined by the sender.
  address: Option<String>,
  /// Provider of the venue database; as defined by the sender. Currently only "foursquare" needs to be supported.
  provider: Option<String>,
  /// Identifier of the venue in the provider database; as defined by the sender.
  id: Option<String>,
  /// Type of the venue in the provider database; as defined by the sender.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  
}



impl Object for Venue {}
impl RObject for Venue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "venue" }
  fn td_type(&self) -> RTDType { RTDType::Venue }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Venue {
  
  pub fn builder() -> RTDVenueBuilder {
    let instance = Self {
      td_name: "venue".to_string(),
      location: None,
      title: None,
      address: None,
      provider: None,
      id: None,
      type_: None,
      
    };
    RTDVenueBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn address(&self) -> Option<String> { self.address.clone() }
  
  pub fn provider(&self) -> Option<String> { self.provider.clone() }
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Venue> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDVenueBuilder { instance: Venue }

impl RTDVenueBuilder {
  fn new(instance: Venue) -> Self { Self { instance } }

  pub fn build(&self) -> Venue { self.instance.clone() }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn address<S: AsRef<str>>(&mut self, address: S) -> &mut Self {
    self.instance.address = Some(address.as_ref().to_string());
    self
  }
  
  pub fn provider<S: AsRef<str>>(&mut self, provider: S) -> &mut Self {
    self.instance.provider = Some(provider.as_ref().to_string());
    self
  }
  
  pub fn id<S: AsRef<str>>(&mut self, id: S) -> &mut Self {
    self.instance.id = Some(id.as_ref().to_string());
    self
  }
  
  pub fn type_<S: AsRef<str>>(&mut self, type_: S) -> &mut Self {
    self.instance.type_ = Some(type_.as_ref().to_string());
    self
  }
  
}



/// Describes a video file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Video {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // video
  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width; as defined by the sender.
  width: Option<i32>,
  /// Video height; as defined by the sender.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,
  
}



impl Object for Video {}
impl RObject for Video {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "video" }
  fn td_type(&self) -> RTDType { RTDType::Video }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Video {
  
  pub fn builder() -> RTDVideoBuilder {
    let instance = Self {
      td_name: "video".to_string(),
      duration: None,
      width: None,
      height: None,
      file_name: None,
      mime_type: None,
      has_stickers: None,
      supports_streaming: None,
      thumbnail: None,
      video: None,
      
    };
    RTDVideoBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn has_stickers(&self) -> Option<bool> { self.has_stickers.clone() }
  
  pub fn supports_streaming(&self) -> Option<bool> { self.supports_streaming.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn video(&self) -> Option<File> { self.video.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Video> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDVideoBuilder { instance: Video }

impl RTDVideoBuilder {
  fn new(instance: Video) -> Self { Self { instance } }

  pub fn build(&self) -> Video { self.instance.clone() }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn has_stickers(&mut self, has_stickers: bool) -> &mut Self {
    self.instance.has_stickers = Some(has_stickers);
    self
  }
  
  pub fn supports_streaming(&mut self, supports_streaming: bool) -> &mut Self {
    self.instance.supports_streaming = Some(supports_streaming);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn video(&mut self, video: File) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
}



/// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // videoNote
  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width and height; as defined by the sender.
  length: Option<i32>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,
  
}



impl Object for VideoNote {}
impl RObject for VideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "videoNote" }
  fn td_type(&self) -> RTDType { RTDType::VideoNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl VideoNote {
  
  pub fn builder() -> RTDVideoNoteBuilder {
    let instance = Self {
      td_name: "videoNote".to_string(),
      duration: None,
      length: None,
      thumbnail: None,
      video: None,
      
    };
    RTDVideoNoteBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn video(&self) -> Option<File> { self.video.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<VideoNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDVideoNoteBuilder { instance: VideoNote }

impl RTDVideoNoteBuilder {
  fn new(instance: VideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> VideoNote { self.instance.clone() }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn video(&mut self, video: File) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
}



/// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // voiceNote
  /// Duration of the voice note, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// A waveform representation of the voice note in 5-bit format.
  waveform: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// File containing the voice note.
  voice: Option<File>,
  
}



impl Object for VoiceNote {}
impl RObject for VoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "voiceNote" }
  fn td_type(&self) -> RTDType { RTDType::VoiceNote }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl VoiceNote {
  
  pub fn builder() -> RTDVoiceNoteBuilder {
    let instance = Self {
      td_name: "voiceNote".to_string(),
      duration: None,
      waveform: None,
      mime_type: None,
      voice: None,
      
    };
    RTDVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn waveform(&self) -> Option<String> { self.waveform.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn voice(&self) -> Option<File> { self.voice.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<VoiceNote> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDVoiceNoteBuilder { instance: VoiceNote }

impl RTDVoiceNoteBuilder {
  fn new(instance: VoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> VoiceNote { self.instance.clone() }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn waveform<S: AsRef<str>>(&mut self, waveform: S) -> &mut Self {
    self.instance.waveform = Some(waveform.as_ref().to_string());
    self
  }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
  pub fn voice(&mut self, voice: File) -> &mut Self {
    self.instance.voice = Some(voice);
    self
  }
  
}



/// Contains information about a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // wallpaper
  /// Unique persistent wallpaper identifier.
  id: Option<i32>,
  /// Available variants of the wallpaper in different sizes. These photos can only be downloaded; they can't be sent in a message.
  sizes: Option<Vec<PhotoSize>>,
  /// Main color of the wallpaper in RGB24 format; should be treated as background color if no photos are specified.
  color: Option<i32>,
  
}



impl Object for Wallpaper {}
impl RObject for Wallpaper {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "wallpaper" }
  fn td_type(&self) -> RTDType { RTDType::Wallpaper }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Wallpaper {
  
  pub fn builder() -> RTDWallpaperBuilder {
    let instance = Self {
      td_name: "wallpaper".to_string(),
      id: None,
      sizes: None,
      color: None,
      
    };
    RTDWallpaperBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn color(&self) -> Option<i32> { self.color.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Wallpaper> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDWallpaperBuilder { instance: Wallpaper }

impl RTDWallpaperBuilder {
  fn new(instance: Wallpaper) -> Self { Self { instance } }

  pub fn build(&self) -> Wallpaper { self.instance.clone() }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
  pub fn color(&mut self, color: i32) -> &mut Self {
    self.instance.color = Some(color);
    self
  }
  
}



/// Contains a list of wallpapers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // wallpapers
  /// A list of wallpapers.
  wallpapers: Option<Vec<Wallpaper>>,
  
}



impl Object for Wallpapers {}
impl RObject for Wallpapers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "wallpapers" }
  fn td_type(&self) -> RTDType { RTDType::Wallpapers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl Wallpapers {
  
  pub fn builder() -> RTDWallpapersBuilder {
    let instance = Self {
      td_name: "wallpapers".to_string(),
      wallpapers: None,
      
    };
    RTDWallpapersBuilder::new(instance)
  }
  
  
  pub fn wallpapers(&self) -> Option<Vec<Wallpaper>> { self.wallpapers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Wallpapers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDWallpapersBuilder { instance: Wallpapers }

impl RTDWallpapersBuilder {
  fn new(instance: Wallpapers) -> Self { Self { instance } }

  pub fn build(&self) -> Wallpapers { self.instance.clone() }
  
  pub fn wallpapers(&mut self, wallpapers: Vec<Wallpaper>) -> &mut Self {
    self.instance.wallpapers = Some(wallpapers);
    self
  }
  
}



/// Describes a web page preview. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebPage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // webPage
  /// Original URL of the link.
  url: Option<String>,
  /// URL to display.
  display_url: Option<String>,
  /// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Short name of the site (e.g., Google Docs, App Store).
  site_name: Option<String>,
  /// Title of the content.
  title: Option<String>,
  /// Description of the content.
  description: Option<String>,
  /// Image representing the content; may be null.
  photo: Option<Photo>,
  /// URL to show in the embedded preview.
  embed_url: Option<String>,
  /// MIME type of the embedded preview, (e.g., text/html or video/mp4).
  embed_type: Option<String>,
  /// Width of the embedded preview.
  embed_width: Option<i32>,
  /// Height of the embedded preview.
  embed_height: Option<i32>,
  /// Duration of the content, in seconds.
  duration: Option<i32>,
  /// Author of the content.
  author: Option<String>,
  /// Preview of the content as an animation, if available; may be null.
  animation: Option<Animation>,
  /// Preview of the content as an audio file, if available; may be null.
  audio: Option<Audio>,
  /// Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null.
  document: Option<Document>,
  /// Preview of the content as a sticker for small WEBP files, if available; may be null.
  sticker: Option<Sticker>,
  /// Preview of the content as a video, if available; may be null.
  video: Option<Video>,
  /// Preview of the content as a video note, if available; may be null.
  video_note: Option<VideoNote>,
  /// Preview of the content as a voice note, if available; may be null.
  voice_note: Option<VoiceNote>,
  /// Version of instant view, available for the web page (currently can be 1 or 2), 0 if none.
  instant_view_version: Option<i32>,
  
}



impl Object for WebPage {}
impl RObject for WebPage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "webPage" }
  fn td_type(&self) -> RTDType { RTDType::WebPage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl WebPage {
  
  pub fn builder() -> RTDWebPageBuilder {
    let instance = Self {
      td_name: "webPage".to_string(),
      url: None,
      display_url: None,
      type_: None,
      site_name: None,
      title: None,
      description: None,
      photo: None,
      embed_url: None,
      embed_type: None,
      embed_width: None,
      embed_height: None,
      duration: None,
      author: None,
      animation: None,
      audio: None,
      document: None,
      sticker: None,
      video: None,
      video_note: None,
      voice_note: None,
      instant_view_version: None,
      
    };
    RTDWebPageBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn display_url(&self) -> Option<String> { self.display_url.clone() }
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn site_name(&self) -> Option<String> { self.site_name.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn embed_url(&self) -> Option<String> { self.embed_url.clone() }
  
  pub fn embed_type(&self) -> Option<String> { self.embed_type.clone() }
  
  pub fn embed_width(&self) -> Option<i32> { self.embed_width.clone() }
  
  pub fn embed_height(&self) -> Option<i32> { self.embed_height.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn instant_view_version(&self) -> Option<i32> { self.instant_view_version.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<WebPage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDWebPageBuilder { instance: WebPage }

impl RTDWebPageBuilder {
  fn new(instance: WebPage) -> Self { Self { instance } }

  pub fn build(&self) -> WebPage { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn display_url<S: AsRef<str>>(&mut self, display_url: S) -> &mut Self {
    self.instance.display_url = Some(display_url.as_ref().to_string());
    self
  }
  
  pub fn type_<S: AsRef<str>>(&mut self, type_: S) -> &mut Self {
    self.instance.type_ = Some(type_.as_ref().to_string());
    self
  }
  
  pub fn site_name<S: AsRef<str>>(&mut self, site_name: S) -> &mut Self {
    self.instance.site_name = Some(site_name.as_ref().to_string());
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn embed_url<S: AsRef<str>>(&mut self, embed_url: S) -> &mut Self {
    self.instance.embed_url = Some(embed_url.as_ref().to_string());
    self
  }
  
  pub fn embed_type<S: AsRef<str>>(&mut self, embed_type: S) -> &mut Self {
    self.instance.embed_type = Some(embed_type.as_ref().to_string());
    self
  }
  
  pub fn embed_width(&mut self, embed_width: i32) -> &mut Self {
    self.instance.embed_width = Some(embed_width);
    self
  }
  
  pub fn embed_height(&mut self, embed_height: i32) -> &mut Self {
    self.instance.embed_height = Some(embed_height);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn author<S: AsRef<str>>(&mut self, author: S) -> &mut Self {
    self.instance.author = Some(author.as_ref().to_string());
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn instant_view_version(&mut self, instant_view_version: i32) -> &mut Self {
    self.instance.instant_view_version = Some(instant_view_version);
    self
  }
  
}



/// Describes an instant view page for a web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct WebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // webPageInstantView
  /// Content of the web page.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Version of the instant view, currently can be 1 or 2.
  version: Option<i32>,
  /// Instant view URL; may be different from WebPage.url and must be used for the correct anchors handling.
  url: Option<String>,
  /// True, if the instant view must be shown from right to left.
  is_rtl: Option<bool>,
  /// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view.
  is_full: Option<bool>,
  
}


impl Clone for WebPageInstantView {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for WebPageInstantView {}
impl RObject for WebPageInstantView {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "webPageInstantView" }
  fn td_type(&self) -> RTDType { RTDType::WebPageInstantView }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}



impl WebPageInstantView {
  
  pub fn builder() -> RTDWebPageInstantViewBuilder {
    let instance = Self {
      td_name: "webPageInstantView".to_string(),
      page_blocks: None,
      version: None,
      url: None,
      is_rtl: None,
      is_full: None,
      
    };
    RTDWebPageInstantViewBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn version(&self) -> Option<i32> { self.version.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn is_rtl(&self) -> Option<bool> { self.is_rtl.clone() }
  
  pub fn is_full(&self) -> Option<bool> { self.is_full.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<WebPageInstantView> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDWebPageInstantViewBuilder { instance: WebPageInstantView }

impl RTDWebPageInstantViewBuilder {
  fn new(instance: WebPageInstantView) -> Self { Self { instance } }

  pub fn build(&self) -> WebPageInstantView { self.instance.clone() }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn version(&mut self, version: i32) -> &mut Self {
    self.instance.version = Some(version);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn is_rtl(&mut self, is_rtl: bool) -> &mut Self {
    self.instance.is_rtl = Some(is_rtl);
    self
  }
  
  pub fn is_full(&mut self, is_full: bool) -> &mut Self {
    self.instance.is_full = Some(is_full);
    self
  }
  
}



/// Accepts an incoming call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // acceptCall
  /// Call identifier.
  call_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,
  
}



impl Object for AcceptCall {}
impl RObject for AcceptCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "acceptCall" }
  fn td_type(&self) -> RTDType { RTDType::AcceptCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AcceptCall {}


impl AcceptCall {
  
  pub fn builder() -> RTDAcceptCallBuilder {
    let instance = Self {
      td_name: "acceptCall".to_string(),
      call_id: None,
      protocol: None,
      
    };
    RTDAcceptCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AcceptCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAcceptCallBuilder { instance: AcceptCall }

impl RTDAcceptCallBuilder {
  fn new(instance: AcceptCall) -> Self { Self { instance } }

  pub fn build(&self) -> AcceptCall { self.instance.clone() }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
}



/// Accepts Telegram terms of services.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // acceptTermsOfService
  /// Terms of service identifier.
  terms_of_service_id: Option<String>,
  
}



impl Object for AcceptTermsOfService {}
impl RObject for AcceptTermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "acceptTermsOfService" }
  fn td_type(&self) -> RTDType { RTDType::AcceptTermsOfService }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AcceptTermsOfService {}


impl AcceptTermsOfService {
  
  pub fn builder() -> RTDAcceptTermsOfServiceBuilder {
    let instance = Self {
      td_name: "acceptTermsOfService".to_string(),
      terms_of_service_id: None,
      
    };
    RTDAcceptTermsOfServiceBuilder::new(instance)
  }
  
  
  pub fn terms_of_service_id(&self) -> Option<String> { self.terms_of_service_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AcceptTermsOfService> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAcceptTermsOfServiceBuilder { instance: AcceptTermsOfService }

impl RTDAcceptTermsOfServiceBuilder {
  fn new(instance: AcceptTermsOfService) -> Self { Self { instance } }

  pub fn build(&self) -> AcceptTermsOfService { self.instance.clone() }
  
  pub fn terms_of_service_id<S: AsRef<str>>(&mut self, terms_of_service_id: S) -> &mut Self {
    self.instance.terms_of_service_id = Some(terms_of_service_id.as_ref().to_string());
    self
  }
  
}



/// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addChatMember
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the user.
  user_id: Option<i32>,
  /// The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels.
  forward_limit: Option<i32>,
  
}



impl Object for AddChatMember {}
impl RObject for AddChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addChatMember" }
  fn td_type(&self) -> RTDType { RTDType::AddChatMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddChatMember {}


impl AddChatMember {
  
  pub fn builder() -> RTDAddChatMemberBuilder {
    let instance = Self {
      td_name: "addChatMember".to_string(),
      chat_id: None,
      user_id: None,
      forward_limit: None,
      
    };
    RTDAddChatMemberBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn forward_limit(&self) -> Option<i32> { self.forward_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddChatMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddChatMemberBuilder { instance: AddChatMember }

impl RTDAddChatMemberBuilder {
  fn new(instance: AddChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> AddChatMember { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn forward_limit(&mut self, forward_limit: i32) -> &mut Self {
    self.instance.forward_limit = Some(forward_limit);
    self
  }
  
}



/// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addChatMembers
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the users to be added to the chat.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for AddChatMembers {}
impl RObject for AddChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addChatMembers" }
  fn td_type(&self) -> RTDType { RTDType::AddChatMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddChatMembers {}


impl AddChatMembers {
  
  pub fn builder() -> RTDAddChatMembersBuilder {
    let instance = Self {
      td_name: "addChatMembers".to_string(),
      chat_id: None,
      user_ids: None,
      
    };
    RTDAddChatMembersBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddChatMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddChatMembersBuilder { instance: AddChatMembers }

impl RTDAddChatMembersBuilder {
  fn new(instance: AddChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> AddChatMembers { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddCustomServerLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addCustomServerLanguagePack
  /// Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link.
  language_pack_id: Option<String>,
  
}



impl Object for AddCustomServerLanguagePack {}
impl RObject for AddCustomServerLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addCustomServerLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::AddCustomServerLanguagePack }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddCustomServerLanguagePack {}


impl AddCustomServerLanguagePack {
  
  pub fn builder() -> RTDAddCustomServerLanguagePackBuilder {
    let instance = Self {
      td_name: "addCustomServerLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    RTDAddCustomServerLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddCustomServerLanguagePack> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddCustomServerLanguagePackBuilder { instance: AddCustomServerLanguagePack }

impl RTDAddCustomServerLanguagePackBuilder {
  fn new(instance: AddCustomServerLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> AddCustomServerLanguagePack { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
}



/// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addFavoriteSticker
  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for AddFavoriteSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddFavoriteSticker {}
impl RObject for AddFavoriteSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addFavoriteSticker" }
  fn td_type(&self) -> RTDType { RTDType::AddFavoriteSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddFavoriteSticker {}


impl AddFavoriteSticker {
  
  pub fn builder() -> RTDAddFavoriteStickerBuilder {
    let instance = Self {
      td_name: "addFavoriteSticker".to_string(),
      sticker: None,
      
    };
    RTDAddFavoriteStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddFavoriteSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddFavoriteStickerBuilder { instance: AddFavoriteSticker }

impl RTDAddFavoriteStickerBuilder {
  fn new(instance: AddFavoriteSticker) -> Self { Self { instance } }

  pub fn build(&self) -> AddFavoriteSticker { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddLocalMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addLocalMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the user who will be shown as the sender of the message; may be 0 for channel posts.
  sender_user_id: Option<i32>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message.
  disable_notification: Option<bool>,
  /// The content of the message to be added.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for AddLocalMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddLocalMessage {}
impl RObject for AddLocalMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addLocalMessage" }
  fn td_type(&self) -> RTDType { RTDType::AddLocalMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddLocalMessage {}


impl AddLocalMessage {
  
  pub fn builder() -> RTDAddLocalMessageBuilder {
    let instance = Self {
      td_name: "addLocalMessage".to_string(),
      chat_id: None,
      sender_user_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      input_message_content: None,
      
    };
    RTDAddLocalMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddLocalMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddLocalMessageBuilder { instance: AddLocalMessage }

impl RTDAddLocalMessageBuilder {
  fn new(instance: AddLocalMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AddLocalMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Adds a message to TDLib internal log. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddLogMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addLogMessage
  /// Minimum verbosity level needed for the message to be logged, 0-1023.
  verbosity_level: Option<i32>,
  /// Text of a message to log.
  text: Option<String>,
  
}



impl Object for AddLogMessage {}
impl RObject for AddLogMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addLogMessage" }
  fn td_type(&self) -> RTDType { RTDType::AddLogMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddLogMessage {}


impl AddLogMessage {
  
  pub fn builder() -> RTDAddLogMessageBuilder {
    let instance = Self {
      td_name: "addLogMessage".to_string(),
      verbosity_level: None,
      text: None,
      
    };
    RTDAddLogMessageBuilder::new(instance)
  }
  
  
  pub fn verbosity_level(&self) -> Option<i32> { self.verbosity_level.clone() }
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddLogMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddLogMessageBuilder { instance: AddLogMessage }

impl RTDAddLogMessageBuilder {
  fn new(instance: AddLogMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AddLogMessage { self.instance.clone() }
  
  pub fn verbosity_level(&mut self, verbosity_level: i32) -> &mut Self {
    self.instance.verbosity_level = Some(verbosity_level);
    self
  }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// Adds the specified data to data usage statistics. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addNetworkStatistics
  /// The network statistics entry with the data to be added to statistics.
  entry: Option<Box<NetworkStatisticsEntry>>,
  
}


impl Clone for AddNetworkStatistics {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddNetworkStatistics {}
impl RObject for AddNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::AddNetworkStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddNetworkStatistics {}


impl AddNetworkStatistics {
  
  pub fn builder() -> RTDAddNetworkStatisticsBuilder {
    let instance = Self {
      td_name: "addNetworkStatistics".to_string(),
      entry: None,
      
    };
    RTDAddNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn entry(&self) -> Option<Box<NetworkStatisticsEntry>> { self.entry.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddNetworkStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddNetworkStatisticsBuilder { instance: AddNetworkStatistics }

impl RTDAddNetworkStatisticsBuilder {
  fn new(instance: AddNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> AddNetworkStatistics { self.instance.clone() }
  
  pub fn entry(&mut self, entry: Box<NetworkStatisticsEntry>) -> &mut Self {
    self.instance.entry = Some(entry);
    self
  }
  
}



/// Adds a proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addProxy
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for AddProxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddProxy {}
impl RObject for AddProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addProxy" }
  fn td_type(&self) -> RTDType { RTDType::AddProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddProxy {}


impl AddProxy {
  
  pub fn builder() -> RTDAddProxyBuilder {
    let instance = Self {
      td_name: "addProxy".to_string(),
      server: None,
      port: None,
      enable: None,
      type_: None,
      
    };
    RTDAddProxyBuilder::new(instance)
  }
  
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn enable(&self) -> Option<bool> { self.enable.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddProxyBuilder { instance: AddProxy }

impl RTDAddProxyBuilder {
  fn new(instance: AddProxy) -> Self { Self { instance } }

  pub fn build(&self) -> AddProxy { self.instance.clone() }
  
  pub fn server<S: AsRef<str>>(&mut self, server: S) -> &mut Self {
    self.instance.server = Some(server.as_ref().to_string());
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn enable(&mut self, enable: bool) -> &mut Self {
    self.instance.enable = Some(enable);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addRecentSticker
  /// Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for AddRecentSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddRecentSticker {}
impl RObject for AddRecentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addRecentSticker" }
  fn td_type(&self) -> RTDType { RTDType::AddRecentSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddRecentSticker {}


impl AddRecentSticker {
  
  pub fn builder() -> RTDAddRecentStickerBuilder {
    let instance = Self {
      td_name: "addRecentSticker".to_string(),
      is_attached: None,
      sticker: None,
      
    };
    RTDAddRecentStickerBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddRecentSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddRecentStickerBuilder { instance: AddRecentSticker }

impl RTDAddRecentStickerBuilder {
  fn new(instance: AddRecentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> AddRecentSticker { self.instance.clone() }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addRecentlyFoundChat
  /// Identifier of the chat to add.
  chat_id: Option<i64>,
  
}



impl Object for AddRecentlyFoundChat {}
impl RObject for AddRecentlyFoundChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addRecentlyFoundChat" }
  fn td_type(&self) -> RTDType { RTDType::AddRecentlyFoundChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddRecentlyFoundChat {}


impl AddRecentlyFoundChat {
  
  pub fn builder() -> RTDAddRecentlyFoundChatBuilder {
    let instance = Self {
      td_name: "addRecentlyFoundChat".to_string(),
      chat_id: None,
      
    };
    RTDAddRecentlyFoundChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddRecentlyFoundChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddRecentlyFoundChatBuilder { instance: AddRecentlyFoundChat }

impl RTDAddRecentlyFoundChatBuilder {
  fn new(instance: AddRecentlyFoundChat) -> Self { Self { instance } }

  pub fn build(&self) -> AddRecentlyFoundChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addSavedAnimation
  /// The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list.
  animation: Option<Box<InputFile>>,
  
}


impl Clone for AddSavedAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AddSavedAnimation {}
impl RObject for AddSavedAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addSavedAnimation" }
  fn td_type(&self) -> RTDType { RTDType::AddSavedAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddSavedAnimation {}


impl AddSavedAnimation {
  
  pub fn builder() -> RTDAddSavedAnimationBuilder {
    let instance = Self {
      td_name: "addSavedAnimation".to_string(),
      animation: None,
      
    };
    RTDAddSavedAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddSavedAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddSavedAnimationBuilder { instance: AddSavedAnimation }

impl RTDAddSavedAnimationBuilder {
  fn new(instance: AddSavedAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> AddSavedAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}



/// Adds a new sticker to a set; for bots only. Returns the sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddStickerToSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addStickerToSet
  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set name.
  name: Option<String>,
  /// Sticker to add to the set.
  sticker: Option<InputSticker>,
  
}



impl Object for AddStickerToSet {}
impl RObject for AddStickerToSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addStickerToSet" }
  fn td_type(&self) -> RTDType { RTDType::AddStickerToSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AddStickerToSet {}


impl AddStickerToSet {
  
  pub fn builder() -> RTDAddStickerToSetBuilder {
    let instance = Self {
      td_name: "addStickerToSet".to_string(),
      user_id: None,
      name: None,
      sticker: None,
      
    };
    RTDAddStickerToSetBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn sticker(&self) -> Option<InputSticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AddStickerToSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAddStickerToSetBuilder { instance: AddStickerToSet }

impl RTDAddStickerToSetBuilder {
  fn new(instance: AddStickerToSet) -> Self { Self { instance } }

  pub fn build(&self) -> AddStickerToSet { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn sticker(&mut self, sticker: InputSticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Sets the result of a callback query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerCallbackQuery
  /// Identifier of the callback query.
  callback_query_id: Option<i64>,
  /// Text of the answer.
  text: Option<String>,
  /// If true, an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,
  /// Time during which the result of the query can be cached, in seconds.
  cache_time: Option<i32>,
  
}



impl Object for AnswerCallbackQuery {}
impl RObject for AnswerCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerCallbackQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AnswerCallbackQuery {}


impl AnswerCallbackQuery {
  
  pub fn builder() -> RTDAnswerCallbackQueryBuilder {
    let instance = Self {
      td_name: "answerCallbackQuery".to_string(),
      callback_query_id: None,
      text: None,
      show_alert: None,
      url: None,
      cache_time: None,
      
    };
    RTDAnswerCallbackQueryBuilder::new(instance)
  }
  
  
  pub fn callback_query_id(&self) -> Option<i64> { self.callback_query_id.clone() }
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn show_alert(&self) -> Option<bool> { self.show_alert.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn cache_time(&self) -> Option<i32> { self.cache_time.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AnswerCallbackQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnswerCallbackQueryBuilder { instance: AnswerCallbackQuery }

impl RTDAnswerCallbackQueryBuilder {
  fn new(instance: AnswerCallbackQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerCallbackQuery { self.instance.clone() }
  
  pub fn callback_query_id(&mut self, callback_query_id: i64) -> &mut Self {
    self.instance.callback_query_id = Some(callback_query_id);
    self
  }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn show_alert(&mut self, show_alert: bool) -> &mut Self {
    self.instance.show_alert = Some(show_alert);
    self
  }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn cache_time(&mut self, cache_time: i32) -> &mut Self {
    self.instance.cache_time = Some(cache_time);
    self
  }
  
}



/// Answers a custom query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerCustomQuery
  /// Identifier of a custom query.
  custom_query_id: Option<i64>,
  /// JSON-serialized answer to the query.
  data: Option<String>,
  
}



impl Object for AnswerCustomQuery {}
impl RObject for AnswerCustomQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerCustomQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerCustomQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AnswerCustomQuery {}


impl AnswerCustomQuery {
  
  pub fn builder() -> RTDAnswerCustomQueryBuilder {
    let instance = Self {
      td_name: "answerCustomQuery".to_string(),
      custom_query_id: None,
      data: None,
      
    };
    RTDAnswerCustomQueryBuilder::new(instance)
  }
  
  
  pub fn custom_query_id(&self) -> Option<i64> { self.custom_query_id.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AnswerCustomQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnswerCustomQueryBuilder { instance: AnswerCustomQuery }

impl RTDAnswerCustomQueryBuilder {
  fn new(instance: AnswerCustomQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerCustomQuery { self.instance.clone() }
  
  pub fn custom_query_id(&mut self, custom_query_id: i64) -> &mut Self {
    self.instance.custom_query_id = Some(custom_query_id);
    self
  }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



/// Sets the result of an inline query; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct AnswerInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerInlineQuery
  /// Identifier of the inline query.
  inline_query_id: Option<i64>,
  /// True, if the result of the query can be cached for the specified user.
  is_personal: Option<bool>,
  /// The results of the query.
  results: Option<Vec<Box<InputInlineQueryResult>>>,
  /// Allowed time to cache the results of the query, in seconds.
  cache_time: Option<i32>,
  /// Offset for the next inline query; pass an empty string if there are no more results.
  next_offset: Option<String>,
  /// If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// The parameter for the bot start message.
  switch_pm_parameter: Option<String>,
  
}


impl Clone for AnswerInlineQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for AnswerInlineQuery {}
impl RObject for AnswerInlineQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerInlineQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerInlineQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AnswerInlineQuery {}


impl AnswerInlineQuery {
  
  pub fn builder() -> RTDAnswerInlineQueryBuilder {
    let instance = Self {
      td_name: "answerInlineQuery".to_string(),
      inline_query_id: None,
      is_personal: None,
      results: None,
      cache_time: None,
      next_offset: None,
      switch_pm_text: None,
      switch_pm_parameter: None,
      
    };
    RTDAnswerInlineQueryBuilder::new(instance)
  }
  
  
  pub fn inline_query_id(&self) -> Option<i64> { self.inline_query_id.clone() }
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn results(&self) -> Option<Vec<Box<InputInlineQueryResult>>> { self.results.clone() }
  
  pub fn cache_time(&self) -> Option<i32> { self.cache_time.clone() }
  
  pub fn next_offset(&self) -> Option<String> { self.next_offset.clone() }
  
  pub fn switch_pm_text(&self) -> Option<String> { self.switch_pm_text.clone() }
  
  pub fn switch_pm_parameter(&self) -> Option<String> { self.switch_pm_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AnswerInlineQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnswerInlineQueryBuilder { instance: AnswerInlineQuery }

impl RTDAnswerInlineQueryBuilder {
  fn new(instance: AnswerInlineQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerInlineQuery { self.instance.clone() }
  
  pub fn inline_query_id(&mut self, inline_query_id: i64) -> &mut Self {
    self.instance.inline_query_id = Some(inline_query_id);
    self
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
  pub fn results(&mut self, results: Vec<Box<InputInlineQueryResult>>) -> &mut Self {
    self.instance.results = Some(results);
    self
  }
  
  pub fn cache_time(&mut self, cache_time: i32) -> &mut Self {
    self.instance.cache_time = Some(cache_time);
    self
  }
  
  pub fn next_offset<S: AsRef<str>>(&mut self, next_offset: S) -> &mut Self {
    self.instance.next_offset = Some(next_offset.as_ref().to_string());
    self
  }
  
  pub fn switch_pm_text<S: AsRef<str>>(&mut self, switch_pm_text: S) -> &mut Self {
    self.instance.switch_pm_text = Some(switch_pm_text.as_ref().to_string());
    self
  }
  
  pub fn switch_pm_parameter<S: AsRef<str>>(&mut self, switch_pm_parameter: S) -> &mut Self {
    self.instance.switch_pm_parameter = Some(switch_pm_parameter.as_ref().to_string());
    self
  }
  
}



/// Sets the result of a pre-checkout query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerPreCheckoutQuery
  /// Identifier of the pre-checkout query.
  pre_checkout_query_id: Option<i64>,
  /// An error message, empty on success.
  error_message: Option<String>,
  
}



impl Object for AnswerPreCheckoutQuery {}
impl RObject for AnswerPreCheckoutQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerPreCheckoutQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerPreCheckoutQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AnswerPreCheckoutQuery {}


impl AnswerPreCheckoutQuery {
  
  pub fn builder() -> RTDAnswerPreCheckoutQueryBuilder {
    let instance = Self {
      td_name: "answerPreCheckoutQuery".to_string(),
      pre_checkout_query_id: None,
      error_message: None,
      
    };
    RTDAnswerPreCheckoutQueryBuilder::new(instance)
  }
  
  
  pub fn pre_checkout_query_id(&self) -> Option<i64> { self.pre_checkout_query_id.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AnswerPreCheckoutQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnswerPreCheckoutQueryBuilder { instance: AnswerPreCheckoutQuery }

impl RTDAnswerPreCheckoutQueryBuilder {
  fn new(instance: AnswerPreCheckoutQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerPreCheckoutQuery { self.instance.clone() }
  
  pub fn pre_checkout_query_id(&mut self, pre_checkout_query_id: i64) -> &mut Self {
    self.instance.pre_checkout_query_id = Some(pre_checkout_query_id);
    self
  }
  
  pub fn error_message<S: AsRef<str>>(&mut self, error_message: S) -> &mut Self {
    self.instance.error_message = Some(error_message.as_ref().to_string());
    self
  }
  
}



/// Sets the result of a shipping query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerShippingQuery
  /// Identifier of the shipping query.
  shipping_query_id: Option<i64>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,
  /// An error message, empty on success.
  error_message: Option<String>,
  
}



impl Object for AnswerShippingQuery {}
impl RObject for AnswerShippingQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerShippingQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerShippingQuery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for AnswerShippingQuery {}


impl AnswerShippingQuery {
  
  pub fn builder() -> RTDAnswerShippingQueryBuilder {
    let instance = Self {
      td_name: "answerShippingQuery".to_string(),
      shipping_query_id: None,
      shipping_options: None,
      error_message: None,
      
    };
    RTDAnswerShippingQueryBuilder::new(instance)
  }
  
  
  pub fn shipping_query_id(&self) -> Option<i64> { self.shipping_query_id.clone() }
  
  pub fn shipping_options(&self) -> Option<Vec<ShippingOption>> { self.shipping_options.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<AnswerShippingQuery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDAnswerShippingQueryBuilder { instance: AnswerShippingQuery }

impl RTDAnswerShippingQueryBuilder {
  fn new(instance: AnswerShippingQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerShippingQuery { self.instance.clone() }
  
  pub fn shipping_query_id(&mut self, shipping_query_id: i64) -> &mut Self {
    self.instance.shipping_query_id = Some(shipping_query_id);
    self
  }
  
  pub fn shipping_options(&mut self, shipping_options: Vec<ShippingOption>) -> &mut Self {
    self.instance.shipping_options = Some(shipping_options);
    self
  }
  
  pub fn error_message<S: AsRef<str>>(&mut self, error_message: S) -> &mut Self {
    self.instance.error_message = Some(error_message.as_ref().to_string());
    self
  }
  
}



/// Adds a user to the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // blockUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for BlockUser {}
impl RObject for BlockUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "blockUser" }
  fn td_type(&self) -> RTDType { RTDType::BlockUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for BlockUser {}


impl BlockUser {
  
  pub fn builder() -> RTDBlockUserBuilder {
    let instance = Self {
      td_name: "blockUser".to_string(),
      user_id: None,
      
    };
    RTDBlockUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<BlockUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDBlockUserBuilder { instance: BlockUser }

impl RTDBlockUserBuilder {
  fn new(instance: BlockUser) -> Self { Self { instance } }

  pub fn build(&self) -> BlockUser { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Stops the downloading of a file. If a file has already been downloaded, does nothing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelDownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cancelDownloadFile
  /// Identifier of a file to stop downloading.
  file_id: Option<i32>,
  /// Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server.
  only_if_pending: Option<bool>,
  
}



impl Object for CancelDownloadFile {}
impl RObject for CancelDownloadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cancelDownloadFile" }
  fn td_type(&self) -> RTDType { RTDType::CancelDownloadFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CancelDownloadFile {}


impl CancelDownloadFile {
  
  pub fn builder() -> RTDCancelDownloadFileBuilder {
    let instance = Self {
      td_name: "cancelDownloadFile".to_string(),
      file_id: None,
      only_if_pending: None,
      
    };
    RTDCancelDownloadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn only_if_pending(&self) -> Option<bool> { self.only_if_pending.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CancelDownloadFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCancelDownloadFileBuilder { instance: CancelDownloadFile }

impl RTDCancelDownloadFileBuilder {
  fn new(instance: CancelDownloadFile) -> Self { Self { instance } }

  pub fn build(&self) -> CancelDownloadFile { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn only_if_pending(&mut self, only_if_pending: bool) -> &mut Self {
    self.instance.only_if_pending = Some(only_if_pending);
    self
  }
  
}



/// Stops the uploading of a file. Supported only for files uploaded by using 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelUploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cancelUploadFile
  /// Identifier of the file to stop uploading.
  file_id: Option<i32>,
  
}



impl Object for CancelUploadFile {}
impl RObject for CancelUploadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cancelUploadFile" }
  fn td_type(&self) -> RTDType { RTDType::CancelUploadFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CancelUploadFile {}


impl CancelUploadFile {
  
  pub fn builder() -> RTDCancelUploadFileBuilder {
    let instance = Self {
      td_name: "cancelUploadFile".to_string(),
      file_id: None,
      
    };
    RTDCancelUploadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CancelUploadFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCancelUploadFileBuilder { instance: CancelUploadFile }

impl RTDCancelUploadFileBuilder {
  fn new(instance: CancelUploadFile) -> Self { Self { instance } }

  pub fn build(&self) -> CancelUploadFile { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}



/// Reports to the server whether a chat is a spam chat or not. Can be used only if ChatReportSpamState.can_report_spam is true. After this request, ChatReportSpamState.can_report_spam becomes false forever.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeChatReportSpamState
  /// Chat identifier.
  chat_id: Option<i64>,
  /// If true, the chat will be reported as spam; otherwise it will be marked as not spam.
  is_spam_chat: Option<bool>,
  
}



impl Object for ChangeChatReportSpamState {}
impl RObject for ChangeChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeChatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::ChangeChatReportSpamState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ChangeChatReportSpamState {}


impl ChangeChatReportSpamState {
  
  pub fn builder() -> RTDChangeChatReportSpamStateBuilder {
    let instance = Self {
      td_name: "changeChatReportSpamState".to_string(),
      chat_id: None,
      is_spam_chat: None,
      
    };
    RTDChangeChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_spam_chat(&self) -> Option<bool> { self.is_spam_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChangeChatReportSpamState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChangeChatReportSpamStateBuilder { instance: ChangeChatReportSpamState }

impl RTDChangeChatReportSpamStateBuilder {
  fn new(instance: ChangeChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeChatReportSpamState { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_spam_chat(&mut self, is_spam_chat: bool) -> &mut Self {
    self.instance.is_spam_chat = Some(is_spam_chat);
    self
  }
  
}



/// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. Query result depends on the result of the previous query, so only one query is possible at the same time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeImportedContacts
  /// The new list of contacts, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,
  
}



impl Object for ChangeImportedContacts {}
impl RObject for ChangeImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeImportedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ChangeImportedContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ChangeImportedContacts {}


impl ChangeImportedContacts {
  
  pub fn builder() -> RTDChangeImportedContactsBuilder {
    let instance = Self {
      td_name: "changeImportedContacts".to_string(),
      contacts: None,
      
    };
    RTDChangeImportedContactsBuilder::new(instance)
  }
  
  
  pub fn contacts(&self) -> Option<Vec<Contact>> { self.contacts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChangeImportedContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChangeImportedContactsBuilder { instance: ChangeImportedContacts }

impl RTDChangeImportedContactsBuilder {
  fn new(instance: ChangeImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeImportedContacts { self.instance.clone() }
  
  pub fn contacts(&mut self, contacts: Vec<Contact>) -> &mut Self {
    self.instance.contacts = Some(contacts);
    self
  }
  
}



/// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changePhoneNumber
  /// The new phone number of the user in international format.
  phone_number: Option<String>,
  /// Pass true if the code can be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for ChangePhoneNumber {}
impl RObject for ChangePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::ChangePhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ChangePhoneNumber {}


impl ChangePhoneNumber {
  
  pub fn builder() -> RTDChangePhoneNumberBuilder {
    let instance = Self {
      td_name: "changePhoneNumber".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    RTDChangePhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChangePhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChangePhoneNumberBuilder { instance: ChangePhoneNumber }

impl RTDChangePhoneNumberBuilder {
  fn new(instance: ChangePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> ChangePhoneNumber { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}



/// Installs/uninstalls or activates/archives a sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeStickerSet
  /// Identifier of the sticker set.
  set_id: Option<i64>,
  /// The new value of is_installed.
  is_installed: Option<bool>,
  /// The new value of is_archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  
}



impl Object for ChangeStickerSet {}
impl RObject for ChangeStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::ChangeStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ChangeStickerSet {}


impl ChangeStickerSet {
  
  pub fn builder() -> RTDChangeStickerSetBuilder {
    let instance = Self {
      td_name: "changeStickerSet".to_string(),
      set_id: None,
      is_installed: None,
      is_archived: None,
      
    };
    RTDChangeStickerSetBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ChangeStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDChangeStickerSetBuilder { instance: ChangeStickerSet }

impl RTDChangeStickerSetBuilder {
  fn new(instance: ChangeStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeStickerSet { self.instance.clone() }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
}



/// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationBotToken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationBotToken
  /// The bot token.
  token: Option<String>,
  
}



impl Object for CheckAuthenticationBotToken {}
impl RObject for CheckAuthenticationBotToken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationBotToken" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationBotToken }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckAuthenticationBotToken {}


impl CheckAuthenticationBotToken {
  
  pub fn builder() -> RTDCheckAuthenticationBotTokenBuilder {
    let instance = Self {
      td_name: "checkAuthenticationBotToken".to_string(),
      token: None,
      
    };
    RTDCheckAuthenticationBotTokenBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckAuthenticationBotToken> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckAuthenticationBotTokenBuilder { instance: CheckAuthenticationBotToken }

impl RTDCheckAuthenticationBotTokenBuilder {
  fn new(instance: CheckAuthenticationBotToken) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationBotToken { self.instance.clone() }
  
  pub fn token<S: AsRef<str>>(&mut self, token: S) -> &mut Self {
    self.instance.token = Some(token.as_ref().to_string());
    self
  }
  
}



/// Checks the authentication code. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationCode
  /// The verification code received via SMS, Telegram message, phone call, or flash call.
  code: Option<String>,
  /// If the user is not yet registered, the first name of the user; 1-64 characters. You can also pass an empty string for unregistered user there to check verification code validness. In the latter case PHONE_NUMBER_UNOCCUPIED error will be returned for a valid code.
  first_name: Option<String>,
  /// If the user is not yet registered; the last name of the user; optional; 0-64 characters.
  last_name: Option<String>,
  
}



impl Object for CheckAuthenticationCode {}
impl RObject for CheckAuthenticationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckAuthenticationCode {}


impl CheckAuthenticationCode {
  
  pub fn builder() -> RTDCheckAuthenticationCodeBuilder {
    let instance = Self {
      td_name: "checkAuthenticationCode".to_string(),
      code: None,
      first_name: None,
      last_name: None,
      
    };
    RTDCheckAuthenticationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckAuthenticationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckAuthenticationCodeBuilder { instance: CheckAuthenticationCode }

impl RTDCheckAuthenticationCodeBuilder {
  fn new(instance: CheckAuthenticationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
  pub fn first_name<S: AsRef<str>>(&mut self, first_name: S) -> &mut Self {
    self.instance.first_name = Some(first_name.as_ref().to_string());
    self
  }
  
  pub fn last_name<S: AsRef<str>>(&mut self, last_name: S) -> &mut Self {
    self.instance.last_name = Some(last_name.as_ref().to_string());
    self
  }
  
}



/// Checks the authentication password for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationPassword
  /// The password to check.
  password: Option<String>,
  
}



impl Object for CheckAuthenticationPassword {}
impl RObject for CheckAuthenticationPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationPassword" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckAuthenticationPassword {}


impl CheckAuthenticationPassword {
  
  pub fn builder() -> RTDCheckAuthenticationPasswordBuilder {
    let instance = Self {
      td_name: "checkAuthenticationPassword".to_string(),
      password: None,
      
    };
    RTDCheckAuthenticationPasswordBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckAuthenticationPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckAuthenticationPasswordBuilder { instance: CheckAuthenticationPassword }

impl RTDCheckAuthenticationPasswordBuilder {
  fn new(instance: CheckAuthenticationPassword) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationPassword { self.instance.clone() }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Checks the authentication code sent to confirm a new phone number of the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChangePhoneNumberCode
  /// Verification code received by SMS, phone call or flash call.
  code: Option<String>,
  
}



impl Object for CheckChangePhoneNumberCode {}
impl RObject for CheckChangePhoneNumberCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChangePhoneNumberCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckChangePhoneNumberCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckChangePhoneNumberCode {}


impl CheckChangePhoneNumberCode {
  
  pub fn builder() -> RTDCheckChangePhoneNumberCodeBuilder {
    let instance = Self {
      td_name: "checkChangePhoneNumberCode".to_string(),
      code: None,
      
    };
    RTDCheckChangePhoneNumberCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChangePhoneNumberCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChangePhoneNumberCodeBuilder { instance: CheckChangePhoneNumberCode }

impl RTDCheckChangePhoneNumberCodeBuilder {
  fn new(instance: CheckChangePhoneNumberCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChangePhoneNumberCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
}



/// Checks the validity of an invite link for a chat and returns information about the corresponding chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatInviteLink
  /// Invite link to be checked; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,
  
}



impl Object for CheckChatInviteLink {}
impl RObject for CheckChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatInviteLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckChatInviteLink {}


impl CheckChatInviteLink {
  
  pub fn builder() -> RTDCheckChatInviteLinkBuilder {
    let instance = Self {
      td_name: "checkChatInviteLink".to_string(),
      invite_link: None,
      
    };
    RTDCheckChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatInviteLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatInviteLinkBuilder { instance: CheckChatInviteLink }

impl RTDCheckChatInviteLinkBuilder {
  fn new(instance: CheckChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatInviteLink { self.instance.clone() }
  
  pub fn invite_link<S: AsRef<str>>(&mut self, invite_link: S) -> &mut Self {
    self.instance.invite_link = Some(invite_link.as_ref().to_string());
    self
  }
  
}



/// Checks whether a username can be set for a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsername
  /// Chat identifier; should be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if chat is being created.
  chat_id: Option<i64>,
  /// Username to be checked.
  username: Option<String>,
  
}



impl Object for CheckChatUsername {}
impl RObject for CheckChatUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsername" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsername }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckChatUsername {}


impl CheckChatUsername {
  
  pub fn builder() -> RTDCheckChatUsernameBuilder {
    let instance = Self {
      td_name: "checkChatUsername".to_string(),
      chat_id: None,
      username: None,
      
    };
    RTDCheckChatUsernameBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckChatUsername> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckChatUsernameBuilder { instance: CheckChatUsername }

impl RTDCheckChatUsernameBuilder {
  fn new(instance: CheckChatUsername) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsername { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
}



/// Checks the database encryption key for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkDatabaseEncryptionKey
  /// Encryption key to check or set up.
  encryption_key: Option<String>,
  
}



impl Object for CheckDatabaseEncryptionKey {}
impl RObject for CheckDatabaseEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkDatabaseEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::CheckDatabaseEncryptionKey }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckDatabaseEncryptionKey {}


impl CheckDatabaseEncryptionKey {
  
  pub fn builder() -> RTDCheckDatabaseEncryptionKeyBuilder {
    let instance = Self {
      td_name: "checkDatabaseEncryptionKey".to_string(),
      encryption_key: None,
      
    };
    RTDCheckDatabaseEncryptionKeyBuilder::new(instance)
  }
  
  
  pub fn encryption_key(&self) -> Option<String> { self.encryption_key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckDatabaseEncryptionKey> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckDatabaseEncryptionKeyBuilder { instance: CheckDatabaseEncryptionKey }

impl RTDCheckDatabaseEncryptionKeyBuilder {
  fn new(instance: CheckDatabaseEncryptionKey) -> Self { Self { instance } }

  pub fn build(&self) -> CheckDatabaseEncryptionKey { self.instance.clone() }
  
  pub fn encryption_key<S: AsRef<str>>(&mut self, encryption_key: S) -> &mut Self {
    self.instance.encryption_key = Some(encryption_key.as_ref().to_string());
    self
  }
  
}



/// Checks the email address verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkEmailAddressVerificationCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckEmailAddressVerificationCode {}
impl RObject for CheckEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckEmailAddressVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckEmailAddressVerificationCode {}


impl CheckEmailAddressVerificationCode {
  
  pub fn builder() -> RTDCheckEmailAddressVerificationCodeBuilder {
    let instance = Self {
      td_name: "checkEmailAddressVerificationCode".to_string(),
      code: None,
      
    };
    RTDCheckEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckEmailAddressVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckEmailAddressVerificationCodeBuilder { instance: CheckEmailAddressVerificationCode }

impl RTDCheckEmailAddressVerificationCodeBuilder {
  fn new(instance: CheckEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckEmailAddressVerificationCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
}



/// Checks phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkPhoneNumberConfirmationCode
  /// The phone number confirmation code.
  code: Option<String>,
  
}



impl Object for CheckPhoneNumberConfirmationCode {}
impl RObject for CheckPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckPhoneNumberConfirmationCode {}


impl CheckPhoneNumberConfirmationCode {
  
  pub fn builder() -> RTDCheckPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      td_name: "checkPhoneNumberConfirmationCode".to_string(),
      code: None,
      
    };
    RTDCheckPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckPhoneNumberConfirmationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckPhoneNumberConfirmationCodeBuilder { instance: CheckPhoneNumberConfirmationCode }

impl RTDCheckPhoneNumberConfirmationCodeBuilder {
  fn new(instance: CheckPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckPhoneNumberConfirmationCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
}



/// Checks the phone number verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkPhoneNumberVerificationCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckPhoneNumberVerificationCode {}
impl RObject for CheckPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckPhoneNumberVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckPhoneNumberVerificationCode {}


impl CheckPhoneNumberVerificationCode {
  
  pub fn builder() -> RTDCheckPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      td_name: "checkPhoneNumberVerificationCode".to_string(),
      code: None,
      
    };
    RTDCheckPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckPhoneNumberVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckPhoneNumberVerificationCodeBuilder { instance: CheckPhoneNumberVerificationCode }

impl RTDCheckPhoneNumberVerificationCodeBuilder {
  fn new(instance: CheckPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckPhoneNumberVerificationCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
}



/// Checks the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkRecoveryEmailAddressCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckRecoveryEmailAddressCode {}
impl RObject for CheckRecoveryEmailAddressCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkRecoveryEmailAddressCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckRecoveryEmailAddressCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CheckRecoveryEmailAddressCode {}


impl CheckRecoveryEmailAddressCode {
  
  pub fn builder() -> RTDCheckRecoveryEmailAddressCodeBuilder {
    let instance = Self {
      td_name: "checkRecoveryEmailAddressCode".to_string(),
      code: None,
      
    };
    RTDCheckRecoveryEmailAddressCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CheckRecoveryEmailAddressCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCheckRecoveryEmailAddressCodeBuilder { instance: CheckRecoveryEmailAddressCode }

impl RTDCheckRecoveryEmailAddressCodeBuilder {
  fn new(instance: CheckRecoveryEmailAddressCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckRecoveryEmailAddressCode { self.instance.clone() }
  
  pub fn code<S: AsRef<str>>(&mut self, code: S) -> &mut Self {
    self.instance.code = Some(code.as_ref().to_string());
    self
  }
  
}



/// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleanFileName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cleanFileName
  /// File name or path to the file.
  file_name: Option<String>,
  
}



impl Object for CleanFileName {}
impl RObject for CleanFileName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cleanFileName" }
  fn td_type(&self) -> RTDType { RTDType::CleanFileName }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CleanFileName {}


impl CleanFileName {
  
  pub fn builder() -> RTDCleanFileNameBuilder {
    let instance = Self {
      td_name: "cleanFileName".to_string(),
      file_name: None,
      
    };
    RTDCleanFileNameBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CleanFileName> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCleanFileNameBuilder { instance: CleanFileName }

impl RTDCleanFileNameBuilder {
  fn new(instance: CleanFileName) -> Self { Self { instance } }

  pub fn build(&self) -> CleanFileName { self.instance.clone() }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
}



/// Clears draft messages in all chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearAllDraftMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearAllDraftMessages
  /// If true, local draft messages in secret chats will not be cleared.
  exclude_secret_chats: Option<bool>,
  
}



impl Object for ClearAllDraftMessages {}
impl RObject for ClearAllDraftMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearAllDraftMessages" }
  fn td_type(&self) -> RTDType { RTDType::ClearAllDraftMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ClearAllDraftMessages {}


impl ClearAllDraftMessages {
  
  pub fn builder() -> RTDClearAllDraftMessagesBuilder {
    let instance = Self {
      td_name: "clearAllDraftMessages".to_string(),
      exclude_secret_chats: None,
      
    };
    RTDClearAllDraftMessagesBuilder::new(instance)
  }
  
  
  pub fn exclude_secret_chats(&self) -> Option<bool> { self.exclude_secret_chats.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ClearAllDraftMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDClearAllDraftMessagesBuilder { instance: ClearAllDraftMessages }

impl RTDClearAllDraftMessagesBuilder {
  fn new(instance: ClearAllDraftMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ClearAllDraftMessages { self.instance.clone() }
  
  pub fn exclude_secret_chats(&mut self, exclude_secret_chats: bool) -> &mut Self {
    self.instance.exclude_secret_chats = Some(exclude_secret_chats);
    self
  }
  
}



/// Clears all imported contacts, contact list remains unchanged.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearImportedContacts
  
}



impl Object for ClearImportedContacts {}
impl RObject for ClearImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearImportedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ClearImportedContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ClearImportedContacts {}


impl ClearImportedContacts {
  
  pub fn builder() -> RTDClearImportedContactsBuilder {
    let instance = Self {
      td_name: "clearImportedContacts".to_string(),
      
    };
    RTDClearImportedContactsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ClearImportedContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDClearImportedContactsBuilder { instance: ClearImportedContacts }

impl RTDClearImportedContactsBuilder {
  fn new(instance: ClearImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ClearImportedContacts { self.instance.clone() }
  
}



/// Clears the list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearRecentStickers
  /// Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers.
  is_attached: Option<bool>,
  
}



impl Object for ClearRecentStickers {}
impl RObject for ClearRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::ClearRecentStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ClearRecentStickers {}


impl ClearRecentStickers {
  
  pub fn builder() -> RTDClearRecentStickersBuilder {
    let instance = Self {
      td_name: "clearRecentStickers".to_string(),
      is_attached: None,
      
    };
    RTDClearRecentStickersBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ClearRecentStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDClearRecentStickersBuilder { instance: ClearRecentStickers }

impl RTDClearRecentStickersBuilder {
  fn new(instance: ClearRecentStickers) -> Self { Self { instance } }

  pub fn build(&self) -> ClearRecentStickers { self.instance.clone() }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
}



/// Clears the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentlyFoundChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearRecentlyFoundChats
  
}



impl Object for ClearRecentlyFoundChats {}
impl RObject for ClearRecentlyFoundChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearRecentlyFoundChats" }
  fn td_type(&self) -> RTDType { RTDType::ClearRecentlyFoundChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ClearRecentlyFoundChats {}


impl ClearRecentlyFoundChats {
  
  pub fn builder() -> RTDClearRecentlyFoundChatsBuilder {
    let instance = Self {
      td_name: "clearRecentlyFoundChats".to_string(),
      
    };
    RTDClearRecentlyFoundChatsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ClearRecentlyFoundChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDClearRecentlyFoundChatsBuilder { instance: ClearRecentlyFoundChats }

impl RTDClearRecentlyFoundChatsBuilder {
  fn new(instance: ClearRecentlyFoundChats) -> Self { Self { instance } }

  pub fn build(&self) -> ClearRecentlyFoundChats { self.instance.clone() }
  
}



/// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Close {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // close
  
}



impl Object for Close {}
impl RObject for Close {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "close" }
  fn td_type(&self) -> RTDType { RTDType::Close }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for Close {}


impl Close {
  
  pub fn builder() -> RTDCloseBuilder {
    let instance = Self {
      td_name: "close".to_string(),
      
    };
    RTDCloseBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Close> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCloseBuilder { instance: Close }

impl RTDCloseBuilder {
  fn new(instance: Close) -> Self { Self { instance } }

  pub fn build(&self) -> Close { self.instance.clone() }
  
}



/// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // closeChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for CloseChat {}
impl RObject for CloseChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "closeChat" }
  fn td_type(&self) -> RTDType { RTDType::CloseChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CloseChat {}


impl CloseChat {
  
  pub fn builder() -> RTDCloseChatBuilder {
    let instance = Self {
      td_name: "closeChat".to_string(),
      chat_id: None,
      
    };
    RTDCloseChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CloseChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCloseChatBuilder { instance: CloseChat }

impl RTDCloseChatBuilder {
  fn new(instance: CloseChat) -> Self { Self { instance } }

  pub fn build(&self) -> CloseChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Closes a secret chat, effectively transfering its state to 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // closeSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for CloseSecretChat {}
impl RObject for CloseSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "closeSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CloseSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CloseSecretChat {}


impl CloseSecretChat {
  
  pub fn builder() -> RTDCloseSecretChatBuilder {
    let instance = Self {
      td_name: "closeSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    RTDCloseSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CloseSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCloseSecretChatBuilder { instance: CloseSecretChat }

impl RTDCloseSecretChatBuilder {
  fn new(instance: CloseSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CloseSecretChat { self.instance.clone() }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}



/// Returns an existing chat corresponding to a known basic group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createBasicGroupChat
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreateBasicGroupChat {}
impl RObject for CreateBasicGroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createBasicGroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateBasicGroupChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateBasicGroupChat {}


impl CreateBasicGroupChat {
  
  pub fn builder() -> RTDCreateBasicGroupChatBuilder {
    let instance = Self {
      td_name: "createBasicGroupChat".to_string(),
      basic_group_id: None,
      force: None,
      
    };
    RTDCreateBasicGroupChatBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateBasicGroupChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateBasicGroupChatBuilder { instance: CreateBasicGroupChat }

impl RTDCreateBasicGroupChatBuilder {
  fn new(instance: CreateBasicGroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateBasicGroupChat { self.instance.clone() }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}



/// Creates a new call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createCall
  /// Identifier of the user to be called.
  user_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,
  
}



impl Object for CreateCall {}
impl RObject for CreateCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createCall" }
  fn td_type(&self) -> RTDType { RTDType::CreateCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateCall {}


impl CreateCall {
  
  pub fn builder() -> RTDCreateCallBuilder {
    let instance = Self {
      td_name: "createCall".to_string(),
      user_id: None,
      protocol: None,
      
    };
    RTDCreateCallBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateCallBuilder { instance: CreateCall }

impl RTDCreateCallBuilder {
  fn new(instance: CreateCall) -> Self { Self { instance } }

  pub fn build(&self) -> CreateCall { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
}



/// Creates a new basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewBasicGroupChat
  /// Identifiers of users to be added to the basic group.
  user_ids: Option<Vec<i32>>,
  /// Title of the new basic group; 1-128 characters.
  title: Option<String>,
  
}



impl Object for CreateNewBasicGroupChat {}
impl RObject for CreateNewBasicGroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewBasicGroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewBasicGroupChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateNewBasicGroupChat {}


impl CreateNewBasicGroupChat {
  
  pub fn builder() -> RTDCreateNewBasicGroupChatBuilder {
    let instance = Self {
      td_name: "createNewBasicGroupChat".to_string(),
      user_ids: None,
      title: None,
      
    };
    RTDCreateNewBasicGroupChatBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateNewBasicGroupChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateNewBasicGroupChatBuilder { instance: CreateNewBasicGroupChat }

impl RTDCreateNewBasicGroupChatBuilder {
  fn new(instance: CreateNewBasicGroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewBasicGroupChat { self.instance.clone() }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// Creates a new secret chat. Returns the newly created chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewSecretChat
  /// Identifier of the target user.
  user_id: Option<i32>,
  
}



impl Object for CreateNewSecretChat {}
impl RObject for CreateNewSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateNewSecretChat {}


impl CreateNewSecretChat {
  
  pub fn builder() -> RTDCreateNewSecretChatBuilder {
    let instance = Self {
      td_name: "createNewSecretChat".to_string(),
      user_id: None,
      
    };
    RTDCreateNewSecretChatBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateNewSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateNewSecretChatBuilder { instance: CreateNewSecretChat }

impl RTDCreateNewSecretChatBuilder {
  fn new(instance: CreateNewSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewSecretChat { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Creates a new sticker set; for bots only. Returns the newly created sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewStickerSet
  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set title; 1-64 characters.
  title: Option<String>,
  /// Sticker set name. Can contain only English letters, digits and underscores. Must end with "by<bot username>" (<bot_username> is case insensitive); 1-64 characters.
  name: Option<String>,
  /// True, if stickers are masks.
  is_masks: Option<bool>,
  /// List of stickers to be added to the set.
  stickers: Option<Vec<InputSticker>>,
  
}



impl Object for CreateNewStickerSet {}
impl RObject for CreateNewStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateNewStickerSet {}


impl CreateNewStickerSet {
  
  pub fn builder() -> RTDCreateNewStickerSetBuilder {
    let instance = Self {
      td_name: "createNewStickerSet".to_string(),
      user_id: None,
      title: None,
      name: None,
      is_masks: None,
      stickers: None,
      
    };
    RTDCreateNewStickerSetBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn stickers(&self) -> Option<Vec<InputSticker>> { self.stickers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateNewStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateNewStickerSetBuilder { instance: CreateNewStickerSet }

impl RTDCreateNewStickerSetBuilder {
  fn new(instance: CreateNewStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewStickerSet { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn stickers(&mut self, stickers: Vec<InputSticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
}



/// Creates a new supergroup or channel and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewSupergroupChat
  /// Title of the new chat; 1-128 characters.
  title: Option<String>,
  /// True, if a channel chat should be created.
  is_channel: Option<bool>,
  /// Chat description; 0-255 characters.
  description: Option<String>,
  
}



impl Object for CreateNewSupergroupChat {}
impl RObject for CreateNewSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewSupergroupChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateNewSupergroupChat {}


impl CreateNewSupergroupChat {
  
  pub fn builder() -> RTDCreateNewSupergroupChatBuilder {
    let instance = Self {
      td_name: "createNewSupergroupChat".to_string(),
      title: None,
      is_channel: None,
      description: None,
      
    };
    RTDCreateNewSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateNewSupergroupChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateNewSupergroupChatBuilder { instance: CreateNewSupergroupChat }

impl RTDCreateNewSupergroupChatBuilder {
  fn new(instance: CreateNewSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewSupergroupChat { self.instance.clone() }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Returns an existing chat corresponding to a given user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePrivateChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createPrivateChat
  /// User identifier.
  user_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreatePrivateChat {}
impl RObject for CreatePrivateChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createPrivateChat" }
  fn td_type(&self) -> RTDType { RTDType::CreatePrivateChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreatePrivateChat {}


impl CreatePrivateChat {
  
  pub fn builder() -> RTDCreatePrivateChatBuilder {
    let instance = Self {
      td_name: "createPrivateChat".to_string(),
      user_id: None,
      force: None,
      
    };
    RTDCreatePrivateChatBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreatePrivateChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreatePrivateChatBuilder { instance: CreatePrivateChat }

impl RTDCreatePrivateChatBuilder {
  fn new(instance: CreatePrivateChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreatePrivateChat { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}



/// Returns an existing chat corresponding to a known secret chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for CreateSecretChat {}
impl RObject for CreateSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateSecretChat {}


impl CreateSecretChat {
  
  pub fn builder() -> RTDCreateSecretChatBuilder {
    let instance = Self {
      td_name: "createSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    RTDCreateSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateSecretChatBuilder { instance: CreateSecretChat }

impl RTDCreateSecretChatBuilder {
  fn new(instance: CreateSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateSecretChat { self.instance.clone() }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}



/// Returns an existing chat corresponding to a known supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createSupergroupChat
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreateSupergroupChat {}
impl RObject for CreateSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateSupergroupChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateSupergroupChat {}


impl CreateSupergroupChat {
  
  pub fn builder() -> RTDCreateSupergroupChatBuilder {
    let instance = Self {
      td_name: "createSupergroupChat".to_string(),
      supergroup_id: None,
      force: None,
      
    };
    RTDCreateSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateSupergroupChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateSupergroupChatBuilder { instance: CreateSupergroupChat }

impl RTDCreateSupergroupChatBuilder {
  fn new(instance: CreateSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateSupergroupChat { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}



/// Creates a new temporary password for processing payments.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateTemporaryPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createTemporaryPassword
  /// Persistent user password.
  password: Option<String>,
  /// Time during which the temporary password will be valid, in seconds; should be between 60 and 86400.
  valid_for: Option<i32>,
  
}



impl Object for CreateTemporaryPassword {}
impl RObject for CreateTemporaryPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createTemporaryPassword" }
  fn td_type(&self) -> RTDType { RTDType::CreateTemporaryPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for CreateTemporaryPassword {}


impl CreateTemporaryPassword {
  
  pub fn builder() -> RTDCreateTemporaryPasswordBuilder {
    let instance = Self {
      td_name: "createTemporaryPassword".to_string(),
      password: None,
      valid_for: None,
      
    };
    RTDCreateTemporaryPasswordBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn valid_for(&self) -> Option<i32> { self.valid_for.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<CreateTemporaryPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDCreateTemporaryPasswordBuilder { instance: CreateTemporaryPassword }

impl RTDCreateTemporaryPasswordBuilder {
  fn new(instance: CreateTemporaryPassword) -> Self { Self { instance } }

  pub fn build(&self) -> CreateTemporaryPassword { self.instance.clone() }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
  pub fn valid_for(&mut self, valid_for: i32) -> &mut Self {
    self.instance.valid_for = Some(valid_for);
    self
  }
  
}



/// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteAccount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteAccount
  /// The reason why the account was deleted; optional.
  reason: Option<String>,
  
}



impl Object for DeleteAccount {}
impl RObject for DeleteAccount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteAccount" }
  fn td_type(&self) -> RTDType { RTDType::DeleteAccount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteAccount {}


impl DeleteAccount {
  
  pub fn builder() -> RTDDeleteAccountBuilder {
    let instance = Self {
      td_name: "deleteAccount".to_string(),
      reason: None,
      
    };
    RTDDeleteAccountBuilder::new(instance)
  }
  
  
  pub fn reason(&self) -> Option<String> { self.reason.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteAccount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteAccountBuilder { instance: DeleteAccount }

impl RTDDeleteAccountBuilder {
  fn new(instance: DeleteAccount) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteAccount { self.instance.clone() }
  
  pub fn reason<S: AsRef<str>>(&mut self, reason: S) -> &mut Self {
    self.instance.reason = Some(reason.as_ref().to_string());
    self
  }
  
}



/// Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatHistory
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Pass true if the chat should be removed from the chat list.
  remove_from_chat_list: Option<bool>,
  /// Pass true to try to delete chat history for all users.
  revoke: Option<bool>,
  
}



impl Object for DeleteChatHistory {}
impl RObject for DeleteChatHistory {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatHistory" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatHistory }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteChatHistory {}


impl DeleteChatHistory {
  
  pub fn builder() -> RTDDeleteChatHistoryBuilder {
    let instance = Self {
      td_name: "deleteChatHistory".to_string(),
      chat_id: None,
      remove_from_chat_list: None,
      revoke: None,
      
    };
    RTDDeleteChatHistoryBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn remove_from_chat_list(&self) -> Option<bool> { self.remove_from_chat_list.clone() }
  
  pub fn revoke(&self) -> Option<bool> { self.revoke.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteChatHistory> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteChatHistoryBuilder { instance: DeleteChatHistory }

impl RTDDeleteChatHistoryBuilder {
  fn new(instance: DeleteChatHistory) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatHistory { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn remove_from_chat_list(&mut self, remove_from_chat_list: bool) -> &mut Self {
    self.instance.remove_from_chat_list = Some(remove_from_chat_list);
    self
  }
  
  pub fn revoke(&mut self, revoke: bool) -> &mut Self {
    self.instance.revoke = Some(revoke);
    self
  }
  
}



/// Deletes all messages sent by the specified user to a chat. Supported only in supergroups; requires can_delete_messages administrator privileges.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatMessagesFromUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatMessagesFromUser
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for DeleteChatMessagesFromUser {}
impl RObject for DeleteChatMessagesFromUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatMessagesFromUser" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatMessagesFromUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteChatMessagesFromUser {}


impl DeleteChatMessagesFromUser {
  
  pub fn builder() -> RTDDeleteChatMessagesFromUserBuilder {
    let instance = Self {
      td_name: "deleteChatMessagesFromUser".to_string(),
      chat_id: None,
      user_id: None,
      
    };
    RTDDeleteChatMessagesFromUserBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteChatMessagesFromUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteChatMessagesFromUserBuilder { instance: DeleteChatMessagesFromUser }

impl RTDDeleteChatMessagesFromUserBuilder {
  fn new(instance: DeleteChatMessagesFromUser) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatMessagesFromUser { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatReplyMarkup
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The message identifier of the used keyboard.
  message_id: Option<i64>,
  
}



impl Object for DeleteChatReplyMarkup {}
impl RObject for DeleteChatReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatReplyMarkup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteChatReplyMarkup {}


impl DeleteChatReplyMarkup {
  
  pub fn builder() -> RTDDeleteChatReplyMarkupBuilder {
    let instance = Self {
      td_name: "deleteChatReplyMarkup".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDDeleteChatReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteChatReplyMarkup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteChatReplyMarkupBuilder { instance: DeleteChatReplyMarkup }

impl RTDDeleteChatReplyMarkupBuilder {
  fn new(instance: DeleteChatReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatReplyMarkup { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Deletes a file from the TDLib file cache.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteFile
  /// Identifier of the file to delete.
  file_id: Option<i32>,
  
}



impl Object for DeleteFile {}
impl RObject for DeleteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteFile" }
  fn td_type(&self) -> RTDType { RTDType::DeleteFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteFile {}


impl DeleteFile {
  
  pub fn builder() -> RTDDeleteFileBuilder {
    let instance = Self {
      td_name: "deleteFile".to_string(),
      file_id: None,
      
    };
    RTDDeleteFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteFileBuilder { instance: DeleteFile }

impl RTDDeleteFileBuilder {
  fn new(instance: DeleteFile) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteFile { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}



/// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteLanguagePack
  /// Identifier of the language pack to delete.
  language_pack_id: Option<String>,
  
}



impl Object for DeleteLanguagePack {}
impl RObject for DeleteLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::DeleteLanguagePack }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteLanguagePack {}


impl DeleteLanguagePack {
  
  pub fn builder() -> RTDDeleteLanguagePackBuilder {
    let instance = Self {
      td_name: "deleteLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    RTDDeleteLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteLanguagePack> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteLanguagePackBuilder { instance: DeleteLanguagePack }

impl RTDDeleteLanguagePackBuilder {
  fn new(instance: DeleteLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteLanguagePack { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
}



/// Deletes messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the messages to be deleted.
  message_ids: Option<Vec<i64>>,
  /// Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats.
  revoke: Option<bool>,
  
}



impl Object for DeleteMessages {}
impl RObject for DeleteMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteMessages" }
  fn td_type(&self) -> RTDType { RTDType::DeleteMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteMessages {}


impl DeleteMessages {
  
  pub fn builder() -> RTDDeleteMessagesBuilder {
    let instance = Self {
      td_name: "deleteMessages".to_string(),
      chat_id: None,
      message_ids: None,
      revoke: None,
      
    };
    RTDDeleteMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn revoke(&self) -> Option<bool> { self.revoke.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteMessagesBuilder { instance: DeleteMessages }

impl RTDDeleteMessagesBuilder {
  fn new(instance: DeleteMessages) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn revoke(&mut self, revoke: bool) -> &mut Self {
    self.instance.revoke = Some(revoke);
    self
  }
  
}



/// Deletes a Telegram Passport element.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeletePassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deletePassportElement
  /// Element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  
}


impl Clone for DeletePassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for DeletePassportElement {}
impl RObject for DeletePassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deletePassportElement" }
  fn td_type(&self) -> RTDType { RTDType::DeletePassportElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeletePassportElement {}


impl DeletePassportElement {
  
  pub fn builder() -> RTDDeletePassportElementBuilder {
    let instance = Self {
      td_name: "deletePassportElement".to_string(),
      type_: None,
      
    };
    RTDDeletePassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeletePassportElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeletePassportElementBuilder { instance: DeletePassportElement }

impl RTDDeletePassportElementBuilder {
  fn new(instance: DeletePassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> DeletePassportElement { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// Deletes a profile photo. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteProfilePhoto
  /// Identifier of the profile photo to delete.
  profile_photo_id: Option<i64>,
  
}



impl Object for DeleteProfilePhoto {}
impl RObject for DeleteProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::DeleteProfilePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteProfilePhoto {}


impl DeleteProfilePhoto {
  
  pub fn builder() -> RTDDeleteProfilePhotoBuilder {
    let instance = Self {
      td_name: "deleteProfilePhoto".to_string(),
      profile_photo_id: None,
      
    };
    RTDDeleteProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn profile_photo_id(&self) -> Option<i64> { self.profile_photo_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteProfilePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteProfilePhotoBuilder { instance: DeleteProfilePhoto }

impl RTDDeleteProfilePhotoBuilder {
  fn new(instance: DeleteProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteProfilePhoto { self.instance.clone() }
  
  pub fn profile_photo_id(&mut self, profile_photo_id: i64) -> &mut Self {
    self.instance.profile_photo_id = Some(profile_photo_id);
    self
  }
  
}



/// Deletes saved credentials for all payment provider bots.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSavedCredentials
  
}



impl Object for DeleteSavedCredentials {}
impl RObject for DeleteSavedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSavedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSavedCredentials }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteSavedCredentials {}


impl DeleteSavedCredentials {
  
  pub fn builder() -> RTDDeleteSavedCredentialsBuilder {
    let instance = Self {
      td_name: "deleteSavedCredentials".to_string(),
      
    };
    RTDDeleteSavedCredentialsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteSavedCredentials> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteSavedCredentialsBuilder { instance: DeleteSavedCredentials }

impl RTDDeleteSavedCredentialsBuilder {
  fn new(instance: DeleteSavedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSavedCredentials { self.instance.clone() }
  
}



/// Deletes saved order info.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSavedOrderInfo
  
}



impl Object for DeleteSavedOrderInfo {}
impl RObject for DeleteSavedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSavedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSavedOrderInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteSavedOrderInfo {}


impl DeleteSavedOrderInfo {
  
  pub fn builder() -> RTDDeleteSavedOrderInfoBuilder {
    let instance = Self {
      td_name: "deleteSavedOrderInfo".to_string(),
      
    };
    RTDDeleteSavedOrderInfoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteSavedOrderInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteSavedOrderInfoBuilder { instance: DeleteSavedOrderInfo }

impl RTDDeleteSavedOrderInfoBuilder {
  fn new(instance: DeleteSavedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSavedOrderInfo { self.instance.clone() }
  
}



/// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires creator privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSupergroup
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  
}



impl Object for DeleteSupergroup {}
impl RObject for DeleteSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSupergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DeleteSupergroup {}


impl DeleteSupergroup {
  
  pub fn builder() -> RTDDeleteSupergroupBuilder {
    let instance = Self {
      td_name: "deleteSupergroup".to_string(),
      supergroup_id: None,
      
    };
    RTDDeleteSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DeleteSupergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDeleteSupergroupBuilder { instance: DeleteSupergroup }

impl RTDDeleteSupergroupBuilder {
  fn new(instance: DeleteSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSupergroup { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}



/// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Destroy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // destroy
  
}



impl Object for Destroy {}
impl RObject for Destroy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "destroy" }
  fn td_type(&self) -> RTDType { RTDType::Destroy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for Destroy {}


impl Destroy {
  
  pub fn builder() -> RTDDestroyBuilder {
    let instance = Self {
      td_name: "destroy".to_string(),
      
    };
    RTDDestroyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Destroy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDestroyBuilder { instance: Destroy }

impl RTDDestroyBuilder {
  fn new(instance: Destroy) -> Self { Self { instance } }

  pub fn build(&self) -> Destroy { self.instance.clone() }
  
}



/// Disables the currently enabled proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disableProxy
  
}



impl Object for DisableProxy {}
impl RObject for DisableProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disableProxy" }
  fn td_type(&self) -> RTDType { RTDType::DisableProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DisableProxy {}


impl DisableProxy {
  
  pub fn builder() -> RTDDisableProxyBuilder {
    let instance = Self {
      td_name: "disableProxy".to_string(),
      
    };
    RTDDisableProxyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DisableProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDisableProxyBuilder { instance: DisableProxy }

impl RTDDisableProxyBuilder {
  fn new(instance: DisableProxy) -> Self { Self { instance } }

  pub fn build(&self) -> DisableProxy { self.instance.clone() }
  
}



/// Discards a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscardCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // discardCall
  /// Call identifier.
  call_id: Option<i32>,
  /// True, if the user was disconnected.
  is_disconnected: Option<bool>,
  /// The call duration, in seconds.
  duration: Option<i32>,
  /// Identifier of the connection used during the call.
  connection_id: Option<i64>,
  
}



impl Object for DiscardCall {}
impl RObject for DiscardCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "discardCall" }
  fn td_type(&self) -> RTDType { RTDType::DiscardCall }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DiscardCall {}


impl DiscardCall {
  
  pub fn builder() -> RTDDiscardCallBuilder {
    let instance = Self {
      td_name: "discardCall".to_string(),
      call_id: None,
      is_disconnected: None,
      duration: None,
      connection_id: None,
      
    };
    RTDDiscardCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn is_disconnected(&self) -> Option<bool> { self.is_disconnected.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn connection_id(&self) -> Option<i64> { self.connection_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DiscardCall> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDiscardCallBuilder { instance: DiscardCall }

impl RTDDiscardCallBuilder {
  fn new(instance: DiscardCall) -> Self { Self { instance } }

  pub fn build(&self) -> DiscardCall { self.instance.clone() }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn is_disconnected(&mut self, is_disconnected: bool) -> &mut Self {
    self.instance.is_disconnected = Some(is_disconnected);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn connection_id(&mut self, connection_id: i64) -> &mut Self {
    self.instance.connection_id = Some(connection_id);
    self
  }
  
}



/// Disconnects all websites from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectAllWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disconnectAllWebsites
  
}



impl Object for DisconnectAllWebsites {}
impl RObject for DisconnectAllWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disconnectAllWebsites" }
  fn td_type(&self) -> RTDType { RTDType::DisconnectAllWebsites }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DisconnectAllWebsites {}


impl DisconnectAllWebsites {
  
  pub fn builder() -> RTDDisconnectAllWebsitesBuilder {
    let instance = Self {
      td_name: "disconnectAllWebsites".to_string(),
      
    };
    RTDDisconnectAllWebsitesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DisconnectAllWebsites> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDisconnectAllWebsitesBuilder { instance: DisconnectAllWebsites }

impl RTDDisconnectAllWebsitesBuilder {
  fn new(instance: DisconnectAllWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> DisconnectAllWebsites { self.instance.clone() }
  
}



/// Disconnects website from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disconnectWebsite
  /// Website identifier.
  website_id: Option<i64>,
  
}



impl Object for DisconnectWebsite {}
impl RObject for DisconnectWebsite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disconnectWebsite" }
  fn td_type(&self) -> RTDType { RTDType::DisconnectWebsite }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DisconnectWebsite {}


impl DisconnectWebsite {
  
  pub fn builder() -> RTDDisconnectWebsiteBuilder {
    let instance = Self {
      td_name: "disconnectWebsite".to_string(),
      website_id: None,
      
    };
    RTDDisconnectWebsiteBuilder::new(instance)
  }
  
  
  pub fn website_id(&self) -> Option<i64> { self.website_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DisconnectWebsite> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDisconnectWebsiteBuilder { instance: DisconnectWebsite }

impl RTDDisconnectWebsiteBuilder {
  fn new(instance: DisconnectWebsite) -> Self { Self { instance } }

  pub fn build(&self) -> DisconnectWebsite { self.instance.clone() }
  
  pub fn website_id(&mut self, website_id: i64) -> &mut Self {
    self.instance.website_id = Some(website_id);
    self
  }
  
}



/// Downloads a file from the cloud. Download progress and completion of the download will be notified through 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // downloadFile
  /// Identifier of the file to download.
  file_id: Option<i32>,
  /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first.
  priority: Option<i32>,
  /// The starting position from which the file should be downloaded.
  offset: Option<i32>,
  /// Number of bytes which should be downloaded starting from the "offset" position before the download will be automatically cancelled; use 0 to download without a limit.
  limit: Option<i32>,
  /// If false, this request returns file state just after the download has been started. If true, this request returns file state only after the download has succeeded, has failed, has been cancelled or a new downloadFile request with different offset/limit parameters was sent.
  synchronous: Option<bool>,
  
}



impl Object for DownloadFile {}
impl RObject for DownloadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "downloadFile" }
  fn td_type(&self) -> RTDType { RTDType::DownloadFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for DownloadFile {}


impl DownloadFile {
  
  pub fn builder() -> RTDDownloadFileBuilder {
    let instance = Self {
      td_name: "downloadFile".to_string(),
      file_id: None,
      priority: None,
      offset: None,
      limit: None,
      synchronous: None,
      
    };
    RTDDownloadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn priority(&self) -> Option<i32> { self.priority.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn synchronous(&self) -> Option<bool> { self.synchronous.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<DownloadFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDDownloadFileBuilder { instance: DownloadFile }

impl RTDDownloadFileBuilder {
  fn new(instance: DownloadFile) -> Self { Self { instance } }

  pub fn build(&self) -> DownloadFile { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn priority(&mut self, priority: i32) -> &mut Self {
    self.instance.priority = Some(priority);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn synchronous(&mut self, synchronous: bool) -> &mut Self {
    self.instance.synchronous = Some(synchronous);
    self
  }
  
}



/// Edits information about a custom local language pack in the current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditCustomLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editCustomLanguagePackInfo
  /// New information about the custom local language pack.
  info: Option<LanguagePackInfo>,
  
}



impl Object for EditCustomLanguagePackInfo {}
impl RObject for EditCustomLanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editCustomLanguagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::EditCustomLanguagePackInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditCustomLanguagePackInfo {}


impl EditCustomLanguagePackInfo {
  
  pub fn builder() -> RTDEditCustomLanguagePackInfoBuilder {
    let instance = Self {
      td_name: "editCustomLanguagePackInfo".to_string(),
      info: None,
      
    };
    RTDEditCustomLanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> Option<LanguagePackInfo> { self.info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditCustomLanguagePackInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditCustomLanguagePackInfoBuilder { instance: EditCustomLanguagePackInfo }

impl RTDEditCustomLanguagePackInfoBuilder {
  fn new(instance: EditCustomLanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> EditCustomLanguagePackInfo { self.instance.clone() }
  
  pub fn info(&mut self, info: LanguagePackInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
}



/// Edits the caption of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageCaption
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for EditInlineMessageCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditInlineMessageCaption {}
impl RObject for EditInlineMessageCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageCaption" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageCaption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditInlineMessageCaption {}


impl EditInlineMessageCaption {
  
  pub fn builder() -> RTDEditInlineMessageCaptionBuilder {
    let instance = Self {
      td_name: "editInlineMessageCaption".to_string(),
      inline_message_id: None,
      reply_markup: None,
      caption: None,
      
    };
    RTDEditInlineMessageCaptionBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditInlineMessageCaption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditInlineMessageCaptionBuilder { instance: EditInlineMessageCaption }

impl RTDEditInlineMessageCaptionBuilder {
  fn new(instance: EditInlineMessageCaption) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageCaption { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// Edits the content of a live location in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageLiveLocation
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,
  
}


impl Clone for EditInlineMessageLiveLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditInlineMessageLiveLocation {}
impl RObject for EditInlineMessageLiveLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageLiveLocation" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageLiveLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditInlineMessageLiveLocation {}


impl EditInlineMessageLiveLocation {
  
  pub fn builder() -> RTDEditInlineMessageLiveLocationBuilder {
    let instance = Self {
      td_name: "editInlineMessageLiveLocation".to_string(),
      inline_message_id: None,
      reply_markup: None,
      location: None,
      
    };
    RTDEditInlineMessageLiveLocationBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditInlineMessageLiveLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditInlineMessageLiveLocationBuilder { instance: EditInlineMessageLiveLocation }

impl RTDEditInlineMessageLiveLocationBuilder {
  fn new(instance: EditInlineMessageLiveLocation) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageLiveLocation { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
}



/// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageMedia
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditInlineMessageMedia {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditInlineMessageMedia {}
impl RObject for EditInlineMessageMedia {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageMedia" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageMedia }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditInlineMessageMedia {}


impl EditInlineMessageMedia {
  
  pub fn builder() -> RTDEditInlineMessageMediaBuilder {
    let instance = Self {
      td_name: "editInlineMessageMedia".to_string(),
      inline_message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDEditInlineMessageMediaBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditInlineMessageMedia> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditInlineMessageMediaBuilder { instance: EditInlineMessageMedia }

impl RTDEditInlineMessageMediaBuilder {
  fn new(instance: EditInlineMessageMedia) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageMedia { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Edits the reply markup of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageReplyMarkup
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for EditInlineMessageReplyMarkup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditInlineMessageReplyMarkup {}
impl RObject for EditInlineMessageReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageReplyMarkup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditInlineMessageReplyMarkup {}


impl EditInlineMessageReplyMarkup {
  
  pub fn builder() -> RTDEditInlineMessageReplyMarkupBuilder {
    let instance = Self {
      td_name: "editInlineMessageReplyMarkup".to_string(),
      inline_message_id: None,
      reply_markup: None,
      
    };
    RTDEditInlineMessageReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditInlineMessageReplyMarkup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditInlineMessageReplyMarkupBuilder { instance: EditInlineMessageReplyMarkup }

impl RTDEditInlineMessageReplyMarkupBuilder {
  fn new(instance: EditInlineMessageReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageReplyMarkup { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}



/// Edits the text of an inline text or game message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageText
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditInlineMessageText {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditInlineMessageText {}
impl RObject for EditInlineMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageText" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditInlineMessageText {}


impl EditInlineMessageText {
  
  pub fn builder() -> RTDEditInlineMessageTextBuilder {
    let instance = Self {
      td_name: "editInlineMessageText".to_string(),
      inline_message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDEditInlineMessageTextBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditInlineMessageText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditInlineMessageTextBuilder { instance: EditInlineMessageText }

impl RTDEditInlineMessageTextBuilder {
  fn new(instance: EditInlineMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageText { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Edits the message content caption. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageCaption
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for EditMessageCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditMessageCaption {}
impl RObject for EditMessageCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageCaption" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageCaption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditMessageCaption {}


impl EditMessageCaption {
  
  pub fn builder() -> RTDEditMessageCaptionBuilder {
    let instance = Self {
      td_name: "editMessageCaption".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      caption: None,
      
    };
    RTDEditMessageCaptionBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditMessageCaption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditMessageCaptionBuilder { instance: EditMessageCaption }

impl RTDEditMessageCaptionBuilder {
  fn new(instance: EditMessageCaption) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageCaption { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}



/// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageLiveLocation
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,
  
}


impl Clone for EditMessageLiveLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditMessageLiveLocation {}
impl RObject for EditMessageLiveLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageLiveLocation" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageLiveLocation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditMessageLiveLocation {}


impl EditMessageLiveLocation {
  
  pub fn builder() -> RTDEditMessageLiveLocationBuilder {
    let instance = Self {
      td_name: "editMessageLiveLocation".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      location: None,
      
    };
    RTDEditMessageLiveLocationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditMessageLiveLocation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditMessageLiveLocationBuilder { instance: EditMessageLiveLocation }

impl RTDEditMessageLiveLocationBuilder {
  fn new(instance: EditMessageLiveLocation) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageLiveLocation { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
}



/// Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageMedia
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditMessageMedia {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditMessageMedia {}
impl RObject for EditMessageMedia {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageMedia" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageMedia }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditMessageMedia {}


impl EditMessageMedia {
  
  pub fn builder() -> RTDEditMessageMediaBuilder {
    let instance = Self {
      td_name: "editMessageMedia".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDEditMessageMediaBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditMessageMedia> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditMessageMediaBuilder { instance: EditMessageMedia }

impl RTDEditMessageMediaBuilder {
  fn new(instance: EditMessageMedia) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageMedia { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageReplyMarkup
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for EditMessageReplyMarkup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditMessageReplyMarkup {}
impl RObject for EditMessageReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageReplyMarkup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditMessageReplyMarkup {}


impl EditMessageReplyMarkup {
  
  pub fn builder() -> RTDEditMessageReplyMarkupBuilder {
    let instance = Self {
      td_name: "editMessageReplyMarkup".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      
    };
    RTDEditMessageReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditMessageReplyMarkup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditMessageReplyMarkupBuilder { instance: EditMessageReplyMarkup }

impl RTDEditMessageReplyMarkupBuilder {
  fn new(instance: EditMessageReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageReplyMarkup { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}



/// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageText
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditMessageText {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditMessageText {}
impl RObject for EditMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageText" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditMessageText {}


impl EditMessageText {
  
  pub fn builder() -> RTDEditMessageTextBuilder {
    let instance = Self {
      td_name: "editMessageText".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDEditMessageTextBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditMessageText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditMessageTextBuilder { instance: EditMessageText }

impl RTDEditMessageTextBuilder {
  fn new(instance: EditMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageText { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Edits an existing proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for EditProxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for EditProxy {}
impl RObject for EditProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editProxy" }
  fn td_type(&self) -> RTDType { RTDType::EditProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EditProxy {}


impl EditProxy {
  
  pub fn builder() -> RTDEditProxyBuilder {
    let instance = Self {
      td_name: "editProxy".to_string(),
      proxy_id: None,
      server: None,
      port: None,
      enable: None,
      type_: None,
      
    };
    RTDEditProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn enable(&self) -> Option<bool> { self.enable.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EditProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEditProxyBuilder { instance: EditProxy }

impl RTDEditProxyBuilder {
  fn new(instance: EditProxy) -> Self { Self { instance } }

  pub fn build(&self) -> EditProxy { self.instance.clone() }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
  pub fn server<S: AsRef<str>>(&mut self, server: S) -> &mut Self {
    self.instance.server = Some(server.as_ref().to_string());
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn enable(&mut self, enable: bool) -> &mut Self {
    self.instance.enable = Some(enable);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // enableProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for EnableProxy {}
impl RObject for EnableProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "enableProxy" }
  fn td_type(&self) -> RTDType { RTDType::EnableProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for EnableProxy {}


impl EnableProxy {
  
  pub fn builder() -> RTDEnableProxyBuilder {
    let instance = Self {
      td_name: "enableProxy".to_string(),
      proxy_id: None,
      
    };
    RTDEnableProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<EnableProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDEnableProxyBuilder { instance: EnableProxy }

impl RTDEnableProxyBuilder {
  fn new(instance: EnableProxy) -> Self { Self { instance } }

  pub fn build(&self) -> EnableProxy { self.instance.clone() }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}



/// Finishes the file generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FinishFileGeneration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // finishFileGeneration
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// If set, means that file generation has failed and should be terminated.
  error: Option<Error>,
  
}



impl Object for FinishFileGeneration {}
impl RObject for FinishFileGeneration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "finishFileGeneration" }
  fn td_type(&self) -> RTDType { RTDType::FinishFileGeneration }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for FinishFileGeneration {}


impl FinishFileGeneration {
  
  pub fn builder() -> RTDFinishFileGenerationBuilder {
    let instance = Self {
      td_name: "finishFileGeneration".to_string(),
      generation_id: None,
      error: None,
      
    };
    RTDFinishFileGenerationBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn error(&self) -> Option<Error> { self.error.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<FinishFileGeneration> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDFinishFileGenerationBuilder { instance: FinishFileGeneration }

impl RTDFinishFileGenerationBuilder {
  fn new(instance: FinishFileGeneration) -> Self { Self { instance } }

  pub fn build(&self) -> FinishFileGeneration { self.instance.clone() }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn error(&mut self, error: Error) -> &mut Self {
    self.instance.error = Some(error);
    self
  }
  
}



/// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForwardMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // forwardMessages
  /// Identifier of the chat to which to forward messages.
  chat_id: Option<i64>,
  /// Identifier of the chat from which to forward messages.
  from_chat_id: Option<i64>,
  /// Identifiers of the messages to forward.
  message_ids: Option<Vec<i64>>,
  /// Pass true to disable notification for the message, doesn't work if messages are forwarded to a secret chat.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// True, if the messages should be grouped into an album after forwarding. For this to work, no more than 10 messages may be forwarded, and all of them must be photo or video messages.
  as_album: Option<bool>,
  
}



impl Object for ForwardMessages {}
impl RObject for ForwardMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "forwardMessages" }
  fn td_type(&self) -> RTDType { RTDType::ForwardMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ForwardMessages {}


impl ForwardMessages {
  
  pub fn builder() -> RTDForwardMessagesBuilder {
    let instance = Self {
      td_name: "forwardMessages".to_string(),
      chat_id: None,
      from_chat_id: None,
      message_ids: None,
      disable_notification: None,
      from_background: None,
      as_album: None,
      
    };
    RTDForwardMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn as_album(&self) -> Option<bool> { self.as_album.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ForwardMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDForwardMessagesBuilder { instance: ForwardMessages }

impl RTDForwardMessagesBuilder {
  fn new(instance: ForwardMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ForwardMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn as_album(&mut self, as_album: bool) -> &mut Self {
    self.instance.as_album = Some(as_album);
    self
  }
  
}



/// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. In basic groups this can be called only by the group's creator; in supergroups and channels this requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // generateChatInviteLink
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GenerateChatInviteLink {}
impl RObject for GenerateChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "generateChatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::GenerateChatInviteLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GenerateChatInviteLink {}


impl GenerateChatInviteLink {
  
  pub fn builder() -> RTDGenerateChatInviteLinkBuilder {
    let instance = Self {
      td_name: "generateChatInviteLink".to_string(),
      chat_id: None,
      
    };
    RTDGenerateChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GenerateChatInviteLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGenerateChatInviteLinkBuilder { instance: GenerateChatInviteLink }

impl RTDGenerateChatInviteLinkBuilder {
  fn new(instance: GenerateChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> GenerateChatInviteLink { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAccountTtl
  
}



impl Object for GetAccountTtl {}
impl RObject for GetAccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAccountTtl" }
  fn td_type(&self) -> RTDType { RTDType::GetAccountTtl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetAccountTtl {}


impl GetAccountTtl {
  
  pub fn builder() -> RTDGetAccountTtlBuilder {
    let instance = Self {
      td_name: "getAccountTtl".to_string(),
      
    };
    RTDGetAccountTtlBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetAccountTtl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetAccountTtlBuilder { instance: GetAccountTtl }

impl RTDGetAccountTtlBuilder {
  fn new(instance: GetAccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> GetAccountTtl { self.instance.clone() }
  
}



/// Returns all active live locations that should be updated by the client. The list is persistent across application restarts only if the message database is used.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveLiveLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getActiveLiveLocationMessages
  
}



impl Object for GetActiveLiveLocationMessages {}
impl RObject for GetActiveLiveLocationMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getActiveLiveLocationMessages" }
  fn td_type(&self) -> RTDType { RTDType::GetActiveLiveLocationMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetActiveLiveLocationMessages {}


impl GetActiveLiveLocationMessages {
  
  pub fn builder() -> RTDGetActiveLiveLocationMessagesBuilder {
    let instance = Self {
      td_name: "getActiveLiveLocationMessages".to_string(),
      
    };
    RTDGetActiveLiveLocationMessagesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetActiveLiveLocationMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetActiveLiveLocationMessagesBuilder { instance: GetActiveLiveLocationMessages }

impl RTDGetActiveLiveLocationMessagesBuilder {
  fn new(instance: GetActiveLiveLocationMessages) -> Self { Self { instance } }

  pub fn build(&self) -> GetActiveLiveLocationMessages { self.instance.clone() }
  
}



/// Returns all active sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getActiveSessions
  
}



impl Object for GetActiveSessions {}
impl RObject for GetActiveSessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getActiveSessions" }
  fn td_type(&self) -> RTDType { RTDType::GetActiveSessions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetActiveSessions {}


impl GetActiveSessions {
  
  pub fn builder() -> RTDGetActiveSessionsBuilder {
    let instance = Self {
      td_name: "getActiveSessions".to_string(),
      
    };
    RTDGetActiveSessionsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetActiveSessions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetActiveSessionsBuilder { instance: GetActiveSessions }

impl RTDGetActiveSessionsBuilder {
  fn new(instance: GetActiveSessions) -> Self { Self { instance } }

  pub fn build(&self) -> GetActiveSessions { self.instance.clone() }
  
}



/// Returns all available Telegram Passport elements.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAllPassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAllPassportElements
  /// Password of the current user.
  password: Option<String>,
  
}



impl Object for GetAllPassportElements {}
impl RObject for GetAllPassportElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAllPassportElements" }
  fn td_type(&self) -> RTDType { RTDType::GetAllPassportElements }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetAllPassportElements {}


impl GetAllPassportElements {
  
  pub fn builder() -> RTDGetAllPassportElementsBuilder {
    let instance = Self {
      td_name: "getAllPassportElements".to_string(),
      password: None,
      
    };
    RTDGetAllPassportElementsBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetAllPassportElements> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetAllPassportElementsBuilder { instance: GetAllPassportElements }

impl RTDGetAllPassportElementsBuilder {
  fn new(instance: GetAllPassportElements) -> Self { Self { instance } }

  pub fn build(&self) -> GetAllPassportElements { self.instance.clone() }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Returns application config, provided by the server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetApplicationConfig {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getApplicationConfig
  
}



impl Object for GetApplicationConfig {}
impl RObject for GetApplicationConfig {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getApplicationConfig" }
  fn td_type(&self) -> RTDType { RTDType::GetApplicationConfig }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetApplicationConfig {}


impl GetApplicationConfig {
  
  pub fn builder() -> RTDGetApplicationConfigBuilder {
    let instance = Self {
      td_name: "getApplicationConfig".to_string(),
      
    };
    RTDGetApplicationConfigBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetApplicationConfig> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetApplicationConfigBuilder { instance: GetApplicationConfig }

impl RTDGetApplicationConfigBuilder {
  fn new(instance: GetApplicationConfig) -> Self { Self { instance } }

  pub fn build(&self) -> GetApplicationConfig { self.instance.clone() }
  
}



/// Returns a list of archived sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetArchivedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getArchivedStickerSets
  /// Pass true to return mask stickers sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifier of the sticker set from which to return the result.
  offset_sticker_set_id: Option<i64>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,
  
}



impl Object for GetArchivedStickerSets {}
impl RObject for GetArchivedStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getArchivedStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetArchivedStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetArchivedStickerSets {}


impl GetArchivedStickerSets {
  
  pub fn builder() -> RTDGetArchivedStickerSetsBuilder {
    let instance = Self {
      td_name: "getArchivedStickerSets".to_string(),
      is_masks: None,
      offset_sticker_set_id: None,
      limit: None,
      
    };
    RTDGetArchivedStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn offset_sticker_set_id(&self) -> Option<i64> { self.offset_sticker_set_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetArchivedStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetArchivedStickerSetsBuilder { instance: GetArchivedStickerSets }

impl RTDGetArchivedStickerSetsBuilder {
  fn new(instance: GetArchivedStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetArchivedStickerSets { self.instance.clone() }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn offset_sticker_set_id(&mut self, offset_sticker_set_id: i64) -> &mut Self {
    self.instance.offset_sticker_set_id = Some(offset_sticker_set_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAttachedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAttachedStickerSets
  /// File identifier.
  file_id: Option<i32>,
  
}



impl Object for GetAttachedStickerSets {}
impl RObject for GetAttachedStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAttachedStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetAttachedStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetAttachedStickerSets {}


impl GetAttachedStickerSets {
  
  pub fn builder() -> RTDGetAttachedStickerSetsBuilder {
    let instance = Self {
      td_name: "getAttachedStickerSets".to_string(),
      file_id: None,
      
    };
    RTDGetAttachedStickerSetsBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetAttachedStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetAttachedStickerSetsBuilder { instance: GetAttachedStickerSets }

impl RTDGetAttachedStickerSetsBuilder {
  fn new(instance: GetAttachedStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetAttachedStickerSets { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}



/// Returns the current authorization state; this is an offline request. For informational purposes only. Use 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAuthorizationState
  
}



impl Object for GetAuthorizationState {}
impl RObject for GetAuthorizationState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAuthorizationState" }
  fn td_type(&self) -> RTDType { RTDType::GetAuthorizationState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetAuthorizationState {}


impl GetAuthorizationState {
  
  pub fn builder() -> RTDGetAuthorizationStateBuilder {
    let instance = Self {
      td_name: "getAuthorizationState".to_string(),
      
    };
    RTDGetAuthorizationStateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetAuthorizationState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetAuthorizationStateBuilder { instance: GetAuthorizationState }

impl RTDGetAuthorizationStateBuilder {
  fn new(instance: GetAuthorizationState) -> Self { Self { instance } }

  pub fn build(&self) -> GetAuthorizationState { self.instance.clone() }
  
}



/// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBasicGroup
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for GetBasicGroup {}
impl RObject for GetBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::GetBasicGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetBasicGroup {}


impl GetBasicGroup {
  
  pub fn builder() -> RTDGetBasicGroupBuilder {
    let instance = Self {
      td_name: "getBasicGroup".to_string(),
      basic_group_id: None,
      
    };
    RTDGetBasicGroupBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetBasicGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetBasicGroupBuilder { instance: GetBasicGroup }

impl RTDGetBasicGroupBuilder {
  fn new(instance: GetBasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> GetBasicGroup { self.instance.clone() }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}



/// Returns full information about a basic group by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBasicGroupFullInfo
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for GetBasicGroupFullInfo {}
impl RObject for GetBasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBasicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetBasicGroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetBasicGroupFullInfo {}


impl GetBasicGroupFullInfo {
  
  pub fn builder() -> RTDGetBasicGroupFullInfoBuilder {
    let instance = Self {
      td_name: "getBasicGroupFullInfo".to_string(),
      basic_group_id: None,
      
    };
    RTDGetBasicGroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetBasicGroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetBasicGroupFullInfoBuilder { instance: GetBasicGroupFullInfo }

impl RTDGetBasicGroupFullInfoBuilder {
  fn new(instance: GetBasicGroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetBasicGroupFullInfo { self.instance.clone() }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}



/// Returns users that were blocked by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBlockedUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBlockedUsers
  /// Number of users to skip in the result; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of users to return; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetBlockedUsers {}
impl RObject for GetBlockedUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBlockedUsers" }
  fn td_type(&self) -> RTDType { RTDType::GetBlockedUsers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetBlockedUsers {}


impl GetBlockedUsers {
  
  pub fn builder() -> RTDGetBlockedUsersBuilder {
    let instance = Self {
      td_name: "getBlockedUsers".to_string(),
      offset: None,
      limit: None,
      
    };
    RTDGetBlockedUsersBuilder::new(instance)
  }
  
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetBlockedUsers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetBlockedUsersBuilder { instance: GetBlockedUsers }

impl RTDGetBlockedUsersBuilder {
  fn new(instance: GetBlockedUsers) -> Self { Self { instance } }

  pub fn build(&self) -> GetBlockedUsers { self.instance.clone() }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetCallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCallbackQueryAnswer
  /// Identifier of the chat with the message.
  chat_id: Option<i64>,
  /// Identifier of the message from which the query originated.
  message_id: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for GetCallbackQueryAnswer {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetCallbackQueryAnswer {}
impl RObject for GetCallbackQueryAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCallbackQueryAnswer" }
  fn td_type(&self) -> RTDType { RTDType::GetCallbackQueryAnswer }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetCallbackQueryAnswer {}


impl GetCallbackQueryAnswer {
  
  pub fn builder() -> RTDGetCallbackQueryAnswerBuilder {
    let instance = Self {
      td_name: "getCallbackQueryAnswer".to_string(),
      chat_id: None,
      message_id: None,
      payload: None,
      
    };
    RTDGetCallbackQueryAnswerBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetCallbackQueryAnswer> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetCallbackQueryAnswerBuilder { instance: GetCallbackQueryAnswer }

impl RTDGetCallbackQueryAnswerBuilder {
  fn new(instance: GetCallbackQueryAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> GetCallbackQueryAnswer { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn payload(&mut self, payload: Box<CallbackQueryPayload>) -> &mut Self {
    self.instance.payload = Some(payload);
    self
  }
  
}



/// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChat {}
impl RObject for GetChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChat" }
  fn td_type(&self) -> RTDType { RTDType::GetChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChat {}


impl GetChat {
  
  pub fn builder() -> RTDGetChatBuilder {
    let instance = Self {
      td_name: "getChat".to_string(),
      chat_id: None,
      
    };
    RTDGetChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatBuilder { instance: GetChat }

impl RTDGetChatBuilder {
  fn new(instance: GetChat) -> Self { Self { instance } }

  pub fn build(&self) -> GetChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns a list of users who are administrators of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatAdministrators
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChatAdministrators {}
impl RObject for GetChatAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::GetChatAdministrators }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatAdministrators {}


impl GetChatAdministrators {
  
  pub fn builder() -> RTDGetChatAdministratorsBuilder {
    let instance = Self {
      td_name: "getChatAdministrators".to_string(),
      chat_id: None,
      
    };
    RTDGetChatAdministratorsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatAdministrators> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatAdministratorsBuilder { instance: GetChatAdministrators }

impl RTDGetChatAdministratorsBuilder {
  fn new(instance: GetChatAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatAdministrators { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only in supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatEventLog {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatEventLog
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Search query by which to filter events.
  query: Option<String>,
  /// Identifier of an event from which to return results. Use 0 to get results from the latest events.
  from_event_id: Option<i64>,
  /// Maximum number of events to return; up to 100.
  limit: Option<i32>,
  /// The types of events to return. By default, all types will be returned.
  filters: Option<ChatEventLogFilters>,
  /// User identifiers by which to filter events. By default, events relating to all users will be returned.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for GetChatEventLog {}
impl RObject for GetChatEventLog {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatEventLog" }
  fn td_type(&self) -> RTDType { RTDType::GetChatEventLog }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatEventLog {}


impl GetChatEventLog {
  
  pub fn builder() -> RTDGetChatEventLogBuilder {
    let instance = Self {
      td_name: "getChatEventLog".to_string(),
      chat_id: None,
      query: None,
      from_event_id: None,
      limit: None,
      filters: None,
      user_ids: None,
      
    };
    RTDGetChatEventLogBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_event_id(&self) -> Option<i64> { self.from_event_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filters(&self) -> Option<ChatEventLogFilters> { self.filters.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatEventLog> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatEventLogBuilder { instance: GetChatEventLog }

impl RTDGetChatEventLogBuilder {
  fn new(instance: GetChatEventLog) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatEventLog { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn from_event_id(&mut self, from_event_id: i64) -> &mut Self {
    self.instance.from_event_id = Some(from_event_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filters(&mut self, filters: ChatEventLogFilters) -> &mut Self {
    self.instance.filters = Some(filters);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatHistory
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater or equal to -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages that are available locally without sending network requests.
  only_local: Option<bool>,
  
}



impl Object for GetChatHistory {}
impl RObject for GetChatHistory {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatHistory" }
  fn td_type(&self) -> RTDType { RTDType::GetChatHistory }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatHistory {}


impl GetChatHistory {
  
  pub fn builder() -> RTDGetChatHistoryBuilder {
    let instance = Self {
      td_name: "getChatHistory".to_string(),
      chat_id: None,
      from_message_id: None,
      offset: None,
      limit: None,
      only_local: None,
      
    };
    RTDGetChatHistoryBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn only_local(&self) -> Option<bool> { self.only_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatHistory> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatHistoryBuilder { instance: GetChatHistory }

impl RTDGetChatHistoryBuilder {
  fn new(instance: GetChatHistory) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatHistory { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn only_local(&mut self, only_local: bool) -> &mut Self {
    self.instance.only_local = Some(only_local);
    self
  }
  
}



/// Returns information about a single member of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMember
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetChatMember {}
impl RObject for GetChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMember" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMember }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatMember {}


impl GetChatMember {
  
  pub fn builder() -> RTDGetChatMemberBuilder {
    let instance = Self {
      td_name: "getChatMember".to_string(),
      chat_id: None,
      user_id: None,
      
    };
    RTDGetChatMemberBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatMember> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatMemberBuilder { instance: GetChatMember }

impl RTDGetChatMemberBuilder {
  fn new(instance: GetChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMember { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Returns the last message sent in a chat no later than the specified date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMessageByDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMessageByDate
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Point in time (Unix timestamp) relative to which to search for messages.
  date: Option<i32>,
  
}



impl Object for GetChatMessageByDate {}
impl RObject for GetChatMessageByDate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMessageByDate" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMessageByDate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatMessageByDate {}


impl GetChatMessageByDate {
  
  pub fn builder() -> RTDGetChatMessageByDateBuilder {
    let instance = Self {
      td_name: "getChatMessageByDate".to_string(),
      chat_id: None,
      date: None,
      
    };
    RTDGetChatMessageByDateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatMessageByDate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatMessageByDateBuilder { instance: GetChatMessageByDate }

impl RTDGetChatMessageByDateBuilder {
  fn new(instance: GetChatMessageByDate) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMessageByDate { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
}



/// Returns approximate number of messages of the specified type in the chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMessageCount
  /// Identifier of the chat in which to count messages.
  chat_id: Option<i64>,
  /// Filter for message content; searchMessagesFilterEmpty is unsupported in this function.
  filter: Option<Box<SearchMessagesFilter>>,
  /// If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown.
  return_local: Option<bool>,
  
}


impl Clone for GetChatMessageCount {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetChatMessageCount {}
impl RObject for GetChatMessageCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMessageCount" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMessageCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatMessageCount {}


impl GetChatMessageCount {
  
  pub fn builder() -> RTDGetChatMessageCountBuilder {
    let instance = Self {
      td_name: "getChatMessageCount".to_string(),
      chat_id: None,
      filter: None,
      return_local: None,
      
    };
    RTDGetChatMessageCountBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn return_local(&self) -> Option<bool> { self.return_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatMessageCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatMessageCountBuilder { instance: GetChatMessageCount }

impl RTDGetChatMessageCountBuilder {
  fn new(instance: GetChatMessageCount) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMessageCount { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
  pub fn return_local(&mut self, return_local: bool) -> &mut Self {
    self.instance.return_local = Some(return_local);
    self
  }
  
}



/// Returns list of chats with non-default notification settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatNotificationSettingsExceptions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatNotificationSettingsExceptions
  /// If specified, only chats from the specified scope will be returned.
  scope: Option<Box<NotificationSettingsScope>>,
  /// If true, also chats with non-default sound will be returned.
  compare_sound: Option<bool>,
  
}


impl Clone for GetChatNotificationSettingsExceptions {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetChatNotificationSettingsExceptions {}
impl RObject for GetChatNotificationSettingsExceptions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatNotificationSettingsExceptions" }
  fn td_type(&self) -> RTDType { RTDType::GetChatNotificationSettingsExceptions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatNotificationSettingsExceptions {}


impl GetChatNotificationSettingsExceptions {
  
  pub fn builder() -> RTDGetChatNotificationSettingsExceptionsBuilder {
    let instance = Self {
      td_name: "getChatNotificationSettingsExceptions".to_string(),
      scope: None,
      compare_sound: None,
      
    };
    RTDGetChatNotificationSettingsExceptionsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn compare_sound(&self) -> Option<bool> { self.compare_sound.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatNotificationSettingsExceptions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatNotificationSettingsExceptionsBuilder { instance: GetChatNotificationSettingsExceptions }

impl RTDGetChatNotificationSettingsExceptionsBuilder {
  fn new(instance: GetChatNotificationSettingsExceptions) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatNotificationSettingsExceptions { self.instance.clone() }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
  pub fn compare_sound(&mut self, compare_sound: bool) -> &mut Self {
    self.instance.compare_sound = Some(compare_sound);
    self
  }
  
}



/// Returns information about a pinned chat message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatPinnedMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  
}



impl Object for GetChatPinnedMessage {}
impl RObject for GetChatPinnedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatPinnedMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetChatPinnedMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatPinnedMessage {}


impl GetChatPinnedMessage {
  
  pub fn builder() -> RTDGetChatPinnedMessageBuilder {
    let instance = Self {
      td_name: "getChatPinnedMessage".to_string(),
      chat_id: None,
      
    };
    RTDGetChatPinnedMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatPinnedMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatPinnedMessageBuilder { instance: GetChatPinnedMessage }

impl RTDGetChatPinnedMessageBuilder {
  fn new(instance: GetChatPinnedMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatPinnedMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns information on whether the current chat can be reported as spam.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatReportSpamState
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChatReportSpamState {}
impl RObject for GetChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::GetChatReportSpamState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatReportSpamState {}


impl GetChatReportSpamState {
  
  pub fn builder() -> RTDGetChatReportSpamStateBuilder {
    let instance = Self {
      td_name: "getChatReportSpamState".to_string(),
      chat_id: None,
      
    };
    RTDGetChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatReportSpamState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatReportSpamStateBuilder { instance: GetChatReportSpamState }

impl RTDGetChatReportSpamStateBuilder {
  fn new(instance: GetChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatReportSpamState { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns URL with the chat statistics. Currently this method can be used only for channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatStatisticsUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatStatisticsUrl
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Parameters from "tg://statsrefresh?params=******" link.
  parameters: Option<String>,
  /// Pass true if a URL with the dark theme must be returned.
  is_dark: Option<bool>,
  
}



impl Object for GetChatStatisticsUrl {}
impl RObject for GetChatStatisticsUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatStatisticsUrl" }
  fn td_type(&self) -> RTDType { RTDType::GetChatStatisticsUrl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChatStatisticsUrl {}


impl GetChatStatisticsUrl {
  
  pub fn builder() -> RTDGetChatStatisticsUrlBuilder {
    let instance = Self {
      td_name: "getChatStatisticsUrl".to_string(),
      chat_id: None,
      parameters: None,
      is_dark: None,
      
    };
    RTDGetChatStatisticsUrlBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn parameters(&self) -> Option<String> { self.parameters.clone() }
  
  pub fn is_dark(&self) -> Option<bool> { self.is_dark.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChatStatisticsUrl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatStatisticsUrlBuilder { instance: GetChatStatisticsUrl }

impl RTDGetChatStatisticsUrlBuilder {
  fn new(instance: GetChatStatisticsUrl) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatStatisticsUrl { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn parameters<S: AsRef<str>>(&mut self, parameters: S) -> &mut Self {
    self.instance.parameters = Some(parameters.as_ref().to_string());
    self
  }
  
  pub fn is_dark(&mut self, is_dark: bool) -> &mut Self {
    self.instance.is_dark = Some(is_dark);
    self
  }
  
}



/// Returns an ordered list of chats. Chats are sorted by the pair (order, chat_id) in decreasing order. (For example, to get a list of chats from the beginning, the offset_order should be equal to a biggest signed 64-bit number 9223372036854775807 == 2^63 - 1). For optimal performance the number of returned chats is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChats
  /// Chat order to return chats from.
  offset_order: Option<i64>,
  /// Chat identifier to return chats from.
  offset_chat_id: Option<i64>,
  /// The maximum number of chats to be returned. It is possible that fewer chats than the limit are returned even if the end of the list is not reached.
  limit: Option<i32>,
  
}



impl Object for GetChats {}
impl RObject for GetChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChats" }
  fn td_type(&self) -> RTDType { RTDType::GetChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetChats {}


impl GetChats {
  
  pub fn builder() -> RTDGetChatsBuilder {
    let instance = Self {
      td_name: "getChats".to_string(),
      offset_order: None,
      offset_chat_id: None,
      limit: None,
      
    };
    RTDGetChatsBuilder::new(instance)
  }
  
  
  pub fn offset_order(&self) -> Option<i64> { self.offset_order.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetChatsBuilder { instance: GetChats }

impl RTDGetChatsBuilder {
  fn new(instance: GetChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetChats { self.instance.clone() }
  
  pub fn offset_order(&mut self, offset_order: i64) -> &mut Self {
    self.instance.offset_order = Some(offset_order);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns all website where the current user used Telegram to log in.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getConnectedWebsites
  
}



impl Object for GetConnectedWebsites {}
impl RObject for GetConnectedWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getConnectedWebsites" }
  fn td_type(&self) -> RTDType { RTDType::GetConnectedWebsites }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetConnectedWebsites {}


impl GetConnectedWebsites {
  
  pub fn builder() -> RTDGetConnectedWebsitesBuilder {
    let instance = Self {
      td_name: "getConnectedWebsites".to_string(),
      
    };
    RTDGetConnectedWebsitesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetConnectedWebsites> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetConnectedWebsitesBuilder { instance: GetConnectedWebsites }

impl RTDGetConnectedWebsitesBuilder {
  fn new(instance: GetConnectedWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> GetConnectedWebsites { self.instance.clone() }
  
}



/// Returns all user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getContacts
  
}



impl Object for GetContacts {}
impl RObject for GetContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getContacts" }
  fn td_type(&self) -> RTDType { RTDType::GetContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetContacts {}


impl GetContacts {
  
  pub fn builder() -> RTDGetContactsBuilder {
    let instance = Self {
      td_name: "getContacts".to_string(),
      
    };
    RTDGetContactsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetContactsBuilder { instance: GetContacts }

impl RTDGetContactsBuilder {
  fn new(instance: GetContacts) -> Self { Self { instance } }

  pub fn build(&self) -> GetContacts { self.instance.clone() }
  
}



/// Uses current user IP to found his country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCountryCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCountryCode
  
}



impl Object for GetCountryCode {}
impl RObject for GetCountryCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCountryCode" }
  fn td_type(&self) -> RTDType { RTDType::GetCountryCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetCountryCode {}


impl GetCountryCode {
  
  pub fn builder() -> RTDGetCountryCodeBuilder {
    let instance = Self {
      td_name: "getCountryCode".to_string(),
      
    };
    RTDGetCountryCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetCountryCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetCountryCodeBuilder { instance: GetCountryCode }

impl RTDGetCountryCodeBuilder {
  fn new(instance: GetCountryCode) -> Self { Self { instance } }

  pub fn build(&self) -> GetCountryCode { self.instance.clone() }
  
}



/// Returns a list of public chats created by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCreatedPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCreatedPublicChats
  
}



impl Object for GetCreatedPublicChats {}
impl RObject for GetCreatedPublicChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCreatedPublicChats" }
  fn td_type(&self) -> RTDType { RTDType::GetCreatedPublicChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetCreatedPublicChats {}


impl GetCreatedPublicChats {
  
  pub fn builder() -> RTDGetCreatedPublicChatsBuilder {
    let instance = Self {
      td_name: "getCreatedPublicChats".to_string(),
      
    };
    RTDGetCreatedPublicChatsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetCreatedPublicChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetCreatedPublicChatsBuilder { instance: GetCreatedPublicChats }

impl RTDGetCreatedPublicChatsBuilder {
  fn new(instance: GetCreatedPublicChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetCreatedPublicChats { self.instance.clone() }
  
}



/// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially usefull if TDLib is run in a separate process. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCurrentState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCurrentState
  
}



impl Object for GetCurrentState {}
impl RObject for GetCurrentState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCurrentState" }
  fn td_type(&self) -> RTDType { RTDType::GetCurrentState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetCurrentState {}


impl GetCurrentState {
  
  pub fn builder() -> RTDGetCurrentStateBuilder {
    let instance = Self {
      td_name: "getCurrentState".to_string(),
      
    };
    RTDGetCurrentStateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetCurrentState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetCurrentStateBuilder { instance: GetCurrentState }

impl RTDGetCurrentStateBuilder {
  fn new(instance: GetCurrentState) -> Self { Self { instance } }

  pub fn build(&self) -> GetCurrentState { self.instance.clone() }
  
}



/// Returns database statistics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getDatabaseStatistics
  
}



impl Object for GetDatabaseStatistics {}
impl RObject for GetDatabaseStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getDatabaseStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetDatabaseStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetDatabaseStatistics {}


impl GetDatabaseStatistics {
  
  pub fn builder() -> RTDGetDatabaseStatisticsBuilder {
    let instance = Self {
      td_name: "getDatabaseStatistics".to_string(),
      
    };
    RTDGetDatabaseStatisticsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetDatabaseStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetDatabaseStatisticsBuilder { instance: GetDatabaseStatistics }

impl RTDGetDatabaseStatisticsBuilder {
  fn new(instance: GetDatabaseStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetDatabaseStatistics { self.instance.clone() }
  
}



/// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getDeepLinkInfo
  /// The link.
  link: Option<String>,
  
}



impl Object for GetDeepLinkInfo {}
impl RObject for GetDeepLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getDeepLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetDeepLinkInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetDeepLinkInfo {}


impl GetDeepLinkInfo {
  
  pub fn builder() -> RTDGetDeepLinkInfoBuilder {
    let instance = Self {
      td_name: "getDeepLinkInfo".to_string(),
      link: None,
      
    };
    RTDGetDeepLinkInfoBuilder::new(instance)
  }
  
  
  pub fn link(&self) -> Option<String> { self.link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetDeepLinkInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetDeepLinkInfoBuilder { instance: GetDeepLinkInfo }

impl RTDGetDeepLinkInfoBuilder {
  fn new(instance: GetDeepLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetDeepLinkInfo { self.instance.clone() }
  
  pub fn link<S: AsRef<str>>(&mut self, link: S) -> &mut Self {
    self.instance.link = Some(link.as_ref().to_string());
    self
  }
  
}



/// Returns favorite stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFavoriteStickers
  
}



impl Object for GetFavoriteStickers {}
impl RObject for GetFavoriteStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFavoriteStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetFavoriteStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetFavoriteStickers {}


impl GetFavoriteStickers {
  
  pub fn builder() -> RTDGetFavoriteStickersBuilder {
    let instance = Self {
      td_name: "getFavoriteStickers".to_string(),
      
    };
    RTDGetFavoriteStickersBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetFavoriteStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetFavoriteStickersBuilder { instance: GetFavoriteStickers }

impl RTDGetFavoriteStickersBuilder {
  fn new(instance: GetFavoriteStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetFavoriteStickers { self.instance.clone() }
  
}



/// Returns information about a file; this is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFile
  /// Identifier of the file to get.
  file_id: Option<i32>,
  
}



impl Object for GetFile {}
impl RObject for GetFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFile" }
  fn td_type(&self) -> RTDType { RTDType::GetFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetFile {}


impl GetFile {
  
  pub fn builder() -> RTDGetFileBuilder {
    let instance = Self {
      td_name: "getFile".to_string(),
      file_id: None,
      
    };
    RTDGetFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetFileBuilder { instance: GetFile }

impl RTDGetFileBuilder {
  fn new(instance: GetFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetFile { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}



/// Returns file downloaded prefix size from a given offset.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileDownloadedPrefixSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileDownloadedPrefixSize
  /// Identifier of the file.
  file_id: Option<i32>,
  /// Offset from which downloaded prefix size should be calculated.
  offset: Option<i32>,
  
}



impl Object for GetFileDownloadedPrefixSize {}
impl RObject for GetFileDownloadedPrefixSize {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileDownloadedPrefixSize" }
  fn td_type(&self) -> RTDType { RTDType::GetFileDownloadedPrefixSize }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetFileDownloadedPrefixSize {}


impl GetFileDownloadedPrefixSize {
  
  pub fn builder() -> RTDGetFileDownloadedPrefixSizeBuilder {
    let instance = Self {
      td_name: "getFileDownloadedPrefixSize".to_string(),
      file_id: None,
      offset: None,
      
    };
    RTDGetFileDownloadedPrefixSizeBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetFileDownloadedPrefixSize> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetFileDownloadedPrefixSizeBuilder { instance: GetFileDownloadedPrefixSize }

impl RTDGetFileDownloadedPrefixSizeBuilder {
  fn new(instance: GetFileDownloadedPrefixSize) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileDownloadedPrefixSize { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
}



/// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileExtension {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileExtension
  /// The MIME type of the file.
  mime_type: Option<String>,
  
}



impl Object for GetFileExtension {}
impl RObject for GetFileExtension {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileExtension" }
  fn td_type(&self) -> RTDType { RTDType::GetFileExtension }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetFileExtension {}


impl GetFileExtension {
  
  pub fn builder() -> RTDGetFileExtensionBuilder {
    let instance = Self {
      td_name: "getFileExtension".to_string(),
      mime_type: None,
      
    };
    RTDGetFileExtensionBuilder::new(instance)
  }
  
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetFileExtension> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetFileExtensionBuilder { instance: GetFileExtension }

impl RTDGetFileExtensionBuilder {
  fn new(instance: GetFileExtension) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileExtension { self.instance.clone() }
  
  pub fn mime_type<S: AsRef<str>>(&mut self, mime_type: S) -> &mut Self {
    self.instance.mime_type = Some(mime_type.as_ref().to_string());
    self
  }
  
}



/// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileMimeType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileMimeType
  /// The name of the file or path to the file.
  file_name: Option<String>,
  
}



impl Object for GetFileMimeType {}
impl RObject for GetFileMimeType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileMimeType" }
  fn td_type(&self) -> RTDType { RTDType::GetFileMimeType }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetFileMimeType {}


impl GetFileMimeType {
  
  pub fn builder() -> RTDGetFileMimeTypeBuilder {
    let instance = Self {
      td_name: "getFileMimeType".to_string(),
      file_name: None,
      
    };
    RTDGetFileMimeTypeBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetFileMimeType> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetFileMimeTypeBuilder { instance: GetFileMimeType }

impl RTDGetFileMimeTypeBuilder {
  fn new(instance: GetFileMimeType) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileMimeType { self.instance.clone() }
  
  pub fn file_name<S: AsRef<str>>(&mut self, file_name: S) -> &mut Self {
    self.instance.file_name = Some(file_name.as_ref().to_string());
    self
  }
  
}



/// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getGameHighScores
  /// The chat that contains the message with the game.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetGameHighScores {}
impl RObject for GetGameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getGameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GetGameHighScores }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetGameHighScores {}


impl GetGameHighScores {
  
  pub fn builder() -> RTDGetGameHighScoresBuilder {
    let instance = Self {
      td_name: "getGameHighScores".to_string(),
      chat_id: None,
      message_id: None,
      user_id: None,
      
    };
    RTDGetGameHighScoresBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetGameHighScores> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetGameHighScoresBuilder { instance: GetGameHighScores }

impl RTDGetGameHighScoresBuilder {
  fn new(instance: GetGameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GetGameHighScores { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGroupsInCommon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getGroupsInCommon
  /// User identifier.
  user_id: Option<i32>,
  /// Chat identifier starting from which to return chats; use 0 for the first request.
  offset_chat_id: Option<i64>,
  /// Maximum number of chats to be returned; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetGroupsInCommon {}
impl RObject for GetGroupsInCommon {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getGroupsInCommon" }
  fn td_type(&self) -> RTDType { RTDType::GetGroupsInCommon }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetGroupsInCommon {}


impl GetGroupsInCommon {
  
  pub fn builder() -> RTDGetGroupsInCommonBuilder {
    let instance = Self {
      td_name: "getGroupsInCommon".to_string(),
      user_id: None,
      offset_chat_id: None,
      limit: None,
      
    };
    RTDGetGroupsInCommonBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetGroupsInCommon> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetGroupsInCommonBuilder { instance: GetGroupsInCommon }

impl RTDGetGroupsInCommonBuilder {
  fn new(instance: GetGroupsInCommon) -> Self { Self { instance } }

  pub fn build(&self) -> GetGroupsInCommon { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns the total number of imported contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetImportedContactCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getImportedContactCount
  
}



impl Object for GetImportedContactCount {}
impl RObject for GetImportedContactCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getImportedContactCount" }
  fn td_type(&self) -> RTDType { RTDType::GetImportedContactCount }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetImportedContactCount {}


impl GetImportedContactCount {
  
  pub fn builder() -> RTDGetImportedContactCountBuilder {
    let instance = Self {
      td_name: "getImportedContactCount".to_string(),
      
    };
    RTDGetImportedContactCountBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetImportedContactCount> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetImportedContactCountBuilder { instance: GetImportedContactCount }

impl RTDGetImportedContactCountBuilder {
  fn new(instance: GetImportedContactCount) -> Self { Self { instance } }

  pub fn build(&self) -> GetImportedContactCount { self.instance.clone() }
  
}



/// Returns game high scores and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInlineGameHighScores
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetInlineGameHighScores {}
impl RObject for GetInlineGameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInlineGameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GetInlineGameHighScores }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetInlineGameHighScores {}


impl GetInlineGameHighScores {
  
  pub fn builder() -> RTDGetInlineGameHighScoresBuilder {
    let instance = Self {
      td_name: "getInlineGameHighScores".to_string(),
      inline_message_id: None,
      user_id: None,
      
    };
    RTDGetInlineGameHighScoresBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetInlineGameHighScores> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetInlineGameHighScoresBuilder { instance: GetInlineGameHighScores }

impl RTDGetInlineGameHighScoresBuilder {
  fn new(instance: GetInlineGameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GetInlineGameHighScores { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInlineQueryResults
  /// The identifier of the target bot.
  bot_user_id: Option<i32>,
  /// Identifier of the chat, where the query was sent.
  chat_id: Option<i64>,
  /// Location of the user, only if needed.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,
  
}



impl Object for GetInlineQueryResults {}
impl RObject for GetInlineQueryResults {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInlineQueryResults" }
  fn td_type(&self) -> RTDType { RTDType::GetInlineQueryResults }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetInlineQueryResults {}


impl GetInlineQueryResults {
  
  pub fn builder() -> RTDGetInlineQueryResultsBuilder {
    let instance = Self {
      td_name: "getInlineQueryResults".to_string(),
      bot_user_id: None,
      chat_id: None,
      user_location: None,
      query: None,
      offset: None,
      
    };
    RTDGetInlineQueryResultsBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset(&self) -> Option<String> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetInlineQueryResults> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetInlineQueryResultsBuilder { instance: GetInlineQueryResults }

impl RTDGetInlineQueryResultsBuilder {
  fn new(instance: GetInlineQueryResults) -> Self { Self { instance } }

  pub fn build(&self) -> GetInlineQueryResults { self.instance.clone() }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_location(&mut self, user_location: Location) -> &mut Self {
    self.instance.user_location = Some(user_location);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn offset<S: AsRef<str>>(&mut self, offset: S) -> &mut Self {
    self.instance.offset = Some(offset.as_ref().to_string());
    self
  }
  
}



/// Returns a list of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInstalledStickerSets
  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  
}



impl Object for GetInstalledStickerSets {}
impl RObject for GetInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetInstalledStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetInstalledStickerSets {}


impl GetInstalledStickerSets {
  
  pub fn builder() -> RTDGetInstalledStickerSetsBuilder {
    let instance = Self {
      td_name: "getInstalledStickerSets".to_string(),
      is_masks: None,
      
    };
    RTDGetInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetInstalledStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetInstalledStickerSetsBuilder { instance: GetInstalledStickerSets }

impl RTDGetInstalledStickerSetsBuilder {
  fn new(instance: GetInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetInstalledStickerSets { self.instance.clone() }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
}



/// Returns the default text for invitation messages to be used as a placeholder when the current user invites friends to Telegram.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInviteText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInviteText
  
}



impl Object for GetInviteText {}
impl RObject for GetInviteText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInviteText" }
  fn td_type(&self) -> RTDType { RTDType::GetInviteText }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetInviteText {}


impl GetInviteText {
  
  pub fn builder() -> RTDGetInviteTextBuilder {
    let instance = Self {
      td_name: "getInviteText".to_string(),
      
    };
    RTDGetInviteTextBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetInviteText> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetInviteTextBuilder { instance: GetInviteText }

impl RTDGetInviteTextBuilder {
  fn new(instance: GetInviteText) -> Self { Self { instance } }

  pub fn build(&self) -> GetInviteText { self.instance.clone() }
  
}



/// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackInfo
  /// Language pack identifier.
  language_pack_id: Option<String>,
  
}



impl Object for GetLanguagePackInfo {}
impl RObject for GetLanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLanguagePackInfo {}


impl GetLanguagePackInfo {
  
  pub fn builder() -> RTDGetLanguagePackInfoBuilder {
    let instance = Self {
      td_name: "getLanguagePackInfo".to_string(),
      language_pack_id: None,
      
    };
    RTDGetLanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLanguagePackInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLanguagePackInfoBuilder { instance: GetLanguagePackInfo }

impl RTDGetLanguagePackInfoBuilder {
  fn new(instance: GetLanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackInfo { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
}



/// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackString
  /// Path to the language pack database in which strings are stored.
  language_pack_database_path: Option<String>,
  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Language pack identifier.
  language_pack_id: Option<String>,
  /// Language pack key of the string to be returned.
  key: Option<String>,
  
}



impl Object for GetLanguagePackString {}
impl RObject for GetLanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackString" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLanguagePackString {}


impl GetLanguagePackString {
  
  pub fn builder() -> RTDGetLanguagePackStringBuilder {
    let instance = Self {
      td_name: "getLanguagePackString".to_string(),
      language_pack_database_path: None,
      localization_target: None,
      language_pack_id: None,
      key: None,
      
    };
    RTDGetLanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn language_pack_database_path(&self) -> Option<String> { self.language_pack_database_path.clone() }
  
  pub fn localization_target(&self) -> Option<String> { self.localization_target.clone() }
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn key(&self) -> Option<String> { self.key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLanguagePackString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLanguagePackStringBuilder { instance: GetLanguagePackString }

impl RTDGetLanguagePackStringBuilder {
  fn new(instance: GetLanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackString { self.instance.clone() }
  
  pub fn language_pack_database_path<S: AsRef<str>>(&mut self, language_pack_database_path: S) -> &mut Self {
    self.instance.language_pack_database_path = Some(language_pack_database_path.as_ref().to_string());
    self
  }
  
  pub fn localization_target<S: AsRef<str>>(&mut self, localization_target: S) -> &mut Self {
    self.instance.localization_target = Some(localization_target.as_ref().to_string());
    self
  }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
  pub fn key<S: AsRef<str>>(&mut self, key: S) -> &mut Self {
    self.instance.key = Some(key.as_ref().to_string());
    self
  }
  
}



/// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackStrings
  /// Language pack identifier of the strings to be returned.
  language_pack_id: Option<String>,
  /// Language pack keys of the strings to be returned; leave empty to request all available strings.
  keys: Option<Vec<String>>,
  
}



impl Object for GetLanguagePackStrings {}
impl RObject for GetLanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackStrings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLanguagePackStrings {}


impl GetLanguagePackStrings {
  
  pub fn builder() -> RTDGetLanguagePackStringsBuilder {
    let instance = Self {
      td_name: "getLanguagePackStrings".to_string(),
      language_pack_id: None,
      keys: None,
      
    };
    RTDGetLanguagePackStringsBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn keys(&self) -> Option<Vec<String>> { self.keys.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLanguagePackStrings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLanguagePackStringsBuilder { instance: GetLanguagePackStrings }

impl RTDGetLanguagePackStringsBuilder {
  fn new(instance: GetLanguagePackStrings) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackStrings { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
  pub fn keys(&mut self, keys: Vec<String>) -> &mut Self {
    self.instance.keys = Some(keys);
    self
  }
  
}



/// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLocalizationTargetInfo
  /// If true, returns only locally available information without sending network requests.
  only_local: Option<bool>,
  
}



impl Object for GetLocalizationTargetInfo {}
impl RObject for GetLocalizationTargetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLocalizationTargetInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetLocalizationTargetInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLocalizationTargetInfo {}


impl GetLocalizationTargetInfo {
  
  pub fn builder() -> RTDGetLocalizationTargetInfoBuilder {
    let instance = Self {
      td_name: "getLocalizationTargetInfo".to_string(),
      only_local: None,
      
    };
    RTDGetLocalizationTargetInfoBuilder::new(instance)
  }
  
  
  pub fn only_local(&self) -> Option<bool> { self.only_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLocalizationTargetInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLocalizationTargetInfoBuilder { instance: GetLocalizationTargetInfo }

impl RTDGetLocalizationTargetInfoBuilder {
  fn new(instance: GetLocalizationTargetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetLocalizationTargetInfo { self.instance.clone() }
  
  pub fn only_local(&mut self, only_local: bool) -> &mut Self {
    self.instance.only_local = Some(only_local);
    self
  }
  
}



/// Returns information about currently used log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogStream
  
}



impl Object for GetLogStream {}
impl RObject for GetLogStream {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogStream" }
  fn td_type(&self) -> RTDType { RTDType::GetLogStream }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLogStream {}


impl GetLogStream {
  
  pub fn builder() -> RTDGetLogStreamBuilder {
    let instance = Self {
      td_name: "getLogStream".to_string(),
      
    };
    RTDGetLogStreamBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLogStream> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLogStreamBuilder { instance: GetLogStream }

impl RTDGetLogStreamBuilder {
  fn new(instance: GetLogStream) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogStream { self.instance.clone() }
  
}



/// Returns current verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogTagVerbosityLevel
  /// Logging tag to change verbosity level.
  tag: Option<String>,
  
}



impl Object for GetLogTagVerbosityLevel {}
impl RObject for GetLogTagVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogTagVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::GetLogTagVerbosityLevel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLogTagVerbosityLevel {}


impl GetLogTagVerbosityLevel {
  
  pub fn builder() -> RTDGetLogTagVerbosityLevelBuilder {
    let instance = Self {
      td_name: "getLogTagVerbosityLevel".to_string(),
      tag: None,
      
    };
    RTDGetLogTagVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn tag(&self) -> Option<String> { self.tag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLogTagVerbosityLevel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLogTagVerbosityLevelBuilder { instance: GetLogTagVerbosityLevel }

impl RTDGetLogTagVerbosityLevelBuilder {
  fn new(instance: GetLogTagVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogTagVerbosityLevel { self.instance.clone() }
  
  pub fn tag<S: AsRef<str>>(&mut self, tag: S) -> &mut Self {
    self.instance.tag = Some(tag.as_ref().to_string());
    self
  }
  
}



/// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogTags
  
}



impl Object for GetLogTags {}
impl RObject for GetLogTags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogTags" }
  fn td_type(&self) -> RTDType { RTDType::GetLogTags }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLogTags {}


impl GetLogTags {
  
  pub fn builder() -> RTDGetLogTagsBuilder {
    let instance = Self {
      td_name: "getLogTags".to_string(),
      
    };
    RTDGetLogTagsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLogTags> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLogTagsBuilder { instance: GetLogTags }

impl RTDGetLogTagsBuilder {
  fn new(instance: GetLogTags) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogTags { self.instance.clone() }
  
}



/// Returns current verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogVerbosityLevel
  
}



impl Object for GetLogVerbosityLevel {}
impl RObject for GetLogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::GetLogVerbosityLevel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetLogVerbosityLevel {}


impl GetLogVerbosityLevel {
  
  pub fn builder() -> RTDGetLogVerbosityLevelBuilder {
    let instance = Self {
      td_name: "getLogVerbosityLevel".to_string(),
      
    };
    RTDGetLogVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetLogVerbosityLevel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetLogVerbosityLevelBuilder { instance: GetLogVerbosityLevel }

impl RTDGetLogVerbosityLevelBuilder {
  fn new(instance: GetLogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogVerbosityLevel { self.instance.clone() }
  
}



/// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMapThumbnailFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMapThumbnailFile
  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level; 13-20.
  zoom: Option<i32>,
  /// Map width in pixels before applying scale; 16-1024.
  width: Option<i32>,
  /// Map height in pixels before applying scale; 16-1024.
  height: Option<i32>,
  /// Map scale; 1-3.
  scale: Option<i32>,
  /// Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown.
  chat_id: Option<i64>,
  
}



impl Object for GetMapThumbnailFile {}
impl RObject for GetMapThumbnailFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMapThumbnailFile" }
  fn td_type(&self) -> RTDType { RTDType::GetMapThumbnailFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMapThumbnailFile {}


impl GetMapThumbnailFile {
  
  pub fn builder() -> RTDGetMapThumbnailFileBuilder {
    let instance = Self {
      td_name: "getMapThumbnailFile".to_string(),
      location: None,
      zoom: None,
      width: None,
      height: None,
      scale: None,
      chat_id: None,
      
    };
    RTDGetMapThumbnailFileBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn zoom(&self) -> Option<i32> { self.zoom.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn scale(&self) -> Option<i32> { self.scale.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMapThumbnailFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMapThumbnailFileBuilder { instance: GetMapThumbnailFile }

impl RTDGetMapThumbnailFileBuilder {
  fn new(instance: GetMapThumbnailFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetMapThumbnailFile { self.instance.clone() }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn zoom(&mut self, zoom: i32) -> &mut Self {
    self.instance.zoom = Some(zoom);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn scale(&mut self, scale: i32) -> &mut Self {
    self.instance.scale = Some(scale);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Returns the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMe
  
}



impl Object for GetMe {}
impl RObject for GetMe {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMe" }
  fn td_type(&self) -> RTDType { RTDType::GetMe }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMe {}


impl GetMe {
  
  pub fn builder() -> RTDGetMeBuilder {
    let instance = Self {
      td_name: "getMe".to_string(),
      
    };
    RTDGetMeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMe> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMeBuilder { instance: GetMe }

impl RTDGetMeBuilder {
  fn new(instance: GetMe) -> Self { Self { instance } }

  pub fn build(&self) -> GetMe { self.instance.clone() }
  
}



/// Returns information about a message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,
  
}



impl Object for GetMessage {}
impl RObject for GetMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMessage {}


impl GetMessage {
  
  pub fn builder() -> RTDGetMessageBuilder {
    let instance = Self {
      td_name: "getMessage".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMessageBuilder { instance: GetMessage }

impl RTDGetMessageBuilder {
  fn new(instance: GetMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns a private HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels. The link will work only for members of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessageLink
  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  
}



impl Object for GetMessageLink {}
impl RObject for GetMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::GetMessageLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMessageLink {}


impl GetMessageLink {
  
  pub fn builder() -> RTDGetMessageLinkBuilder {
    let instance = Self {
      td_name: "getMessageLink".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetMessageLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMessageLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMessageLinkBuilder { instance: GetMessageLink }

impl RTDGetMessageLinkBuilder {
  fn new(instance: GetMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessageLink { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns information about a message, if it is available locally without sending network request. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLocally {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessageLocally
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,
  
}



impl Object for GetMessageLocally {}
impl RObject for GetMessageLocally {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessageLocally" }
  fn td_type(&self) -> RTDType { RTDType::GetMessageLocally }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMessageLocally {}


impl GetMessageLocally {
  
  pub fn builder() -> RTDGetMessageLocallyBuilder {
    let instance = Self {
      td_name: "getMessageLocally".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetMessageLocallyBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMessageLocally> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMessageLocallyBuilder { instance: GetMessageLocally }

impl RTDGetMessageLocallyBuilder {
  fn new(instance: GetMessageLocally) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessageLocally { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns information about messages. If a message is not found, returns null on the corresponding position of the result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessages
  /// Identifier of the chat the messages belong to.
  chat_id: Option<i64>,
  /// Identifiers of the messages to get.
  message_ids: Option<Vec<i64>>,
  
}



impl Object for GetMessages {}
impl RObject for GetMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessages" }
  fn td_type(&self) -> RTDType { RTDType::GetMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetMessages {}


impl GetMessages {
  
  pub fn builder() -> RTDGetMessagesBuilder {
    let instance = Self {
      td_name: "getMessages".to_string(),
      chat_id: None,
      message_ids: None,
      
    };
    RTDGetMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetMessagesBuilder { instance: GetMessages }

impl RTDGetMessagesBuilder {
  fn new(instance: GetMessages) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}



/// Returns network data usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getNetworkStatistics
  /// If true, returns only data for the current library launch.
  only_current: Option<bool>,
  
}



impl Object for GetNetworkStatistics {}
impl RObject for GetNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetNetworkStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetNetworkStatistics {}


impl GetNetworkStatistics {
  
  pub fn builder() -> RTDGetNetworkStatisticsBuilder {
    let instance = Self {
      td_name: "getNetworkStatistics".to_string(),
      only_current: None,
      
    };
    RTDGetNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn only_current(&self) -> Option<bool> { self.only_current.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetNetworkStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetNetworkStatisticsBuilder { instance: GetNetworkStatistics }

impl RTDGetNetworkStatisticsBuilder {
  fn new(instance: GetNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetNetworkStatistics { self.instance.clone() }
  
  pub fn only_current(&mut self, only_current: bool) -> &mut Self {
    self.instance.only_current = Some(only_current);
    self
  }
  
}



/// Returns the value of an option by its name. (Check the list of available options on 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getOption
  /// The name of the option.
  name: Option<String>,
  
}



impl Object for GetOption {}
impl RObject for GetOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getOption" }
  fn td_type(&self) -> RTDType { RTDType::GetOption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetOption {}


impl GetOption {
  
  pub fn builder() -> RTDGetOptionBuilder {
    let instance = Self {
      td_name: "getOption".to_string(),
      name: None,
      
    };
    RTDGetOptionBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetOption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetOptionBuilder { instance: GetOption }

impl RTDGetOptionBuilder {
  fn new(instance: GetOption) -> Self { Self { instance } }

  pub fn build(&self) -> GetOption { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
}



/// Returns a Telegram Passport authorization form for sharing data with a service.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportAuthorizationForm
  /// User identifier of the service's bot.
  bot_user_id: Option<i32>,
  /// Telegram Passport element types requested by the service.
  scope: Option<String>,
  /// Service's public_key.
  public_key: Option<String>,
  /// Authorization form nonce provided by the service.
  nonce: Option<String>,
  
}



impl Object for GetPassportAuthorizationForm {}
impl RObject for GetPassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportAuthorizationForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPassportAuthorizationForm {}


impl GetPassportAuthorizationForm {
  
  pub fn builder() -> RTDGetPassportAuthorizationFormBuilder {
    let instance = Self {
      td_name: "getPassportAuthorizationForm".to_string(),
      bot_user_id: None,
      scope: None,
      public_key: None,
      nonce: None,
      
    };
    RTDGetPassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn scope(&self) -> Option<String> { self.scope.clone() }
  
  pub fn public_key(&self) -> Option<String> { self.public_key.clone() }
  
  pub fn nonce(&self) -> Option<String> { self.nonce.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPassportAuthorizationForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPassportAuthorizationFormBuilder { instance: GetPassportAuthorizationForm }

impl RTDGetPassportAuthorizationFormBuilder {
  fn new(instance: GetPassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportAuthorizationForm { self.instance.clone() }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn scope<S: AsRef<str>>(&mut self, scope: S) -> &mut Self {
    self.instance.scope = Some(scope.as_ref().to_string());
    self
  }
  
  pub fn public_key<S: AsRef<str>>(&mut self, public_key: S) -> &mut Self {
    self.instance.public_key = Some(public_key.as_ref().to_string());
    self
  }
  
  pub fn nonce<S: AsRef<str>>(&mut self, nonce: S) -> &mut Self {
    self.instance.nonce = Some(nonce.as_ref().to_string());
    self
  }
  
}



/// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationFormAvailableElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportAuthorizationFormAvailableElements
  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Password of the current user.
  password: Option<String>,
  
}



impl Object for GetPassportAuthorizationFormAvailableElements {}
impl RObject for GetPassportAuthorizationFormAvailableElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportAuthorizationFormAvailableElements" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportAuthorizationFormAvailableElements }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPassportAuthorizationFormAvailableElements {}


impl GetPassportAuthorizationFormAvailableElements {
  
  pub fn builder() -> RTDGetPassportAuthorizationFormAvailableElementsBuilder {
    let instance = Self {
      td_name: "getPassportAuthorizationFormAvailableElements".to_string(),
      autorization_form_id: None,
      password: None,
      
    };
    RTDGetPassportAuthorizationFormAvailableElementsBuilder::new(instance)
  }
  
  
  pub fn autorization_form_id(&self) -> Option<i32> { self.autorization_form_id.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPassportAuthorizationFormAvailableElements> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPassportAuthorizationFormAvailableElementsBuilder { instance: GetPassportAuthorizationFormAvailableElements }

impl RTDGetPassportAuthorizationFormAvailableElementsBuilder {
  fn new(instance: GetPassportAuthorizationFormAvailableElements) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportAuthorizationFormAvailableElements { self.instance.clone() }
  
  pub fn autorization_form_id(&mut self, autorization_form_id: i32) -> &mut Self {
    self.instance.autorization_form_id = Some(autorization_form_id);
    self
  }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Returns one of the available Telegram Passport elements.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportElement
  /// Telegram Passport element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Password of the current user.
  password: Option<String>,
  
}


impl Clone for GetPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetPassportElement {}
impl RObject for GetPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPassportElement {}


impl GetPassportElement {
  
  pub fn builder() -> RTDGetPassportElementBuilder {
    let instance = Self {
      td_name: "getPassportElement".to_string(),
      type_: None,
      password: None,
      
    };
    RTDGetPassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPassportElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPassportElementBuilder { instance: GetPassportElement }

impl RTDGetPassportElementBuilder {
  fn new(instance: GetPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportElement { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Returns the current state of 2-step verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPasswordState
  
}



impl Object for GetPasswordState {}
impl RObject for GetPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::GetPasswordState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPasswordState {}


impl GetPasswordState {
  
  pub fn builder() -> RTDGetPasswordStateBuilder {
    let instance = Self {
      td_name: "getPasswordState".to_string(),
      
    };
    RTDGetPasswordStateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPasswordState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPasswordStateBuilder { instance: GetPasswordState }

impl RTDGetPasswordStateBuilder {
  fn new(instance: GetPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> GetPasswordState { self.instance.clone() }
  
}



/// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPaymentForm
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for GetPaymentForm {}
impl RObject for GetPaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPaymentForm" }
  fn td_type(&self) -> RTDType { RTDType::GetPaymentForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPaymentForm {}


impl GetPaymentForm {
  
  pub fn builder() -> RTDGetPaymentFormBuilder {
    let instance = Self {
      td_name: "getPaymentForm".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetPaymentFormBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPaymentForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPaymentFormBuilder { instance: GetPaymentForm }

impl RTDGetPaymentFormBuilder {
  fn new(instance: GetPaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> GetPaymentForm { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns information about a successful payment.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPaymentReceipt
  /// Chat identifier of the PaymentSuccessful message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for GetPaymentReceipt {}
impl RObject for GetPaymentReceipt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPaymentReceipt" }
  fn td_type(&self) -> RTDType { RTDType::GetPaymentReceipt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPaymentReceipt {}


impl GetPaymentReceipt {
  
  pub fn builder() -> RTDGetPaymentReceiptBuilder {
    let instance = Self {
      td_name: "getPaymentReceipt".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetPaymentReceiptBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPaymentReceipt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPaymentReceiptBuilder { instance: GetPaymentReceipt }

impl RTDGetPaymentReceiptBuilder {
  fn new(instance: GetPaymentReceipt) -> Self { Self { instance } }

  pub fn build(&self) -> GetPaymentReceipt { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPreferredCountryLanguage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPreferredCountryLanguage
  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,
  
}



impl Object for GetPreferredCountryLanguage {}
impl RObject for GetPreferredCountryLanguage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPreferredCountryLanguage" }
  fn td_type(&self) -> RTDType { RTDType::GetPreferredCountryLanguage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPreferredCountryLanguage {}


impl GetPreferredCountryLanguage {
  
  pub fn builder() -> RTDGetPreferredCountryLanguageBuilder {
    let instance = Self {
      td_name: "getPreferredCountryLanguage".to_string(),
      country_code: None,
      
    };
    RTDGetPreferredCountryLanguageBuilder::new(instance)
  }
  
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPreferredCountryLanguage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPreferredCountryLanguageBuilder { instance: GetPreferredCountryLanguage }

impl RTDGetPreferredCountryLanguageBuilder {
  fn new(instance: GetPreferredCountryLanguage) -> Self { Self { instance } }

  pub fn build(&self) -> GetPreferredCountryLanguage { self.instance.clone() }
  
  pub fn country_code<S: AsRef<str>>(&mut self, country_code: S) -> &mut Self {
    self.instance.country_code = Some(country_code.as_ref().to_string());
    self
  }
  
}



/// Returns list of proxies that are currently set up. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getProxies
  
}



impl Object for GetProxies {}
impl RObject for GetProxies {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getProxies" }
  fn td_type(&self) -> RTDType { RTDType::GetProxies }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetProxies {}


impl GetProxies {
  
  pub fn builder() -> RTDGetProxiesBuilder {
    let instance = Self {
      td_name: "getProxies".to_string(),
      
    };
    RTDGetProxiesBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetProxies> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetProxiesBuilder { instance: GetProxies }

impl RTDGetProxiesBuilder {
  fn new(instance: GetProxies) -> Self { Self { instance } }

  pub fn build(&self) -> GetProxies { self.instance.clone() }
  
}



/// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxyLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getProxyLink
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for GetProxyLink {}
impl RObject for GetProxyLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getProxyLink" }
  fn td_type(&self) -> RTDType { RTDType::GetProxyLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetProxyLink {}


impl GetProxyLink {
  
  pub fn builder() -> RTDGetProxyLinkBuilder {
    let instance = Self {
      td_name: "getProxyLink".to_string(),
      proxy_id: None,
      
    };
    RTDGetProxyLinkBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetProxyLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetProxyLinkBuilder { instance: GetProxyLink }

impl RTDGetProxyLinkBuilder {
  fn new(instance: GetProxyLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetProxyLink { self.instance.clone() }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}



/// Returns a public HTTPS link to a message. Available only for messages in public supergroups and channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPublicMessageLink
  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// Pass true if a link for a whole media album should be returned.
  for_album: Option<bool>,
  
}



impl Object for GetPublicMessageLink {}
impl RObject for GetPublicMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPublicMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::GetPublicMessageLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPublicMessageLink {}


impl GetPublicMessageLink {
  
  pub fn builder() -> RTDGetPublicMessageLinkBuilder {
    let instance = Self {
      td_name: "getPublicMessageLink".to_string(),
      chat_id: None,
      message_id: None,
      for_album: None,
      
    };
    RTDGetPublicMessageLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn for_album(&self) -> Option<bool> { self.for_album.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPublicMessageLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPublicMessageLinkBuilder { instance: GetPublicMessageLink }

impl RTDGetPublicMessageLinkBuilder {
  fn new(instance: GetPublicMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetPublicMessageLink { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn for_album(&mut self, for_album: bool) -> &mut Self {
    self.instance.for_album = Some(for_album);
    self
  }
  
}



/// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPushReceiverId
  /// JSON-encoded push notification payload.
  payload: Option<String>,
  
}



impl Object for GetPushReceiverId {}
impl RObject for GetPushReceiverId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPushReceiverId" }
  fn td_type(&self) -> RTDType { RTDType::GetPushReceiverId }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetPushReceiverId {}


impl GetPushReceiverId {
  
  pub fn builder() -> RTDGetPushReceiverIdBuilder {
    let instance = Self {
      td_name: "getPushReceiverId".to_string(),
      payload: None,
      
    };
    RTDGetPushReceiverIdBuilder::new(instance)
  }
  
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetPushReceiverId> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetPushReceiverIdBuilder { instance: GetPushReceiverId }

impl RTDGetPushReceiverIdBuilder {
  fn new(instance: GetPushReceiverId) -> Self { Self { instance } }

  pub fn build(&self) -> GetPushReceiverId { self.instance.clone() }
  
  pub fn payload<S: AsRef<str>>(&mut self, payload: S) -> &mut Self {
    self.instance.payload = Some(payload.as_ref().to_string());
    self
  }
  
}



/// Returns up to 20 recently used inline bots in the order of their last usage.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentInlineBots
  
}



impl Object for GetRecentInlineBots {}
impl RObject for GetRecentInlineBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentInlineBots" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentInlineBots }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRecentInlineBots {}


impl GetRecentInlineBots {
  
  pub fn builder() -> RTDGetRecentInlineBotsBuilder {
    let instance = Self {
      td_name: "getRecentInlineBots".to_string(),
      
    };
    RTDGetRecentInlineBotsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRecentInlineBots> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRecentInlineBotsBuilder { instance: GetRecentInlineBots }

impl RTDGetRecentInlineBotsBuilder {
  fn new(instance: GetRecentInlineBots) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentInlineBots { self.instance.clone() }
  
}



/// Returns a list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentStickers
  /// Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers.
  is_attached: Option<bool>,
  
}



impl Object for GetRecentStickers {}
impl RObject for GetRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRecentStickers {}


impl GetRecentStickers {
  
  pub fn builder() -> RTDGetRecentStickersBuilder {
    let instance = Self {
      td_name: "getRecentStickers".to_string(),
      is_attached: None,
      
    };
    RTDGetRecentStickersBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRecentStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRecentStickersBuilder { instance: GetRecentStickers }

impl RTDGetRecentStickersBuilder {
  fn new(instance: GetRecentStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentStickers { self.instance.clone() }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
}



/// Returns t.me URLs recently visited by a newly registered user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentlyVisitedTMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentlyVisitedTMeUrls
  /// Google Play referrer to identify the user.
  referrer: Option<String>,
  
}



impl Object for GetRecentlyVisitedTMeUrls {}
impl RObject for GetRecentlyVisitedTMeUrls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentlyVisitedTMeUrls" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentlyVisitedTMeUrls }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRecentlyVisitedTMeUrls {}


impl GetRecentlyVisitedTMeUrls {
  
  pub fn builder() -> RTDGetRecentlyVisitedTMeUrlsBuilder {
    let instance = Self {
      td_name: "getRecentlyVisitedTMeUrls".to_string(),
      referrer: None,
      
    };
    RTDGetRecentlyVisitedTMeUrlsBuilder::new(instance)
  }
  
  
  pub fn referrer(&self) -> Option<String> { self.referrer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRecentlyVisitedTMeUrls> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRecentlyVisitedTMeUrlsBuilder { instance: GetRecentlyVisitedTMeUrls }

impl RTDGetRecentlyVisitedTMeUrlsBuilder {
  fn new(instance: GetRecentlyVisitedTMeUrls) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentlyVisitedTMeUrls { self.instance.clone() }
  
  pub fn referrer<S: AsRef<str>>(&mut self, referrer: S) -> &mut Self {
    self.instance.referrer = Some(referrer.as_ref().to_string());
    self
  }
  
}



/// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecoveryEmailAddress
  /// The password for the current user.
  password: Option<String>,
  
}



impl Object for GetRecoveryEmailAddress {}
impl RObject for GetRecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::GetRecoveryEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRecoveryEmailAddress {}


impl GetRecoveryEmailAddress {
  
  pub fn builder() -> RTDGetRecoveryEmailAddressBuilder {
    let instance = Self {
      td_name: "getRecoveryEmailAddress".to_string(),
      password: None,
      
    };
    RTDGetRecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRecoveryEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRecoveryEmailAddressBuilder { instance: GetRecoveryEmailAddress }

impl RTDGetRecoveryEmailAddressBuilder {
  fn new(instance: GetRecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecoveryEmailAddress { self.instance.clone() }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetRemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRemoteFile
  /// Remote identifier of the file to get.
  remote_file_id: Option<String>,
  /// File type, if known.
  file_type: Option<Box<FileType>>,
  
}


impl Clone for GetRemoteFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetRemoteFile {}
impl RObject for GetRemoteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRemoteFile" }
  fn td_type(&self) -> RTDType { RTDType::GetRemoteFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRemoteFile {}


impl GetRemoteFile {
  
  pub fn builder() -> RTDGetRemoteFileBuilder {
    let instance = Self {
      td_name: "getRemoteFile".to_string(),
      remote_file_id: None,
      file_type: None,
      
    };
    RTDGetRemoteFileBuilder::new(instance)
  }
  
  
  pub fn remote_file_id(&self) -> Option<String> { self.remote_file_id.clone() }
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRemoteFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRemoteFileBuilder { instance: GetRemoteFile }

impl RTDGetRemoteFileBuilder {
  fn new(instance: GetRemoteFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetRemoteFile { self.instance.clone() }
  
  pub fn remote_file_id<S: AsRef<str>>(&mut self, remote_file_id: S) -> &mut Self {
    self.instance.remote_file_id = Some(remote_file_id.as_ref().to_string());
    self
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
}



/// Returns information about a message that is replied by given message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRepliedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRepliedMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message reply to which get.
  message_id: Option<i64>,
  
}



impl Object for GetRepliedMessage {}
impl RObject for GetRepliedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRepliedMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetRepliedMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetRepliedMessage {}


impl GetRepliedMessage {
  
  pub fn builder() -> RTDGetRepliedMessageBuilder {
    let instance = Self {
      td_name: "getRepliedMessage".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDGetRepliedMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetRepliedMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetRepliedMessageBuilder { instance: GetRepliedMessage }

impl RTDGetRepliedMessageBuilder {
  fn new(instance: GetRepliedMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetRepliedMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Returns saved animations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSavedAnimations
  
}



impl Object for GetSavedAnimations {}
impl RObject for GetSavedAnimations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSavedAnimations" }
  fn td_type(&self) -> RTDType { RTDType::GetSavedAnimations }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSavedAnimations {}


impl GetSavedAnimations {
  
  pub fn builder() -> RTDGetSavedAnimationsBuilder {
    let instance = Self {
      td_name: "getSavedAnimations".to_string(),
      
    };
    RTDGetSavedAnimationsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSavedAnimations> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSavedAnimationsBuilder { instance: GetSavedAnimations }

impl RTDGetSavedAnimationsBuilder {
  fn new(instance: GetSavedAnimations) -> Self { Self { instance } }

  pub fn build(&self) -> GetSavedAnimations { self.instance.clone() }
  
}



/// Returns saved order info, if any.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSavedOrderInfo
  
}



impl Object for GetSavedOrderInfo {}
impl RObject for GetSavedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSavedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetSavedOrderInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSavedOrderInfo {}


impl GetSavedOrderInfo {
  
  pub fn builder() -> RTDGetSavedOrderInfoBuilder {
    let instance = Self {
      td_name: "getSavedOrderInfo".to_string(),
      
    };
    RTDGetSavedOrderInfoBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSavedOrderInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSavedOrderInfoBuilder { instance: GetSavedOrderInfo }

impl RTDGetSavedOrderInfoBuilder {
  fn new(instance: GetSavedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetSavedOrderInfo { self.instance.clone() }
  
}



/// Returns the notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getScopeNotificationSettings
  /// Types of chats for which to return the notification settings information.
  scope: Option<Box<NotificationSettingsScope>>,
  
}


impl Clone for GetScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetScopeNotificationSettings {}
impl RObject for GetScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::GetScopeNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetScopeNotificationSettings {}


impl GetScopeNotificationSettings {
  
  pub fn builder() -> RTDGetScopeNotificationSettingsBuilder {
    let instance = Self {
      td_name: "getScopeNotificationSettings".to_string(),
      scope: None,
      
    };
    RTDGetScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetScopeNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetScopeNotificationSettingsBuilder { instance: GetScopeNotificationSettings }

impl RTDGetScopeNotificationSettingsBuilder {
  fn new(instance: GetScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> GetScopeNotificationSettings { self.instance.clone() }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
}



/// Returns information about a secret chat by its identifier. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for GetSecretChat {}
impl RObject for GetSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::GetSecretChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSecretChat {}


impl GetSecretChat {
  
  pub fn builder() -> RTDGetSecretChatBuilder {
    let instance = Self {
      td_name: "getSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    RTDGetSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSecretChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSecretChatBuilder { instance: GetSecretChat }

impl RTDGetSecretChatBuilder {
  fn new(instance: GetSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> GetSecretChat { self.instance.clone() }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}



/// Returns emoji corresponding to a sticker.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetStickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickerEmojis
  /// Sticker file identifier.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for GetStickerEmojis {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetStickerEmojis {}
impl RObject for GetStickerEmojis {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickerEmojis" }
  fn td_type(&self) -> RTDType { RTDType::GetStickerEmojis }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetStickerEmojis {}


impl GetStickerEmojis {
  
  pub fn builder() -> RTDGetStickerEmojisBuilder {
    let instance = Self {
      td_name: "getStickerEmojis".to_string(),
      sticker: None,
      
    };
    RTDGetStickerEmojisBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetStickerEmojis> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetStickerEmojisBuilder { instance: GetStickerEmojis }

impl RTDGetStickerEmojisBuilder {
  fn new(instance: GetStickerEmojis) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickerEmojis { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Returns information about a sticker set by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickerSet
  /// Identifier of the sticker set.
  set_id: Option<i64>,
  
}



impl Object for GetStickerSet {}
impl RObject for GetStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::GetStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetStickerSet {}


impl GetStickerSet {
  
  pub fn builder() -> RTDGetStickerSetBuilder {
    let instance = Self {
      td_name: "getStickerSet".to_string(),
      set_id: None,
      
    };
    RTDGetStickerSetBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetStickerSetBuilder { instance: GetStickerSet }

impl RTDGetStickerSetBuilder {
  fn new(instance: GetStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickerSet { self.instance.clone() }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
}



/// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickers
  /// String representation of emoji. If empty, returns all known installed stickers.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,
  
}



impl Object for GetStickers {}
impl RObject for GetStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetStickers {}


impl GetStickers {
  
  pub fn builder() -> RTDGetStickersBuilder {
    let instance = Self {
      td_name: "getStickers".to_string(),
      emoji: None,
      limit: None,
      
    };
    RTDGetStickersBuilder::new(instance)
  }
  
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetStickersBuilder { instance: GetStickers }

impl RTDGetStickersBuilder {
  fn new(instance: GetStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickers { self.instance.clone() }
  
  pub fn emoji<S: AsRef<str>>(&mut self, emoji: S) -> &mut Self {
    self.instance.emoji = Some(emoji.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStorageStatistics
  /// Maximum number of chats with the largest storage usage for which separate statistics should be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0.
  chat_limit: Option<i32>,
  
}



impl Object for GetStorageStatistics {}
impl RObject for GetStorageStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStorageStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetStorageStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetStorageStatistics {}


impl GetStorageStatistics {
  
  pub fn builder() -> RTDGetStorageStatisticsBuilder {
    let instance = Self {
      td_name: "getStorageStatistics".to_string(),
      chat_limit: None,
      
    };
    RTDGetStorageStatisticsBuilder::new(instance)
  }
  
  
  pub fn chat_limit(&self) -> Option<i32> { self.chat_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetStorageStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetStorageStatisticsBuilder { instance: GetStorageStatistics }

impl RTDGetStorageStatisticsBuilder {
  fn new(instance: GetStorageStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetStorageStatistics { self.instance.clone() }
  
  pub fn chat_limit(&mut self, chat_limit: i32) -> &mut Self {
    self.instance.chat_limit = Some(chat_limit);
    self
  }
  
}



/// Quickly returns approximate storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStorageStatisticsFast
  
}



impl Object for GetStorageStatisticsFast {}
impl RObject for GetStorageStatisticsFast {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStorageStatisticsFast" }
  fn td_type(&self) -> RTDType { RTDType::GetStorageStatisticsFast }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetStorageStatisticsFast {}


impl GetStorageStatisticsFast {
  
  pub fn builder() -> RTDGetStorageStatisticsFastBuilder {
    let instance = Self {
      td_name: "getStorageStatisticsFast".to_string(),
      
    };
    RTDGetStorageStatisticsFastBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetStorageStatisticsFast> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetStorageStatisticsFastBuilder { instance: GetStorageStatisticsFast }

impl RTDGetStorageStatisticsFastBuilder {
  fn new(instance: GetStorageStatisticsFast) -> Self { Self { instance } }

  pub fn build(&self) -> GetStorageStatisticsFast { self.instance.clone() }
  
}



/// Returns information about a supergroup or channel by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroup
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  
}



impl Object for GetSupergroup {}
impl RObject for GetSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSupergroup {}


impl GetSupergroup {
  
  pub fn builder() -> RTDGetSupergroupBuilder {
    let instance = Self {
      td_name: "getSupergroup".to_string(),
      supergroup_id: None,
      
    };
    RTDGetSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSupergroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSupergroupBuilder { instance: GetSupergroup }

impl RTDGetSupergroupBuilder {
  fn new(instance: GetSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroup { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}



/// Returns full information about a supergroup or channel by its identifier, cached for up to 1 minute.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroupFullInfo
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  
}



impl Object for GetSupergroupFullInfo {}
impl RObject for GetSupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroupFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSupergroupFullInfo {}


impl GetSupergroupFullInfo {
  
  pub fn builder() -> RTDGetSupergroupFullInfoBuilder {
    let instance = Self {
      td_name: "getSupergroupFullInfo".to_string(),
      supergroup_id: None,
      
    };
    RTDGetSupergroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSupergroupFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSupergroupFullInfoBuilder { instance: GetSupergroupFullInfo }

impl RTDGetSupergroupFullInfoBuilder {
  fn new(instance: GetSupergroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroupFullInfo { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}



/// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetSupergroupMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroupMembers
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// The type of users to return. By default, supergroupMembersRecent.
  filter: Option<Box<SupergroupMembersFilter>>,
  /// Number of users to skip.
  offset: Option<i32>,
  /// The maximum number of users be returned; up to 200.
  limit: Option<i32>,
  
}


impl Clone for GetSupergroupMembers {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetSupergroupMembers {}
impl RObject for GetSupergroupMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroupMembers" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroupMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSupergroupMembers {}


impl GetSupergroupMembers {
  
  pub fn builder() -> RTDGetSupergroupMembersBuilder {
    let instance = Self {
      td_name: "getSupergroupMembers".to_string(),
      supergroup_id: None,
      filter: None,
      offset: None,
      limit: None,
      
    };
    RTDGetSupergroupMembersBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn filter(&self) -> Option<Box<SupergroupMembersFilter>> { self.filter.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSupergroupMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSupergroupMembersBuilder { instance: GetSupergroupMembers }

impl RTDGetSupergroupMembersBuilder {
  fn new(instance: GetSupergroupMembers) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroupMembers { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SupergroupMembersFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns a user that can be contacted to get support.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupportUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupportUser
  
}



impl Object for GetSupportUser {}
impl RObject for GetSupportUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupportUser" }
  fn td_type(&self) -> RTDType { RTDType::GetSupportUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetSupportUser {}


impl GetSupportUser {
  
  pub fn builder() -> RTDGetSupportUserBuilder {
    let instance = Self {
      td_name: "getSupportUser".to_string(),
      
    };
    RTDGetSupportUserBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetSupportUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetSupportUserBuilder { instance: GetSupportUser }

impl RTDGetSupportUserBuilder {
  fn new(instance: GetSupportUser) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupportUser { self.instance.clone() }
  
}



/// Returns information about the current temporary password.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTemporaryPasswordState
  
}



impl Object for GetTemporaryPasswordState {}
impl RObject for GetTemporaryPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTemporaryPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::GetTemporaryPasswordState }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetTemporaryPasswordState {}


impl GetTemporaryPasswordState {
  
  pub fn builder() -> RTDGetTemporaryPasswordStateBuilder {
    let instance = Self {
      td_name: "getTemporaryPasswordState".to_string(),
      
    };
    RTDGetTemporaryPasswordStateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetTemporaryPasswordState> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetTemporaryPasswordStateBuilder { instance: GetTemporaryPasswordState }

impl RTDGetTemporaryPasswordStateBuilder {
  fn new(instance: GetTemporaryPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> GetTemporaryPasswordState { self.instance.clone() }
  
}



/// Returns all entities (mentions, hashtags, cashtags, bot commands, URLs, and email addresses) contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTextEntities
  /// The text in which to look for entites.
  text: Option<String>,
  
}



impl Object for GetTextEntities {}
impl RObject for GetTextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTextEntities" }
  fn td_type(&self) -> RTDType { RTDType::GetTextEntities }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetTextEntities {}


impl GetTextEntities {
  
  pub fn builder() -> RTDGetTextEntitiesBuilder {
    let instance = Self {
      td_name: "getTextEntities".to_string(),
      text: None,
      
    };
    RTDGetTextEntitiesBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetTextEntities> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetTextEntitiesBuilder { instance: GetTextEntities }

impl RTDGetTextEntitiesBuilder {
  fn new(instance: GetTextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> GetTextEntities { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
}



/// Returns a list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetTopChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTopChats
  /// Category of chats to be returned.
  category: Option<Box<TopChatCategory>>,
  /// Maximum number of chats to be returned; up to 30.
  limit: Option<i32>,
  
}


impl Clone for GetTopChats {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetTopChats {}
impl RObject for GetTopChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTopChats" }
  fn td_type(&self) -> RTDType { RTDType::GetTopChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetTopChats {}


impl GetTopChats {
  
  pub fn builder() -> RTDGetTopChatsBuilder {
    let instance = Self {
      td_name: "getTopChats".to_string(),
      category: None,
      limit: None,
      
    };
    RTDGetTopChatsBuilder::new(instance)
  }
  
  
  pub fn category(&self) -> Option<Box<TopChatCategory>> { self.category.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetTopChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetTopChatsBuilder { instance: GetTopChats }

impl RTDGetTopChatsBuilder {
  fn new(instance: GetTopChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetTopChats { self.instance.clone() }
  
  pub fn category(&mut self, category: Box<TopChatCategory>) -> &mut Self {
    self.instance.category = Some(category);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns a list of trending sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTrendingStickerSets
  
}



impl Object for GetTrendingStickerSets {}
impl RObject for GetTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetTrendingStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetTrendingStickerSets {}


impl GetTrendingStickerSets {
  
  pub fn builder() -> RTDGetTrendingStickerSetsBuilder {
    let instance = Self {
      td_name: "getTrendingStickerSets".to_string(),
      
    };
    RTDGetTrendingStickerSetsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetTrendingStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetTrendingStickerSetsBuilder { instance: GetTrendingStickerSets }

impl RTDGetTrendingStickerSetsBuilder {
  fn new(instance: GetTrendingStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetTrendingStickerSets { self.instance.clone() }
  
}



/// Returns information about a user by their identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetUser {}
impl RObject for GetUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUser" }
  fn td_type(&self) -> RTDType { RTDType::GetUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetUser {}


impl GetUser {
  
  pub fn builder() -> RTDGetUserBuilder {
    let instance = Self {
      td_name: "getUser".to_string(),
      user_id: None,
      
    };
    RTDGetUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetUserBuilder { instance: GetUser }

impl RTDGetUserBuilder {
  fn new(instance: GetUser) -> Self { Self { instance } }

  pub fn build(&self) -> GetUser { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Returns full information about a user by their identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserFullInfo
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetUserFullInfo {}
impl RObject for GetUserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetUserFullInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetUserFullInfo {}


impl GetUserFullInfo {
  
  pub fn builder() -> RTDGetUserFullInfoBuilder {
    let instance = Self {
      td_name: "getUserFullInfo".to_string(),
      user_id: None,
      
    };
    RTDGetUserFullInfoBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetUserFullInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetUserFullInfoBuilder { instance: GetUserFullInfo }

impl RTDGetUserFullInfoBuilder {
  fn new(instance: GetUserFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserFullInfo { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Returns the current privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  
}


impl Clone for GetUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for GetUserPrivacySettingRules {}
impl RObject for GetUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::GetUserPrivacySettingRules }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetUserPrivacySettingRules {}


impl GetUserPrivacySettingRules {
  
  pub fn builder() -> RTDGetUserPrivacySettingRulesBuilder {
    let instance = Self {
      td_name: "getUserPrivacySettingRules".to_string(),
      setting: None,
      
    };
    RTDGetUserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetUserPrivacySettingRules> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetUserPrivacySettingRulesBuilder { instance: GetUserPrivacySettingRules }

impl RTDGetUserPrivacySettingRulesBuilder {
  fn new(instance: GetUserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserPrivacySettingRules { self.instance.clone() }
  
  pub fn setting(&mut self, setting: Box<UserPrivacySetting>) -> &mut Self {
    self.instance.setting = Some(setting);
    self
  }
  
}



/// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserProfilePhotos
  /// User identifier.
  user_id: Option<i32>,
  /// The number of photos to skip; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of photos to be returned; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetUserProfilePhotos {}
impl RObject for GetUserProfilePhotos {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserProfilePhotos" }
  fn td_type(&self) -> RTDType { RTDType::GetUserProfilePhotos }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetUserProfilePhotos {}


impl GetUserProfilePhotos {
  
  pub fn builder() -> RTDGetUserProfilePhotosBuilder {
    let instance = Self {
      td_name: "getUserProfilePhotos".to_string(),
      user_id: None,
      offset: None,
      limit: None,
      
    };
    RTDGetUserProfilePhotosBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetUserProfilePhotos> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetUserProfilePhotosBuilder { instance: GetUserProfilePhotos }

impl RTDGetUserProfilePhotosBuilder {
  fn new(instance: GetUserProfilePhotos) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserProfilePhotos { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Returns background wallpapers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWallpapers
  
}



impl Object for GetWallpapers {}
impl RObject for GetWallpapers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWallpapers" }
  fn td_type(&self) -> RTDType { RTDType::GetWallpapers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetWallpapers {}


impl GetWallpapers {
  
  pub fn builder() -> RTDGetWallpapersBuilder {
    let instance = Self {
      td_name: "getWallpapers".to_string(),
      
    };
    RTDGetWallpapersBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetWallpapers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetWallpapersBuilder { instance: GetWallpapers }

impl RTDGetWallpapersBuilder {
  fn new(instance: GetWallpapers) -> Self { Self { instance } }

  pub fn build(&self) -> GetWallpapers { self.instance.clone() }
  
}



/// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWebPageInstantView
  /// The web page URL.
  url: Option<String>,
  /// If true, the full instant view for the web page will be returned.
  force_full: Option<bool>,
  
}



impl Object for GetWebPageInstantView {}
impl RObject for GetWebPageInstantView {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWebPageInstantView" }
  fn td_type(&self) -> RTDType { RTDType::GetWebPageInstantView }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetWebPageInstantView {}


impl GetWebPageInstantView {
  
  pub fn builder() -> RTDGetWebPageInstantViewBuilder {
    let instance = Self {
      td_name: "getWebPageInstantView".to_string(),
      url: None,
      force_full: None,
      
    };
    RTDGetWebPageInstantViewBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn force_full(&self) -> Option<bool> { self.force_full.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetWebPageInstantView> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetWebPageInstantViewBuilder { instance: GetWebPageInstantView }

impl RTDGetWebPageInstantViewBuilder {
  fn new(instance: GetWebPageInstantView) -> Self { Self { instance } }

  pub fn build(&self) -> GetWebPageInstantView { self.instance.clone() }
  
  pub fn url<S: AsRef<str>>(&mut self, url: S) -> &mut Self {
    self.instance.url = Some(url.as_ref().to_string());
    self
  }
  
  pub fn force_full(&mut self, force_full: bool) -> &mut Self {
    self.instance.force_full = Some(force_full);
    self
  }
  
}



/// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPagePreview {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWebPagePreview
  /// Message text with formatting.
  text: Option<FormattedText>,
  
}



impl Object for GetWebPagePreview {}
impl RObject for GetWebPagePreview {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWebPagePreview" }
  fn td_type(&self) -> RTDType { RTDType::GetWebPagePreview }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for GetWebPagePreview {}


impl GetWebPagePreview {
  
  pub fn builder() -> RTDGetWebPagePreviewBuilder {
    let instance = Self {
      td_name: "getWebPagePreview".to_string(),
      text: None,
      
    };
    RTDGetWebPagePreviewBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<GetWebPagePreview> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDGetWebPagePreviewBuilder { instance: GetWebPagePreview }

impl RTDGetWebPagePreviewBuilder {
  fn new(instance: GetWebPagePreview) -> Self { Self { instance } }

  pub fn build(&self) -> GetWebPagePreview { self.instance.clone() }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}



/// Adds new contacts or edits existing contacts; contacts' user identifiers are ignored.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // importContacts
  /// The list of contacts to import or edit, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,
  
}



impl Object for ImportContacts {}
impl RObject for ImportContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "importContacts" }
  fn td_type(&self) -> RTDType { RTDType::ImportContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ImportContacts {}


impl ImportContacts {
  
  pub fn builder() -> RTDImportContactsBuilder {
    let instance = Self {
      td_name: "importContacts".to_string(),
      contacts: None,
      
    };
    RTDImportContactsBuilder::new(instance)
  }
  
  
  pub fn contacts(&self) -> Option<Vec<Contact>> { self.contacts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ImportContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDImportContactsBuilder { instance: ImportContacts }

impl RTDImportContactsBuilder {
  fn new(instance: ImportContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ImportContacts { self.instance.clone() }
  
  pub fn contacts(&mut self, contacts: Vec<Contact>) -> &mut Self {
    self.instance.contacts = Some(contacts);
    self
  }
  
}



/// Adds current user as a new member to a chat. Private and secret chats can't be joined using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // joinChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for JoinChat {}
impl RObject for JoinChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "joinChat" }
  fn td_type(&self) -> RTDType { RTDType::JoinChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for JoinChat {}


impl JoinChat {
  
  pub fn builder() -> RTDJoinChatBuilder {
    let instance = Self {
      td_name: "joinChat".to_string(),
      chat_id: None,
      
    };
    RTDJoinChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<JoinChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDJoinChatBuilder { instance: JoinChat }

impl RTDJoinChatBuilder {
  fn new(instance: JoinChat) -> Self { Self { instance } }

  pub fn build(&self) -> JoinChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChatByInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // joinChatByInviteLink
  /// Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,
  
}



impl Object for JoinChatByInviteLink {}
impl RObject for JoinChatByInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "joinChatByInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::JoinChatByInviteLink }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for JoinChatByInviteLink {}


impl JoinChatByInviteLink {
  
  pub fn builder() -> RTDJoinChatByInviteLinkBuilder {
    let instance = Self {
      td_name: "joinChatByInviteLink".to_string(),
      invite_link: None,
      
    };
    RTDJoinChatByInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<JoinChatByInviteLink> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDJoinChatByInviteLinkBuilder { instance: JoinChatByInviteLink }

impl RTDJoinChatByInviteLinkBuilder {
  fn new(instance: JoinChatByInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> JoinChatByInviteLink { self.instance.clone() }
  
  pub fn invite_link<S: AsRef<str>>(&mut self, invite_link: S) -> &mut Self {
    self.instance.invite_link = Some(invite_link.as_ref().to_string());
    self
  }
  
}



/// Removes current user from chat members. Private and secret chats can't be left using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LeaveChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // leaveChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for LeaveChat {}
impl RObject for LeaveChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "leaveChat" }
  fn td_type(&self) -> RTDType { RTDType::LeaveChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for LeaveChat {}


impl LeaveChat {
  
  pub fn builder() -> RTDLeaveChatBuilder {
    let instance = Self {
      td_name: "leaveChat".to_string(),
      chat_id: None,
      
    };
    RTDLeaveChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LeaveChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLeaveChatBuilder { instance: LeaveChat }

impl RTDLeaveChatBuilder {
  fn new(instance: LeaveChat) -> Self { Self { instance } }

  pub fn build(&self) -> LeaveChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logOut
  
}



impl Object for LogOut {}
impl RObject for LogOut {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logOut" }
  fn td_type(&self) -> RTDType { RTDType::LogOut }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for LogOut {}


impl LogOut {
  
  pub fn builder() -> RTDLogOutBuilder {
    let instance = Self {
      td_name: "logOut".to_string(),
      
    };
    RTDLogOutBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<LogOut> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDLogOutBuilder { instance: LogOut }

impl RTDLogOutBuilder {
  fn new(instance: LogOut) -> Self { Self { instance } }

  pub fn build(&self) -> LogOut { self.instance.clone() }
  
}



/// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // openChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for OpenChat {}
impl RObject for OpenChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "openChat" }
  fn td_type(&self) -> RTDType { RTDType::OpenChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for OpenChat {}


impl OpenChat {
  
  pub fn builder() -> RTDOpenChatBuilder {
    let instance = Self {
      td_name: "openChat".to_string(),
      chat_id: None,
      
    };
    RTDOpenChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OpenChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOpenChatBuilder { instance: OpenChat }

impl RTDOpenChatBuilder {
  fn new(instance: OpenChat) -> Self { Self { instance } }

  pub fn build(&self) -> OpenChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // openMessageContent
  /// Chat identifier of the message.
  chat_id: Option<i64>,
  /// Identifier of the message with the opened content.
  message_id: Option<i64>,
  
}



impl Object for OpenMessageContent {}
impl RObject for OpenMessageContent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "openMessageContent" }
  fn td_type(&self) -> RTDType { RTDType::OpenMessageContent }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for OpenMessageContent {}


impl OpenMessageContent {
  
  pub fn builder() -> RTDOpenMessageContentBuilder {
    let instance = Self {
      td_name: "openMessageContent".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    RTDOpenMessageContentBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OpenMessageContent> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOpenMessageContentBuilder { instance: OpenMessageContent }

impl RTDOpenMessageContentBuilder {
  fn new(instance: OpenMessageContent) -> Self { Self { instance } }

  pub fn build(&self) -> OpenMessageContent { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}



/// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted.
#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizeStorage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optimizeStorage
  /// Limit on the total size of files after deletion. Pass -1 to use the default limit.
  size: Option<i64>,
  /// Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit.
  ttl: Option<i32>,
  /// Limit on the total count of files after deletion. Pass -1 to use the default limit.
  count: Option<i32>,
  /// The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value.
  immunity_delay: Option<i32>,
  /// If not empty, only files with the given type(s) are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted.
  file_types: Option<Vec<Box<FileType>>>,
  /// If not empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos).
  chat_ids: Option<Vec<i64>>,
  /// If not empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos).
  exclude_chat_ids: Option<Vec<i64>>,
  /// Same as in getStorageStatistics. Affects only returned statistics.
  chat_limit: Option<i32>,
  
}


impl Clone for OptimizeStorage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for OptimizeStorage {}
impl RObject for OptimizeStorage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optimizeStorage" }
  fn td_type(&self) -> RTDType { RTDType::OptimizeStorage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for OptimizeStorage {}


impl OptimizeStorage {
  
  pub fn builder() -> RTDOptimizeStorageBuilder {
    let instance = Self {
      td_name: "optimizeStorage".to_string(),
      size: None,
      ttl: None,
      count: None,
      immunity_delay: None,
      file_types: None,
      chat_ids: None,
      exclude_chat_ids: None,
      chat_limit: None,
      
    };
    RTDOptimizeStorageBuilder::new(instance)
  }
  
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn immunity_delay(&self) -> Option<i32> { self.immunity_delay.clone() }
  
  pub fn file_types(&self) -> Option<Vec<Box<FileType>>> { self.file_types.clone() }
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn exclude_chat_ids(&self) -> Option<Vec<i64>> { self.exclude_chat_ids.clone() }
  
  pub fn chat_limit(&self) -> Option<i32> { self.chat_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<OptimizeStorage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDOptimizeStorageBuilder { instance: OptimizeStorage }

impl RTDOptimizeStorageBuilder {
  fn new(instance: OptimizeStorage) -> Self { Self { instance } }

  pub fn build(&self) -> OptimizeStorage { self.instance.clone() }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn immunity_delay(&mut self, immunity_delay: i32) -> &mut Self {
    self.instance.immunity_delay = Some(immunity_delay);
    self
  }
  
  pub fn file_types(&mut self, file_types: Vec<Box<FileType>>) -> &mut Self {
    self.instance.file_types = Some(file_types);
    self
  }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
  pub fn exclude_chat_ids(&mut self, exclude_chat_ids: Vec<i64>) -> &mut Self {
    self.instance.exclude_chat_ids = Some(exclude_chat_ids);
    self
  }
  
  pub fn chat_limit(&mut self, chat_limit: i32) -> &mut Self {
    self.instance.chat_limit = Some(chat_limit);
    self
  }
  
}



/// Parses Bold, Italic, Code, Pre, PreCode and TextUrl entities contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct ParseTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // parseTextEntities
  /// The text which should be parsed.
  text: Option<String>,
  /// Text parse mode.
  parse_mode: Option<Box<TextParseMode>>,
  
}


impl Clone for ParseTextEntities {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ParseTextEntities {}
impl RObject for ParseTextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "parseTextEntities" }
  fn td_type(&self) -> RTDType { RTDType::ParseTextEntities }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ParseTextEntities {}


impl ParseTextEntities {
  
  pub fn builder() -> RTDParseTextEntitiesBuilder {
    let instance = Self {
      td_name: "parseTextEntities".to_string(),
      text: None,
      parse_mode: None,
      
    };
    RTDParseTextEntitiesBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn parse_mode(&self) -> Option<Box<TextParseMode>> { self.parse_mode.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ParseTextEntities> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDParseTextEntitiesBuilder { instance: ParseTextEntities }

impl RTDParseTextEntitiesBuilder {
  fn new(instance: ParseTextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> ParseTextEntities { self.instance.clone() }
  
  pub fn text<S: AsRef<str>>(&mut self, text: S) -> &mut Self {
    self.instance.text = Some(text.as_ref().to_string());
    self
  }
  
  pub fn parse_mode(&mut self, parse_mode: Box<TextParseMode>) -> &mut Self {
    self.instance.parse_mode = Some(parse_mode);
    self
  }
  
}



/// Pins a message in a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pinChatMessage
  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// Identifier of the new pinned message.
  message_id: Option<i64>,
  /// True, if there should be no notification about the pinned message.
  disable_notification: Option<bool>,
  
}



impl Object for PinChatMessage {}
impl RObject for PinChatMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pinChatMessage" }
  fn td_type(&self) -> RTDType { RTDType::PinChatMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for PinChatMessage {}


impl PinChatMessage {
  
  pub fn builder() -> RTDPinChatMessageBuilder {
    let instance = Self {
      td_name: "pinChatMessage".to_string(),
      chat_id: None,
      message_id: None,
      disable_notification: None,
      
    };
    RTDPinChatMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PinChatMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPinChatMessageBuilder { instance: PinChatMessage }

impl RTDPinChatMessageBuilder {
  fn new(instance: PinChatMessage) -> Self { Self { instance } }

  pub fn build(&self) -> PinChatMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
}



/// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PingProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pingProxy
  /// Proxy identifier. Use 0 to ping a Telegram server without a proxy.
  proxy_id: Option<i32>,
  
}



impl Object for PingProxy {}
impl RObject for PingProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pingProxy" }
  fn td_type(&self) -> RTDType { RTDType::PingProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for PingProxy {}


impl PingProxy {
  
  pub fn builder() -> RTDPingProxyBuilder {
    let instance = Self {
      td_name: "pingProxy".to_string(),
      proxy_id: None,
      
    };
    RTDPingProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<PingProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDPingProxyBuilder { instance: PingProxy }

impl RTDPingProxyBuilder {
  fn new(instance: PingProxy) -> Self { Self { instance } }

  pub fn build(&self) -> PingProxy { self.instance.clone() }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}



/// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessPushNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // processPushNotification
  /// JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added.
  payload: Option<String>,
  
}



impl Object for ProcessPushNotification {}
impl RObject for ProcessPushNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "processPushNotification" }
  fn td_type(&self) -> RTDType { RTDType::ProcessPushNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ProcessPushNotification {}


impl ProcessPushNotification {
  
  pub fn builder() -> RTDProcessPushNotificationBuilder {
    let instance = Self {
      td_name: "processPushNotification".to_string(),
      payload: None,
      
    };
    RTDProcessPushNotificationBuilder::new(instance)
  }
  
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ProcessPushNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDProcessPushNotificationBuilder { instance: ProcessPushNotification }

impl RTDProcessPushNotificationBuilder {
  fn new(instance: ProcessPushNotification) -> Self { Self { instance } }

  pub fn build(&self) -> ProcessPushNotification { self.instance.clone() }
  
  pub fn payload<S: AsRef<str>>(&mut self, payload: S) -> &mut Self {
    self.instance.payload = Some(payload.as_ref().to_string());
    self
  }
  
}



/// Marks all mentions in a chat as read.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadAllChatMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // readAllChatMentions
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for ReadAllChatMentions {}
impl RObject for ReadAllChatMentions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "readAllChatMentions" }
  fn td_type(&self) -> RTDType { RTDType::ReadAllChatMentions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ReadAllChatMentions {}


impl ReadAllChatMentions {
  
  pub fn builder() -> RTDReadAllChatMentionsBuilder {
    let instance = Self {
      td_name: "readAllChatMentions".to_string(),
      chat_id: None,
      
    };
    RTDReadAllChatMentionsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReadAllChatMentions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReadAllChatMentionsBuilder { instance: ReadAllChatMentions }

impl RTDReadAllChatMentionsBuilder {
  fn new(instance: ReadAllChatMentions) -> Self { Self { instance } }

  pub fn build(&self) -> ReadAllChatMentions { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct read from the file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // readFilePart
  /// Identifier of the file. The file must be located in the TDLib file cache.
  file_id: Option<i32>,
  /// The offset from which to read the file.
  offset: Option<i32>,
  /// Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position.
  count: Option<i32>,
  
}



impl Object for ReadFilePart {}
impl RObject for ReadFilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "readFilePart" }
  fn td_type(&self) -> RTDType { RTDType::ReadFilePart }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ReadFilePart {}


impl ReadFilePart {
  
  pub fn builder() -> RTDReadFilePartBuilder {
    let instance = Self {
      td_name: "readFilePart".to_string(),
      file_id: None,
      offset: None,
      count: None,
      
    };
    RTDReadFilePartBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReadFilePart> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReadFilePartBuilder { instance: ReadFilePart }

impl RTDReadFilePartBuilder {
  fn new(instance: ReadFilePart) -> Self { Self { instance } }

  pub fn build(&self) -> ReadFilePart { self.instance.clone() }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}



/// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoverAuthenticationPassword
  /// Recovery code to check.
  recovery_code: Option<String>,
  
}



impl Object for RecoverAuthenticationPassword {}
impl RObject for RecoverAuthenticationPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoverAuthenticationPassword" }
  fn td_type(&self) -> RTDType { RTDType::RecoverAuthenticationPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RecoverAuthenticationPassword {}


impl RecoverAuthenticationPassword {
  
  pub fn builder() -> RTDRecoverAuthenticationPasswordBuilder {
    let instance = Self {
      td_name: "recoverAuthenticationPassword".to_string(),
      recovery_code: None,
      
    };
    RTDRecoverAuthenticationPasswordBuilder::new(instance)
  }
  
  
  pub fn recovery_code(&self) -> Option<String> { self.recovery_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RecoverAuthenticationPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRecoverAuthenticationPasswordBuilder { instance: RecoverAuthenticationPassword }

impl RTDRecoverAuthenticationPasswordBuilder {
  fn new(instance: RecoverAuthenticationPassword) -> Self { Self { instance } }

  pub fn build(&self) -> RecoverAuthenticationPassword { self.instance.clone() }
  
  pub fn recovery_code<S: AsRef<str>>(&mut self, recovery_code: S) -> &mut Self {
    self.instance.recovery_code = Some(recovery_code.as_ref().to_string());
    self
  }
  
}



/// Recovers the password using a recovery code sent to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoverPassword
  /// Recovery code to check.
  recovery_code: Option<String>,
  
}



impl Object for RecoverPassword {}
impl RObject for RecoverPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoverPassword" }
  fn td_type(&self) -> RTDType { RTDType::RecoverPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RecoverPassword {}


impl RecoverPassword {
  
  pub fn builder() -> RTDRecoverPasswordBuilder {
    let instance = Self {
      td_name: "recoverPassword".to_string(),
      recovery_code: None,
      
    };
    RTDRecoverPasswordBuilder::new(instance)
  }
  
  
  pub fn recovery_code(&self) -> Option<String> { self.recovery_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RecoverPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRecoverPasswordBuilder { instance: RecoverPassword }

impl RTDRecoverPasswordBuilder {
  fn new(instance: RecoverPassword) -> Self { Self { instance } }

  pub fn build(&self) -> RecoverPassword { self.instance.clone() }
  
  pub fn recovery_code<S: AsRef<str>>(&mut self, recovery_code: S) -> &mut Self {
    self.instance.recovery_code = Some(recovery_code.as_ref().to_string());
    self
  }
  
}



/// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription.
#[derive(Debug, Serialize, Deserialize)]
pub struct RegisterDevice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // registerDevice
  /// Device token.
  device_token: Option<Box<DeviceToken>>,
  /// List of user identifiers of other users currently using the client.
  other_user_ids: Option<Vec<i32>>,
  
}


impl Clone for RegisterDevice {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RegisterDevice {}
impl RObject for RegisterDevice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "registerDevice" }
  fn td_type(&self) -> RTDType { RTDType::RegisterDevice }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RegisterDevice {}


impl RegisterDevice {
  
  pub fn builder() -> RTDRegisterDeviceBuilder {
    let instance = Self {
      td_name: "registerDevice".to_string(),
      device_token: None,
      other_user_ids: None,
      
    };
    RTDRegisterDeviceBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> Option<Box<DeviceToken>> { self.device_token.clone() }
  
  pub fn other_user_ids(&self) -> Option<Vec<i32>> { self.other_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RegisterDevice> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRegisterDeviceBuilder { instance: RegisterDevice }

impl RTDRegisterDeviceBuilder {
  fn new(instance: RegisterDevice) -> Self { Self { instance } }

  pub fn build(&self) -> RegisterDevice { self.instance.clone() }
  
  pub fn device_token(&mut self, device_token: Box<DeviceToken>) -> &mut Self {
    self.instance.device_token = Some(device_token);
    self
  }
  
  pub fn other_user_ids(&mut self, other_user_ids: Vec<i32>) -> &mut Self {
    self.instance.other_user_ids = Some(other_user_ids);
    self
  }
  
}



/// Removes users from the contact list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeContacts
  /// Identifiers of users to be deleted.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for RemoveContacts {}
impl RObject for RemoveContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeContacts" }
  fn td_type(&self) -> RTDType { RTDType::RemoveContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveContacts {}


impl RemoveContacts {
  
  pub fn builder() -> RTDRemoveContactsBuilder {
    let instance = Self {
      td_name: "removeContacts".to_string(),
      user_ids: None,
      
    };
    RTDRemoveContactsBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveContactsBuilder { instance: RemoveContacts }

impl RTDRemoveContactsBuilder {
  fn new(instance: RemoveContacts) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveContacts { self.instance.clone() }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}



/// Removes a sticker from the list of favorite stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeFavoriteSticker
  /// Sticker file to delete from the list.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveFavoriteSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RemoveFavoriteSticker {}
impl RObject for RemoveFavoriteSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeFavoriteSticker" }
  fn td_type(&self) -> RTDType { RTDType::RemoveFavoriteSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveFavoriteSticker {}


impl RemoveFavoriteSticker {
  
  pub fn builder() -> RTDRemoveFavoriteStickerBuilder {
    let instance = Self {
      td_name: "removeFavoriteSticker".to_string(),
      sticker: None,
      
    };
    RTDRemoveFavoriteStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveFavoriteSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveFavoriteStickerBuilder { instance: RemoveFavoriteSticker }

impl RTDRemoveFavoriteStickerBuilder {
  fn new(instance: RemoveFavoriteSticker) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveFavoriteSticker { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeNotification
  /// Identifier of notification group to which the notification belongs.
  notification_group_id: Option<i32>,
  /// Identifier of removed notification.
  notification_id: Option<i32>,
  
}



impl Object for RemoveNotification {}
impl RObject for RemoveNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeNotification" }
  fn td_type(&self) -> RTDType { RTDType::RemoveNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveNotification {}


impl RemoveNotification {
  
  pub fn builder() -> RTDRemoveNotificationBuilder {
    let instance = Self {
      td_name: "removeNotification".to_string(),
      notification_group_id: None,
      notification_id: None,
      
    };
    RTDRemoveNotificationBuilder::new(instance)
  }
  
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn notification_id(&self) -> Option<i32> { self.notification_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveNotificationBuilder { instance: RemoveNotification }

impl RTDRemoveNotificationBuilder {
  fn new(instance: RemoveNotification) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveNotification { self.instance.clone() }
  
  pub fn notification_group_id(&mut self, notification_group_id: i32) -> &mut Self {
    self.instance.notification_group_id = Some(notification_group_id);
    self
  }
  
  pub fn notification_id(&mut self, notification_id: i32) -> &mut Self {
    self.instance.notification_id = Some(notification_id);
    self
  }
  
}



/// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeNotificationGroup
  /// Notification group identifier.
  notification_group_id: Option<i32>,
  /// Maximum identifier of removed notifications.
  max_notification_id: Option<i32>,
  
}



impl Object for RemoveNotificationGroup {}
impl RObject for RemoveNotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeNotificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::RemoveNotificationGroup }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveNotificationGroup {}


impl RemoveNotificationGroup {
  
  pub fn builder() -> RTDRemoveNotificationGroupBuilder {
    let instance = Self {
      td_name: "removeNotificationGroup".to_string(),
      notification_group_id: None,
      max_notification_id: None,
      
    };
    RTDRemoveNotificationGroupBuilder::new(instance)
  }
  
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn max_notification_id(&self) -> Option<i32> { self.max_notification_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveNotificationGroup> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveNotificationGroupBuilder { instance: RemoveNotificationGroup }

impl RTDRemoveNotificationGroupBuilder {
  fn new(instance: RemoveNotificationGroup) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveNotificationGroup { self.instance.clone() }
  
  pub fn notification_group_id(&mut self, notification_group_id: i32) -> &mut Self {
    self.instance.notification_group_id = Some(notification_group_id);
    self
  }
  
  pub fn max_notification_id(&mut self, max_notification_id: i32) -> &mut Self {
    self.instance.max_notification_id = Some(max_notification_id);
    self
  }
  
}



/// Removes a proxy server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for RemoveProxy {}
impl RObject for RemoveProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeProxy" }
  fn td_type(&self) -> RTDType { RTDType::RemoveProxy }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveProxy {}


impl RemoveProxy {
  
  pub fn builder() -> RTDRemoveProxyBuilder {
    let instance = Self {
      td_name: "removeProxy".to_string(),
      proxy_id: None,
      
    };
    RTDRemoveProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveProxy> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveProxyBuilder { instance: RemoveProxy }

impl RTDRemoveProxyBuilder {
  fn new(instance: RemoveProxy) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveProxy { self.instance.clone() }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}



/// Removes a hashtag from the list of recently used hashtags.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentHashtag
  /// Hashtag to delete.
  hashtag: Option<String>,
  
}



impl Object for RemoveRecentHashtag {}
impl RObject for RemoveRecentHashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentHashtag" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentHashtag }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveRecentHashtag {}


impl RemoveRecentHashtag {
  
  pub fn builder() -> RTDRemoveRecentHashtagBuilder {
    let instance = Self {
      td_name: "removeRecentHashtag".to_string(),
      hashtag: None,
      
    };
    RTDRemoveRecentHashtagBuilder::new(instance)
  }
  
  
  pub fn hashtag(&self) -> Option<String> { self.hashtag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveRecentHashtag> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveRecentHashtagBuilder { instance: RemoveRecentHashtag }

impl RTDRemoveRecentHashtagBuilder {
  fn new(instance: RemoveRecentHashtag) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentHashtag { self.instance.clone() }
  
  pub fn hashtag<S: AsRef<str>>(&mut self, hashtag: S) -> &mut Self {
    self.instance.hashtag = Some(hashtag.as_ref().to_string());
    self
  }
  
}



/// Removes a sticker from the list of recently used stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentSticker
  /// Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to delete.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveRecentSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RemoveRecentSticker {}
impl RObject for RemoveRecentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentSticker" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentSticker }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveRecentSticker {}


impl RemoveRecentSticker {
  
  pub fn builder() -> RTDRemoveRecentStickerBuilder {
    let instance = Self {
      td_name: "removeRecentSticker".to_string(),
      is_attached: None,
      sticker: None,
      
    };
    RTDRemoveRecentStickerBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveRecentSticker> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveRecentStickerBuilder { instance: RemoveRecentSticker }

impl RTDRemoveRecentStickerBuilder {
  fn new(instance: RemoveRecentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentSticker { self.instance.clone() }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Removes a chat from the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentlyFoundChat
  /// Identifier of the chat to be removed.
  chat_id: Option<i64>,
  
}



impl Object for RemoveRecentlyFoundChat {}
impl RObject for RemoveRecentlyFoundChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentlyFoundChat" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentlyFoundChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveRecentlyFoundChat {}


impl RemoveRecentlyFoundChat {
  
  pub fn builder() -> RTDRemoveRecentlyFoundChatBuilder {
    let instance = Self {
      td_name: "removeRecentlyFoundChat".to_string(),
      chat_id: None,
      
    };
    RTDRemoveRecentlyFoundChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveRecentlyFoundChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveRecentlyFoundChatBuilder { instance: RemoveRecentlyFoundChat }

impl RTDRemoveRecentlyFoundChatBuilder {
  fn new(instance: RemoveRecentlyFoundChat) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentlyFoundChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Removes an animation from the list of saved animations.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeSavedAnimation
  /// Animation file to be removed.
  animation: Option<Box<InputFile>>,
  
}


impl Clone for RemoveSavedAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RemoveSavedAnimation {}
impl RObject for RemoveSavedAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeSavedAnimation" }
  fn td_type(&self) -> RTDType { RTDType::RemoveSavedAnimation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveSavedAnimation {}


impl RemoveSavedAnimation {
  
  pub fn builder() -> RTDRemoveSavedAnimationBuilder {
    let instance = Self {
      td_name: "removeSavedAnimation".to_string(),
      animation: None,
      
    };
    RTDRemoveSavedAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveSavedAnimation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveSavedAnimationBuilder { instance: RemoveSavedAnimation }

impl RTDRemoveSavedAnimationBuilder {
  fn new(instance: RemoveSavedAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveSavedAnimation { self.instance.clone() }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}



/// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveStickerFromSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeStickerFromSet
  /// Sticker.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveStickerFromSet {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RemoveStickerFromSet {}
impl RObject for RemoveStickerFromSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeStickerFromSet" }
  fn td_type(&self) -> RTDType { RTDType::RemoveStickerFromSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveStickerFromSet {}


impl RemoveStickerFromSet {
  
  pub fn builder() -> RTDRemoveStickerFromSetBuilder {
    let instance = Self {
      td_name: "removeStickerFromSet".to_string(),
      sticker: None,
      
    };
    RTDRemoveStickerFromSetBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveStickerFromSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveStickerFromSetBuilder { instance: RemoveStickerFromSet }

impl RTDRemoveStickerFromSetBuilder {
  fn new(instance: RemoveStickerFromSet) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveStickerFromSet { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}



/// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveTopChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeTopChat
  /// Category of frequently used chats.
  category: Option<Box<TopChatCategory>>,
  /// Chat identifier.
  chat_id: Option<i64>,
  
}


impl Clone for RemoveTopChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for RemoveTopChat {}
impl RObject for RemoveTopChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeTopChat" }
  fn td_type(&self) -> RTDType { RTDType::RemoveTopChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RemoveTopChat {}


impl RemoveTopChat {
  
  pub fn builder() -> RTDRemoveTopChatBuilder {
    let instance = Self {
      td_name: "removeTopChat".to_string(),
      category: None,
      chat_id: None,
      
    };
    RTDRemoveTopChatBuilder::new(instance)
  }
  
  
  pub fn category(&self) -> Option<Box<TopChatCategory>> { self.category.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RemoveTopChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRemoveTopChatBuilder { instance: RemoveTopChat }

impl RTDRemoveTopChatBuilder {
  fn new(instance: RemoveTopChat) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveTopChat { self.instance.clone() }
  
  pub fn category(&mut self, category: Box<TopChatCategory>) -> &mut Self {
    self.instance.category = Some(category);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Changes the order of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReorderInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reorderInstalledStickerSets
  /// Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifiers of installed sticker sets in the new correct order.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for ReorderInstalledStickerSets {}
impl RObject for ReorderInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reorderInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::ReorderInstalledStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ReorderInstalledStickerSets {}


impl ReorderInstalledStickerSets {
  
  pub fn builder() -> RTDReorderInstalledStickerSetsBuilder {
    let instance = Self {
      td_name: "reorderInstalledStickerSets".to_string(),
      is_masks: None,
      sticker_set_ids: None,
      
    };
    RTDReorderInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReorderInstalledStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReorderInstalledStickerSetsBuilder { instance: ReorderInstalledStickerSets }

impl RTDReorderInstalledStickerSetsBuilder {
  fn new(instance: ReorderInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> ReorderInstalledStickerSets { self.instance.clone() }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn sticker_set_ids(&mut self, sticker_set_ids: Vec<i64>) -> &mut Self {
    self.instance.sticker_set_ids = Some(sticker_set_ids);
    self
  }
  
}



/// Reports a chat to the Telegram moderators. Supported only for supergroups, channels, or private chats with bots, since other chats can't be checked by moderators.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReportChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reportChat
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The reason for reporting the chat.
  reason: Option<Box<ChatReportReason>>,
  /// Identifiers of reported messages, if any.
  message_ids: Option<Vec<i64>>,
  
}


impl Clone for ReportChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for ReportChat {}
impl RObject for ReportChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reportChat" }
  fn td_type(&self) -> RTDType { RTDType::ReportChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ReportChat {}


impl ReportChat {
  
  pub fn builder() -> RTDReportChatBuilder {
    let instance = Self {
      td_name: "reportChat".to_string(),
      chat_id: None,
      reason: None,
      message_ids: None,
      
    };
    RTDReportChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reason(&self) -> Option<Box<ChatReportReason>> { self.reason.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReportChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReportChatBuilder { instance: ReportChat }

impl RTDReportChatBuilder {
  fn new(instance: ReportChat) -> Self { Self { instance } }

  pub fn build(&self) -> ReportChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reason(&mut self, reason: Box<ChatReportReason>) -> &mut Self {
    self.instance.reason = Some(reason);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}



/// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportSupergroupSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reportSupergroupSpam
  /// Supergroup identifier.
  supergroup_id: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// Identifiers of messages sent in the supergroup by the user. This list must be non-empty.
  message_ids: Option<Vec<i64>>,
  
}



impl Object for ReportSupergroupSpam {}
impl RObject for ReportSupergroupSpam {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reportSupergroupSpam" }
  fn td_type(&self) -> RTDType { RTDType::ReportSupergroupSpam }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ReportSupergroupSpam {}


impl ReportSupergroupSpam {
  
  pub fn builder() -> RTDReportSupergroupSpamBuilder {
    let instance = Self {
      td_name: "reportSupergroupSpam".to_string(),
      supergroup_id: None,
      user_id: None,
      message_ids: None,
      
    };
    RTDReportSupergroupSpamBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ReportSupergroupSpam> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDReportSupergroupSpamBuilder { instance: ReportSupergroupSpam }

impl RTDReportSupergroupSpamBuilder {
  fn new(instance: ReportSupergroupSpam) -> Self { Self { instance } }

  pub fn build(&self) -> ReportSupergroupSpam { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}



/// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestAuthenticationPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // requestAuthenticationPasswordRecovery
  
}



impl Object for RequestAuthenticationPasswordRecovery {}
impl RObject for RequestAuthenticationPasswordRecovery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "requestAuthenticationPasswordRecovery" }
  fn td_type(&self) -> RTDType { RTDType::RequestAuthenticationPasswordRecovery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RequestAuthenticationPasswordRecovery {}


impl RequestAuthenticationPasswordRecovery {
  
  pub fn builder() -> RTDRequestAuthenticationPasswordRecoveryBuilder {
    let instance = Self {
      td_name: "requestAuthenticationPasswordRecovery".to_string(),
      
    };
    RTDRequestAuthenticationPasswordRecoveryBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RequestAuthenticationPasswordRecovery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRequestAuthenticationPasswordRecoveryBuilder { instance: RequestAuthenticationPasswordRecovery }

impl RTDRequestAuthenticationPasswordRecoveryBuilder {
  fn new(instance: RequestAuthenticationPasswordRecovery) -> Self { Self { instance } }

  pub fn build(&self) -> RequestAuthenticationPasswordRecovery { self.instance.clone() }
  
}



/// Requests to send a password recovery code to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // requestPasswordRecovery
  
}



impl Object for RequestPasswordRecovery {}
impl RObject for RequestPasswordRecovery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "requestPasswordRecovery" }
  fn td_type(&self) -> RTDType { RTDType::RequestPasswordRecovery }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for RequestPasswordRecovery {}


impl RequestPasswordRecovery {
  
  pub fn builder() -> RTDRequestPasswordRecoveryBuilder {
    let instance = Self {
      td_name: "requestPasswordRecovery".to_string(),
      
    };
    RTDRequestPasswordRecoveryBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<RequestPasswordRecovery> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDRequestPasswordRecoveryBuilder { instance: RequestPasswordRecovery }

impl RTDRequestPasswordRecoveryBuilder {
  fn new(instance: RequestPasswordRecovery) -> Self { Self { instance } }

  pub fn build(&self) -> RequestPasswordRecovery { self.instance.clone() }
  
}



/// Re-sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendAuthenticationCode
  
}



impl Object for ResendAuthenticationCode {}
impl RObject for ResendAuthenticationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendAuthenticationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendAuthenticationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendAuthenticationCode {}


impl ResendAuthenticationCode {
  
  pub fn builder() -> RTDResendAuthenticationCodeBuilder {
    let instance = Self {
      td_name: "resendAuthenticationCode".to_string(),
      
    };
    RTDResendAuthenticationCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendAuthenticationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendAuthenticationCodeBuilder { instance: ResendAuthenticationCode }

impl RTDResendAuthenticationCodeBuilder {
  fn new(instance: ResendAuthenticationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendAuthenticationCode { self.instance.clone() }
  
}



/// Re-sends the authentication code sent to confirm a new phone number for the user. Works only if the previously received 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendChangePhoneNumberCode
  
}



impl Object for ResendChangePhoneNumberCode {}
impl RObject for ResendChangePhoneNumberCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendChangePhoneNumberCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendChangePhoneNumberCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendChangePhoneNumberCode {}


impl ResendChangePhoneNumberCode {
  
  pub fn builder() -> RTDResendChangePhoneNumberCodeBuilder {
    let instance = Self {
      td_name: "resendChangePhoneNumberCode".to_string(),
      
    };
    RTDResendChangePhoneNumberCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendChangePhoneNumberCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendChangePhoneNumberCodeBuilder { instance: ResendChangePhoneNumberCode }

impl RTDResendChangePhoneNumberCodeBuilder {
  fn new(instance: ResendChangePhoneNumberCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendChangePhoneNumberCode { self.instance.clone() }
  
}



/// Re-sends the code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendEmailAddressVerificationCode
  
}



impl Object for ResendEmailAddressVerificationCode {}
impl RObject for ResendEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendEmailAddressVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendEmailAddressVerificationCode {}


impl ResendEmailAddressVerificationCode {
  
  pub fn builder() -> RTDResendEmailAddressVerificationCodeBuilder {
    let instance = Self {
      td_name: "resendEmailAddressVerificationCode".to_string(),
      
    };
    RTDResendEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendEmailAddressVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendEmailAddressVerificationCodeBuilder { instance: ResendEmailAddressVerificationCode }

impl RTDResendEmailAddressVerificationCodeBuilder {
  fn new(instance: ResendEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendEmailAddressVerificationCode { self.instance.clone() }
  
}



/// Resends phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendPhoneNumberConfirmationCode
  
}



impl Object for ResendPhoneNumberConfirmationCode {}
impl RObject for ResendPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendPhoneNumberConfirmationCode {}


impl ResendPhoneNumberConfirmationCode {
  
  pub fn builder() -> RTDResendPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      td_name: "resendPhoneNumberConfirmationCode".to_string(),
      
    };
    RTDResendPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendPhoneNumberConfirmationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendPhoneNumberConfirmationCodeBuilder { instance: ResendPhoneNumberConfirmationCode }

impl RTDResendPhoneNumberConfirmationCodeBuilder {
  fn new(instance: ResendPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendPhoneNumberConfirmationCode { self.instance.clone() }
  
}



/// Re-sends the code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendPhoneNumberVerificationCode
  
}



impl Object for ResendPhoneNumberVerificationCode {}
impl RObject for ResendPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendPhoneNumberVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendPhoneNumberVerificationCode {}


impl ResendPhoneNumberVerificationCode {
  
  pub fn builder() -> RTDResendPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      td_name: "resendPhoneNumberVerificationCode".to_string(),
      
    };
    RTDResendPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendPhoneNumberVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendPhoneNumberVerificationCodeBuilder { instance: ResendPhoneNumberVerificationCode }

impl RTDResendPhoneNumberVerificationCodeBuilder {
  fn new(instance: ResendPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendPhoneNumberVerificationCode { self.instance.clone() }
  
}



/// Resends the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendRecoveryEmailAddressCode
  
}



impl Object for ResendRecoveryEmailAddressCode {}
impl RObject for ResendRecoveryEmailAddressCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendRecoveryEmailAddressCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendRecoveryEmailAddressCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResendRecoveryEmailAddressCode {}


impl ResendRecoveryEmailAddressCode {
  
  pub fn builder() -> RTDResendRecoveryEmailAddressCodeBuilder {
    let instance = Self {
      td_name: "resendRecoveryEmailAddressCode".to_string(),
      
    };
    RTDResendRecoveryEmailAddressCodeBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResendRecoveryEmailAddressCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResendRecoveryEmailAddressCodeBuilder { instance: ResendRecoveryEmailAddressCode }

impl RTDResendRecoveryEmailAddressCodeBuilder {
  fn new(instance: ResendRecoveryEmailAddressCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendRecoveryEmailAddressCode { self.instance.clone() }
  
}



/// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetAllNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resetAllNotificationSettings
  
}



impl Object for ResetAllNotificationSettings {}
impl RObject for ResetAllNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resetAllNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ResetAllNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResetAllNotificationSettings {}


impl ResetAllNotificationSettings {
  
  pub fn builder() -> RTDResetAllNotificationSettingsBuilder {
    let instance = Self {
      td_name: "resetAllNotificationSettings".to_string(),
      
    };
    RTDResetAllNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResetAllNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResetAllNotificationSettingsBuilder { instance: ResetAllNotificationSettings }

impl RTDResetAllNotificationSettingsBuilder {
  fn new(instance: ResetAllNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ResetAllNotificationSettings { self.instance.clone() }
  
}



/// Resets all network data usage statistics to zero. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resetNetworkStatistics
  
}



impl Object for ResetNetworkStatistics {}
impl RObject for ResetNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resetNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::ResetNetworkStatistics }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ResetNetworkStatistics {}


impl ResetNetworkStatistics {
  
  pub fn builder() -> RTDResetNetworkStatisticsBuilder {
    let instance = Self {
      td_name: "resetNetworkStatistics".to_string(),
      
    };
    RTDResetNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ResetNetworkStatistics> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDResetNetworkStatisticsBuilder { instance: ResetNetworkStatistics }

impl RTDResetNetworkStatisticsBuilder {
  fn new(instance: ResetNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> ResetNetworkStatistics { self.instance.clone() }
  
}



/// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchCallMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchCallMessages
  /// Identifier of the message from which to search; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages with missed calls.
  only_missed: Option<bool>,
  
}



impl Object for SearchCallMessages {}
impl RObject for SearchCallMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchCallMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchCallMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchCallMessages {}


impl SearchCallMessages {
  
  pub fn builder() -> RTDSearchCallMessagesBuilder {
    let instance = Self {
      td_name: "searchCallMessages".to_string(),
      from_message_id: None,
      limit: None,
      only_missed: None,
      
    };
    RTDSearchCallMessagesBuilder::new(instance)
  }
  
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn only_missed(&self) -> Option<bool> { self.only_missed.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchCallMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchCallMessagesBuilder { instance: SearchCallMessages }

impl RTDSearchCallMessagesBuilder {
  fn new(instance: SearchCallMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchCallMessages { self.instance.clone() }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn only_missed(&mut self, only_missed: bool) -> &mut Self {
    self.instance.only_missed = Some(only_missed);
    self
  }
  
}



/// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatMembers
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// The maximum number of users to be returned.
  limit: Option<i32>,
  /// The type of users to return. By default, chatMembersFilterMembers.
  filter: Option<Box<ChatMembersFilter>>,
  
}


impl Clone for SearchChatMembers {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SearchChatMembers {}
impl RObject for SearchChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatMembers" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatMembers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchChatMembers {}


impl SearchChatMembers {
  
  pub fn builder() -> RTDSearchChatMembersBuilder {
    let instance = Self {
      td_name: "searchChatMembers".to_string(),
      chat_id: None,
      query: None,
      limit: None,
      filter: None,
      
    };
    RTDSearchChatMembersBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<ChatMembersFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchChatMembers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchChatMembersBuilder { instance: SearchChatMembers }

impl RTDSearchChatMembersBuilder {
  fn new(instance: SearchChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatMembers { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<ChatMembersFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}



/// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query (
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatMessages
  /// Identifier of the chat in which to search messages.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// If not 0, only messages sent by the specified user will be returned. Not supported in secret chats.
  sender_user_id: Option<i32>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// Filter for message content in the search results.
  filter: Option<Box<SearchMessagesFilter>>,
  
}


impl Clone for SearchChatMessages {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SearchChatMessages {}
impl RObject for SearchChatMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchChatMessages {}


impl SearchChatMessages {
  
  pub fn builder() -> RTDSearchChatMessagesBuilder {
    let instance = Self {
      td_name: "searchChatMessages".to_string(),
      chat_id: None,
      query: None,
      sender_user_id: None,
      from_message_id: None,
      offset: None,
      limit: None,
      filter: None,
      
    };
    RTDSearchChatMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchChatMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchChatMessagesBuilder { instance: SearchChatMessages }

impl RTDSearchChatMessagesBuilder {
  fn new(instance: SearchChatMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}



/// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatRecentLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatRecentLocationMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Maximum number of messages to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChatRecentLocationMessages {}
impl RObject for SearchChatRecentLocationMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatRecentLocationMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatRecentLocationMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchChatRecentLocationMessages {}


impl SearchChatRecentLocationMessages {
  
  pub fn builder() -> RTDSearchChatRecentLocationMessagesBuilder {
    let instance = Self {
      td_name: "searchChatRecentLocationMessages".to_string(),
      chat_id: None,
      limit: None,
      
    };
    RTDSearchChatRecentLocationMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchChatRecentLocationMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchChatRecentLocationMessagesBuilder { instance: SearchChatRecentLocationMessages }

impl RTDSearchChatRecentLocationMessagesBuilder {
  fn new(instance: SearchChatRecentLocationMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatRecentLocationMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChats
  /// Query to search for. If the query is empty, returns up to 20 recently found chats.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChats {}
impl RObject for SearchChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChats" }
  fn td_type(&self) -> RTDType { RTDType::SearchChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchChats {}


impl SearchChats {
  
  pub fn builder() -> RTDSearchChatsBuilder {
    let instance = Self {
      td_name: "searchChats".to_string(),
      query: None,
      limit: None,
      
    };
    RTDSearchChatsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchChatsBuilder { instance: SearchChats }

impl RTDSearchChatsBuilder {
  fn new(instance: SearchChats) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChats { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatsOnServer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatsOnServer
  /// Query to search for.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChatsOnServer {}
impl RObject for SearchChatsOnServer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatsOnServer" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatsOnServer }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchChatsOnServer {}


impl SearchChatsOnServer {
  
  pub fn builder() -> RTDSearchChatsOnServerBuilder {
    let instance = Self {
      td_name: "searchChatsOnServer".to_string(),
      query: None,
      limit: None,
      
    };
    RTDSearchChatsOnServerBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchChatsOnServer> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchChatsOnServerBuilder { instance: SearchChatsOnServer }

impl RTDSearchChatsOnServerBuilder {
  fn new(instance: SearchChatsOnServer) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatsOnServer { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for the specified query in the first names, last names and usernames of the known user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchContacts
  /// Query to search for; may be empty to return all contacts.
  query: Option<String>,
  /// Maximum number of users to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchContacts {}
impl RObject for SearchContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchContacts" }
  fn td_type(&self) -> RTDType { RTDType::SearchContacts }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchContacts {}


impl SearchContacts {
  
  pub fn builder() -> RTDSearchContactsBuilder {
    let instance = Self {
      td_name: "searchContacts".to_string(),
      query: None,
      limit: None,
      
    };
    RTDSearchContactsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchContacts> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchContactsBuilder { instance: SearchContacts }

impl RTDSearchContactsBuilder {
  fn new(instance: SearchContacts) -> Self { Self { instance } }

  pub fn build(&self) -> SearchContacts { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for recently used hashtags by their prefix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchHashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchHashtags
  /// Hashtag prefix to search for.
  prefix: Option<String>,
  /// Maximum number of hashtags to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchHashtags {}
impl RObject for SearchHashtags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchHashtags" }
  fn td_type(&self) -> RTDType { RTDType::SearchHashtags }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchHashtags {}


impl SearchHashtags {
  
  pub fn builder() -> RTDSearchHashtagsBuilder {
    let instance = Self {
      td_name: "searchHashtags".to_string(),
      prefix: None,
      limit: None,
      
    };
    RTDSearchHashtagsBuilder::new(instance)
  }
  
  
  pub fn prefix(&self) -> Option<String> { self.prefix.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchHashtags> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchHashtagsBuilder { instance: SearchHashtags }

impl RTDSearchHashtagsBuilder {
  fn new(instance: SearchHashtags) -> Self { Self { instance } }

  pub fn build(&self) -> SearchHashtags { self.instance.clone() }
  
  pub fn prefix<S: AsRef<str>>(&mut self, prefix: S) -> &mut Self {
    self.instance.prefix = Some(prefix.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for installed sticker sets by looking for specified query in their title and name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchInstalledStickerSets
  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Query to search for.
  query: Option<String>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,
  
}



impl Object for SearchInstalledStickerSets {}
impl RObject for SearchInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::SearchInstalledStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchInstalledStickerSets {}


impl SearchInstalledStickerSets {
  
  pub fn builder() -> RTDSearchInstalledStickerSetsBuilder {
    let instance = Self {
      td_name: "searchInstalledStickerSets".to_string(),
      is_masks: None,
      query: None,
      limit: None,
      
    };
    RTDSearchInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchInstalledStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchInstalledStickerSetsBuilder { instance: SearchInstalledStickerSets }

impl RTDSearchInstalledStickerSetsBuilder {
  fn new(instance: SearchInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> SearchInstalledStickerSets { self.instance.clone() }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessages
  /// Query to search for.
  query: Option<String>,
  /// The date of the message starting from which the results should be fetched. Use 0 or any date in the future to get results from the last message.
  offset_date: Option<i32>,
  /// The chat identifier of the last found message, or 0 for the first request.
  offset_chat_id: Option<i64>,
  /// The message identifier of the last found message, or 0 for the first request.
  offset_message_id: Option<i64>,
  /// The maximum number of messages to be returned, up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  
}



impl Object for SearchMessages {}
impl RObject for SearchMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchMessages {}


impl SearchMessages {
  
  pub fn builder() -> RTDSearchMessagesBuilder {
    let instance = Self {
      td_name: "searchMessages".to_string(),
      query: None,
      offset_date: None,
      offset_chat_id: None,
      offset_message_id: None,
      limit: None,
      
    };
    RTDSearchMessagesBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset_date(&self) -> Option<i32> { self.offset_date.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn offset_message_id(&self) -> Option<i64> { self.offset_message_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchMessagesBuilder { instance: SearchMessages }

impl RTDSearchMessagesBuilder {
  fn new(instance: SearchMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessages { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn offset_date(&mut self, offset_date: i32) -> &mut Self {
    self.instance.offset_date = Some(offset_date);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn offset_message_id(&mut self, offset_message_id: i64) -> &mut Self {
    self.instance.offset_message_id = Some(offset_message_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchPublicChat
  /// Username to be resolved.
  username: Option<String>,
  
}



impl Object for SearchPublicChat {}
impl RObject for SearchPublicChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchPublicChat" }
  fn td_type(&self) -> RTDType { RTDType::SearchPublicChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchPublicChat {}


impl SearchPublicChat {
  
  pub fn builder() -> RTDSearchPublicChatBuilder {
    let instance = Self {
      td_name: "searchPublicChat".to_string(),
      username: None,
      
    };
    RTDSearchPublicChatBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchPublicChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchPublicChatBuilder { instance: SearchPublicChat }

impl RTDSearchPublicChatBuilder {
  fn new(instance: SearchPublicChat) -> Self { Self { instance } }

  pub fn build(&self) -> SearchPublicChat { self.instance.clone() }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
}



/// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchPublicChats
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SearchPublicChats {}
impl RObject for SearchPublicChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchPublicChats" }
  fn td_type(&self) -> RTDType { RTDType::SearchPublicChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchPublicChats {}


impl SearchPublicChats {
  
  pub fn builder() -> RTDSearchPublicChatsBuilder {
    let instance = Self {
      td_name: "searchPublicChats".to_string(),
      query: None,
      
    };
    RTDSearchPublicChatsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchPublicChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchPublicChatsBuilder { instance: SearchPublicChats }

impl RTDSearchPublicChatsBuilder {
  fn new(instance: SearchPublicChats) -> Self { Self { instance } }

  pub fn build(&self) -> SearchPublicChats { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
}



/// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchSecretMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchSecretMessages
  /// Identifier of the chat in which to search. Specify 0 to search in all secret chats.
  chat_id: Option<i64>,
  /// Query to search for. If empty, searchChatMessages should be used instead.
  query: Option<String>,
  /// The identifier from the result of a previous request, use 0 to get results from the last message.
  from_search_id: Option<i64>,
  /// Maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// A filter for the content of messages in the search results.
  filter: Option<Box<SearchMessagesFilter>>,
  
}


impl Clone for SearchSecretMessages {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SearchSecretMessages {}
impl RObject for SearchSecretMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchSecretMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchSecretMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchSecretMessages {}


impl SearchSecretMessages {
  
  pub fn builder() -> RTDSearchSecretMessagesBuilder {
    let instance = Self {
      td_name: "searchSecretMessages".to_string(),
      chat_id: None,
      query: None,
      from_search_id: None,
      limit: None,
      filter: None,
      
    };
    RTDSearchSecretMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_search_id(&self) -> Option<i64> { self.from_search_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchSecretMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchSecretMessagesBuilder { instance: SearchSecretMessages }

impl RTDSearchSecretMessagesBuilder {
  fn new(instance: SearchSecretMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchSecretMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
  pub fn from_search_id(&mut self, from_search_id: i64) -> &mut Self {
    self.instance.from_search_id = Some(from_search_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}



/// Searches for a sticker set by its name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickerSet
  /// Name of the sticker set.
  name: Option<String>,
  
}



impl Object for SearchStickerSet {}
impl RObject for SearchStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchStickerSet {}


impl SearchStickerSet {
  
  pub fn builder() -> RTDSearchStickerSetBuilder {
    let instance = Self {
      td_name: "searchStickerSet".to_string(),
      name: None,
      
    };
    RTDSearchStickerSetBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchStickerSetBuilder { instance: SearchStickerSet }

impl RTDSearchStickerSetBuilder {
  fn new(instance: SearchStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickerSet { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
}



/// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickerSets
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SearchStickerSets {}
impl RObject for SearchStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchStickerSets {}


impl SearchStickerSets {
  
  pub fn builder() -> RTDSearchStickerSetsBuilder {
    let instance = Self {
      td_name: "searchStickerSets".to_string(),
      query: None,
      
    };
    RTDSearchStickerSetsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchStickerSetsBuilder { instance: SearchStickerSets }

impl RTDSearchStickerSetsBuilder {
  fn new(instance: SearchStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickerSets { self.instance.clone() }
  
  pub fn query<S: AsRef<str>>(&mut self, query: S) -> &mut Self {
    self.instance.query = Some(query.as_ref().to_string());
    self
  }
  
}



/// Searches for stickers from public sticker sets that correspond to a given emoji.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickers
  /// String representation of emoji; must be non-empty.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchStickers {}
impl RObject for SearchStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickers" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickers }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SearchStickers {}


impl SearchStickers {
  
  pub fn builder() -> RTDSearchStickersBuilder {
    let instance = Self {
      td_name: "searchStickers".to_string(),
      emoji: None,
      limit: None,
      
    };
    RTDSearchStickersBuilder::new(instance)
  }
  
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SearchStickers> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSearchStickersBuilder { instance: SearchStickers }

impl RTDSearchStickersBuilder {
  fn new(instance: SearchStickers) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickers { self.instance.clone() }
  
  pub fn emoji<S: AsRef<str>>(&mut self, emoji: S) -> &mut Self {
    self.instance.emoji = Some(emoji.as_ref().to_string());
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}



/// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendBotStartMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendBotStartMessage
  /// Identifier of the bot.
  bot_user_id: Option<i32>,
  /// Identifier of the target chat.
  chat_id: Option<i64>,
  /// A hidden parameter sent to the bot for deep linking purposes (https://api.telegram.org/bots#deep-linking).
  parameter: Option<String>,
  
}



impl Object for SendBotStartMessage {}
impl RObject for SendBotStartMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendBotStartMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendBotStartMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendBotStartMessage {}


impl SendBotStartMessage {
  
  pub fn builder() -> RTDSendBotStartMessageBuilder {
    let instance = Self {
      td_name: "sendBotStartMessage".to_string(),
      bot_user_id: None,
      chat_id: None,
      parameter: None,
      
    };
    RTDSendBotStartMessageBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn parameter(&self) -> Option<String> { self.parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendBotStartMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendBotStartMessageBuilder { instance: SendBotStartMessage }

impl RTDSendBotStartMessageBuilder {
  fn new(instance: SendBotStartMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendBotStartMessage { self.instance.clone() }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn parameter<S: AsRef<str>>(&mut self, parameter: S) -> &mut Self {
    self.instance.parameter = Some(parameter.as_ref().to_string());
    self
  }
  
}



/// Sends debug information for a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallDebugInformation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCallDebugInformation
  /// Call identifier.
  call_id: Option<i32>,
  /// Debug information in application-specific format.
  debug_information: Option<String>,
  
}



impl Object for SendCallDebugInformation {}
impl RObject for SendCallDebugInformation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCallDebugInformation" }
  fn td_type(&self) -> RTDType { RTDType::SendCallDebugInformation }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendCallDebugInformation {}


impl SendCallDebugInformation {
  
  pub fn builder() -> RTDSendCallDebugInformationBuilder {
    let instance = Self {
      td_name: "sendCallDebugInformation".to_string(),
      call_id: None,
      debug_information: None,
      
    };
    RTDSendCallDebugInformationBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn debug_information(&self) -> Option<String> { self.debug_information.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendCallDebugInformation> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendCallDebugInformationBuilder { instance: SendCallDebugInformation }

impl RTDSendCallDebugInformationBuilder {
  fn new(instance: SendCallDebugInformation) -> Self { Self { instance } }

  pub fn build(&self) -> SendCallDebugInformation { self.instance.clone() }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn debug_information<S: AsRef<str>>(&mut self, debug_information: S) -> &mut Self {
    self.instance.debug_information = Some(debug_information.as_ref().to_string());
    self
  }
  
}



/// Sends a call rating.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallRating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCallRating
  /// Call identifier.
  call_id: Option<i32>,
  /// Call rating; 1-5.
  rating: Option<i32>,
  /// An optional user comment if the rating is less than 5.
  comment: Option<String>,
  
}



impl Object for SendCallRating {}
impl RObject for SendCallRating {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCallRating" }
  fn td_type(&self) -> RTDType { RTDType::SendCallRating }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendCallRating {}


impl SendCallRating {
  
  pub fn builder() -> RTDSendCallRatingBuilder {
    let instance = Self {
      td_name: "sendCallRating".to_string(),
      call_id: None,
      rating: None,
      comment: None,
      
    };
    RTDSendCallRatingBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn rating(&self) -> Option<i32> { self.rating.clone() }
  
  pub fn comment(&self) -> Option<String> { self.comment.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendCallRating> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendCallRatingBuilder { instance: SendCallRating }

impl RTDSendCallRatingBuilder {
  fn new(instance: SendCallRating) -> Self { Self { instance } }

  pub fn build(&self) -> SendCallRating { self.instance.clone() }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn rating(&mut self, rating: i32) -> &mut Self {
    self.instance.rating = Some(rating);
    self
  }
  
  pub fn comment<S: AsRef<str>>(&mut self, comment: S) -> &mut Self {
    self.instance.comment = Some(comment.as_ref().to_string());
    self
  }
  
}



/// Sends a notification about user activity in a chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatAction
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The action description.
  action: Option<Box<ChatAction>>,
  
}


impl Clone for SendChatAction {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SendChatAction {}
impl RObject for SendChatAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatAction" }
  fn td_type(&self) -> RTDType { RTDType::SendChatAction }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendChatAction {}


impl SendChatAction {
  
  pub fn builder() -> RTDSendChatActionBuilder {
    let instance = Self {
      td_name: "sendChatAction".to_string(),
      chat_id: None,
      action: None,
      
    };
    RTDSendChatActionBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendChatAction> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendChatActionBuilder { instance: SendChatAction }

impl RTDSendChatActionBuilder {
  fn new(instance: SendChatAction) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatAction { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn action(&mut self, action: Box<ChatAction>) -> &mut Self {
    self.instance.action = Some(action);
    self
  }
  
}



/// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatScreenshotTakenNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatScreenshotTakenNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for SendChatScreenshotTakenNotification {}
impl RObject for SendChatScreenshotTakenNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatScreenshotTakenNotification" }
  fn td_type(&self) -> RTDType { RTDType::SendChatScreenshotTakenNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendChatScreenshotTakenNotification {}


impl SendChatScreenshotTakenNotification {
  
  pub fn builder() -> RTDSendChatScreenshotTakenNotificationBuilder {
    let instance = Self {
      td_name: "sendChatScreenshotTakenNotification".to_string(),
      chat_id: None,
      
    };
    RTDSendChatScreenshotTakenNotificationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendChatScreenshotTakenNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendChatScreenshotTakenNotificationBuilder { instance: SendChatScreenshotTakenNotification }

impl RTDSendChatScreenshotTakenNotificationBuilder {
  fn new(instance: SendChatScreenshotTakenNotification) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatScreenshotTakenNotification { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatSetTtlMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatSetTtlMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New TTL value, in seconds.
  ttl: Option<i32>,
  
}



impl Object for SendChatSetTtlMessage {}
impl RObject for SendChatSetTtlMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatSetTtlMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendChatSetTtlMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendChatSetTtlMessage {}


impl SendChatSetTtlMessage {
  
  pub fn builder() -> RTDSendChatSetTtlMessageBuilder {
    let instance = Self {
      td_name: "sendChatSetTtlMessage".to_string(),
      chat_id: None,
      ttl: None,
      
    };
    RTDSendChatSetTtlMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendChatSetTtlMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendChatSetTtlMessageBuilder { instance: SendChatSetTtlMessage }

impl RTDSendChatSetTtlMessageBuilder {
  fn new(instance: SendChatSetTtlMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatSetTtlMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}



/// Sends a custom request; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCustomRequest {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCustomRequest
  /// The method name.
  method: Option<String>,
  /// JSON-serialized method parameters.
  parameters: Option<String>,
  
}



impl Object for SendCustomRequest {}
impl RObject for SendCustomRequest {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCustomRequest" }
  fn td_type(&self) -> RTDType { RTDType::SendCustomRequest }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendCustomRequest {}


impl SendCustomRequest {
  
  pub fn builder() -> RTDSendCustomRequestBuilder {
    let instance = Self {
      td_name: "sendCustomRequest".to_string(),
      method: None,
      parameters: None,
      
    };
    RTDSendCustomRequestBuilder::new(instance)
  }
  
  
  pub fn method(&self) -> Option<String> { self.method.clone() }
  
  pub fn parameters(&self) -> Option<String> { self.parameters.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendCustomRequest> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendCustomRequestBuilder { instance: SendCustomRequest }

impl RTDSendCustomRequestBuilder {
  fn new(instance: SendCustomRequest) -> Self { Self { instance } }

  pub fn build(&self) -> SendCustomRequest { self.instance.clone() }
  
  pub fn method<S: AsRef<str>>(&mut self, method: S) -> &mut Self {
    self.instance.method = Some(method.as_ref().to_string());
    self
  }
  
  pub fn parameters<S: AsRef<str>>(&mut self, parameters: S) -> &mut Self {
    self.instance.parameters = Some(parameters.as_ref().to_string());
    self
  }
  
}



/// Sends a code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendEmailAddressVerificationCode
  /// Email address.
  email_address: Option<String>,
  
}



impl Object for SendEmailAddressVerificationCode {}
impl RObject for SendEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendEmailAddressVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendEmailAddressVerificationCode {}


impl SendEmailAddressVerificationCode {
  
  pub fn builder() -> RTDSendEmailAddressVerificationCodeBuilder {
    let instance = Self {
      td_name: "sendEmailAddressVerificationCode".to_string(),
      email_address: None,
      
    };
    RTDSendEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendEmailAddressVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendEmailAddressVerificationCodeBuilder { instance: SendEmailAddressVerificationCode }

impl RTDSendEmailAddressVerificationCodeBuilder {
  fn new(instance: SendEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendEmailAddressVerificationCode { self.instance.clone() }
  
  pub fn email_address<S: AsRef<str>>(&mut self, email_address: S) -> &mut Self {
    self.instance.email_address = Some(email_address.as_ref().to_string());
    self
  }
  
}



/// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendInlineQueryResultMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendInlineQueryResultMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from background.
  from_background: Option<bool>,
  /// Identifier of the inline query.
  query_id: Option<i64>,
  /// Identifier of the inline result.
  result_id: Option<String>,
  /// If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username").
  hide_via_bot: Option<bool>,
  
}



impl Object for SendInlineQueryResultMessage {}
impl RObject for SendInlineQueryResultMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendInlineQueryResultMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendInlineQueryResultMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendInlineQueryResultMessage {}


impl SendInlineQueryResultMessage {
  
  pub fn builder() -> RTDSendInlineQueryResultMessageBuilder {
    let instance = Self {
      td_name: "sendInlineQueryResultMessage".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      query_id: None,
      result_id: None,
      hide_via_bot: None,
      
    };
    RTDSendInlineQueryResultMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn query_id(&self) -> Option<i64> { self.query_id.clone() }
  
  pub fn result_id(&self) -> Option<String> { self.result_id.clone() }
  
  pub fn hide_via_bot(&self) -> Option<bool> { self.hide_via_bot.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendInlineQueryResultMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendInlineQueryResultMessageBuilder { instance: SendInlineQueryResultMessage }

impl RTDSendInlineQueryResultMessageBuilder {
  fn new(instance: SendInlineQueryResultMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendInlineQueryResultMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn query_id(&mut self, query_id: i64) -> &mut Self {
    self.instance.query_id = Some(query_id);
    self
  }
  
  pub fn result_id<S: AsRef<str>>(&mut self, result_id: S) -> &mut Self {
    self.instance.result_id = Some(result_id.as_ref().to_string());
    self
  }
  
  pub fn hide_via_bot(&mut self, hide_via_bot: bool) -> &mut Self {
    self.instance.hide_via_bot = Some(hide_via_bot);
    self
  }
  
}



/// Sends a message. Returns the sent message.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// Markup for replying to the message; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for SendMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SendMessage {}
impl RObject for SendMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendMessage {}


impl SendMessage {
  
  pub fn builder() -> RTDSendMessageBuilder {
    let instance = Self {
      td_name: "sendMessage".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    RTDSendMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendMessageBuilder { instance: SendMessage }

impl RTDSendMessageBuilder {
  fn new(instance: SendMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}



/// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessageAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendMessageAlbum
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the messages. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the messages are sent from the background.
  from_background: Option<bool>,
  /// Contents of messages to be sent.
  input_message_contents: Option<Vec<Box<InputMessageContent>>>,
  
}


impl Clone for SendMessageAlbum {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SendMessageAlbum {}
impl RObject for SendMessageAlbum {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendMessageAlbum" }
  fn td_type(&self) -> RTDType { RTDType::SendMessageAlbum }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendMessageAlbum {}


impl SendMessageAlbum {
  
  pub fn builder() -> RTDSendMessageAlbumBuilder {
    let instance = Self {
      td_name: "sendMessageAlbum".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      input_message_contents: None,
      
    };
    RTDSendMessageAlbumBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn input_message_contents(&self) -> Option<Vec<Box<InputMessageContent>>> { self.input_message_contents.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendMessageAlbum> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendMessageAlbumBuilder { instance: SendMessageAlbum }

impl RTDSendMessageAlbumBuilder {
  fn new(instance: SendMessageAlbum) -> Self { Self { instance } }

  pub fn build(&self) -> SendMessageAlbum { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn input_message_contents(&mut self, input_message_contents: Vec<Box<InputMessageContent>>) -> &mut Self {
    self.instance.input_message_contents = Some(input_message_contents);
    self
  }
  
}



/// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after 
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPassportAuthorizationForm
  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Types of Telegram Passport elements chosen by user to complete the authorization form.
  types: Option<Vec<Box<PassportElementType>>>,
  
}


impl Clone for SendPassportAuthorizationForm {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SendPassportAuthorizationForm {}
impl RObject for SendPassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPassportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::SendPassportAuthorizationForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendPassportAuthorizationForm {}


impl SendPassportAuthorizationForm {
  
  pub fn builder() -> RTDSendPassportAuthorizationFormBuilder {
    let instance = Self {
      td_name: "sendPassportAuthorizationForm".to_string(),
      autorization_form_id: None,
      types: None,
      
    };
    RTDSendPassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn autorization_form_id(&self) -> Option<i32> { self.autorization_form_id.clone() }
  
  pub fn types(&self) -> Option<Vec<Box<PassportElementType>>> { self.types.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendPassportAuthorizationForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendPassportAuthorizationFormBuilder { instance: SendPassportAuthorizationForm }

impl RTDSendPassportAuthorizationFormBuilder {
  fn new(instance: SendPassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> SendPassportAuthorizationForm { self.instance.clone() }
  
  pub fn autorization_form_id(&mut self, autorization_form_id: i32) -> &mut Self {
    self.instance.autorization_form_id = Some(autorization_form_id);
    self
  }
  
  pub fn types(&mut self, types: Vec<Box<PassportElementType>>) -> &mut Self {
    self.instance.types = Some(types);
    self
  }
  
}



/// Sends a filled-out payment form to the bot for final verification.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPaymentForm
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Identifier returned by ValidateOrderInfo, or an empty string.
  order_info_id: Option<String>,
  /// Identifier of a chosen shipping option, if applicable.
  shipping_option_id: Option<String>,
  /// The credentials chosen by user for payment.
  credentials: Option<Box<InputCredentials>>,
  
}


impl Clone for SendPaymentForm {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SendPaymentForm {}
impl RObject for SendPaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPaymentForm" }
  fn td_type(&self) -> RTDType { RTDType::SendPaymentForm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendPaymentForm {}


impl SendPaymentForm {
  
  pub fn builder() -> RTDSendPaymentFormBuilder {
    let instance = Self {
      td_name: "sendPaymentForm".to_string(),
      chat_id: None,
      message_id: None,
      order_info_id: None,
      shipping_option_id: None,
      credentials: None,
      
    };
    RTDSendPaymentFormBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn order_info_id(&self) -> Option<String> { self.order_info_id.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn credentials(&self) -> Option<Box<InputCredentials>> { self.credentials.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendPaymentForm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendPaymentFormBuilder { instance: SendPaymentForm }

impl RTDSendPaymentFormBuilder {
  fn new(instance: SendPaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> SendPaymentForm { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn order_info_id<S: AsRef<str>>(&mut self, order_info_id: S) -> &mut Self {
    self.instance.order_info_id = Some(order_info_id.as_ref().to_string());
    self
  }
  
  pub fn shipping_option_id<S: AsRef<str>>(&mut self, shipping_option_id: S) -> &mut Self {
    self.instance.shipping_option_id = Some(shipping_option_id.as_ref().to_string());
    self
  }
  
  pub fn credentials(&mut self, credentials: Box<InputCredentials>) -> &mut Self {
    self.instance.credentials = Some(credentials);
    self
  }
  
}



/// Sends phone number confirmation code. Should be called when user presses "
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPhoneNumberConfirmationCode
  /// Value of the "hash" parameter from the link.
  hash: Option<String>,
  /// Value of the "phone" parameter from the link.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SendPhoneNumberConfirmationCode {}
impl RObject for SendPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendPhoneNumberConfirmationCode {}


impl SendPhoneNumberConfirmationCode {
  
  pub fn builder() -> RTDSendPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      td_name: "sendPhoneNumberConfirmationCode".to_string(),
      hash: None,
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    RTDSendPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendPhoneNumberConfirmationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendPhoneNumberConfirmationCodeBuilder { instance: SendPhoneNumberConfirmationCode }

impl RTDSendPhoneNumberConfirmationCodeBuilder {
  fn new(instance: SendPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendPhoneNumberConfirmationCode { self.instance.clone() }
  
  pub fn hash<S: AsRef<str>>(&mut self, hash: S) -> &mut Self {
    self.instance.hash = Some(hash.as_ref().to_string());
    self
  }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}



/// Sends a code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPhoneNumberVerificationCode
  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SendPhoneNumberVerificationCode {}
impl RObject for SendPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendPhoneNumberVerificationCode }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SendPhoneNumberVerificationCode {}


impl SendPhoneNumberVerificationCode {
  
  pub fn builder() -> RTDSendPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      td_name: "sendPhoneNumberVerificationCode".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    RTDSendPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SendPhoneNumberVerificationCode> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSendPhoneNumberVerificationCodeBuilder { instance: SendPhoneNumberVerificationCode }

impl RTDSendPhoneNumberVerificationCodeBuilder {
  fn new(instance: SendPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendPhoneNumberVerificationCode { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}



/// Changes the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAccountTtl
  /// New account TTL.
  ttl: Option<AccountTtl>,
  
}



impl Object for SetAccountTtl {}
impl RObject for SetAccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAccountTtl" }
  fn td_type(&self) -> RTDType { RTDType::SetAccountTtl }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetAccountTtl {}


impl SetAccountTtl {
  
  pub fn builder() -> RTDSetAccountTtlBuilder {
    let instance = Self {
      td_name: "setAccountTtl".to_string(),
      ttl: None,
      
    };
    RTDSetAccountTtlBuilder::new(instance)
  }
  
  
  pub fn ttl(&self) -> Option<AccountTtl> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetAccountTtl> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetAccountTtlBuilder { instance: SetAccountTtl }

impl RTDSetAccountTtlBuilder {
  fn new(instance: SetAccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> SetAccountTtl { self.instance.clone() }
  
  pub fn ttl(&mut self, ttl: AccountTtl) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}



/// Succeeds after a specified amount of time has passed. Can be called before authorization. Can be called before initialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAlarm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAlarm
  /// Number of seconds before the function returns.
  seconds: Option<f64>,
  
}



impl Object for SetAlarm {}
impl RObject for SetAlarm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAlarm" }
  fn td_type(&self) -> RTDType { RTDType::SetAlarm }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetAlarm {}


impl SetAlarm {
  
  pub fn builder() -> RTDSetAlarmBuilder {
    let instance = Self {
      td_name: "setAlarm".to_string(),
      seconds: None,
      
    };
    RTDSetAlarmBuilder::new(instance)
  }
  
  
  pub fn seconds(&self) -> Option<f64> { self.seconds.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetAlarm> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetAlarmBuilder { instance: SetAlarm }

impl RTDSetAlarmBuilder {
  fn new(instance: SetAlarm) -> Self { Self { instance } }

  pub fn build(&self) -> SetAlarm { self.instance.clone() }
  
  pub fn seconds(&mut self, seconds: f64) -> &mut Self {
    self.instance.seconds = Some(seconds);
    self
  }
  
}



/// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAuthenticationPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAuthenticationPhoneNumber
  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SetAuthenticationPhoneNumber {}
impl RObject for SetAuthenticationPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAuthenticationPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::SetAuthenticationPhoneNumber }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetAuthenticationPhoneNumber {}


impl SetAuthenticationPhoneNumber {
  
  pub fn builder() -> RTDSetAuthenticationPhoneNumberBuilder {
    let instance = Self {
      td_name: "setAuthenticationPhoneNumber".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    RTDSetAuthenticationPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetAuthenticationPhoneNumber> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetAuthenticationPhoneNumberBuilder { instance: SetAuthenticationPhoneNumber }

impl RTDSetAuthenticationPhoneNumberBuilder {
  fn new(instance: SetAuthenticationPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> SetAuthenticationPhoneNumber { self.instance.clone() }
  
  pub fn phone_number<S: AsRef<str>>(&mut self, phone_number: S) -> &mut Self {
    self.instance.phone_number = Some(phone_number.as_ref().to_string());
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}



/// Changes the bio of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setBio
  /// The new value of the user bio; 0-70 characters without line feeds.
  bio: Option<String>,
  
}



impl Object for SetBio {}
impl RObject for SetBio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setBio" }
  fn td_type(&self) -> RTDType { RTDType::SetBio }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetBio {}


impl SetBio {
  
  pub fn builder() -> RTDSetBioBuilder {
    let instance = Self {
      td_name: "setBio".to_string(),
      bio: None,
      
    };
    RTDSetBioBuilder::new(instance)
  }
  
  
  pub fn bio(&self) -> Option<String> { self.bio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetBio> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetBioBuilder { instance: SetBio }

impl RTDSetBioBuilder {
  fn new(instance: SetBio) -> Self { Self { instance } }

  pub fn build(&self) -> SetBio { self.instance.clone() }
  
  pub fn bio<S: AsRef<str>>(&mut self, bio: S) -> &mut Self {
    self.instance.bio = Some(bio.as_ref().to_string());
    self
  }
  
}



/// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBotUpdatesStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setBotUpdatesStatus
  /// The number of pending updates.
  pending_update_count: Option<i32>,
  /// The last error message.
  error_message: Option<String>,
  
}



impl Object for SetBotUpdatesStatus {}
impl RObject for SetBotUpdatesStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setBotUpdatesStatus" }
  fn td_type(&self) -> RTDType { RTDType::SetBotUpdatesStatus }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetBotUpdatesStatus {}


impl SetBotUpdatesStatus {
  
  pub fn builder() -> RTDSetBotUpdatesStatusBuilder {
    let instance = Self {
      td_name: "setBotUpdatesStatus".to_string(),
      pending_update_count: None,
      error_message: None,
      
    };
    RTDSetBotUpdatesStatusBuilder::new(instance)
  }
  
  
  pub fn pending_update_count(&self) -> Option<i32> { self.pending_update_count.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetBotUpdatesStatus> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetBotUpdatesStatusBuilder { instance: SetBotUpdatesStatus }

impl RTDSetBotUpdatesStatusBuilder {
  fn new(instance: SetBotUpdatesStatus) -> Self { Self { instance } }

  pub fn build(&self) -> SetBotUpdatesStatus { self.instance.clone() }
  
  pub fn pending_update_count(&mut self, pending_update_count: i32) -> &mut Self {
    self.instance.pending_update_count = Some(pending_update_count);
    self
  }
  
  pub fn error_message<S: AsRef<str>>(&mut self, error_message: S) -> &mut Self {
    self.instance.error_message = Some(error_message.as_ref().to_string());
    self
  }
  
}



/// Changes client data associated with a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatClientData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatClientData
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of client_data.
  client_data: Option<String>,
  
}



impl Object for SetChatClientData {}
impl RObject for SetChatClientData {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatClientData" }
  fn td_type(&self) -> RTDType { RTDType::SetChatClientData }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatClientData {}


impl SetChatClientData {
  
  pub fn builder() -> RTDSetChatClientDataBuilder {
    let instance = Self {
      td_name: "setChatClientData".to_string(),
      chat_id: None,
      client_data: None,
      
    };
    RTDSetChatClientDataBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn client_data(&self) -> Option<String> { self.client_data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatClientData> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatClientDataBuilder { instance: SetChatClientData }

impl RTDSetChatClientDataBuilder {
  fn new(instance: SetChatClientData) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatClientData { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn client_data<S: AsRef<str>>(&mut self, client_data: S) -> &mut Self {
    self.instance.client_data = Some(client_data.as_ref().to_string());
    self
  }
  
}



/// Changes the draft message in a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatDraftMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New draft message; may be null.
  draft_message: Option<DraftMessage>,
  
}



impl Object for SetChatDraftMessage {}
impl RObject for SetChatDraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatDraftMessage" }
  fn td_type(&self) -> RTDType { RTDType::SetChatDraftMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatDraftMessage {}


impl SetChatDraftMessage {
  
  pub fn builder() -> RTDSetChatDraftMessageBuilder {
    let instance = Self {
      td_name: "setChatDraftMessage".to_string(),
      chat_id: None,
      draft_message: None,
      
    };
    RTDSetChatDraftMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatDraftMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatDraftMessageBuilder { instance: SetChatDraftMessage }

impl RTDSetChatDraftMessageBuilder {
  fn new(instance: SetChatDraftMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatDraftMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn draft_message(&mut self, draft_message: DraftMessage) -> &mut Self {
    self.instance.draft_message = Some(draft_message);
    self
  }
  
}



/// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat; instead, use 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatMemberStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatMemberStatus
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for SetChatMemberStatus {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetChatMemberStatus {}
impl RObject for SetChatMemberStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatMemberStatus" }
  fn td_type(&self) -> RTDType { RTDType::SetChatMemberStatus }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatMemberStatus {}


impl SetChatMemberStatus {
  
  pub fn builder() -> RTDSetChatMemberStatusBuilder {
    let instance = Self {
      td_name: "setChatMemberStatus".to_string(),
      chat_id: None,
      user_id: None,
      status: None,
      
    };
    RTDSetChatMemberStatusBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatMemberStatus> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatMemberStatusBuilder { instance: SetChatMemberStatus }

impl RTDSetChatMemberStatusBuilder {
  fn new(instance: SetChatMemberStatus) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatMemberStatus { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
}



/// Changes the notification settings of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatNotificationSettings
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New notification settings for the chat.
  notification_settings: Option<ChatNotificationSettings>,
  
}



impl Object for SetChatNotificationSettings {}
impl RObject for SetChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::SetChatNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatNotificationSettings {}


impl SetChatNotificationSettings {
  
  pub fn builder() -> RTDSetChatNotificationSettingsBuilder {
    let instance = Self {
      td_name: "setChatNotificationSettings".to_string(),
      chat_id: None,
      notification_settings: None,
      
    };
    RTDSetChatNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatNotificationSettingsBuilder { instance: SetChatNotificationSettings }

impl RTDSetChatNotificationSettingsBuilder {
  fn new(instance: SetChatNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatNotificationSettings { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ChatNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
}



/// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The photo will not be changed before request to the server has been completed.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatPhoto
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New chat photo. You can use a zero InputFileId to delete the chat photo. Files that are accessible only by HTTP URL are not acceptable.
  photo: Option<Box<InputFile>>,
  
}


impl Clone for SetChatPhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetChatPhoto {}
impl RObject for SetChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SetChatPhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatPhoto {}


impl SetChatPhoto {
  
  pub fn builder() -> RTDSetChatPhotoBuilder {
    let instance = Self {
      td_name: "setChatPhoto".to_string(),
      chat_id: None,
      photo: None,
      
    };
    RTDSetChatPhotoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatPhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatPhotoBuilder { instance: SetChatPhoto }

impl RTDSetChatPhotoBuilder {
  fn new(instance: SetChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatPhoto { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}



/// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The title will not be changed until the request to the server has been completed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatTitle
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New title of the chat; 1-128 characters.
  title: Option<String>,
  
}



impl Object for SetChatTitle {}
impl RObject for SetChatTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatTitle" }
  fn td_type(&self) -> RTDType { RTDType::SetChatTitle }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetChatTitle {}


impl SetChatTitle {
  
  pub fn builder() -> RTDSetChatTitleBuilder {
    let instance = Self {
      td_name: "setChatTitle".to_string(),
      chat_id: None,
      title: None,
      
    };
    RTDSetChatTitleBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetChatTitle> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetChatTitleBuilder { instance: SetChatTitle }

impl RTDSetChatTitleBuilder {
  fn new(instance: SetChatTitle) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatTitle { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn title<S: AsRef<str>>(&mut self, title: S) -> &mut Self {
    self.instance.title = Some(title.as_ref().to_string());
    self
  }
  
}



/// Adds or changes a custom local language pack to the current localization target.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setCustomLanguagePack
  /// Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization.
  info: Option<LanguagePackInfo>,
  /// Strings of the new language pack.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for SetCustomLanguagePack {}
impl RObject for SetCustomLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setCustomLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::SetCustomLanguagePack }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetCustomLanguagePack {}


impl SetCustomLanguagePack {
  
  pub fn builder() -> RTDSetCustomLanguagePackBuilder {
    let instance = Self {
      td_name: "setCustomLanguagePack".to_string(),
      info: None,
      strings: None,
      
    };
    RTDSetCustomLanguagePackBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> Option<LanguagePackInfo> { self.info.clone() }
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetCustomLanguagePack> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetCustomLanguagePackBuilder { instance: SetCustomLanguagePack }

impl RTDSetCustomLanguagePackBuilder {
  fn new(instance: SetCustomLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> SetCustomLanguagePack { self.instance.clone() }
  
  pub fn info(&mut self, info: LanguagePackInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
  pub fn strings(&mut self, strings: Vec<LanguagePackString>) -> &mut Self {
    self.instance.strings = Some(strings);
    self
  }
  
}



/// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setCustomLanguagePackString
  /// Identifier of a previously added custom local language pack in the current localization target.
  language_pack_id: Option<String>,
  /// New language pack string.
  new_string: Option<LanguagePackString>,
  
}



impl Object for SetCustomLanguagePackString {}
impl RObject for SetCustomLanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setCustomLanguagePackString" }
  fn td_type(&self) -> RTDType { RTDType::SetCustomLanguagePackString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetCustomLanguagePackString {}


impl SetCustomLanguagePackString {
  
  pub fn builder() -> RTDSetCustomLanguagePackStringBuilder {
    let instance = Self {
      td_name: "setCustomLanguagePackString".to_string(),
      language_pack_id: None,
      new_string: None,
      
    };
    RTDSetCustomLanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn new_string(&self) -> Option<LanguagePackString> { self.new_string.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetCustomLanguagePackString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetCustomLanguagePackStringBuilder { instance: SetCustomLanguagePackString }

impl RTDSetCustomLanguagePackStringBuilder {
  fn new(instance: SetCustomLanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> SetCustomLanguagePackString { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
  pub fn new_string(&mut self, new_string: LanguagePackString) -> &mut Self {
    self.instance.new_string = Some(new_string);
    self
  }
  
}



/// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setDatabaseEncryptionKey
  /// New encryption key.
  new_encryption_key: Option<String>,
  
}



impl Object for SetDatabaseEncryptionKey {}
impl RObject for SetDatabaseEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setDatabaseEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::SetDatabaseEncryptionKey }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetDatabaseEncryptionKey {}


impl SetDatabaseEncryptionKey {
  
  pub fn builder() -> RTDSetDatabaseEncryptionKeyBuilder {
    let instance = Self {
      td_name: "setDatabaseEncryptionKey".to_string(),
      new_encryption_key: None,
      
    };
    RTDSetDatabaseEncryptionKeyBuilder::new(instance)
  }
  
  
  pub fn new_encryption_key(&self) -> Option<String> { self.new_encryption_key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetDatabaseEncryptionKey> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetDatabaseEncryptionKeyBuilder { instance: SetDatabaseEncryptionKey }

impl RTDSetDatabaseEncryptionKeyBuilder {
  fn new(instance: SetDatabaseEncryptionKey) -> Self { Self { instance } }

  pub fn build(&self) -> SetDatabaseEncryptionKey { self.instance.clone() }
  
  pub fn new_encryption_key<S: AsRef<str>>(&mut self, new_encryption_key: S) -> &mut Self {
    self.instance.new_encryption_key = Some(new_encryption_key.as_ref().to_string());
    self
  }
  
}



/// Informs TDLib on a file generation prograss.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetFileGenerationProgress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setFileGenerationProgress
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// Expected size of the generated file, in bytes; 0 if unknown.
  expected_size: Option<i32>,
  /// The number of bytes already generated.
  local_prefix_size: Option<i32>,
  
}



impl Object for SetFileGenerationProgress {}
impl RObject for SetFileGenerationProgress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setFileGenerationProgress" }
  fn td_type(&self) -> RTDType { RTDType::SetFileGenerationProgress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetFileGenerationProgress {}


impl SetFileGenerationProgress {
  
  pub fn builder() -> RTDSetFileGenerationProgressBuilder {
    let instance = Self {
      td_name: "setFileGenerationProgress".to_string(),
      generation_id: None,
      expected_size: None,
      local_prefix_size: None,
      
    };
    RTDSetFileGenerationProgressBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn local_prefix_size(&self) -> Option<i32> { self.local_prefix_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetFileGenerationProgress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetFileGenerationProgressBuilder { instance: SetFileGenerationProgress }

impl RTDSetFileGenerationProgressBuilder {
  fn new(instance: SetFileGenerationProgress) -> Self { Self { instance } }

  pub fn build(&self) -> SetFileGenerationProgress { self.instance.clone() }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
  pub fn local_prefix_size(&mut self, local_prefix_size: i32) -> &mut Self {
    self.instance.local_prefix_size = Some(local_prefix_size);
    self
  }
  
}



/// Updates the game score of the specified user in the game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setGameScore
  /// The chat to which the message with the game belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,
  
}



impl Object for SetGameScore {}
impl RObject for SetGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setGameScore" }
  fn td_type(&self) -> RTDType { RTDType::SetGameScore }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetGameScore {}


impl SetGameScore {
  
  pub fn builder() -> RTDSetGameScoreBuilder {
    let instance = Self {
      td_name: "setGameScore".to_string(),
      chat_id: None,
      message_id: None,
      edit_message: None,
      user_id: None,
      score: None,
      force: None,
      
    };
    RTDSetGameScoreBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn edit_message(&self) -> Option<bool> { self.edit_message.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetGameScore> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetGameScoreBuilder { instance: SetGameScore }

impl RTDSetGameScoreBuilder {
  fn new(instance: SetGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> SetGameScore { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn edit_message(&mut self, edit_message: bool) -> &mut Self {
    self.instance.edit_message = Some(edit_message);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}



/// Updates the game score of the specified user in a game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetInlineGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setInlineGameScore
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,
  
}



impl Object for SetInlineGameScore {}
impl RObject for SetInlineGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setInlineGameScore" }
  fn td_type(&self) -> RTDType { RTDType::SetInlineGameScore }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetInlineGameScore {}


impl SetInlineGameScore {
  
  pub fn builder() -> RTDSetInlineGameScoreBuilder {
    let instance = Self {
      td_name: "setInlineGameScore".to_string(),
      inline_message_id: None,
      edit_message: None,
      user_id: None,
      score: None,
      force: None,
      
    };
    RTDSetInlineGameScoreBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn edit_message(&self) -> Option<bool> { self.edit_message.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetInlineGameScore> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetInlineGameScoreBuilder { instance: SetInlineGameScore }

impl RTDSetInlineGameScoreBuilder {
  fn new(instance: SetInlineGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> SetInlineGameScore { self.instance.clone() }
  
  pub fn inline_message_id<S: AsRef<str>>(&mut self, inline_message_id: S) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id.as_ref().to_string());
    self
  }
  
  pub fn edit_message(&mut self, edit_message: bool) -> &mut Self {
    self.instance.edit_message = Some(edit_message);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}



/// Sets new log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogStream
  /// New log stream.
  log_stream: Option<Box<LogStream>>,
  
}


impl Clone for SetLogStream {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetLogStream {}
impl RObject for SetLogStream {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogStream" }
  fn td_type(&self) -> RTDType { RTDType::SetLogStream }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetLogStream {}


impl SetLogStream {
  
  pub fn builder() -> RTDSetLogStreamBuilder {
    let instance = Self {
      td_name: "setLogStream".to_string(),
      log_stream: None,
      
    };
    RTDSetLogStreamBuilder::new(instance)
  }
  
  
  pub fn log_stream(&self) -> Option<Box<LogStream>> { self.log_stream.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetLogStream> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetLogStreamBuilder { instance: SetLogStream }

impl RTDSetLogStreamBuilder {
  fn new(instance: SetLogStream) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogStream { self.instance.clone() }
  
  pub fn log_stream(&mut self, log_stream: Box<LogStream>) -> &mut Self {
    self.instance.log_stream = Some(log_stream);
    self
  }
  
}



/// Sets the verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogTagVerbosityLevel
  /// Logging tag to change verbosity level.
  tag: Option<String>,
  /// New verbosity level; 1-1024.
  new_verbosity_level: Option<i32>,
  
}



impl Object for SetLogTagVerbosityLevel {}
impl RObject for SetLogTagVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogTagVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::SetLogTagVerbosityLevel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetLogTagVerbosityLevel {}


impl SetLogTagVerbosityLevel {
  
  pub fn builder() -> RTDSetLogTagVerbosityLevelBuilder {
    let instance = Self {
      td_name: "setLogTagVerbosityLevel".to_string(),
      tag: None,
      new_verbosity_level: None,
      
    };
    RTDSetLogTagVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn tag(&self) -> Option<String> { self.tag.clone() }
  
  pub fn new_verbosity_level(&self) -> Option<i32> { self.new_verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetLogTagVerbosityLevel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetLogTagVerbosityLevelBuilder { instance: SetLogTagVerbosityLevel }

impl RTDSetLogTagVerbosityLevelBuilder {
  fn new(instance: SetLogTagVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogTagVerbosityLevel { self.instance.clone() }
  
  pub fn tag<S: AsRef<str>>(&mut self, tag: S) -> &mut Self {
    self.instance.tag = Some(tag.as_ref().to_string());
    self
  }
  
  pub fn new_verbosity_level(&mut self, new_verbosity_level: i32) -> &mut Self {
    self.instance.new_verbosity_level = Some(new_verbosity_level);
    self
  }
  
}



/// Sets the verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogVerbosityLevel
  /// New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging.
  new_verbosity_level: Option<i32>,
  
}



impl Object for SetLogVerbosityLevel {}
impl RObject for SetLogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::SetLogVerbosityLevel }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetLogVerbosityLevel {}


impl SetLogVerbosityLevel {
  
  pub fn builder() -> RTDSetLogVerbosityLevelBuilder {
    let instance = Self {
      td_name: "setLogVerbosityLevel".to_string(),
      new_verbosity_level: None,
      
    };
    RTDSetLogVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn new_verbosity_level(&self) -> Option<i32> { self.new_verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetLogVerbosityLevel> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetLogVerbosityLevelBuilder { instance: SetLogVerbosityLevel }

impl RTDSetLogVerbosityLevelBuilder {
  fn new(instance: SetLogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogVerbosityLevel { self.instance.clone() }
  
  pub fn new_verbosity_level(&mut self, new_verbosity_level: i32) -> &mut Self {
    self.instance.new_verbosity_level = Some(new_verbosity_level);
    self
  }
  
}



/// Changes the first and last name of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setName
  /// The new value of the first name for the user; 1-64 characters.
  first_name: Option<String>,
  /// The new value of the optional last name for the user; 0-64 characters.
  last_name: Option<String>,
  
}



impl Object for SetName {}
impl RObject for SetName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setName" }
  fn td_type(&self) -> RTDType { RTDType::SetName }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetName {}


impl SetName {
  
  pub fn builder() -> RTDSetNameBuilder {
    let instance = Self {
      td_name: "setName".to_string(),
      first_name: None,
      last_name: None,
      
    };
    RTDSetNameBuilder::new(instance)
  }
  
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetName> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetNameBuilder { instance: SetName }

impl RTDSetNameBuilder {
  fn new(instance: SetName) -> Self { Self { instance } }

  pub fn build(&self) -> SetName { self.instance.clone() }
  
  pub fn first_name<S: AsRef<str>>(&mut self, first_name: S) -> &mut Self {
    self.instance.first_name = Some(first_name.as_ref().to_string());
    self
  }
  
  pub fn last_name<S: AsRef<str>>(&mut self, last_name: S) -> &mut Self {
    self.instance.last_name = Some(last_name.as_ref().to_string());
    self
  }
  
}



/// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetNetworkType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setNetworkType
  /// The new network type. By default, networkTypeOther.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NetworkType>>,
  
}


impl Clone for SetNetworkType {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetNetworkType {}
impl RObject for SetNetworkType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setNetworkType" }
  fn td_type(&self) -> RTDType { RTDType::SetNetworkType }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetNetworkType {}


impl SetNetworkType {
  
  pub fn builder() -> RTDSetNetworkTypeBuilder {
    let instance = Self {
      td_name: "setNetworkType".to_string(),
      type_: None,
      
    };
    RTDSetNetworkTypeBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> Option<Box<NetworkType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetNetworkType> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetNetworkTypeBuilder { instance: SetNetworkType }

impl RTDSetNetworkTypeBuilder {
  fn new(instance: SetNetworkType) -> Self { Self { instance } }

  pub fn build(&self) -> SetNetworkType { self.instance.clone() }
  
  pub fn type_(&mut self, type_: Box<NetworkType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}



/// Sets the value of an option. (Check the list of available options on 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setOption
  /// The name of the option.
  name: Option<String>,
  /// The new value of the option.
  value: Option<Box<OptionValue>>,
  
}


impl Clone for SetOption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetOption {}
impl RObject for SetOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setOption" }
  fn td_type(&self) -> RTDType { RTDType::SetOption }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetOption {}


impl SetOption {
  
  pub fn builder() -> RTDSetOptionBuilder {
    let instance = Self {
      td_name: "setOption".to_string(),
      name: None,
      value: None,
      
    };
    RTDSetOptionBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn value(&self) -> Option<Box<OptionValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetOption> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetOptionBuilder { instance: SetOption }

impl RTDSetOptionBuilder {
  fn new(instance: SetOption) -> Self { Self { instance } }

  pub fn build(&self) -> SetOption { self.instance.clone() }
  
  pub fn name<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
    self.instance.name = Some(name.as_ref().to_string());
    self
  }
  
  pub fn value(&mut self, value: Box<OptionValue>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}



/// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassportElement
  /// Input Telegram Passport element.
  element: Option<Box<InputPassportElement>>,
  /// Password of the current user.
  password: Option<String>,
  
}


impl Clone for SetPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetPassportElement {}
impl RObject for SetPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::SetPassportElement }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetPassportElement {}


impl SetPassportElement {
  
  pub fn builder() -> RTDSetPassportElementBuilder {
    let instance = Self {
      td_name: "setPassportElement".to_string(),
      element: None,
      password: None,
      
    };
    RTDSetPassportElementBuilder::new(instance)
  }
  
  
  pub fn element(&self) -> Option<Box<InputPassportElement>> { self.element.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetPassportElement> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetPassportElementBuilder { instance: SetPassportElement }

impl RTDSetPassportElementBuilder {
  fn new(instance: SetPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassportElement { self.instance.clone() }
  
  pub fn element(&mut self, element: Box<InputPassportElement>) -> &mut Self {
    self.instance.element = Some(element);
    self
  }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
}



/// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassportElementErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassportElementErrors
  /// User identifier.
  user_id: Option<i32>,
  /// The errors.
  errors: Option<Vec<InputPassportElementError>>,
  
}



impl Object for SetPassportElementErrors {}
impl RObject for SetPassportElementErrors {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassportElementErrors" }
  fn td_type(&self) -> RTDType { RTDType::SetPassportElementErrors }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetPassportElementErrors {}


impl SetPassportElementErrors {
  
  pub fn builder() -> RTDSetPassportElementErrorsBuilder {
    let instance = Self {
      td_name: "setPassportElementErrors".to_string(),
      user_id: None,
      errors: None,
      
    };
    RTDSetPassportElementErrorsBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn errors(&self) -> Option<Vec<InputPassportElementError>> { self.errors.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetPassportElementErrors> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetPassportElementErrorsBuilder { instance: SetPassportElementErrors }

impl RTDSetPassportElementErrorsBuilder {
  fn new(instance: SetPassportElementErrors) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassportElementErrors { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn errors(&mut self, errors: Vec<InputPassportElementError>) -> &mut Self {
    self.instance.errors = Some(errors);
    self
  }
  
}



/// Changes the password for the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassword
  /// Previous password of the user.
  old_password: Option<String>,
  /// New password of the user; may be empty to remove the password.
  new_password: Option<String>,
  /// New password hint; may be empty.
  new_hint: Option<String>,
  /// Pass true if the recovery email address should be changed.
  set_recovery_email_address: Option<bool>,
  /// New recovery email address; may be empty.
  new_recovery_email_address: Option<String>,
  
}



impl Object for SetPassword {}
impl RObject for SetPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassword" }
  fn td_type(&self) -> RTDType { RTDType::SetPassword }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetPassword {}


impl SetPassword {
  
  pub fn builder() -> RTDSetPasswordBuilder {
    let instance = Self {
      td_name: "setPassword".to_string(),
      old_password: None,
      new_password: None,
      new_hint: None,
      set_recovery_email_address: None,
      new_recovery_email_address: None,
      
    };
    RTDSetPasswordBuilder::new(instance)
  }
  
  
  pub fn old_password(&self) -> Option<String> { self.old_password.clone() }
  
  pub fn new_password(&self) -> Option<String> { self.new_password.clone() }
  
  pub fn new_hint(&self) -> Option<String> { self.new_hint.clone() }
  
  pub fn set_recovery_email_address(&self) -> Option<bool> { self.set_recovery_email_address.clone() }
  
  pub fn new_recovery_email_address(&self) -> Option<String> { self.new_recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetPassword> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetPasswordBuilder { instance: SetPassword }

impl RTDSetPasswordBuilder {
  fn new(instance: SetPassword) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassword { self.instance.clone() }
  
  pub fn old_password<S: AsRef<str>>(&mut self, old_password: S) -> &mut Self {
    self.instance.old_password = Some(old_password.as_ref().to_string());
    self
  }
  
  pub fn new_password<S: AsRef<str>>(&mut self, new_password: S) -> &mut Self {
    self.instance.new_password = Some(new_password.as_ref().to_string());
    self
  }
  
  pub fn new_hint<S: AsRef<str>>(&mut self, new_hint: S) -> &mut Self {
    self.instance.new_hint = Some(new_hint.as_ref().to_string());
    self
  }
  
  pub fn set_recovery_email_address(&mut self, set_recovery_email_address: bool) -> &mut Self {
    self.instance.set_recovery_email_address = Some(set_recovery_email_address);
    self
  }
  
  pub fn new_recovery_email_address<S: AsRef<str>>(&mut self, new_recovery_email_address: S) -> &mut Self {
    self.instance.new_recovery_email_address = Some(new_recovery_email_address.as_ref().to_string());
    self
  }
  
}



/// Changes the order of pinned chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPinnedChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPinnedChats
  /// The new list of pinned chats.
  chat_ids: Option<Vec<i64>>,
  
}



impl Object for SetPinnedChats {}
impl RObject for SetPinnedChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPinnedChats" }
  fn td_type(&self) -> RTDType { RTDType::SetPinnedChats }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetPinnedChats {}


impl SetPinnedChats {
  
  pub fn builder() -> RTDSetPinnedChatsBuilder {
    let instance = Self {
      td_name: "setPinnedChats".to_string(),
      chat_ids: None,
      
    };
    RTDSetPinnedChatsBuilder::new(instance)
  }
  
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetPinnedChats> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetPinnedChatsBuilder { instance: SetPinnedChats }

impl RTDSetPinnedChatsBuilder {
  fn new(instance: SetPinnedChats) -> Self { Self { instance } }

  pub fn build(&self) -> SetPinnedChats { self.instance.clone() }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
}



/// Changes user answer to a poll.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPollAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPollAnswer
  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// 0-based identifiers of options, chosen by the user. Currently user can't choose more than 1 option.
  option_ids: Option<Vec<i32>>,
  
}



impl Object for SetPollAnswer {}
impl RObject for SetPollAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPollAnswer" }
  fn td_type(&self) -> RTDType { RTDType::SetPollAnswer }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetPollAnswer {}


impl SetPollAnswer {
  
  pub fn builder() -> RTDSetPollAnswerBuilder {
    let instance = Self {
      td_name: "setPollAnswer".to_string(),
      chat_id: None,
      message_id: None,
      option_ids: None,
      
    };
    RTDSetPollAnswerBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn option_ids(&self) -> Option<Vec<i32>> { self.option_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetPollAnswer> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetPollAnswerBuilder { instance: SetPollAnswer }

impl RTDSetPollAnswerBuilder {
  fn new(instance: SetPollAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> SetPollAnswer { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn option_ids(&mut self, option_ids: Vec<i32>) -> &mut Self {
    self.instance.option_ids = Some(option_ids);
    self
  }
  
}



/// Uploads a new profile photo for the current user. If something changes, 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setProfilePhoto
  /// Profile photo to set. inputFileId and inputFileRemote may still be unsupported.
  photo: Option<Box<InputFile>>,
  
}


impl Clone for SetProfilePhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetProfilePhoto {}
impl RObject for SetProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::SetProfilePhoto }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetProfilePhoto {}


impl SetProfilePhoto {
  
  pub fn builder() -> RTDSetProfilePhotoBuilder {
    let instance = Self {
      td_name: "setProfilePhoto".to_string(),
      photo: None,
      
    };
    RTDSetProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetProfilePhoto> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetProfilePhotoBuilder { instance: SetProfilePhoto }

impl RTDSetProfilePhotoBuilder {
  fn new(instance: SetProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SetProfilePhoto { self.instance.clone() }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}



/// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setRecoveryEmailAddress
  /// Password of the current user.
  password: Option<String>,
  /// New recovery email address.
  new_recovery_email_address: Option<String>,
  
}



impl Object for SetRecoveryEmailAddress {}
impl RObject for SetRecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setRecoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::SetRecoveryEmailAddress }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetRecoveryEmailAddress {}


impl SetRecoveryEmailAddress {
  
  pub fn builder() -> RTDSetRecoveryEmailAddressBuilder {
    let instance = Self {
      td_name: "setRecoveryEmailAddress".to_string(),
      password: None,
      new_recovery_email_address: None,
      
    };
    RTDSetRecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn new_recovery_email_address(&self) -> Option<String> { self.new_recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetRecoveryEmailAddress> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetRecoveryEmailAddressBuilder { instance: SetRecoveryEmailAddress }

impl RTDSetRecoveryEmailAddressBuilder {
  fn new(instance: SetRecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> SetRecoveryEmailAddress { self.instance.clone() }
  
  pub fn password<S: AsRef<str>>(&mut self, password: S) -> &mut Self {
    self.instance.password = Some(password.as_ref().to_string());
    self
  }
  
  pub fn new_recovery_email_address<S: AsRef<str>>(&mut self, new_recovery_email_address: S) -> &mut Self {
    self.instance.new_recovery_email_address = Some(new_recovery_email_address.as_ref().to_string());
    self
  }
  
}



/// Changes notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setScopeNotificationSettings
  /// Types of chats for which to change the notification settings.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings for the given scope.
  notification_settings: Option<ScopeNotificationSettings>,
  
}


impl Clone for SetScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetScopeNotificationSettings {}
impl RObject for SetScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::SetScopeNotificationSettings }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetScopeNotificationSettings {}


impl SetScopeNotificationSettings {
  
  pub fn builder() -> RTDSetScopeNotificationSettingsBuilder {
    let instance = Self {
      td_name: "setScopeNotificationSettings".to_string(),
      scope: None,
      notification_settings: None,
      
    };
    RTDSetScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn notification_settings(&self) -> Option<ScopeNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetScopeNotificationSettings> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetScopeNotificationSettingsBuilder { instance: SetScopeNotificationSettings }

impl RTDSetScopeNotificationSettingsBuilder {
  fn new(instance: SetScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> SetScopeNotificationSettings { self.instance.clone() }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ScopeNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
}



/// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetStickerPositionInSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setStickerPositionInSet
  /// Sticker.
  sticker: Option<Box<InputFile>>,
  /// New position of the sticker in the set, zero-based.
  position: Option<i32>,
  
}


impl Clone for SetStickerPositionInSet {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetStickerPositionInSet {}
impl RObject for SetStickerPositionInSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setStickerPositionInSet" }
  fn td_type(&self) -> RTDType { RTDType::SetStickerPositionInSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetStickerPositionInSet {}


impl SetStickerPositionInSet {
  
  pub fn builder() -> RTDSetStickerPositionInSetBuilder {
    let instance = Self {
      td_name: "setStickerPositionInSet".to_string(),
      sticker: None,
      position: None,
      
    };
    RTDSetStickerPositionInSetBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn position(&self) -> Option<i32> { self.position.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetStickerPositionInSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetStickerPositionInSetBuilder { instance: SetStickerPositionInSet }

impl RTDSetStickerPositionInSetBuilder {
  fn new(instance: SetStickerPositionInSet) -> Self { Self { instance } }

  pub fn build(&self) -> SetStickerPositionInSet { self.instance.clone() }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn position(&mut self, position: i32) -> &mut Self {
    self.instance.position = Some(position);
    self
  }
  
}



/// Changes information about a supergroup or channel; requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupDescription {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupDescription
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New supergroup or channel description; 0-255 characters.
  description: Option<String>,
  
}



impl Object for SetSupergroupDescription {}
impl RObject for SetSupergroupDescription {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupDescription" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupDescription }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetSupergroupDescription {}


impl SetSupergroupDescription {
  
  pub fn builder() -> RTDSetSupergroupDescriptionBuilder {
    let instance = Self {
      td_name: "setSupergroupDescription".to_string(),
      supergroup_id: None,
      description: None,
      
    };
    RTDSetSupergroupDescriptionBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetSupergroupDescription> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetSupergroupDescriptionBuilder { instance: SetSupergroupDescription }

impl RTDSetSupergroupDescriptionBuilder {
  fn new(instance: SetSupergroupDescription) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupDescription { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn description<S: AsRef<str>>(&mut self, description: S) -> &mut Self {
    self.instance.description = Some(description.as_ref().to_string());
    self
  }
  
}



/// Changes the sticker set of a supergroup; requires appropriate rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupStickerSet
  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set.
  sticker_set_id: Option<i64>,
  
}



impl Object for SetSupergroupStickerSet {}
impl RObject for SetSupergroupStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupStickerSet }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetSupergroupStickerSet {}


impl SetSupergroupStickerSet {
  
  pub fn builder() -> RTDSetSupergroupStickerSetBuilder {
    let instance = Self {
      td_name: "setSupergroupStickerSet".to_string(),
      supergroup_id: None,
      sticker_set_id: None,
      
    };
    RTDSetSupergroupStickerSetBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetSupergroupStickerSet> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetSupergroupStickerSetBuilder { instance: SetSupergroupStickerSet }

impl RTDSetSupergroupStickerSetBuilder {
  fn new(instance: SetSupergroupStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupStickerSet { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
}



/// Changes the username of a supergroup or channel, requires creator privileges in the supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupUsername
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New value of the username. Use an empty string to remove the username.
  username: Option<String>,
  
}



impl Object for SetSupergroupUsername {}
impl RObject for SetSupergroupUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupUsername" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupUsername }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetSupergroupUsername {}


impl SetSupergroupUsername {
  
  pub fn builder() -> RTDSetSupergroupUsernameBuilder {
    let instance = Self {
      td_name: "setSupergroupUsername".to_string(),
      supergroup_id: None,
      username: None,
      
    };
    RTDSetSupergroupUsernameBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetSupergroupUsername> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetSupergroupUsernameBuilder { instance: SetSupergroupUsername }

impl RTDSetSupergroupUsernameBuilder {
  fn new(instance: SetSupergroupUsername) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupUsername { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
}



/// Sets the parameters for TDLib initialization. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setTdlibParameters
  /// Parameters.
  parameters: Option<TdlibParameters>,
  
}



impl Object for SetTdlibParameters {}
impl RObject for SetTdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setTdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::SetTdlibParameters }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetTdlibParameters {}


impl SetTdlibParameters {
  
  pub fn builder() -> RTDSetTdlibParametersBuilder {
    let instance = Self {
      td_name: "setTdlibParameters".to_string(),
      parameters: None,
      
    };
    RTDSetTdlibParametersBuilder::new(instance)
  }
  
  
  pub fn parameters(&self) -> Option<TdlibParameters> { self.parameters.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetTdlibParameters> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetTdlibParametersBuilder { instance: SetTdlibParameters }

impl RTDSetTdlibParametersBuilder {
  fn new(instance: SetTdlibParameters) -> Self { Self { instance } }

  pub fn build(&self) -> SetTdlibParameters { self.instance.clone() }
  
  pub fn parameters(&mut self, parameters: TdlibParameters) -> &mut Self {
    self.instance.parameters = Some(parameters);
    self
  }
  
}



/// Changes user privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// The new privacy rules.
  rules: Option<UserPrivacySettingRules>,
  
}


impl Clone for SetUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for SetUserPrivacySettingRules {}
impl RObject for SetUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::SetUserPrivacySettingRules }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetUserPrivacySettingRules {}


impl SetUserPrivacySettingRules {
  
  pub fn builder() -> RTDSetUserPrivacySettingRulesBuilder {
    let instance = Self {
      td_name: "setUserPrivacySettingRules".to_string(),
      setting: None,
      rules: None,
      
    };
    RTDSetUserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn rules(&self) -> Option<UserPrivacySettingRules> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetUserPrivacySettingRules> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetUserPrivacySettingRulesBuilder { instance: SetUserPrivacySettingRules }

impl RTDSetUserPrivacySettingRulesBuilder {
  fn new(instance: SetUserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> SetUserPrivacySettingRules { self.instance.clone() }
  
  pub fn setting(&mut self, setting: Box<UserPrivacySetting>) -> &mut Self {
    self.instance.setting = Some(setting);
    self
  }
  
  pub fn rules(&mut self, rules: UserPrivacySettingRules) -> &mut Self {
    self.instance.rules = Some(rules);
    self
  }
  
}



/// Changes the username of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setUsername
  /// The new value of the username. Use an empty string to remove the username.
  username: Option<String>,
  
}



impl Object for SetUsername {}
impl RObject for SetUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setUsername" }
  fn td_type(&self) -> RTDType { RTDType::SetUsername }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SetUsername {}


impl SetUsername {
  
  pub fn builder() -> RTDSetUsernameBuilder {
    let instance = Self {
      td_name: "setUsername".to_string(),
      username: None,
      
    };
    RTDSetUsernameBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SetUsername> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSetUsernameBuilder { instance: SetUsername }

impl RTDSetUsernameBuilder {
  fn new(instance: SetUsername) -> Self { Self { instance } }

  pub fn build(&self) -> SetUsername { self.instance.clone() }
  
  pub fn username<S: AsRef<str>>(&mut self, username: S) -> &mut Self {
    self.instance.username = Some(username.as_ref().to_string());
    self
  }
  
}



/// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set.
#[derive(Debug, Serialize, Deserialize)]
pub struct StopPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stopPoll
  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for StopPoll {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for StopPoll {}
impl RObject for StopPoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stopPoll" }
  fn td_type(&self) -> RTDType { RTDType::StopPoll }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for StopPoll {}


impl StopPoll {
  
  pub fn builder() -> RTDStopPollBuilder {
    let instance = Self {
      td_name: "stopPoll".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      
    };
    RTDStopPollBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<StopPoll> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDStopPollBuilder { instance: StopPoll }

impl RTDStopPollBuilder {
  fn new(instance: StopPoll) -> Self { Self { instance } }

  pub fn build(&self) -> StopPoll { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}



/// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynchronizeLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // synchronizeLanguagePack
  /// Language pack identifier.
  language_pack_id: Option<String>,
  
}



impl Object for SynchronizeLanguagePack {}
impl RObject for SynchronizeLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "synchronizeLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::SynchronizeLanguagePack }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for SynchronizeLanguagePack {}


impl SynchronizeLanguagePack {
  
  pub fn builder() -> RTDSynchronizeLanguagePackBuilder {
    let instance = Self {
      td_name: "synchronizeLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    RTDSynchronizeLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<SynchronizeLanguagePack> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDSynchronizeLanguagePackBuilder { instance: SynchronizeLanguagePack }

impl RTDSynchronizeLanguagePackBuilder {
  fn new(instance: SynchronizeLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> SynchronizeLanguagePack { self.instance.clone() }
  
  pub fn language_pack_id<S: AsRef<str>>(&mut self, language_pack_id: S) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id.as_ref().to_string());
    self
  }
  
}



/// Terminates all other sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateAllOtherSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // terminateAllOtherSessions
  
}



impl Object for TerminateAllOtherSessions {}
impl RObject for TerminateAllOtherSessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "terminateAllOtherSessions" }
  fn td_type(&self) -> RTDType { RTDType::TerminateAllOtherSessions }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TerminateAllOtherSessions {}


impl TerminateAllOtherSessions {
  
  pub fn builder() -> RTDTerminateAllOtherSessionsBuilder {
    let instance = Self {
      td_name: "terminateAllOtherSessions".to_string(),
      
    };
    RTDTerminateAllOtherSessionsBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TerminateAllOtherSessions> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTerminateAllOtherSessionsBuilder { instance: TerminateAllOtherSessions }

impl RTDTerminateAllOtherSessionsBuilder {
  fn new(instance: TerminateAllOtherSessions) -> Self { Self { instance } }

  pub fn build(&self) -> TerminateAllOtherSessions { self.instance.clone() }
  
}



/// Terminates a session of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateSession {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // terminateSession
  /// Session identifier.
  session_id: Option<i64>,
  
}



impl Object for TerminateSession {}
impl RObject for TerminateSession {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "terminateSession" }
  fn td_type(&self) -> RTDType { RTDType::TerminateSession }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TerminateSession {}


impl TerminateSession {
  
  pub fn builder() -> RTDTerminateSessionBuilder {
    let instance = Self {
      td_name: "terminateSession".to_string(),
      session_id: None,
      
    };
    RTDTerminateSessionBuilder::new(instance)
  }
  
  
  pub fn session_id(&self) -> Option<i64> { self.session_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TerminateSession> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTerminateSessionBuilder { instance: TerminateSession }

impl RTDTerminateSessionBuilder {
  fn new(instance: TerminateSession) -> Self { Self { instance } }

  pub fn build(&self) -> TerminateSession { self.instance.clone() }
  
  pub fn session_id(&mut self, session_id: i64) -> &mut Self {
    self.instance.session_id = Some(session_id);
    self
  }
  
}



/// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallBytes
  /// Bytes to return.
  x: Option<String>,
  
}



impl Object for TestCallBytes {}
impl RObject for TestCallBytes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallBytes" }
  fn td_type(&self) -> RTDType { RTDType::TestCallBytes }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallBytes {}


impl TestCallBytes {
  
  pub fn builder() -> RTDTestCallBytesBuilder {
    let instance = Self {
      td_name: "testCallBytes".to_string(),
      x: None,
      
    };
    RTDTestCallBytesBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<String> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallBytes> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallBytesBuilder { instance: TestCallBytes }

impl RTDTestCallBytesBuilder {
  fn new(instance: TestCallBytes) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallBytes { self.instance.clone() }
  
  pub fn x<S: AsRef<str>>(&mut self, x: S) -> &mut Self {
    self.instance.x = Some(x.as_ref().to_string());
    self
  }
  
}



/// Does nothing; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallEmpty
  
}



impl Object for TestCallEmpty {}
impl RObject for TestCallEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallEmpty" }
  fn td_type(&self) -> RTDType { RTDType::TestCallEmpty }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallEmpty {}


impl TestCallEmpty {
  
  pub fn builder() -> RTDTestCallEmptyBuilder {
    let instance = Self {
      td_name: "testCallEmpty".to_string(),
      
    };
    RTDTestCallEmptyBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallEmpty> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallEmptyBuilder { instance: TestCallEmpty }

impl RTDTestCallEmptyBuilder {
  fn new(instance: TestCallEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallEmpty { self.instance.clone() }
  
}



/// Returns the received string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallString
  /// String to return.
  x: Option<String>,
  
}



impl Object for TestCallString {}
impl RObject for TestCallString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallString" }
  fn td_type(&self) -> RTDType { RTDType::TestCallString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallString {}


impl TestCallString {
  
  pub fn builder() -> RTDTestCallStringBuilder {
    let instance = Self {
      td_name: "testCallString".to_string(),
      x: None,
      
    };
    RTDTestCallStringBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<String> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallStringBuilder { instance: TestCallString }

impl RTDTestCallStringBuilder {
  fn new(instance: TestCallString) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallString { self.instance.clone() }
  
  pub fn x<S: AsRef<str>>(&mut self, x: S) -> &mut Self {
    self.instance.x = Some(x.as_ref().to_string());
    self
  }
  
}



/// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorInt
  /// Vector of numbers to return.
  x: Option<Vec<i32>>,
  
}



impl Object for TestCallVectorInt {}
impl RObject for TestCallVectorInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorInt" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorInt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallVectorInt {}


impl TestCallVectorInt {
  
  pub fn builder() -> RTDTestCallVectorIntBuilder {
    let instance = Self {
      td_name: "testCallVectorInt".to_string(),
      x: None,
      
    };
    RTDTestCallVectorIntBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<Vec<i32>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallVectorInt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallVectorIntBuilder { instance: TestCallVectorInt }

impl RTDTestCallVectorIntBuilder {
  fn new(instance: TestCallVectorInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorInt { self.instance.clone() }
  
  pub fn x(&mut self, x: Vec<i32>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}



/// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorIntObject
  /// Vector of objects to return.
  x: Option<Vec<TestInt>>,
  
}



impl Object for TestCallVectorIntObject {}
impl RObject for TestCallVectorIntObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorIntObject" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorIntObject }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallVectorIntObject {}


impl TestCallVectorIntObject {
  
  pub fn builder() -> RTDTestCallVectorIntObjectBuilder {
    let instance = Self {
      td_name: "testCallVectorIntObject".to_string(),
      x: None,
      
    };
    RTDTestCallVectorIntObjectBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<Vec<TestInt>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallVectorIntObject> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallVectorIntObjectBuilder { instance: TestCallVectorIntObject }

impl RTDTestCallVectorIntObjectBuilder {
  fn new(instance: TestCallVectorIntObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorIntObject { self.instance.clone() }
  
  pub fn x(&mut self, x: Vec<TestInt>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}



/// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorString
  /// Vector of strings to return.
  x: Option<Vec<String>>,
  
}



impl Object for TestCallVectorString {}
impl RObject for TestCallVectorString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorString" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorString }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallVectorString {}


impl TestCallVectorString {
  
  pub fn builder() -> RTDTestCallVectorStringBuilder {
    let instance = Self {
      td_name: "testCallVectorString".to_string(),
      x: None,
      
    };
    RTDTestCallVectorStringBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<Vec<String>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallVectorString> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallVectorStringBuilder { instance: TestCallVectorString }

impl RTDTestCallVectorStringBuilder {
  fn new(instance: TestCallVectorString) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorString { self.instance.clone() }
  
  pub fn x(&mut self, x: Vec<String>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}



/// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorStringObject
  /// Vector of objects to return.
  x: Option<Vec<TestString>>,
  
}



impl Object for TestCallVectorStringObject {}
impl RObject for TestCallVectorStringObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorStringObject" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorStringObject }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestCallVectorStringObject {}


impl TestCallVectorStringObject {
  
  pub fn builder() -> RTDTestCallVectorStringObjectBuilder {
    let instance = Self {
      td_name: "testCallVectorStringObject".to_string(),
      x: None,
      
    };
    RTDTestCallVectorStringObjectBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<Vec<TestString>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestCallVectorStringObject> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestCallVectorStringObjectBuilder { instance: TestCallVectorStringObject }

impl RTDTestCallVectorStringObjectBuilder {
  fn new(instance: TestCallVectorStringObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorStringObject { self.instance.clone() }
  
  pub fn x(&mut self, x: Vec<TestString>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}



/// Forces an updates.getDifference call to the Telegram servers; for testing only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestGetDifference {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testGetDifference
  
}



impl Object for TestGetDifference {}
impl RObject for TestGetDifference {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testGetDifference" }
  fn td_type(&self) -> RTDType { RTDType::TestGetDifference }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestGetDifference {}


impl TestGetDifference {
  
  pub fn builder() -> RTDTestGetDifferenceBuilder {
    let instance = Self {
      td_name: "testGetDifference".to_string(),
      
    };
    RTDTestGetDifferenceBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestGetDifference> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestGetDifferenceBuilder { instance: TestGetDifference }

impl RTDTestGetDifferenceBuilder {
  fn new(instance: TestGetDifference) -> Self { Self { instance } }

  pub fn build(&self) -> TestGetDifference { self.instance.clone() }
  
}



/// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testNetwork
  
}



impl Object for TestNetwork {}
impl RObject for TestNetwork {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testNetwork" }
  fn td_type(&self) -> RTDType { RTDType::TestNetwork }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestNetwork {}


impl TestNetwork {
  
  pub fn builder() -> RTDTestNetworkBuilder {
    let instance = Self {
      td_name: "testNetwork".to_string(),
      
    };
    RTDTestNetworkBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestNetwork> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestNetworkBuilder { instance: TestNetwork }

impl RTDTestNetworkBuilder {
  fn new(instance: TestNetwork) -> Self { Self { instance } }

  pub fn build(&self) -> TestNetwork { self.instance.clone() }
  
}



/// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestSquareInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testSquareInt
  /// Number to square.
  x: Option<i32>,
  
}



impl Object for TestSquareInt {}
impl RObject for TestSquareInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testSquareInt" }
  fn td_type(&self) -> RTDType { RTDType::TestSquareInt }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestSquareInt {}


impl TestSquareInt {
  
  pub fn builder() -> RTDTestSquareIntBuilder {
    let instance = Self {
      td_name: "testSquareInt".to_string(),
      x: None,
      
    };
    RTDTestSquareIntBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> Option<i32> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestSquareInt> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestSquareIntBuilder { instance: TestSquareInt }

impl RTDTestSquareIntBuilder {
  fn new(instance: TestSquareInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestSquareInt { self.instance.clone() }
  
  pub fn x(&mut self, x: i32) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}



/// Does nothing and ensures that the Error object is used; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testUseError
  
}



impl Object for TestUseError {}
impl RObject for TestUseError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testUseError" }
  fn td_type(&self) -> RTDType { RTDType::TestUseError }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestUseError {}


impl TestUseError {
  
  pub fn builder() -> RTDTestUseErrorBuilder {
    let instance = Self {
      td_name: "testUseError".to_string(),
      
    };
    RTDTestUseErrorBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestUseError> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestUseErrorBuilder { instance: TestUseError }

impl RTDTestUseErrorBuilder {
  fn new(instance: TestUseError) -> Self { Self { instance } }

  pub fn build(&self) -> TestUseError { self.instance.clone() }
  
}



/// Does nothing and ensures that the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseUpdate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testUseUpdate
  
}



impl Object for TestUseUpdate {}
impl RObject for TestUseUpdate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testUseUpdate" }
  fn td_type(&self) -> RTDType { RTDType::TestUseUpdate }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for TestUseUpdate {}


impl TestUseUpdate {
  
  pub fn builder() -> RTDTestUseUpdateBuilder {
    let instance = Self {
      td_name: "testUseUpdate".to_string(),
      
    };
    RTDTestUseUpdateBuilder::new(instance)
  }
  
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<TestUseUpdate> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDTestUseUpdateBuilder { instance: TestUseUpdate }

impl RTDTestUseUpdateBuilder {
  fn new(instance: TestUseUpdate) -> Self { Self { instance } }

  pub fn build(&self) -> TestUseUpdate { self.instance.clone() }
  
}



/// Toggles the "All members are admins" setting in basic groups; requires creator privileges in the group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleBasicGroupAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleBasicGroupAdministrators
  /// Identifier of the basic group.
  basic_group_id: Option<i32>,
  /// New value of everyone_is_administrator.
  everyone_is_administrator: Option<bool>,
  
}



impl Object for ToggleBasicGroupAdministrators {}
impl RObject for ToggleBasicGroupAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleBasicGroupAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::ToggleBasicGroupAdministrators }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleBasicGroupAdministrators {}


impl ToggleBasicGroupAdministrators {
  
  pub fn builder() -> RTDToggleBasicGroupAdministratorsBuilder {
    let instance = Self {
      td_name: "toggleBasicGroupAdministrators".to_string(),
      basic_group_id: None,
      everyone_is_administrator: None,
      
    };
    RTDToggleBasicGroupAdministratorsBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn everyone_is_administrator(&self) -> Option<bool> { self.everyone_is_administrator.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleBasicGroupAdministrators> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleBasicGroupAdministratorsBuilder { instance: ToggleBasicGroupAdministrators }

impl RTDToggleBasicGroupAdministratorsBuilder {
  fn new(instance: ToggleBasicGroupAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleBasicGroupAdministrators { self.instance.clone() }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
  pub fn everyone_is_administrator(&mut self, everyone_is_administrator: bool) -> &mut Self {
    self.instance.everyone_is_administrator = Some(everyone_is_administrator);
    self
  }
  
}



/// Changes the value of the default disable_notification parameter, used when a message is sent to a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatDefaultDisableNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of default_disable_notification.
  default_disable_notification: Option<bool>,
  
}



impl Object for ToggleChatDefaultDisableNotification {}
impl RObject for ToggleChatDefaultDisableNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatDefaultDisableNotification" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatDefaultDisableNotification }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleChatDefaultDisableNotification {}


impl ToggleChatDefaultDisableNotification {
  
  pub fn builder() -> RTDToggleChatDefaultDisableNotificationBuilder {
    let instance = Self {
      td_name: "toggleChatDefaultDisableNotification".to_string(),
      chat_id: None,
      default_disable_notification: None,
      
    };
    RTDToggleChatDefaultDisableNotificationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleChatDefaultDisableNotification> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleChatDefaultDisableNotificationBuilder { instance: ToggleChatDefaultDisableNotification }

impl RTDToggleChatDefaultDisableNotificationBuilder {
  fn new(instance: ToggleChatDefaultDisableNotification) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatDefaultDisableNotification { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn default_disable_notification(&mut self, default_disable_notification: bool) -> &mut Self {
    self.instance.default_disable_notification = Some(default_disable_notification);
    self
  }
  
}



/// Changes the marked as unread state of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatIsMarkedAsUnread
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,
  
}



impl Object for ToggleChatIsMarkedAsUnread {}
impl RObject for ToggleChatIsMarkedAsUnread {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatIsMarkedAsUnread" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatIsMarkedAsUnread }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleChatIsMarkedAsUnread {}


impl ToggleChatIsMarkedAsUnread {
  
  pub fn builder() -> RTDToggleChatIsMarkedAsUnreadBuilder {
    let instance = Self {
      td_name: "toggleChatIsMarkedAsUnread".to_string(),
      chat_id: None,
      is_marked_as_unread: None,
      
    };
    RTDToggleChatIsMarkedAsUnreadBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleChatIsMarkedAsUnread> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleChatIsMarkedAsUnreadBuilder { instance: ToggleChatIsMarkedAsUnread }

impl RTDToggleChatIsMarkedAsUnreadBuilder {
  fn new(instance: ToggleChatIsMarkedAsUnread) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatIsMarkedAsUnread { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_marked_as_unread(&mut self, is_marked_as_unread: bool) -> &mut Self {
    self.instance.is_marked_as_unread = Some(is_marked_as_unread);
    self
  }
  
}



/// Changes the pinned state of a chat. You can pin up to GetOption("pinned_chat_count_max") non-secret chats and the same number of secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatIsPinned
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,
  
}



impl Object for ToggleChatIsPinned {}
impl RObject for ToggleChatIsPinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatIsPinned" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatIsPinned }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleChatIsPinned {}


impl ToggleChatIsPinned {
  
  pub fn builder() -> RTDToggleChatIsPinnedBuilder {
    let instance = Self {
      td_name: "toggleChatIsPinned".to_string(),
      chat_id: None,
      is_pinned: None,
      
    };
    RTDToggleChatIsPinnedBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleChatIsPinned> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleChatIsPinnedBuilder { instance: ToggleChatIsPinned }

impl RTDToggleChatIsPinnedBuilder {
  fn new(instance: ToggleChatIsPinned) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatIsPinned { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}



/// Toggles whether all members of a supergroup can add new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupInvites
  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,
  
}



impl Object for ToggleSupergroupInvites {}
impl RObject for ToggleSupergroupInvites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupInvites" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupInvites }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleSupergroupInvites {}


impl ToggleSupergroupInvites {
  
  pub fn builder() -> RTDToggleSupergroupInvitesBuilder {
    let instance = Self {
      td_name: "toggleSupergroupInvites".to_string(),
      supergroup_id: None,
      anyone_can_invite: None,
      
    };
    RTDToggleSupergroupInvitesBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleSupergroupInvites> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleSupergroupInvitesBuilder { instance: ToggleSupergroupInvites }

impl RTDToggleSupergroupInvitesBuilder {
  fn new(instance: ToggleSupergroupInvites) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupInvites { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
}



/// Toggles whether the message history of a supergroup is available to new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupIsAllHistoryAvailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupIsAllHistoryAvailable
  /// The identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// The new value of is_all_history_available.
  is_all_history_available: Option<bool>,
  
}



impl Object for ToggleSupergroupIsAllHistoryAvailable {}
impl RObject for ToggleSupergroupIsAllHistoryAvailable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupIsAllHistoryAvailable" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupIsAllHistoryAvailable }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleSupergroupIsAllHistoryAvailable {}


impl ToggleSupergroupIsAllHistoryAvailable {
  
  pub fn builder() -> RTDToggleSupergroupIsAllHistoryAvailableBuilder {
    let instance = Self {
      td_name: "toggleSupergroupIsAllHistoryAvailable".to_string(),
      supergroup_id: None,
      is_all_history_available: None,
      
    };
    RTDToggleSupergroupIsAllHistoryAvailableBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleSupergroupIsAllHistoryAvailable> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleSupergroupIsAllHistoryAvailableBuilder { instance: ToggleSupergroupIsAllHistoryAvailable }

impl RTDToggleSupergroupIsAllHistoryAvailableBuilder {
  fn new(instance: ToggleSupergroupIsAllHistoryAvailable) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupIsAllHistoryAvailable { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
}



/// Toggles sender signatures messages sent in a channel; requires appropriate administrator rights in the channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupSignMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupSignMessages
  /// Identifier of the channel.
  supergroup_id: Option<i32>,
  /// New value of sign_messages.
  sign_messages: Option<bool>,
  
}



impl Object for ToggleSupergroupSignMessages {}
impl RObject for ToggleSupergroupSignMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupSignMessages" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupSignMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ToggleSupergroupSignMessages {}


impl ToggleSupergroupSignMessages {
  
  pub fn builder() -> RTDToggleSupergroupSignMessagesBuilder {
    let instance = Self {
      td_name: "toggleSupergroupSignMessages".to_string(),
      supergroup_id: None,
      sign_messages: None,
      
    };
    RTDToggleSupergroupSignMessagesBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ToggleSupergroupSignMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDToggleSupergroupSignMessagesBuilder { instance: ToggleSupergroupSignMessages }

impl RTDToggleSupergroupSignMessagesBuilder {
  fn new(instance: ToggleSupergroupSignMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupSignMessages { self.instance.clone() }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
}



/// Removes a user from the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnblockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // unblockUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for UnblockUser {}
impl RObject for UnblockUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "unblockUser" }
  fn td_type(&self) -> RTDType { RTDType::UnblockUser }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for UnblockUser {}


impl UnblockUser {
  
  pub fn builder() -> RTDUnblockUserBuilder {
    let instance = Self {
      td_name: "unblockUser".to_string(),
      user_id: None,
      
    };
    RTDUnblockUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UnblockUser> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUnblockUserBuilder { instance: UnblockUser }

impl RTDUnblockUserBuilder {
  fn new(instance: UnblockUser) -> Self { Self { instance } }

  pub fn build(&self) -> UnblockUser { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}



/// Removes the pinned message from a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnpinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // unpinChatMessage
  /// Identifier of the chat.
  chat_id: Option<i64>,
  
}



impl Object for UnpinChatMessage {}
impl RObject for UnpinChatMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "unpinChatMessage" }
  fn td_type(&self) -> RTDType { RTDType::UnpinChatMessage }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for UnpinChatMessage {}


impl UnpinChatMessage {
  
  pub fn builder() -> RTDUnpinChatMessageBuilder {
    let instance = Self {
      td_name: "unpinChatMessage".to_string(),
      chat_id: None,
      
    };
    RTDUnpinChatMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UnpinChatMessage> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUnpinChatMessageBuilder { instance: UnpinChatMessage }

impl RTDUnpinChatMessageBuilder {
  fn new(instance: UnpinChatMessage) -> Self { Self { instance } }

  pub fn build(&self) -> UnpinChatMessage { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Creates a new supergroup from an existing basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpgradeBasicGroupChatToSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // upgradeBasicGroupChatToSupergroupChat
  /// Identifier of the chat to upgrade.
  chat_id: Option<i64>,
  
}



impl Object for UpgradeBasicGroupChatToSupergroupChat {}
impl RObject for UpgradeBasicGroupChatToSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "upgradeBasicGroupChatToSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::UpgradeBasicGroupChatToSupergroupChat }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for UpgradeBasicGroupChatToSupergroupChat {}


impl UpgradeBasicGroupChatToSupergroupChat {
  
  pub fn builder() -> RTDUpgradeBasicGroupChatToSupergroupChatBuilder {
    let instance = Self {
      td_name: "upgradeBasicGroupChatToSupergroupChat".to_string(),
      chat_id: None,
      
    };
    RTDUpgradeBasicGroupChatToSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UpgradeBasicGroupChatToSupergroupChat> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUpgradeBasicGroupChatToSupergroupChatBuilder { instance: UpgradeBasicGroupChatToSupergroupChat }

impl RTDUpgradeBasicGroupChatToSupergroupChatBuilder {
  fn new(instance: UpgradeBasicGroupChatToSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> UpgradeBasicGroupChatToSupergroupChat { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}



/// Asynchronously uploads a file to the cloud without sending it in a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // uploadFile
  /// File to upload.
  file: Option<Box<InputFile>>,
  /// File type.
  file_type: Option<Box<FileType>>,
  /// Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first.
  priority: Option<i32>,
  
}


impl Clone for UploadFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UploadFile {}
impl RObject for UploadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "uploadFile" }
  fn td_type(&self) -> RTDType { RTDType::UploadFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for UploadFile {}


impl UploadFile {
  
  pub fn builder() -> RTDUploadFileBuilder {
    let instance = Self {
      td_name: "uploadFile".to_string(),
      file: None,
      file_type: None,
      priority: None,
      
    };
    RTDUploadFileBuilder::new(instance)
  }
  
  
  pub fn file(&self) -> Option<Box<InputFile>> { self.file.clone() }
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn priority(&self) -> Option<i32> { self.priority.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UploadFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUploadFileBuilder { instance: UploadFile }

impl RTDUploadFileBuilder {
  fn new(instance: UploadFile) -> Self { Self { instance } }

  pub fn build(&self) -> UploadFile { self.instance.clone() }
  
  pub fn file(&mut self, file: Box<InputFile>) -> &mut Self {
    self.instance.file = Some(file);
    self
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn priority(&mut self, priority: i32) -> &mut Self {
    self.instance.priority = Some(priority);
    self
  }
  
}



/// Uploads a PNG image with a sticker; for bots only; returns the uploaded file.
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadStickerFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // uploadStickerFile
  /// Sticker file owner.
  user_id: Option<i32>,
  /// PNG image with the sticker; must be up to 512 kB in size and fit in 512x512 square.
  png_sticker: Option<Box<InputFile>>,
  
}


impl Clone for UploadStickerFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


impl Object for UploadStickerFile {}
impl RObject for UploadStickerFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "uploadStickerFile" }
  fn td_type(&self) -> RTDType { RTDType::UploadStickerFile }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for UploadStickerFile {}


impl UploadStickerFile {
  
  pub fn builder() -> RTDUploadStickerFileBuilder {
    let instance = Self {
      td_name: "uploadStickerFile".to_string(),
      user_id: None,
      png_sticker: None,
      
    };
    RTDUploadStickerFileBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn png_sticker(&self) -> Option<Box<InputFile>> { self.png_sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<UploadStickerFile> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDUploadStickerFileBuilder { instance: UploadStickerFile }

impl RTDUploadStickerFileBuilder {
  fn new(instance: UploadStickerFile) -> Self { Self { instance } }

  pub fn build(&self) -> UploadStickerFile { self.instance.clone() }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn png_sticker(&mut self, png_sticker: Box<InputFile>) -> &mut Self {
    self.instance.png_sticker = Some(png_sticker);
    self
  }
  
}



/// Validates the order information provided by a user and returns the available shipping options for a flexible invoice.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidateOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // validateOrderInfo
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The order information, provided by the user.
  order_info: Option<OrderInfo>,
  /// True, if the order information can be saved.
  allow_save: Option<bool>,
  
}



impl Object for ValidateOrderInfo {}
impl RObject for ValidateOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "validateOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::ValidateOrderInfo }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ValidateOrderInfo {}


impl ValidateOrderInfo {
  
  pub fn builder() -> RTDValidateOrderInfoBuilder {
    let instance = Self {
      td_name: "validateOrderInfo".to_string(),
      chat_id: None,
      message_id: None,
      order_info: None,
      allow_save: None,
      
    };
    RTDValidateOrderInfoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn allow_save(&self) -> Option<bool> { self.allow_save.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ValidateOrderInfo> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDValidateOrderInfoBuilder { instance: ValidateOrderInfo }

impl RTDValidateOrderInfoBuilder {
  fn new(instance: ValidateOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ValidateOrderInfo { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn allow_save(&mut self, allow_save: bool) -> &mut Self {
    self.instance.allow_save = Some(allow_save);
    self
  }
  
}



/// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // viewMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The identifiers of the messages being viewed.
  message_ids: Option<Vec<i64>>,
  /// True, if messages in closed chats should be marked as read.
  force_read: Option<bool>,
  
}



impl Object for ViewMessages {}
impl RObject for ViewMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "viewMessages" }
  fn td_type(&self) -> RTDType { RTDType::ViewMessages }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ViewMessages {}


impl ViewMessages {
  
  pub fn builder() -> RTDViewMessagesBuilder {
    let instance = Self {
      td_name: "viewMessages".to_string(),
      chat_id: None,
      message_ids: None,
      force_read: None,
      
    };
    RTDViewMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn force_read(&self) -> Option<bool> { self.force_read.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ViewMessages> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDViewMessagesBuilder { instance: ViewMessages }

impl RTDViewMessagesBuilder {
  fn new(instance: ViewMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ViewMessages { self.instance.clone() }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn force_read(&mut self, force_read: bool) -> &mut Self {
    self.instance.force_read = Some(force_read);
    self
  }
  
}



/// Informs the server that some trending sticker sets have been viewed by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // viewTrendingStickerSets
  /// Identifiers of viewed trending sticker sets.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for ViewTrendingStickerSets {}
impl RObject for ViewTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "viewTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::ViewTrendingStickerSets }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for ViewTrendingStickerSets {}


impl ViewTrendingStickerSets {
  
  pub fn builder() -> RTDViewTrendingStickerSetsBuilder {
    let instance = Self {
      td_name: "viewTrendingStickerSets".to_string(),
      sticker_set_ids: None,
      
    };
    RTDViewTrendingStickerSetsBuilder::new(instance)
  }
  
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<ViewTrendingStickerSets> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDViewTrendingStickerSetsBuilder { instance: ViewTrendingStickerSets }

impl RTDViewTrendingStickerSetsBuilder {
  fn new(instance: ViewTrendingStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> ViewTrendingStickerSets { self.instance.clone() }
  
  pub fn sticker_set_ids(&mut self, sticker_set_ids: Vec<i64>) -> &mut Self {
    self.instance.sticker_set_ids = Some(sticker_set_ids);
    self
  }
  
}



/// Writes a part of a generated file. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WriteGeneratedFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // writeGeneratedFilePart
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// The offset from which to write the data to the file.
  offset: Option<i32>,
  /// The data to write.
  data: Option<String>,
  
}



impl Object for WriteGeneratedFilePart {}
impl RObject for WriteGeneratedFilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "writeGeneratedFilePart" }
  fn td_type(&self) -> RTDType { RTDType::WriteGeneratedFilePart }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}


impl Function for WriteGeneratedFilePart {}


impl WriteGeneratedFilePart {
  
  pub fn builder() -> RTDWriteGeneratedFilePartBuilder {
    let instance = Self {
      td_name: "writeGeneratedFilePart".to_string(),
      generation_id: None,
      offset: None,
      data: None,
      
    };
    RTDWriteGeneratedFilePartBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<WriteGeneratedFilePart> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}


#[derive(Debug)]
pub struct RTDWriteGeneratedFilePartBuilder { instance: WriteGeneratedFilePart }

impl RTDWriteGeneratedFilePartBuilder {
  fn new(instance: WriteGeneratedFilePart) -> Self { Self { instance } }

  pub fn build(&self) -> WriteGeneratedFilePart { self.instance.clone() }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn data<S: AsRef<str>>(&mut self, data: S) -> &mut Self {
    self.instance.data = Some(data.as_ref().to_string());
    self
  }
  
}



