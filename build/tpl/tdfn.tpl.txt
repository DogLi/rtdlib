{% if td.clz_description %}/// {{ td.clz_description }}{% endif %}
{% if td.clz_is_trait %}{% if td.set_trait_typetag %}#[typetag::serde(tag = "@struct")]{% endif %}{% else %}#[derive(Debug, {% if not td.has_trait_field %}Clone, {% endif %}Serialize, Deserialize)]{% endif %}
{% if not td.is_private %}pub {% endif %}{% if td.clz_is_trait %}trait{% else %}struct{% endif %} {{ td.clz_name }}{% if td.clz_is_trait %}: {% if td.clz_name != 'Object' %}Object + {% endif %}RObject + Debug {}{% else %} {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // {{ td.origin_name }}
  {% if td.fields %}{% for field in td.fields %}/// {{field.description}}
  {% if field.name == 'type_' %}#[serde(rename(serialize = "type", deserialize = "type"))] {% endif %}{{field.name}}: {{field.class | field_type(td = td, field_name = field.name, wrap_option = true)}},
  {% endfor %}{% endif %}
}
{% endif %}
{% if td.has_trait_field %}
impl Clone for {{ td.clz_name }} {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}
{% endif %}
{% if not td.clz_is_trait %}
impl Object for {{ td.clz_name }} {}
impl RObject for {{ td.clz_name }} {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "{{ td.origin_name }}" }
  fn td_type(&self) -> RTDType { RTDType::{{ td.clz_name }} }
  fn to_json(&self) -> String { tdkit::fill_json_struct(serde_json::to_string(self).unwrap()) }
}
{% endif %}
{% if td.clz_super and td.clz_super != 'Object' and td.clz_super != 'TlObject' %}
{% if td.impl_trait_typetag %}#[typetag::serde] {% endif %}impl {{ td.clz_super }} for {{ td.clz_name }} {}
{% endif %}
{% if not td.is_private and not td.clz_is_trait %}
impl {{ td.clz_name }} {
  {% if td.has_builder_struct %}
  pub fn builder() -> RTD{{ td.clz_name }}Builder {
    let instance = Self {
      td_name: "{{ td.origin_name }}".to_string(),
      {% if td.fields %}{% for field in td.fields %}{{field.name}}: None,
      {% endfor %}{% endif %}
    };
    RTD{{ td.clz_name }}Builder::new(instance)
  }
  {% endif %}
  {% if td.fields %}{% for field in td.fields %}
  pub fn {{field.name}}(&self) -> {{field.class | field_type(td = td, field_name = field.name, wrap_option = true)}} { self.{{field.name}}.clone() }
  {% endfor %}{% endif %}
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<{{ td.clz_name }}> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
{% endif %}
{% if td.has_builder_struct %}
#[derive(Debug)]
pub struct RTD{{ td.clz_name }}Builder { instance: {{ td.clz_name }} }

impl RTD{{ td.clz_name }}Builder {
  fn new(instance: {{ td.clz_name }}) -> Self { Self { instance } }

  pub fn build(&self) -> {{ td.clz_name }} { self.instance.clone() }
  {% if td.fields %}{% for field in td.fields %}
  {% set field_class = field.class | field_type(td = td, field_name = field.name, wrap_option = false) -%}
  pub fn {{field.name}}{% if field_class == 'String' %}<S: AsRef<str>>{% endif %}(&mut self, {{field.name}}: {% if field_class == 'String' %}S{% else %}{{field_class}}{% endif %}) -> &mut Self {
    self.instance.{{field.name}} = Some({{field.name}}{% if field_class == 'String' %}.as_ref().to_string(){% endif %});
    self
  }
  {% endfor %}{% endif %}
}
{% endif %}
{% if td.clz_is_trait %}
{% if td.clz_name != 'Object' and td.clz_name != 'Function' %}
impl {{ td.clz_name }} {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<{{ td.clz_name }}>> {
    match serde_json::from_str(&tdkit::fill_json_struct(json.as_ref())[..]) { Ok(t) => t, Err(_) => None }
  }
}
impl Clone for Box<{{td.clz_name}}> {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}
{% endif %}
{% if td.has_subclasses and td.clz_name != 'Object' %}
#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTD{{td.clz_name}}Type {
  {% for sub in td.sub_classes %}{{ sub }},
  {% endfor %}
}
impl RTD{{td.clz_name}}Type {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { match Self::from_str(&tdkit::uppercase_first_char(text.as_ref())[..]) { Ok(t) => Some(t), Err(_) => None } }
}
{% endif %}
{% endif %}
