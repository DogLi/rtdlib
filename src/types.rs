
use std::fmt::Debug;
use std::str::FromStr;
use crate::tdkit;

macro_rules! from_json {
  () => {
    |json| match serde_json::from_str(&tdkit::fill_json_struct(json)[..]) {
      Ok(t) => t,
      Err(e) => {
        eprintln!("{:?}", e);
        None
      }
    }
  };
}

macro_rules! rtd_of {
  ($rtd_type:ident) => {
    |text| match $rtd_type::from_str(&tdkit::uppercase_first_char(text)[..]) {
      Ok(t) => Some(t),
      Err(e) => {
        eprintln!("{:?}", e);
        None
      }
    }
  };
}

macro_rules! rtd_clone {
  () => {
    |obj| {
      let json = serde_json::to_string(obj).unwrap();
      serde_json::from_str(&json[..]).unwrap()
    }
  }
}

macro_rules! rtd_to_json {
  () => {
    |obj| tdkit::fill_json_struct(serde_json::to_string(obj).unwrap())
  }
}


/// All tdlib type abstract class defined the same behavior
pub trait RObject {
 #[doc(hidden)] fn td_name(&self) -> &'static str;
 /// convert TDLib type to rust enum RTDType
 fn td_type(&self) -> RTDType;
 /// The string that implements the return of to_json should be called `tdkit::fill_json_struct` for optimization,
 /// appending the `@struct` field, although usually struct will actively generate `@struct`, but not in `Object` and `Function`,
 /// because the implementation of typetag cannot be automatically generated.
 fn to_json(&self) -> String;
}

/// This class is a base class for all TDLib TL-objects.
/// This parent class is not important and will not be implemented for every class.
trait TlObject: Debug + Clone {}

/// TDLib all class name mappers
#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDType {
  Object,
  Function,
  AccountTtl,
  Address,
  Animation,
  Animations,
  Audio,
  AuthenticationCodeInfo,
  AuthenticationCodeType,
  AuthenticationCodeTypeTelegramMessage,
  AuthenticationCodeTypeSms,
  AuthenticationCodeTypeCall,
  AuthenticationCodeTypeFlashCall,
  AuthorizationState,
  AuthorizationStateWaitTdlibParameters,
  AuthorizationStateWaitEncryptionKey,
  AuthorizationStateWaitPhoneNumber,
  AuthorizationStateWaitCode,
  AuthorizationStateWaitPassword,
  AuthorizationStateReady,
  AuthorizationStateLoggingOut,
  AuthorizationStateClosing,
  AuthorizationStateClosed,
  BasicGroup,
  BasicGroupFullInfo,
  BotCommand,
  BotInfo,
  Call,
  CallConnection,
  CallDiscardReason,
  CallDiscardReasonEmpty,
  CallDiscardReasonMissed,
  CallDiscardReasonDeclined,
  CallDiscardReasonDisconnected,
  CallDiscardReasonHungUp,
  CallId,
  CallProtocol,
  CallState,
  CallStatePending,
  CallStateExchangingKeys,
  CallStateReady,
  CallStateHangingUp,
  CallStateDiscarded,
  CallStateError,
  CallbackQueryAnswer,
  CallbackQueryPayload,
  CallbackQueryPayloadData,
  CallbackQueryPayloadGame,
  Chat,
  ChatAction,
  ChatActionTyping,
  ChatActionRecordingVideo,
  ChatActionUploadingVideo,
  ChatActionRecordingVoiceNote,
  ChatActionUploadingVoiceNote,
  ChatActionUploadingPhoto,
  ChatActionUploadingDocument,
  ChatActionChoosingLocation,
  ChatActionChoosingContact,
  ChatActionStartPlayingGame,
  ChatActionRecordingVideoNote,
  ChatActionUploadingVideoNote,
  ChatActionCancel,
  ChatEvent,
  ChatEventAction,
  ChatEventMessageEdited,
  ChatEventMessageDeleted,
  ChatEventMessagePinned,
  ChatEventMessageUnpinned,
  ChatEventMemberJoined,
  ChatEventMemberLeft,
  ChatEventMemberInvited,
  ChatEventMemberPromoted,
  ChatEventMemberRestricted,
  ChatEventTitleChanged,
  ChatEventDescriptionChanged,
  ChatEventUsernameChanged,
  ChatEventPhotoChanged,
  ChatEventInvitesToggled,
  ChatEventSignMessagesToggled,
  ChatEventStickerSetChanged,
  ChatEventIsAllHistoryAvailableToggled,
  ChatEventLogFilters,
  ChatEvents,
  ChatInviteLink,
  ChatInviteLinkInfo,
  ChatMember,
  ChatMemberStatus,
  ChatMemberStatusCreator,
  ChatMemberStatusAdministrator,
  ChatMemberStatusMember,
  ChatMemberStatusRestricted,
  ChatMemberStatusLeft,
  ChatMemberStatusBanned,
  ChatMembers,
  ChatMembersFilter,
  ChatMembersFilterAdministrators,
  ChatMembersFilterMembers,
  ChatMembersFilterRestricted,
  ChatMembersFilterBanned,
  ChatMembersFilterBots,
  ChatNotificationSettings,
  ChatPhoto,
  ChatReportReason,
  ChatReportReasonSpam,
  ChatReportReasonViolence,
  ChatReportReasonPornography,
  ChatReportReasonChildAbuse,
  ChatReportReasonCopyright,
  ChatReportReasonCustom,
  ChatReportSpamState,
  ChatType,
  ChatTypePrivate,
  ChatTypeBasicGroup,
  ChatTypeSupergroup,
  ChatTypeSecret,
  Chats,
  CheckChatUsernameResult,
  CheckChatUsernameResultOk,
  CheckChatUsernameResultUsernameInvalid,
  CheckChatUsernameResultUsernameOccupied,
  CheckChatUsernameResultPublicChatsTooMuch,
  CheckChatUsernameResultPublicGroupsUnavailable,
  ConnectedWebsite,
  ConnectedWebsites,
  ConnectionState,
  ConnectionStateWaitingForNetwork,
  ConnectionStateConnectingToProxy,
  ConnectionStateConnecting,
  ConnectionStateUpdating,
  ConnectionStateReady,
  Contact,
  Count,
  CustomRequestResult,
  DatabaseStatistics,
  Date,
  DatedFile,
  DeepLinkInfo,
  DeviceToken,
  DeviceTokenFirebaseCloudMessaging,
  DeviceTokenApplePush,
  DeviceTokenApplePushVoIP,
  DeviceTokenWindowsPush,
  DeviceTokenMicrosoftPush,
  DeviceTokenMicrosoftPushVoIP,
  DeviceTokenWebPush,
  DeviceTokenSimplePush,
  DeviceTokenUbuntuPush,
  DeviceTokenBlackBerryPush,
  DeviceTokenTizenPush,
  Document,
  DraftMessage,
  EmailAddressAuthenticationCodeInfo,
  EncryptedCredentials,
  EncryptedPassportElement,
  Error,
  File,
  FilePart,
  FileType,
  FileTypeNone,
  FileTypeAnimation,
  FileTypeAudio,
  FileTypeDocument,
  FileTypePhoto,
  FileTypeProfilePhoto,
  FileTypeSecret,
  FileTypeSecretThumbnail,
  FileTypeSecure,
  FileTypeSticker,
  FileTypeThumbnail,
  FileTypeUnknown,
  FileTypeVideo,
  FileTypeVideoNote,
  FileTypeVoiceNote,
  FileTypeWallpaper,
  FormattedText,
  FoundMessages,
  Game,
  GameHighScore,
  GameHighScores,
  Hashtags,
  HttpUrl,
  IdentityDocument,
  ImportedContacts,
  InlineKeyboardButton,
  InlineKeyboardButtonType,
  InlineKeyboardButtonTypeUrl,
  InlineKeyboardButtonTypeCallback,
  InlineKeyboardButtonTypeCallbackGame,
  InlineKeyboardButtonTypeSwitchInline,
  InlineKeyboardButtonTypeBuy,
  InlineQueryResult,
  InlineQueryResultArticle,
  InlineQueryResultContact,
  InlineQueryResultLocation,
  InlineQueryResultVenue,
  InlineQueryResultGame,
  InlineQueryResultAnimation,
  InlineQueryResultAudio,
  InlineQueryResultDocument,
  InlineQueryResultPhoto,
  InlineQueryResultSticker,
  InlineQueryResultVideo,
  InlineQueryResultVoiceNote,
  InlineQueryResults,
  InputCredentials,
  InputCredentialsSaved,
  InputCredentialsNew,
  InputCredentialsAndroidPay,
  InputCredentialsApplePay,
  InputFile,
  InputFileId,
  InputFileRemote,
  InputFileLocal,
  InputFileGenerated,
  InputIdentityDocument,
  InputInlineQueryResult,
  InputInlineQueryResultAnimatedGif,
  InputInlineQueryResultAnimatedMpeg4,
  InputInlineQueryResultArticle,
  InputInlineQueryResultAudio,
  InputInlineQueryResultContact,
  InputInlineQueryResultDocument,
  InputInlineQueryResultGame,
  InputInlineQueryResultLocation,
  InputInlineQueryResultPhoto,
  InputInlineQueryResultSticker,
  InputInlineQueryResultVenue,
  InputInlineQueryResultVideo,
  InputInlineQueryResultVoiceNote,
  InputMessageContent,
  InputMessageText,
  InputMessageAnimation,
  InputMessageAudio,
  InputMessageDocument,
  InputMessagePhoto,
  InputMessageSticker,
  InputMessageVideo,
  InputMessageVideoNote,
  InputMessageVoiceNote,
  InputMessageLocation,
  InputMessageVenue,
  InputMessageContact,
  InputMessageGame,
  InputMessageInvoice,
  InputMessagePoll,
  InputMessageForwarded,
  InputPassportElement,
  InputPassportElementPersonalDetails,
  InputPassportElementPassport,
  InputPassportElementDriverLicense,
  InputPassportElementIdentityCard,
  InputPassportElementInternalPassport,
  InputPassportElementAddress,
  InputPassportElementUtilityBill,
  InputPassportElementBankStatement,
  InputPassportElementRentalAgreement,
  InputPassportElementPassportRegistration,
  InputPassportElementTemporaryRegistration,
  InputPassportElementPhoneNumber,
  InputPassportElementEmailAddress,
  InputPassportElementError,
  InputPassportElementErrorSource,
  InputPassportElementErrorSourceUnspecified,
  InputPassportElementErrorSourceDataField,
  InputPassportElementErrorSourceFrontSide,
  InputPassportElementErrorSourceReverseSide,
  InputPassportElementErrorSourceSelfie,
  InputPassportElementErrorSourceTranslationFile,
  InputPassportElementErrorSourceTranslationFiles,
  InputPassportElementErrorSourceFile,
  InputPassportElementErrorSourceFiles,
  InputPersonalDocument,
  InputSticker,
  InputThumbnail,
  Invoice,
  KeyboardButton,
  KeyboardButtonType,
  KeyboardButtonTypeText,
  KeyboardButtonTypeRequestPhoneNumber,
  KeyboardButtonTypeRequestLocation,
  LabeledPricePart,
  LanguagePackInfo,
  LanguagePackString,
  LanguagePackStringValue,
  LanguagePackStringValueOrdinary,
  LanguagePackStringValuePluralized,
  LanguagePackStringValueDeleted,
  LanguagePackStrings,
  LinkState,
  LinkStateNone,
  LinkStateKnowsPhoneNumber,
  LinkStateIsContact,
  LocalFile,
  LocalizationTargetInfo,
  Location,
  LogStream,
  LogStreamDefault,
  LogStreamFile,
  LogStreamEmpty,
  LogTags,
  LogVerbosityLevel,
  MaskPoint,
  MaskPointForehead,
  MaskPointEyes,
  MaskPointMouth,
  MaskPointChin,
  MaskPosition,
  Message,
  MessageContent,
  MessageText,
  MessageAnimation,
  MessageAudio,
  MessageDocument,
  MessagePhoto,
  MessageExpiredPhoto,
  MessageSticker,
  MessageVideo,
  MessageExpiredVideo,
  MessageVideoNote,
  MessageVoiceNote,
  MessageLocation,
  MessageVenue,
  MessageContact,
  MessageGame,
  MessagePoll,
  MessageInvoice,
  MessageCall,
  MessageBasicGroupChatCreate,
  MessageSupergroupChatCreate,
  MessageChatChangeTitle,
  MessageChatChangePhoto,
  MessageChatDeletePhoto,
  MessageChatAddMembers,
  MessageChatJoinByLink,
  MessageChatDeleteMember,
  MessageChatUpgradeTo,
  MessageChatUpgradeFrom,
  MessagePinMessage,
  MessageScreenshotTaken,
  MessageChatSetTtl,
  MessageCustomServiceAction,
  MessageGameScore,
  MessagePaymentSuccessful,
  MessagePaymentSuccessfulBot,
  MessageContactRegistered,
  MessageWebsiteConnected,
  MessagePassportDataSent,
  MessagePassportDataReceived,
  MessageUnsupported,
  MessageForwardInfo,
  MessageForwardOrigin,
  MessageForwardOriginUser,
  MessageForwardOriginHiddenUser,
  MessageForwardOriginChannel,
  MessageSendingState,
  MessageSendingStatePending,
  MessageSendingStateFailed,
  Messages,
  NetworkStatistics,
  NetworkStatisticsEntry,
  NetworkStatisticsEntryFile,
  NetworkStatisticsEntryCall,
  NetworkType,
  NetworkTypeNone,
  NetworkTypeMobile,
  NetworkTypeMobileRoaming,
  NetworkTypeWiFi,
  NetworkTypeOther,
  Notification,
  NotificationGroup,
  NotificationGroupType,
  NotificationGroupTypeMessages,
  NotificationGroupTypeMentions,
  NotificationGroupTypeSecretChat,
  NotificationGroupTypeCalls,
  NotificationSettingsScope,
  NotificationSettingsScopePrivateChats,
  NotificationSettingsScopeGroupChats,
  NotificationSettingsScopeChannelChats,
  NotificationType,
  NotificationTypeNewMessage,
  NotificationTypeNewSecretChat,
  NotificationTypeNewCall,
  NotificationTypeNewPushMessage,
  Ok,
  OptionValue,
  OptionValueBoolean,
  OptionValueEmpty,
  OptionValueInteger,
  OptionValueString,
  OrderInfo,
  PageBlock,
  PageBlockTitle,
  PageBlockSubtitle,
  PageBlockAuthorDate,
  PageBlockHeader,
  PageBlockSubheader,
  PageBlockKicker,
  PageBlockParagraph,
  PageBlockPreformatted,
  PageBlockFooter,
  PageBlockDivider,
  PageBlockAnchor,
  PageBlockList,
  PageBlockBlockQuote,
  PageBlockPullQuote,
  PageBlockAnimation,
  PageBlockAudio,
  PageBlockPhoto,
  PageBlockVideo,
  PageBlockCover,
  PageBlockEmbedded,
  PageBlockEmbeddedPost,
  PageBlockCollage,
  PageBlockSlideshow,
  PageBlockChatLink,
  PageBlockTable,
  PageBlockDetails,
  PageBlockRelatedArticles,
  PageBlockMap,
  PageBlockCaption,
  PageBlockHorizontalAlignment,
  PageBlockHorizontalAlignmentLeft,
  PageBlockHorizontalAlignmentCenter,
  PageBlockHorizontalAlignmentRight,
  PageBlockListItem,
  PageBlockRelatedArticle,
  PageBlockTableCell,
  PageBlockVerticalAlignment,
  PageBlockVerticalAlignmentTop,
  PageBlockVerticalAlignmentMiddle,
  PageBlockVerticalAlignmentBottom,
  PassportAuthorizationForm,
  PassportElement,
  PassportElementPersonalDetails,
  PassportElementPassport,
  PassportElementDriverLicense,
  PassportElementIdentityCard,
  PassportElementInternalPassport,
  PassportElementAddress,
  PassportElementUtilityBill,
  PassportElementBankStatement,
  PassportElementRentalAgreement,
  PassportElementPassportRegistration,
  PassportElementTemporaryRegistration,
  PassportElementPhoneNumber,
  PassportElementEmailAddress,
  PassportElementError,
  PassportElementErrorSource,
  PassportElementErrorSourceUnspecified,
  PassportElementErrorSourceDataField,
  PassportElementErrorSourceFrontSide,
  PassportElementErrorSourceReverseSide,
  PassportElementErrorSourceSelfie,
  PassportElementErrorSourceTranslationFile,
  PassportElementErrorSourceTranslationFiles,
  PassportElementErrorSourceFile,
  PassportElementErrorSourceFiles,
  PassportElementType,
  PassportElementTypePersonalDetails,
  PassportElementTypePassport,
  PassportElementTypeDriverLicense,
  PassportElementTypeIdentityCard,
  PassportElementTypeInternalPassport,
  PassportElementTypeAddress,
  PassportElementTypeUtilityBill,
  PassportElementTypeBankStatement,
  PassportElementTypeRentalAgreement,
  PassportElementTypePassportRegistration,
  PassportElementTypeTemporaryRegistration,
  PassportElementTypePhoneNumber,
  PassportElementTypeEmailAddress,
  PassportElements,
  PassportElementsWithErrors,
  PassportRequiredElement,
  PassportSuitableElement,
  PasswordState,
  PaymentForm,
  PaymentReceipt,
  PaymentResult,
  PaymentsProviderStripe,
  PersonalDetails,
  PersonalDocument,
  Photo,
  PhotoSize,
  Poll,
  PollOption,
  ProfilePhoto,
  Proxies,
  Proxy,
  ProxyType,
  ProxyTypeSocks5,
  ProxyTypeHttp,
  ProxyTypeMtproto,
  PublicMessageLink,
  PushMessageContent,
  PushMessageContentHidden,
  PushMessageContentAnimation,
  PushMessageContentAudio,
  PushMessageContentContact,
  PushMessageContentContactRegistered,
  PushMessageContentDocument,
  PushMessageContentGame,
  PushMessageContentGameScore,
  PushMessageContentInvoice,
  PushMessageContentLocation,
  PushMessageContentPhoto,
  PushMessageContentPoll,
  PushMessageContentScreenshotTaken,
  PushMessageContentSticker,
  PushMessageContentText,
  PushMessageContentVideo,
  PushMessageContentVideoNote,
  PushMessageContentVoiceNote,
  PushMessageContentBasicGroupChatCreate,
  PushMessageContentChatAddMembers,
  PushMessageContentChatChangePhoto,
  PushMessageContentChatChangeTitle,
  PushMessageContentChatDeleteMember,
  PushMessageContentChatJoinByLink,
  PushMessageContentMessageForwards,
  PushMessageContentMediaAlbum,
  PushReceiverId,
  RecoveryEmailAddress,
  RemoteFile,
  ReplyMarkup,
  ReplyMarkupRemoveKeyboard,
  ReplyMarkupForceReply,
  ReplyMarkupShowKeyboard,
  ReplyMarkupInlineKeyboard,
  RichText,
  RichTextPlain,
  RichTextBold,
  RichTextItalic,
  RichTextUnderline,
  RichTextStrikethrough,
  RichTextFixed,
  RichTextUrl,
  RichTextEmailAddress,
  RichTextSubscript,
  RichTextSuperscript,
  RichTextMarked,
  RichTextPhoneNumber,
  RichTextIcon,
  RichTextAnchor,
  RichTexts,
  SavedCredentials,
  ScopeNotificationSettings,
  SearchMessagesFilter,
  SearchMessagesFilterEmpty,
  SearchMessagesFilterAnimation,
  SearchMessagesFilterAudio,
  SearchMessagesFilterDocument,
  SearchMessagesFilterPhoto,
  SearchMessagesFilterVideo,
  SearchMessagesFilterVoiceNote,
  SearchMessagesFilterPhotoAndVideo,
  SearchMessagesFilterUrl,
  SearchMessagesFilterChatPhoto,
  SearchMessagesFilterCall,
  SearchMessagesFilterMissedCall,
  SearchMessagesFilterVideoNote,
  SearchMessagesFilterVoiceAndVideoNote,
  SearchMessagesFilterMention,
  SearchMessagesFilterUnreadMention,
  Seconds,
  SecretChat,
  SecretChatState,
  SecretChatStatePending,
  SecretChatStateReady,
  SecretChatStateClosed,
  Session,
  Sessions,
  ShippingOption,
  Sticker,
  StickerEmojis,
  StickerSet,
  StickerSetInfo,
  StickerSets,
  Stickers,
  StorageStatistics,
  StorageStatisticsByChat,
  StorageStatisticsByFileType,
  StorageStatisticsFast,
  Supergroup,
  SupergroupFullInfo,
  SupergroupMembersFilter,
  SupergroupMembersFilterRecent,
  SupergroupMembersFilterAdministrators,
  SupergroupMembersFilterSearch,
  SupergroupMembersFilterRestricted,
  SupergroupMembersFilterBanned,
  SupergroupMembersFilterBots,
  TMeUrl,
  TMeUrlType,
  TMeUrlTypeUser,
  TMeUrlTypeSupergroup,
  TMeUrlTypeChatInvite,
  TMeUrlTypeStickerSet,
  TMeUrls,
  TdlibParameters,
  TemporaryPasswordState,
  TermsOfService,
  TestBytes,
  TestInt,
  TestString,
  TestVectorInt,
  TestVectorIntObject,
  TestVectorString,
  TestVectorStringObject,
  Text,
  TextEntities,
  TextEntity,
  TextEntityType,
  TextEntityTypeMention,
  TextEntityTypeHashtag,
  TextEntityTypeCashtag,
  TextEntityTypeBotCommand,
  TextEntityTypeUrl,
  TextEntityTypeEmailAddress,
  TextEntityTypeBold,
  TextEntityTypeItalic,
  TextEntityTypeCode,
  TextEntityTypePre,
  TextEntityTypePreCode,
  TextEntityTypeTextUrl,
  TextEntityTypeMentionName,
  TextEntityTypePhoneNumber,
  TextParseMode,
  TextParseModeMarkdown,
  TextParseModeHTML,
  TopChatCategory,
  TopChatCategoryUsers,
  TopChatCategoryBots,
  TopChatCategoryGroups,
  TopChatCategoryChannels,
  TopChatCategoryInlineBots,
  TopChatCategoryCalls,
  Update,
  UpdateAuthorizationState,
  UpdateNewMessage,
  UpdateMessageSendAcknowledged,
  UpdateMessageSendSucceeded,
  UpdateMessageSendFailed,
  UpdateMessageContent,
  UpdateMessageEdited,
  UpdateMessageViews,
  UpdateMessageContentOpened,
  UpdateMessageMentionRead,
  UpdateNewChat,
  UpdateChatTitle,
  UpdateChatPhoto,
  UpdateChatLastMessage,
  UpdateChatOrder,
  UpdateChatIsPinned,
  UpdateChatIsMarkedAsUnread,
  UpdateChatIsSponsored,
  UpdateChatDefaultDisableNotification,
  UpdateChatReadInbox,
  UpdateChatReadOutbox,
  UpdateChatUnreadMentionCount,
  UpdateChatNotificationSettings,
  UpdateScopeNotificationSettings,
  UpdateChatPinnedMessage,
  UpdateChatReplyMarkup,
  UpdateChatDraftMessage,
  UpdateChatOnlineMemberCount,
  UpdateNotification,
  UpdateNotificationGroup,
  UpdateActiveNotifications,
  UpdateHavePendingNotifications,
  UpdateDeleteMessages,
  UpdateUserChatAction,
  UpdateUserStatus,
  UpdateUser,
  UpdateBasicGroup,
  UpdateSupergroup,
  UpdateSecretChat,
  UpdateUserFullInfo,
  UpdateBasicGroupFullInfo,
  UpdateSupergroupFullInfo,
  UpdateServiceNotification,
  UpdateFile,
  UpdateFileGenerationStart,
  UpdateFileGenerationStop,
  UpdateCall,
  UpdateUserPrivacySettingRules,
  UpdateUnreadMessageCount,
  UpdateUnreadChatCount,
  UpdateOption,
  UpdateInstalledStickerSets,
  UpdateTrendingStickerSets,
  UpdateRecentStickers,
  UpdateFavoriteStickers,
  UpdateSavedAnimations,
  UpdateLanguagePackStrings,
  UpdateConnectionState,
  UpdateTermsOfService,
  UpdateNewInlineQuery,
  UpdateNewChosenInlineResult,
  UpdateNewCallbackQuery,
  UpdateNewInlineCallbackQuery,
  UpdateNewShippingQuery,
  UpdateNewPreCheckoutQuery,
  UpdateNewCustomEvent,
  UpdateNewCustomQuery,
  UpdatePoll,
  Updates,
  User,
  UserFullInfo,
  UserPrivacySetting,
  UserPrivacySettingShowStatus,
  UserPrivacySettingAllowChatInvites,
  UserPrivacySettingAllowCalls,
  UserPrivacySettingAllowPeerToPeerCalls,
  UserPrivacySettingRule,
  UserPrivacySettingRuleAllowAll,
  UserPrivacySettingRuleAllowContacts,
  UserPrivacySettingRuleAllowUsers,
  UserPrivacySettingRuleRestrictAll,
  UserPrivacySettingRuleRestrictContacts,
  UserPrivacySettingRuleRestrictUsers,
  UserPrivacySettingRules,
  UserProfilePhoto,
  UserProfilePhotos,
  UserStatus,
  UserStatusEmpty,
  UserStatusOnline,
  UserStatusOffline,
  UserStatusRecently,
  UserStatusLastWeek,
  UserStatusLastMonth,
  UserType,
  UserTypeRegular,
  UserTypeDeleted,
  UserTypeBot,
  UserTypeUnknown,
  Users,
  ValidatedOrderInfo,
  Venue,
  Video,
  VideoNote,
  VoiceNote,
  Wallpaper,
  Wallpapers,
  WebPage,
  WebPageInstantView,
  AcceptCall,
  AcceptTermsOfService,
  AddChatMember,
  AddChatMembers,
  AddCustomServerLanguagePack,
  AddFavoriteSticker,
  AddLocalMessage,
  AddLogMessage,
  AddNetworkStatistics,
  AddProxy,
  AddRecentSticker,
  AddRecentlyFoundChat,
  AddSavedAnimation,
  AddStickerToSet,
  AnswerCallbackQuery,
  AnswerCustomQuery,
  AnswerInlineQuery,
  AnswerPreCheckoutQuery,
  AnswerShippingQuery,
  BlockUser,
  CancelDownloadFile,
  CancelUploadFile,
  ChangeChatReportSpamState,
  ChangeImportedContacts,
  ChangePhoneNumber,
  ChangeStickerSet,
  CheckAuthenticationBotToken,
  CheckAuthenticationCode,
  CheckAuthenticationPassword,
  CheckChangePhoneNumberCode,
  CheckChatInviteLink,
  CheckChatUsername,
  CheckDatabaseEncryptionKey,
  CheckEmailAddressVerificationCode,
  CheckPhoneNumberConfirmationCode,
  CheckPhoneNumberVerificationCode,
  CheckRecoveryEmailAddressCode,
  CleanFileName,
  ClearAllDraftMessages,
  ClearImportedContacts,
  ClearRecentStickers,
  ClearRecentlyFoundChats,
  Close,
  CloseChat,
  CloseSecretChat,
  CreateBasicGroupChat,
  CreateCall,
  CreateNewBasicGroupChat,
  CreateNewSecretChat,
  CreateNewStickerSet,
  CreateNewSupergroupChat,
  CreatePrivateChat,
  CreateSecretChat,
  CreateSupergroupChat,
  CreateTemporaryPassword,
  DeleteAccount,
  DeleteChatHistory,
  DeleteChatMessagesFromUser,
  DeleteChatReplyMarkup,
  DeleteFile,
  DeleteLanguagePack,
  DeleteMessages,
  DeletePassportElement,
  DeleteProfilePhoto,
  DeleteSavedCredentials,
  DeleteSavedOrderInfo,
  DeleteSupergroup,
  Destroy,
  DisableProxy,
  DiscardCall,
  DisconnectAllWebsites,
  DisconnectWebsite,
  DownloadFile,
  EditCustomLanguagePackInfo,
  EditInlineMessageCaption,
  EditInlineMessageLiveLocation,
  EditInlineMessageMedia,
  EditInlineMessageReplyMarkup,
  EditInlineMessageText,
  EditMessageCaption,
  EditMessageLiveLocation,
  EditMessageMedia,
  EditMessageReplyMarkup,
  EditMessageText,
  EditProxy,
  EnableProxy,
  FinishFileGeneration,
  ForwardMessages,
  GenerateChatInviteLink,
  GetAccountTtl,
  GetActiveLiveLocationMessages,
  GetActiveSessions,
  GetAllPassportElements,
  GetApplicationConfig,
  GetArchivedStickerSets,
  GetAttachedStickerSets,
  GetAuthorizationState,
  GetBasicGroup,
  GetBasicGroupFullInfo,
  GetBlockedUsers,
  GetCallbackQueryAnswer,
  GetChat,
  GetChatAdministrators,
  GetChatEventLog,
  GetChatHistory,
  GetChatMember,
  GetChatMessageByDate,
  GetChatMessageCount,
  GetChatNotificationSettingsExceptions,
  GetChatPinnedMessage,
  GetChatReportSpamState,
  GetChatStatisticsUrl,
  GetChats,
  GetConnectedWebsites,
  GetContacts,
  GetCountryCode,
  GetCreatedPublicChats,
  GetCurrentState,
  GetDatabaseStatistics,
  GetDeepLinkInfo,
  GetFavoriteStickers,
  GetFile,
  GetFileDownloadedPrefixSize,
  GetFileExtension,
  GetFileMimeType,
  GetGameHighScores,
  GetGroupsInCommon,
  GetImportedContactCount,
  GetInlineGameHighScores,
  GetInlineQueryResults,
  GetInstalledStickerSets,
  GetInviteText,
  GetLanguagePackInfo,
  GetLanguagePackString,
  GetLanguagePackStrings,
  GetLocalizationTargetInfo,
  GetLogStream,
  GetLogTagVerbosityLevel,
  GetLogTags,
  GetLogVerbosityLevel,
  GetMapThumbnailFile,
  GetMe,
  GetMessage,
  GetMessageLink,
  GetMessageLocally,
  GetMessages,
  GetNetworkStatistics,
  GetOption,
  GetPassportAuthorizationForm,
  GetPassportAuthorizationFormAvailableElements,
  GetPassportElement,
  GetPasswordState,
  GetPaymentForm,
  GetPaymentReceipt,
  GetPreferredCountryLanguage,
  GetProxies,
  GetProxyLink,
  GetPublicMessageLink,
  GetPushReceiverId,
  GetRecentInlineBots,
  GetRecentStickers,
  GetRecentlyVisitedTMeUrls,
  GetRecoveryEmailAddress,
  GetRemoteFile,
  GetRepliedMessage,
  GetSavedAnimations,
  GetSavedOrderInfo,
  GetScopeNotificationSettings,
  GetSecretChat,
  GetStickerEmojis,
  GetStickerSet,
  GetStickers,
  GetStorageStatistics,
  GetStorageStatisticsFast,
  GetSupergroup,
  GetSupergroupFullInfo,
  GetSupergroupMembers,
  GetSupportUser,
  GetTemporaryPasswordState,
  GetTextEntities,
  GetTopChats,
  GetTrendingStickerSets,
  GetUser,
  GetUserFullInfo,
  GetUserPrivacySettingRules,
  GetUserProfilePhotos,
  GetWallpapers,
  GetWebPageInstantView,
  GetWebPagePreview,
  ImportContacts,
  JoinChat,
  JoinChatByInviteLink,
  LeaveChat,
  LogOut,
  OpenChat,
  OpenMessageContent,
  OptimizeStorage,
  ParseTextEntities,
  PinChatMessage,
  PingProxy,
  ProcessPushNotification,
  ReadAllChatMentions,
  ReadFilePart,
  RecoverAuthenticationPassword,
  RecoverPassword,
  RegisterDevice,
  RemoveContacts,
  RemoveFavoriteSticker,
  RemoveNotification,
  RemoveNotificationGroup,
  RemoveProxy,
  RemoveRecentHashtag,
  RemoveRecentSticker,
  RemoveRecentlyFoundChat,
  RemoveSavedAnimation,
  RemoveStickerFromSet,
  RemoveTopChat,
  ReorderInstalledStickerSets,
  ReportChat,
  ReportSupergroupSpam,
  RequestAuthenticationPasswordRecovery,
  RequestPasswordRecovery,
  ResendAuthenticationCode,
  ResendChangePhoneNumberCode,
  ResendEmailAddressVerificationCode,
  ResendPhoneNumberConfirmationCode,
  ResendPhoneNumberVerificationCode,
  ResendRecoveryEmailAddressCode,
  ResetAllNotificationSettings,
  ResetNetworkStatistics,
  SearchCallMessages,
  SearchChatMembers,
  SearchChatMessages,
  SearchChatRecentLocationMessages,
  SearchChats,
  SearchChatsOnServer,
  SearchContacts,
  SearchHashtags,
  SearchInstalledStickerSets,
  SearchMessages,
  SearchPublicChat,
  SearchPublicChats,
  SearchSecretMessages,
  SearchStickerSet,
  SearchStickerSets,
  SearchStickers,
  SendBotStartMessage,
  SendCallDebugInformation,
  SendCallRating,
  SendChatAction,
  SendChatScreenshotTakenNotification,
  SendChatSetTtlMessage,
  SendCustomRequest,
  SendEmailAddressVerificationCode,
  SendInlineQueryResultMessage,
  SendMessage,
  SendMessageAlbum,
  SendPassportAuthorizationForm,
  SendPaymentForm,
  SendPhoneNumberConfirmationCode,
  SendPhoneNumberVerificationCode,
  SetAccountTtl,
  SetAlarm,
  SetAuthenticationPhoneNumber,
  SetBio,
  SetBotUpdatesStatus,
  SetChatClientData,
  SetChatDraftMessage,
  SetChatMemberStatus,
  SetChatNotificationSettings,
  SetChatPhoto,
  SetChatTitle,
  SetCustomLanguagePack,
  SetCustomLanguagePackString,
  SetDatabaseEncryptionKey,
  SetFileGenerationProgress,
  SetGameScore,
  SetInlineGameScore,
  SetLogStream,
  SetLogTagVerbosityLevel,
  SetLogVerbosityLevel,
  SetName,
  SetNetworkType,
  SetOption,
  SetPassportElement,
  SetPassportElementErrors,
  SetPassword,
  SetPinnedChats,
  SetPollAnswer,
  SetProfilePhoto,
  SetRecoveryEmailAddress,
  SetScopeNotificationSettings,
  SetStickerPositionInSet,
  SetSupergroupDescription,
  SetSupergroupStickerSet,
  SetSupergroupUsername,
  SetTdlibParameters,
  SetUserPrivacySettingRules,
  SetUsername,
  StopPoll,
  SynchronizeLanguagePack,
  TerminateAllOtherSessions,
  TerminateSession,
  TestCallBytes,
  TestCallEmpty,
  TestCallString,
  TestCallVectorInt,
  TestCallVectorIntObject,
  TestCallVectorString,
  TestCallVectorStringObject,
  TestGetDifference,
  TestNetwork,
  TestSquareInt,
  TestUseError,
  TestUseUpdate,
  ToggleBasicGroupAdministrators,
  ToggleChatDefaultDisableNotification,
  ToggleChatIsMarkedAsUnread,
  ToggleChatIsPinned,
  ToggleSupergroupInvites,
  ToggleSupergroupIsAllHistoryAvailable,
  ToggleSupergroupSignMessages,
  UnblockUser,
  UnpinChatMessage,
  UpgradeBasicGroupChatToSupergroupChat,
  UploadFile,
  UploadStickerFile,
  ValidateOrderInfo,
  ViewMessages,
  ViewTrendingStickerSets,
  WriteGeneratedFilePart,
  
}

impl RTDType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDType)(text.as_ref()) }
}

/// This class is a base class for all TDLib API classes. 

pub trait Object: RObject + Debug {}









/// This class is a base class for all TDLib API functions. 

pub trait Function: Object + RObject + Debug {}







#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDFunctionType {
  AcceptCall,
  AcceptTermsOfService,
  AddChatMember,
  AddChatMembers,
  AddCustomServerLanguagePack,
  AddFavoriteSticker,
  AddLocalMessage,
  AddLogMessage,
  AddNetworkStatistics,
  AddProxy,
  AddRecentlyFoundChat,
  AddRecentSticker,
  AddSavedAnimation,
  AddStickerToSet,
  AnswerCallbackQuery,
  AnswerCustomQuery,
  AnswerInlineQuery,
  AnswerPreCheckoutQuery,
  AnswerShippingQuery,
  BlockUser,
  CancelDownloadFile,
  CancelUploadFile,
  ChangeChatReportSpamState,
  ChangeImportedContacts,
  ChangePhoneNumber,
  ChangeStickerSet,
  CheckAuthenticationBotToken,
  CheckAuthenticationCode,
  CheckAuthenticationPassword,
  CheckChangePhoneNumberCode,
  CheckChatInviteLink,
  CheckChatUsername,
  CheckDatabaseEncryptionKey,
  CheckEmailAddressVerificationCode,
  CheckPhoneNumberConfirmationCode,
  CheckPhoneNumberVerificationCode,
  CheckRecoveryEmailAddressCode,
  CleanFileName,
  ClearAllDraftMessages,
  ClearImportedContacts,
  ClearRecentlyFoundChats,
  ClearRecentStickers,
  Close,
  CloseChat,
  CloseSecretChat,
  CreateBasicGroupChat,
  CreateCall,
  CreateNewBasicGroupChat,
  CreateNewSecretChat,
  CreateNewStickerSet,
  CreateNewSupergroupChat,
  CreatePrivateChat,
  CreateSecretChat,
  CreateSupergroupChat,
  CreateTemporaryPassword,
  DeleteAccount,
  DeleteChatHistory,
  DeleteChatMessagesFromUser,
  DeleteChatReplyMarkup,
  DeleteFile,
  DeleteLanguagePack,
  DeleteMessages,
  DeletePassportElement,
  DeleteProfilePhoto,
  DeleteSavedCredentials,
  DeleteSavedOrderInfo,
  DeleteSupergroup,
  Destroy,
  DisableProxy,
  DiscardCall,
  DisconnectAllWebsites,
  DisconnectWebsite,
  DownloadFile,
  EditCustomLanguagePackInfo,
  EditInlineMessageCaption,
  EditInlineMessageLiveLocation,
  EditInlineMessageMedia,
  EditInlineMessageReplyMarkup,
  EditInlineMessageText,
  EditMessageCaption,
  EditMessageLiveLocation,
  EditMessageMedia,
  EditMessageReplyMarkup,
  EditMessageText,
  EditProxy,
  EnableProxy,
  FinishFileGeneration,
  ForwardMessages,
  GenerateChatInviteLink,
  GetAccountTtl,
  GetActiveLiveLocationMessages,
  GetActiveSessions,
  GetAllPassportElements,
  GetApplicationConfig,
  GetArchivedStickerSets,
  GetAttachedStickerSets,
  GetAuthorizationState,
  GetBasicGroup,
  GetBasicGroupFullInfo,
  GetBlockedUsers,
  GetCallbackQueryAnswer,
  GetChat,
  GetChatAdministrators,
  GetChatEventLog,
  GetChatHistory,
  GetChatMember,
  GetChatMessageByDate,
  GetChatMessageCount,
  GetChatNotificationSettingsExceptions,
  GetChatPinnedMessage,
  GetChatReportSpamState,
  GetChats,
  GetChatStatisticsUrl,
  GetConnectedWebsites,
  GetContacts,
  GetCountryCode,
  GetCreatedPublicChats,
  GetCurrentState,
  GetDatabaseStatistics,
  GetDeepLinkInfo,
  GetFavoriteStickers,
  GetFile,
  GetFileDownloadedPrefixSize,
  GetFileExtension,
  GetFileMimeType,
  GetGameHighScores,
  GetGroupsInCommon,
  GetImportedContactCount,
  GetInlineGameHighScores,
  GetInlineQueryResults,
  GetInstalledStickerSets,
  GetInviteText,
  GetJsonString,
  GetJsonValue,
  GetLanguagePackInfo,
  GetLanguagePackString,
  GetLanguagePackStrings,
  GetLocalizationTargetInfo,
  GetLogStream,
  GetLogTags,
  GetLogTagVerbosityLevel,
  GetLogVerbosityLevel,
  GetMapThumbnailFile,
  GetMe,
  GetMessage,
  GetMessageLink,
  GetMessageLocally,
  GetMessages,
  GetNetworkStatistics,
  GetOption,
  GetPassportAuthorizationForm,
  GetPassportAuthorizationFormAvailableElements,
  GetPassportElement,
  GetPasswordState,
  GetPaymentForm,
  GetPaymentReceipt,
  GetPreferredCountryLanguage,
  GetProxies,
  GetProxyLink,
  GetPublicMessageLink,
  GetPushReceiverId,
  GetRecentInlineBots,
  GetRecentlyVisitedTMeUrls,
  GetRecentStickers,
  GetRecoveryEmailAddress,
  GetRemoteFile,
  GetRepliedMessage,
  GetSavedAnimations,
  GetSavedOrderInfo,
  GetScopeNotificationSettings,
  GetSecretChat,
  GetStickerEmojis,
  GetStickers,
  GetStickerSet,
  GetStorageStatistics,
  GetStorageStatisticsFast,
  GetSupergroup,
  GetSupergroupFullInfo,
  GetSupergroupMembers,
  GetSupportUser,
  GetTemporaryPasswordState,
  GetTextEntities,
  GetTopChats,
  GetTrendingStickerSets,
  GetUser,
  GetUserFullInfo,
  GetUserPrivacySettingRules,
  GetUserProfilePhotos,
  GetWallpapers,
  GetWebPageInstantView,
  GetWebPagePreview,
  ImportContacts,
  JoinChat,
  JoinChatByInviteLink,
  LeaveChat,
  LogOut,
  OpenChat,
  OpenMessageContent,
  OptimizeStorage,
  ParseTextEntities,
  PinChatMessage,
  PingProxy,
  ProcessPushNotification,
  ReadAllChatMentions,
  ReadFilePart,
  RecoverAuthenticationPassword,
  RecoverPassword,
  RegisterDevice,
  RemoveContacts,
  RemoveFavoriteSticker,
  RemoveNotification,
  RemoveNotificationGroup,
  RemoveProxy,
  RemoveRecentHashtag,
  RemoveRecentlyFoundChat,
  RemoveRecentSticker,
  RemoveSavedAnimation,
  RemoveStickerFromSet,
  RemoveTopChat,
  ReorderInstalledStickerSets,
  ReportChat,
  ReportSupergroupSpam,
  RequestAuthenticationPasswordRecovery,
  RequestPasswordRecovery,
  ResendAuthenticationCode,
  ResendChangePhoneNumberCode,
  ResendEmailAddressVerificationCode,
  ResendPhoneNumberConfirmationCode,
  ResendPhoneNumberVerificationCode,
  ResendRecoveryEmailAddressCode,
  ResetAllNotificationSettings,
  ResetNetworkStatistics,
  SaveApplicationLogEvent,
  SearchCallMessages,
  SearchChatMembers,
  SearchChatMessages,
  SearchChatRecentLocationMessages,
  SearchChats,
  SearchChatsOnServer,
  SearchContacts,
  SearchHashtags,
  SearchInstalledStickerSets,
  SearchMessages,
  SearchPublicChat,
  SearchPublicChats,
  SearchSecretMessages,
  SearchStickers,
  SearchStickerSet,
  SearchStickerSets,
  SendBotStartMessage,
  SendCallDebugInformation,
  SendCallRating,
  SendChatAction,
  SendChatScreenshotTakenNotification,
  SendChatSetTtlMessage,
  SendCustomRequest,
  SendEmailAddressVerificationCode,
  SendInlineQueryResultMessage,
  SendMessage,
  SendMessageAlbum,
  SendPassportAuthorizationForm,
  SendPaymentForm,
  SendPhoneNumberConfirmationCode,
  SendPhoneNumberVerificationCode,
  SetAccountTtl,
  SetAlarm,
  SetAuthenticationPhoneNumber,
  SetBio,
  SetBotUpdatesStatus,
  SetChatClientData,
  SetChatDraftMessage,
  SetChatMemberStatus,
  SetChatNotificationSettings,
  SetChatPhoto,
  SetChatTitle,
  SetCustomLanguagePack,
  SetCustomLanguagePackString,
  SetDatabaseEncryptionKey,
  SetFileGenerationProgress,
  SetGameScore,
  SetInlineGameScore,
  SetLogStream,
  SetLogTagVerbosityLevel,
  SetLogVerbosityLevel,
  SetName,
  SetNetworkType,
  SetOption,
  SetPassportElement,
  SetPassportElementErrors,
  SetPassword,
  SetPinnedChats,
  SetPollAnswer,
  SetProfilePhoto,
  SetRecoveryEmailAddress,
  SetScopeNotificationSettings,
  SetStickerPositionInSet,
  SetSupergroupDescription,
  SetSupergroupStickerSet,
  SetSupergroupUsername,
  SetTdlibParameters,
  SetUsername,
  SetUserPrivacySettingRules,
  StopPoll,
  SynchronizeLanguagePack,
  TerminateAllOtherSessions,
  TerminateSession,
  TestCallBytes,
  TestCallEmpty,
  TestCallString,
  TestCallVectorInt,
  TestCallVectorIntObject,
  TestCallVectorString,
  TestCallVectorStringObject,
  TestGetDifference,
  TestNetwork,
  TestSquareInt,
  TestUseError,
  TestUseUpdate,
  ToggleBasicGroupAdministrators,
  ToggleChatDefaultDisableNotification,
  ToggleChatIsMarkedAsUnread,
  ToggleChatIsPinned,
  ToggleSupergroupInvites,
  ToggleSupergroupIsAllHistoryAvailable,
  ToggleSupergroupSignMessages,
  UnblockUser,
  UnpinChatMessage,
  UpgradeBasicGroupChatToSupergroupChat,
  UploadFile,
  UploadStickerFile,
  ValidateOrderInfo,
  ViewMessages,
  ViewTrendingStickerSets,
  WriteGeneratedFilePart,
  
}
impl RTDFunctionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDFunctionType)(text.as_ref()) }
}



/// Contains information about the period of inactivity after which the current user's account will automatically be deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // accountTtl
  /// Number of days of inactivity before the account will be flagged for deletion; should range from 30-366 days.
  days: Option<i32>,
  
}



impl Object for AccountTtl {}
impl RObject for AccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "accountTtl" }
  fn td_type(&self) -> RTDType { RTDType::AccountTtl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl AccountTtl {
  
  pub fn days(&self) -> Option<i32> { self.days.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes an address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // address
  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,
  /// State, if applicable.
  state: Option<String>,
  /// City.
  city: Option<String>,
  /// First line of the address.
  street_line1: Option<String>,
  /// Second line of the address.
  street_line2: Option<String>,
  /// Address postal code.
  postal_code: Option<String>,
  
}



impl Object for Address {}
impl RObject for Address {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "address" }
  fn td_type(&self) -> RTDType { RTDType::Address }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Address {
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn state(&self) -> Option<String> { self.state.clone() }
  
  pub fn city(&self) -> Option<String> { self.city.clone() }
  
  pub fn street_line1(&self) -> Option<String> { self.street_line1.clone() }
  
  pub fn street_line2(&self) -> Option<String> { self.street_line2.clone() }
  
  pub fn postal_code(&self) -> Option<String> { self.postal_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes an animation file. The animation must be encoded in GIF or MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // animation
  /// Duration of the animation, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Width of the animation.
  width: Option<i32>,
  /// Height of the animation.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file, usually "image/gif" or "video/mp4".
  mime_type: Option<String>,
  /// Animation thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the animation.
  animation: Option<File>,
  
}



impl Object for Animation {}
impl RObject for Animation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "animation" }
  fn td_type(&self) -> RTDType { RTDType::Animation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Animation {
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn animation(&self) -> Option<File> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of animations. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // animations
  /// List of animations.
  animations: Option<Vec<Animation>>,
  
}



impl Object for Animations {}
impl RObject for Animations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "animations" }
  fn td_type(&self) -> RTDType { RTDType::Animations }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Animations {
  
  pub fn animations(&self) -> Option<Vec<Animation>> { self.animations.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes an audio file. Audio is usually in MP3 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Audio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // audio
  /// Duration of the audio, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Title of the audio; as defined by the sender.
  title: Option<String>,
  /// Performer of the audio; as defined by the sender.
  performer: Option<String>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// The MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// The thumbnail of the album cover; as defined by the sender. The full size thumbnail should be extracted from the downloaded file; may be null.
  album_cover_thumbnail: Option<PhotoSize>,
  /// File containing the audio.
  audio: Option<File>,
  
}



impl Object for Audio {}
impl RObject for Audio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "audio" }
  fn td_type(&self) -> RTDType { RTDType::Audio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Audio {
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn album_cover_thumbnail(&self) -> Option<PhotoSize> { self.album_cover_thumbnail.clone() }
  
  pub fn audio(&self) -> Option<File> { self.audio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Information about the authentication code that was sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeInfo
  /// A phone number that is being authenticated.
  phone_number: Option<String>,
  /// Describes the way the code was sent to the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<AuthenticationCodeType>>,
  /// Describes the way the next code will be sent to the user; may be null.
  next_type: Option<Box<AuthenticationCodeType>>,
  /// Timeout before the code should be re-sent, in seconds.
  timeout: Option<i32>,
  
}


impl Clone for AuthenticationCodeInfo {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AuthenticationCodeInfo {}
impl RObject for AuthenticationCodeInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeInfo" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl AuthenticationCodeInfo {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn type_(&self) -> Option<Box<AuthenticationCodeType>> { self.type_.clone() }
  
  pub fn next_type(&self) -> Option<Box<AuthenticationCodeType>> { self.next_type.clone() }
  
  pub fn timeout(&self) -> Option<i32> { self.timeout.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Provides information about the method by which an authentication code is delivered to the user. 
#[typetag::serde(tag = "@struct")]
pub trait AuthenticationCodeType: Object + RObject + Debug {}






impl AuthenticationCodeType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<AuthenticationCodeType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDAuthenticationCodeTypeType {
  AuthenticationCodeTypeCall,
  AuthenticationCodeTypeFlashCall,
  AuthenticationCodeTypeSms,
  AuthenticationCodeTypeTelegramMessage,
  
}
impl RTDAuthenticationCodeTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDAuthenticationCodeTypeType)(text.as_ref()) }
}



/// An authentication code is delivered via a private Telegram message, which can be viewed in another client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeTelegramMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeTelegramMessage
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeTelegramMessage {}
impl RObject for AuthenticationCodeTypeTelegramMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeTelegramMessage" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeTelegramMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeTelegramMessage {}


impl AuthenticationCodeTypeTelegramMessage {
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An authentication code is delivered via an SMS message to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeSms {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeSms
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeSms {}
impl RObject for AuthenticationCodeTypeSms {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeSms" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeSms }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeSms {}


impl AuthenticationCodeTypeSms {
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An authentication code is delivered via a phone call to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeCall
  /// Length of the code.
  length: Option<i32>,
  
}



impl Object for AuthenticationCodeTypeCall {}
impl RObject for AuthenticationCodeTypeCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeCall" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeCall {}


impl AuthenticationCodeTypeCall {
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeFlashCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authenticationCodeTypeFlashCall
  /// Pattern of the phone number from which the call will be made.
  pattern: Option<String>,
  
}



impl Object for AuthenticationCodeTypeFlashCall {}
impl RObject for AuthenticationCodeTypeFlashCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authenticationCodeTypeFlashCall" }
  fn td_type(&self) -> RTDType { RTDType::AuthenticationCodeTypeFlashCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthenticationCodeType for AuthenticationCodeTypeFlashCall {}


impl AuthenticationCodeTypeFlashCall {
  
  pub fn pattern(&self) -> Option<String> { self.pattern.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the current authorization state of the client. 
#[typetag::serde(tag = "@struct")]
pub trait AuthorizationState: Object + RObject + Debug {}






impl AuthorizationState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<AuthorizationState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDAuthorizationStateType {
  AuthorizationStateClosed,
  AuthorizationStateClosing,
  AuthorizationStateLoggingOut,
  AuthorizationStateReady,
  AuthorizationStateWaitCode,
  AuthorizationStateWaitEncryptionKey,
  AuthorizationStateWaitPassword,
  AuthorizationStateWaitPhoneNumber,
  AuthorizationStateWaitTdlibParameters,
  
}
impl RTDAuthorizationStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDAuthorizationStateType)(text.as_ref()) }
}



/// TDLib needs TdlibParameters for initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitTdlibParameters
  
}



impl Object for AuthorizationStateWaitTdlibParameters {}
impl RObject for AuthorizationStateWaitTdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitTdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitTdlibParameters }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitTdlibParameters {}


impl AuthorizationStateWaitTdlibParameters {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// TDLib needs an encryption key to decrypt the local database. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitEncryptionKey
  /// True, if the database is currently encrypted.
  is_encrypted: Option<bool>,
  
}



impl Object for AuthorizationStateWaitEncryptionKey {}
impl RObject for AuthorizationStateWaitEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitEncryptionKey }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitEncryptionKey {}


impl AuthorizationStateWaitEncryptionKey {
  
  pub fn is_encrypted(&self) -> Option<bool> { self.is_encrypted.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// TDLib needs the user's phone number to authorize. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitPhoneNumber
  
}



impl Object for AuthorizationStateWaitPhoneNumber {}
impl RObject for AuthorizationStateWaitPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitPhoneNumber {}


impl AuthorizationStateWaitPhoneNumber {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// TDLib needs the user's authentication code to finalize authorization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitCode
  /// True, if the user is already registered.
  is_registered: Option<bool>,
  /// Telegram terms of service, which should be accepted before user can continue registration; may be null.
  terms_of_service: Option<TermsOfService>,
  /// Information about the authorization code that was sent.
  code_info: Option<AuthenticationCodeInfo>,
  
}



impl Object for AuthorizationStateWaitCode {}
impl RObject for AuthorizationStateWaitCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitCode" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitCode {}


impl AuthorizationStateWaitCode {
  
  pub fn is_registered(&self) -> Option<bool> { self.is_registered.clone() }
  
  pub fn terms_of_service(&self) -> Option<TermsOfService> { self.terms_of_service.clone() }
  
  pub fn code_info(&self) -> Option<AuthenticationCodeInfo> { self.code_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has been authorized, but needs to enter a password to start using the application. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateWaitPassword
  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True if a recovery email address has been set up.
  has_recovery_email_address: Option<bool>,
  /// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent.
  recovery_email_address_pattern: Option<String>,
  
}



impl Object for AuthorizationStateWaitPassword {}
impl RObject for AuthorizationStateWaitPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateWaitPassword" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateWaitPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateWaitPassword {}


impl AuthorizationStateWaitPassword {
  
  pub fn password_hint(&self) -> Option<String> { self.password_hint.clone() }
  
  pub fn has_recovery_email_address(&self) -> Option<bool> { self.has_recovery_email_address.clone() }
  
  pub fn recovery_email_address_pattern(&self) -> Option<String> { self.recovery_email_address_pattern.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has been successfully authorized. TDLib is now ready to answer queries. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateReady
  
}



impl Object for AuthorizationStateReady {}
impl RObject for AuthorizationStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateReady" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateReady }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateReady {}


impl AuthorizationStateReady {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is currently logging out. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateLoggingOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateLoggingOut
  
}



impl Object for AuthorizationStateLoggingOut {}
impl RObject for AuthorizationStateLoggingOut {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateLoggingOut" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateLoggingOut }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateLoggingOut {}


impl AuthorizationStateLoggingOut {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosing {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateClosing
  
}



impl Object for AuthorizationStateClosing {}
impl RObject for AuthorizationStateClosing {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateClosing" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateClosing }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateClosing {}


impl AuthorizationStateClosing {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one should create a new instance of the TDLib client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // authorizationStateClosed
  
}



impl Object for AuthorizationStateClosed {}
impl RObject for AuthorizationStateClosed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "authorizationStateClosed" }
  fn td_type(&self) -> RTDType { RTDType::AuthorizationStateClosed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl AuthorizationState for AuthorizationStateClosed {}


impl AuthorizationStateClosed {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users). 
#[derive(Debug, Serialize, Deserialize)]
pub struct BasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // basicGroup
  /// Group identifier.
  id: Option<i32>,
  /// Number of members in the group.
  member_count: Option<i32>,
  /// Status of the current user in the group.
  status: Option<Box<ChatMemberStatus>>,
  /// True, if all members have been granted administrator rights in the group.
  everyone_is_administrator: Option<bool>,
  /// True, if the group is active.
  is_active: Option<bool>,
  /// Identifier of the supergroup to which this group was upgraded; 0 if none.
  upgraded_to_supergroup_id: Option<i32>,
  
}


impl Clone for BasicGroup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for BasicGroup {}
impl RObject for BasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "basicGroup" }
  fn td_type(&self) -> RTDType { RTDType::BasicGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl BasicGroup {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn everyone_is_administrator(&self) -> Option<bool> { self.everyone_is_administrator.clone() }
  
  pub fn is_active(&self) -> Option<bool> { self.is_active.clone() }
  
  pub fn upgraded_to_supergroup_id(&self) -> Option<i32> { self.upgraded_to_supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains full information about a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // basicGroupFullInfo
  /// User identifier of the creator of the group; 0 if unknown.
  creator_user_id: Option<i32>,
  /// Group members.
  members: Option<Vec<ChatMember>>,
  /// Invite link for this group; available only for the group creator and only after it has been generated at least once.
  invite_link: Option<String>,
  
}



impl Object for BasicGroupFullInfo {}
impl RObject for BasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "basicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::BasicGroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl BasicGroupFullInfo {
  
  pub fn creator_user_id(&self) -> Option<i32> { self.creator_user_id.clone() }
  
  pub fn members(&self) -> Option<Vec<ChatMember>> { self.members.clone() }
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents commands supported by a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // botCommand
  /// Text of the bot command.
  command: Option<String>,
  /// Description of the bot command.
  description: Option<String>,
  
}



impl Object for BotCommand {}
impl RObject for BotCommand {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "botCommand" }
  fn td_type(&self) -> RTDType { RTDType::BotCommand }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl BotCommand {
  
  pub fn command(&self) -> Option<String> { self.command.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Provides information about a bot and its supported commands. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // botInfo
  /// Long description shown on the user info page.
  description: Option<String>,
  /// A list of commands supported by the bot.
  commands: Option<Vec<BotCommand>>,
  
}



impl Object for BotInfo {}
impl RObject for BotInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "botInfo" }
  fn td_type(&self) -> RTDType { RTDType::BotInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl BotInfo {
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn commands(&self) -> Option<Vec<BotCommand>> { self.commands.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Call {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // call
  /// Call identifier, not persistent.
  id: Option<i32>,
  /// Peer user identifier.
  user_id: Option<i32>,
  /// True, if the call is outgoing.
  is_outgoing: Option<bool>,
  /// Call state.
  state: Option<Box<CallState>>,
  
}


impl Clone for Call {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Call {}
impl RObject for Call {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "call" }
  fn td_type(&self) -> RTDType { RTDType::Call }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Call {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn is_outgoing(&self) -> Option<bool> { self.is_outgoing.clone() }
  
  pub fn state(&self) -> Option<Box<CallState>> { self.state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes the address of UDP reflectors. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallConnection {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callConnection
  /// Reflector identifier.
  id: Option<i64>,
  /// IPv4 reflector address.
  ip: Option<String>,
  /// IPv6 reflector address.
  ipv6: Option<String>,
  /// Reflector port number.
  port: Option<i32>,
  /// Connection peer tag.
  peer_tag: Option<String>,
  
}



impl Object for CallConnection {}
impl RObject for CallConnection {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callConnection" }
  fn td_type(&self) -> RTDType { RTDType::CallConnection }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl CallConnection {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn ipv6(&self) -> Option<String> { self.ipv6.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn peer_tag(&self) -> Option<String> { self.peer_tag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the reason why a call was discarded. 
#[typetag::serde(tag = "@struct")]
pub trait CallDiscardReason: Object + RObject + Debug {}






impl CallDiscardReason {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<CallDiscardReason> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallDiscardReasonType {
  CallDiscardReasonDeclined,
  CallDiscardReasonDisconnected,
  CallDiscardReasonEmpty,
  CallDiscardReasonHungUp,
  CallDiscardReasonMissed,
  
}
impl RTDCallDiscardReasonType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDCallDiscardReasonType)(text.as_ref()) }
}



/// The call wasn't discarded, or the reason is unknown. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonEmpty
  
}



impl Object for CallDiscardReasonEmpty {}
impl RObject for CallDiscardReasonEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonEmpty" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonEmpty {}


impl CallDiscardReasonEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call was ended before the conversation started. It was cancelled by the caller or missed by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonMissed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonMissed
  
}



impl Object for CallDiscardReasonMissed {}
impl RObject for CallDiscardReasonMissed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonMissed" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonMissed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonMissed {}


impl CallDiscardReasonMissed {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call was ended before the conversation started. It was declined by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDeclined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonDeclined
  
}



impl Object for CallDiscardReasonDeclined {}
impl RObject for CallDiscardReasonDeclined {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonDeclined" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonDeclined }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonDeclined {}


impl CallDiscardReasonDeclined {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call was ended during the conversation because the users were disconnected. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDisconnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonDisconnected
  
}



impl Object for CallDiscardReasonDisconnected {}
impl RObject for CallDiscardReasonDisconnected {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonDisconnected" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonDisconnected }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonDisconnected {}


impl CallDiscardReasonDisconnected {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call was ended because one of the parties hung up. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonHungUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callDiscardReasonHungUp
  
}



impl Object for CallDiscardReasonHungUp {}
impl RObject for CallDiscardReasonHungUp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callDiscardReasonHungUp" }
  fn td_type(&self) -> RTDType { RTDType::CallDiscardReasonHungUp }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallDiscardReason for CallDiscardReasonHungUp {}


impl CallDiscardReasonHungUp {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the call identifier. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callId
  /// Call identifier.
  id: Option<i32>,
  
}



impl Object for CallId {}
impl RObject for CallId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callId" }
  fn td_type(&self) -> RTDType { RTDType::CallId }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl CallId {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Specifies the supported call protocols. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallProtocol {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callProtocol
  /// True, if UDP peer-to-peer connections are supported.
  udp_p2p: Option<bool>,
  /// True, if connection through UDP reflectors is supported.
  udp_reflector: Option<bool>,
  /// Minimum supported API layer; use 65.
  min_layer: Option<i32>,
  /// Maximum supported API layer; use 65.
  max_layer: Option<i32>,
  
}



impl Object for CallProtocol {}
impl RObject for CallProtocol {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callProtocol" }
  fn td_type(&self) -> RTDType { RTDType::CallProtocol }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl CallProtocol {
  
  pub fn udp_p2p(&self) -> Option<bool> { self.udp_p2p.clone() }
  
  pub fn udp_reflector(&self) -> Option<bool> { self.udp_reflector.clone() }
  
  pub fn min_layer(&self) -> Option<i32> { self.min_layer.clone() }
  
  pub fn max_layer(&self) -> Option<i32> { self.max_layer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the current call state. 
#[typetag::serde(tag = "@struct")]
pub trait CallState: Object + RObject + Debug {}






impl CallState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<CallState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallStateType {
  CallStateDiscarded,
  CallStateError,
  CallStateExchangingKeys,
  CallStateHangingUp,
  CallStatePending,
  CallStateReady,
  
}
impl RTDCallStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDCallStateType)(text.as_ref()) }
}



/// The call is pending, waiting to be accepted by a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStatePending
  /// True, if the call has already been created by the server.
  is_created: Option<bool>,
  /// True, if the call has already been received by the other party.
  is_received: Option<bool>,
  
}



impl Object for CallStatePending {}
impl RObject for CallStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStatePending" }
  fn td_type(&self) -> RTDType { RTDType::CallStatePending }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStatePending {}


impl CallStatePending {
  
  pub fn is_created(&self) -> Option<bool> { self.is_created.clone() }
  
  pub fn is_received(&self) -> Option<bool> { self.is_received.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call has been answered and encryption keys are being exchanged. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateExchangingKeys {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateExchangingKeys
  
}



impl Object for CallStateExchangingKeys {}
impl RObject for CallStateExchangingKeys {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateExchangingKeys" }
  fn td_type(&self) -> RTDType { RTDType::CallStateExchangingKeys }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStateExchangingKeys {}


impl CallStateExchangingKeys {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateReady
  /// Call protocols supported by the peer.
  protocol: Option<CallProtocol>,
  /// Available UDP reflectors.
  connections: Option<Vec<CallConnection>>,
  /// A JSON-encoded call config.
  config: Option<String>,
  /// Call encryption key.
  encryption_key: Option<String>,
  /// Encryption key emojis fingerprint.
  emojis: Option<Vec<String>>,
  /// True, if peer-to-peer connection is allowed by users privacy settings.
  allow_p2p: Option<bool>,
  
}



impl Object for CallStateReady {}
impl RObject for CallStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateReady" }
  fn td_type(&self) -> RTDType { RTDType::CallStateReady }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStateReady {}


impl CallStateReady {
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn connections(&self) -> Option<Vec<CallConnection>> { self.connections.clone() }
  
  pub fn config(&self) -> Option<String> { self.config.clone() }
  
  pub fn encryption_key(&self) -> Option<String> { self.encryption_key.clone() }
  
  pub fn emojis(&self) -> Option<Vec<String>> { self.emojis.clone() }
  
  pub fn allow_p2p(&self) -> Option<bool> { self.allow_p2p.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call is hanging up after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateHangingUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateHangingUp
  
}



impl Object for CallStateHangingUp {}
impl RObject for CallStateHangingUp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateHangingUp" }
  fn td_type(&self) -> RTDType { RTDType::CallStateHangingUp }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStateHangingUp {}


impl CallStateHangingUp {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call has ended successfully. 
#[derive(Debug, Serialize, Deserialize)]
pub struct CallStateDiscarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateDiscarded
  /// The reason, why the call has ended.
  reason: Option<Box<CallDiscardReason>>,
  /// True, if the call rating should be sent to the server.
  need_rating: Option<bool>,
  /// True, if the call debug information should be sent to the server.
  need_debug_information: Option<bool>,
  
}


impl Clone for CallStateDiscarded {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for CallStateDiscarded {}
impl RObject for CallStateDiscarded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateDiscarded" }
  fn td_type(&self) -> RTDType { RTDType::CallStateDiscarded }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStateDiscarded {}


impl CallStateDiscarded {
  
  pub fn reason(&self) -> Option<Box<CallDiscardReason>> { self.reason.clone() }
  
  pub fn need_rating(&self) -> Option<bool> { self.need_rating.clone() }
  
  pub fn need_debug_information(&self) -> Option<bool> { self.need_debug_information.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The call has ended with an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callStateError
  /// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout.
  error: Option<Error>,
  
}



impl Object for CallStateError {}
impl RObject for CallStateError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callStateError" }
  fn td_type(&self) -> RTDType { RTDType::CallStateError }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallState for CallStateError {}


impl CallStateError {
  
  pub fn error(&self) -> Option<Error> { self.error.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a bot's answer to a callback query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryAnswer
  /// Text of the answer.
  text: Option<String>,
  /// True, if an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,
  
}



impl Object for CallbackQueryAnswer {}
impl RObject for CallbackQueryAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryAnswer" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryAnswer }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl CallbackQueryAnswer {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn show_alert(&self) -> Option<bool> { self.show_alert.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a payload of a callback query. 
#[typetag::serde(tag = "@struct")]
pub trait CallbackQueryPayload: Object + RObject + Debug {}






impl CallbackQueryPayload {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<CallbackQueryPayload> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCallbackQueryPayloadType {
  CallbackQueryPayloadData,
  CallbackQueryPayloadGame,
  
}
impl RTDCallbackQueryPayloadType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDCallbackQueryPayloadType)(text.as_ref()) }
}



/// The payload from a general callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryPayloadData
  /// Data that was attached to the callback button.
  data: Option<String>,
  
}



impl Object for CallbackQueryPayloadData {}
impl RObject for CallbackQueryPayloadData {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryPayloadData" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryPayloadData }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallbackQueryPayload for CallbackQueryPayloadData {}


impl CallbackQueryPayloadData {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The payload from a game callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // callbackQueryPayloadGame
  /// A short name of the game that was attached to the callback button.
  game_short_name: Option<String>,
  
}



impl Object for CallbackQueryPayloadGame {}
impl RObject for CallbackQueryPayloadGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "callbackQueryPayloadGame" }
  fn td_type(&self) -> RTDType { RTDType::CallbackQueryPayloadGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CallbackQueryPayload for CallbackQueryPayloadGame {}


impl CallbackQueryPayloadGame {
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat. (Can be a private chat, basic group, supergroup, or secret chat.) 
#[derive(Debug, Serialize, Deserialize)]
pub struct Chat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chat
  /// Chat unique identifier.
  id: Option<i64>,
  /// Type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Last message in the chat; may be null.
  last_message: Option<Message>,
  /// Descending parameter by which chats are sorted in the main chat list. If the order number of two chats is the same, they must be sorted in descending order by ID. If 0, the position of the chat in the list is undetermined.
  order: Option<String>,
  /// True, if the chat is pinned.
  is_pinned: Option<bool>,
  /// True, if the chat is marked as unread.
  is_marked_as_unread: Option<bool>,
  /// True, if the chat is sponsored by the user's MTProxy server.
  is_sponsored: Option<bool>,
  /// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the chat messages can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the chat can be reported to Telegram moderators through reportChat.
  can_be_reported: Option<bool>,
  /// Default value of the disable_notification parameter, used when a message is sent to the chat.
  default_disable_notification: Option<bool>,
  /// Number of unread messages in the chat.
  unread_count: Option<i32>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// Identifier of the last read outgoing message.
  last_read_outbox_message_id: Option<i64>,
  /// Number of unread messages with a mention/reply in the chat.
  unread_mention_count: Option<i32>,
  /// Notification settings for this chat.
  notification_settings: Option<ChatNotificationSettings>,
  /// Identifier of the pinned message in the chat; 0 if none.
  pinned_message_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,
  /// A draft of a message in the chat; may be null.
  draft_message: Option<DraftMessage>,
  /// Contains client-specific data associated with the chat. (For example, the chat position or local chat notification settings can be stored here.) Persistent if a message database is used.
  client_data: Option<String>,
  
}


impl Clone for Chat {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Chat {}
impl RObject for Chat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chat" }
  fn td_type(&self) -> RTDType { RTDType::Chat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Chat {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn type_(&self) -> Option<Box<ChatType>> { self.type_.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn last_message(&self) -> Option<Message> { self.last_message.clone() }
  
  pub fn order(&self) -> Option<String> { self.order.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn is_sponsored(&self) -> Option<bool> { self.is_sponsored.clone() }
  
  pub fn can_be_deleted_only_for_self(&self) -> Option<bool> { self.can_be_deleted_only_for_self.clone() }
  
  pub fn can_be_deleted_for_all_users(&self) -> Option<bool> { self.can_be_deleted_for_all_users.clone() }
  
  pub fn can_be_reported(&self) -> Option<bool> { self.can_be_reported.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn last_read_inbox_message_id(&self) -> Option<i64> { self.last_read_inbox_message_id.clone() }
  
  pub fn last_read_outbox_message_id(&self) -> Option<i64> { self.last_read_outbox_message_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn pinned_message_id(&self) -> Option<i64> { self.pinned_message_id.clone() }
  
  pub fn reply_markup_message_id(&self) -> Option<i64> { self.reply_markup_message_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn client_data(&self) -> Option<String> { self.client_data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the different types of activity in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatAction: Object + RObject + Debug {}






impl ChatAction {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatAction> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatActionType {
  ChatActionCancel,
  ChatActionChoosingContact,
  ChatActionChoosingLocation,
  ChatActionRecordingVideo,
  ChatActionRecordingVideoNote,
  ChatActionRecordingVoiceNote,
  ChatActionStartPlayingGame,
  ChatActionTyping,
  ChatActionUploadingDocument,
  ChatActionUploadingPhoto,
  ChatActionUploadingVideo,
  ChatActionUploadingVideoNote,
  ChatActionUploadingVoiceNote,
  
}
impl RTDChatActionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatActionType)(text.as_ref()) }
}



/// The user is typing a message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionTyping {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionTyping
  
}



impl Object for ChatActionTyping {}
impl RObject for ChatActionTyping {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionTyping" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionTyping }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionTyping {}


impl ChatActionTyping {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is recording a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVideo
  
}



impl Object for ChatActionRecordingVideo {}
impl RObject for ChatActionRecordingVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVideo" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVideo {}


impl ChatActionRecordingVideo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is uploading a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVideo
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVideo {}
impl RObject for ChatActionUploadingVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVideo" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVideo {}


impl ChatActionUploadingVideo {
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is recording a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVoiceNote
  
}



impl Object for ChatActionRecordingVoiceNote {}
impl RObject for ChatActionRecordingVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVoiceNote {}


impl ChatActionRecordingVoiceNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is uploading a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVoiceNote
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVoiceNote {}
impl RObject for ChatActionUploadingVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVoiceNote {}


impl ChatActionUploadingVoiceNote {
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is uploading a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingPhoto
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingPhoto {}
impl RObject for ChatActionUploadingPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingPhoto" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingPhoto {}


impl ChatActionUploadingPhoto {
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is uploading a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingDocument
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingDocument {}
impl RObject for ChatActionUploadingDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingDocument" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingDocument {}


impl ChatActionUploadingDocument {
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is picking a location or venue to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionChoosingLocation
  
}



impl Object for ChatActionChoosingLocation {}
impl RObject for ChatActionChoosingLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionChoosingLocation" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionChoosingLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionChoosingLocation {}


impl ChatActionChoosingLocation {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is picking a contact to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionChoosingContact
  
}



impl Object for ChatActionChoosingContact {}
impl RObject for ChatActionChoosingContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionChoosingContact" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionChoosingContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionChoosingContact {}


impl ChatActionChoosingContact {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has started to play a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionStartPlayingGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionStartPlayingGame
  
}



impl Object for ChatActionStartPlayingGame {}
impl RObject for ChatActionStartPlayingGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionStartPlayingGame" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionStartPlayingGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionStartPlayingGame {}


impl ChatActionStartPlayingGame {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is recording a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionRecordingVideoNote
  
}



impl Object for ChatActionRecordingVideoNote {}
impl RObject for ChatActionRecordingVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionRecordingVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionRecordingVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionRecordingVideoNote {}


impl ChatActionRecordingVideoNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is uploading a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionUploadingVideoNote
  /// Upload progress, as a percentage.
  progress: Option<i32>,
  
}



impl Object for ChatActionUploadingVideoNote {}
impl RObject for ChatActionUploadingVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionUploadingVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionUploadingVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionUploadingVideoNote {}


impl ChatActionUploadingVideoNote {
  
  pub fn progress(&self) -> Option<i32> { self.progress.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has cancelled the previous action. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionCancel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatActionCancel
  
}



impl Object for ChatActionCancel {}
impl RObject for ChatActionCancel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatActionCancel" }
  fn td_type(&self) -> RTDType { RTDType::ChatActionCancel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatAction for ChatActionCancel {}


impl ChatActionCancel {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a chat event. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEvent
  /// Chat event identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the event happened.
  date: Option<i32>,
  /// Identifier of the user who performed the action that triggered the event.
  user_id: Option<i32>,
  /// Action performed by the user.
  action: Option<Box<ChatEventAction>>,
  
}


impl Clone for ChatEvent {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatEvent {}
impl RObject for ChatEvent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEvent" }
  fn td_type(&self) -> RTDType { RTDType::ChatEvent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatEvent {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatEventAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a chat event. 
#[typetag::serde(tag = "@struct")]
pub trait ChatEventAction: Object + RObject + Debug {}






impl ChatEventAction {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatEventAction> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatEventActionType {
  ChatEventDescriptionChanged,
  ChatEventInvitesToggled,
  ChatEventIsAllHistoryAvailableToggled,
  ChatEventMemberInvited,
  ChatEventMemberJoined,
  ChatEventMemberLeft,
  ChatEventMemberPromoted,
  ChatEventMemberRestricted,
  ChatEventMessageDeleted,
  ChatEventMessageEdited,
  ChatEventMessagePinned,
  ChatEventMessageUnpinned,
  ChatEventPhotoChanged,
  ChatEventSignMessagesToggled,
  ChatEventStickerSetChanged,
  ChatEventTitleChanged,
  ChatEventUsernameChanged,
  
}
impl RTDChatEventActionType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatEventActionType)(text.as_ref()) }
}



/// A message was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageEdited
  /// The original message before the edit.
  old_message: Option<Message>,
  /// The message after it was edited.
  new_message: Option<Message>,
  
}



impl Object for ChatEventMessageEdited {}
impl RObject for ChatEventMessageEdited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageEdited" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageEdited }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageEdited {}


impl ChatEventMessageEdited {
  
  pub fn old_message(&self) -> Option<Message> { self.old_message.clone() }
  
  pub fn new_message(&self) -> Option<Message> { self.new_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageDeleted
  /// Deleted message.
  message: Option<Message>,
  
}



impl Object for ChatEventMessageDeleted {}
impl RObject for ChatEventMessageDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageDeleted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageDeleted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageDeleted {}


impl ChatEventMessageDeleted {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message was pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessagePinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessagePinned
  /// Pinned message.
  message: Option<Message>,
  
}



impl Object for ChatEventMessagePinned {}
impl RObject for ChatEventMessagePinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessagePinned" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessagePinned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessagePinned {}


impl ChatEventMessagePinned {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message was unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageUnpinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMessageUnpinned
  
}



impl Object for ChatEventMessageUnpinned {}
impl RObject for ChatEventMessageUnpinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMessageUnpinned" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMessageUnpinned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMessageUnpinned {}


impl ChatEventMessageUnpinned {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new member joined the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberJoined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberJoined
  
}



impl Object for ChatEventMemberJoined {}
impl RObject for ChatEventMemberJoined {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberJoined" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberJoined }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberJoined {}


impl ChatEventMemberJoined {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A member left the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberLeft
  
}



impl Object for ChatEventMemberLeft {}
impl RObject for ChatEventMemberLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberLeft" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberLeft }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberLeft {}


impl ChatEventMemberLeft {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new chat member was invited. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberInvited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberInvited
  /// New member user identifier.
  user_id: Option<i32>,
  /// New member status.
  status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberInvited {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatEventMemberInvited {}
impl RObject for ChatEventMemberInvited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberInvited" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberInvited }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberInvited {}


impl ChatEventMemberInvited {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberPromoted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberPromoted
  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberPromoted {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatEventMemberPromoted {}
impl RObject for ChatEventMemberPromoted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberPromoted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberPromoted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberPromoted {}


impl ChatEventMemberPromoted {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn old_status(&self) -> Option<Box<ChatMemberStatus>> { self.old_status.clone() }
  
  pub fn new_status(&self) -> Option<Box<ChatMemberStatus>> { self.new_status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventMemberRestricted
  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for ChatEventMemberRestricted {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatEventMemberRestricted {}
impl RObject for ChatEventMemberRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventMemberRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventMemberRestricted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventMemberRestricted {}


impl ChatEventMemberRestricted {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn old_status(&self) -> Option<Box<ChatMemberStatus>> { self.old_status.clone() }
  
  pub fn new_status(&self) -> Option<Box<ChatMemberStatus>> { self.new_status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat title was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventTitleChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventTitleChanged
  /// Previous chat title.
  old_title: Option<String>,
  /// New chat title.
  new_title: Option<String>,
  
}



impl Object for ChatEventTitleChanged {}
impl RObject for ChatEventTitleChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventTitleChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventTitleChanged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventTitleChanged {}


impl ChatEventTitleChanged {
  
  pub fn old_title(&self) -> Option<String> { self.old_title.clone() }
  
  pub fn new_title(&self) -> Option<String> { self.new_title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat description was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventDescriptionChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventDescriptionChanged
  /// Previous chat description.
  old_description: Option<String>,
  /// New chat description.
  new_description: Option<String>,
  
}



impl Object for ChatEventDescriptionChanged {}
impl RObject for ChatEventDescriptionChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventDescriptionChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventDescriptionChanged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventDescriptionChanged {}


impl ChatEventDescriptionChanged {
  
  pub fn old_description(&self) -> Option<String> { self.old_description.clone() }
  
  pub fn new_description(&self) -> Option<String> { self.new_description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat username was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventUsernameChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventUsernameChanged
  /// Previous chat username.
  old_username: Option<String>,
  /// New chat username.
  new_username: Option<String>,
  
}



impl Object for ChatEventUsernameChanged {}
impl RObject for ChatEventUsernameChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventUsernameChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventUsernameChanged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventUsernameChanged {}


impl ChatEventUsernameChanged {
  
  pub fn old_username(&self) -> Option<String> { self.old_username.clone() }
  
  pub fn new_username(&self) -> Option<String> { self.new_username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventPhotoChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventPhotoChanged
  /// Previous chat photo value; may be null.
  old_photo: Option<ChatPhoto>,
  /// New chat photo value; may be null.
  new_photo: Option<ChatPhoto>,
  
}



impl Object for ChatEventPhotoChanged {}
impl RObject for ChatEventPhotoChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventPhotoChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventPhotoChanged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventPhotoChanged {}


impl ChatEventPhotoChanged {
  
  pub fn old_photo(&self) -> Option<ChatPhoto> { self.old_photo.clone() }
  
  pub fn new_photo(&self) -> Option<ChatPhoto> { self.new_photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The anyone_can_invite setting of a supergroup chat was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventInvitesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventInvitesToggled
  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,
  
}



impl Object for ChatEventInvitesToggled {}
impl RObject for ChatEventInvitesToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventInvitesToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventInvitesToggled }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventInvitesToggled {}


impl ChatEventInvitesToggled {
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The sign_messages setting of a channel was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventSignMessagesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventSignMessagesToggled
  /// New value of sign_messages.
  sign_messages: Option<bool>,
  
}



impl Object for ChatEventSignMessagesToggled {}
impl RObject for ChatEventSignMessagesToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventSignMessagesToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventSignMessagesToggled }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventSignMessagesToggled {}


impl ChatEventSignMessagesToggled {
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The supergroup sticker set was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventStickerSetChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventStickerSetChanged
  /// Previous identifier of the chat sticker set; 0 if none.
  old_sticker_set_id: Option<i64>,
  /// New identifier of the chat sticker set; 0 if none.
  new_sticker_set_id: Option<i64>,
  
}



impl Object for ChatEventStickerSetChanged {}
impl RObject for ChatEventStickerSetChanged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventStickerSetChanged" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventStickerSetChanged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventStickerSetChanged {}


impl ChatEventStickerSetChanged {
  
  pub fn old_sticker_set_id(&self) -> Option<i64> { self.old_sticker_set_id.clone() }
  
  pub fn new_sticker_set_id(&self) -> Option<i64> { self.new_sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The is_all_history_available setting of a supergroup was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventIsAllHistoryAvailableToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventIsAllHistoryAvailableToggled
  /// New value of is_all_history_available.
  is_all_history_available: Option<bool>,
  
}



impl Object for ChatEventIsAllHistoryAvailableToggled {}
impl RObject for ChatEventIsAllHistoryAvailableToggled {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventIsAllHistoryAvailableToggled" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventIsAllHistoryAvailableToggled }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatEventAction for ChatEventIsAllHistoryAvailableToggled {}


impl ChatEventIsAllHistoryAvailableToggled {
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a set of filters used to obtain a chat event log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventLogFilters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEventLogFilters
  /// True, if message edits should be returned.
  message_edits: Option<bool>,
  /// True, if message deletions should be returned.
  message_deletions: Option<bool>,
  /// True, if pin/unpin events should be returned.
  message_pins: Option<bool>,
  /// True, if members joining events should be returned.
  member_joins: Option<bool>,
  /// True, if members leaving events should be returned.
  member_leaves: Option<bool>,
  /// True, if invited member events should be returned.
  member_invites: Option<bool>,
  /// True, if member promotion/demotion events should be returned.
  member_promotions: Option<bool>,
  /// True, if member restricted/unrestricted/banned/unbanned events should be returned.
  member_restrictions: Option<bool>,
  /// True, if changes in chat information should be returned.
  info_changes: Option<bool>,
  /// True, if changes in chat settings should be returned.
  setting_changes: Option<bool>,
  
}



impl Object for ChatEventLogFilters {}
impl RObject for ChatEventLogFilters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEventLogFilters" }
  fn td_type(&self) -> RTDType { RTDType::ChatEventLogFilters }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatEventLogFilters {
  
  pub fn message_edits(&self) -> Option<bool> { self.message_edits.clone() }
  
  pub fn message_deletions(&self) -> Option<bool> { self.message_deletions.clone() }
  
  pub fn message_pins(&self) -> Option<bool> { self.message_pins.clone() }
  
  pub fn member_joins(&self) -> Option<bool> { self.member_joins.clone() }
  
  pub fn member_leaves(&self) -> Option<bool> { self.member_leaves.clone() }
  
  pub fn member_invites(&self) -> Option<bool> { self.member_invites.clone() }
  
  pub fn member_promotions(&self) -> Option<bool> { self.member_promotions.clone() }
  
  pub fn member_restrictions(&self) -> Option<bool> { self.member_restrictions.clone() }
  
  pub fn info_changes(&self) -> Option<bool> { self.info_changes.clone() }
  
  pub fn setting_changes(&self) -> Option<bool> { self.setting_changes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of chat events. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEvents {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatEvents
  /// List of events.
  events: Option<Vec<ChatEvent>>,
  
}



impl Object for ChatEvents {}
impl RObject for ChatEvents {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatEvents" }
  fn td_type(&self) -> RTDType { RTDType::ChatEvents }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatEvents {
  
  pub fn events(&self) -> Option<Vec<ChatEvent>> { self.events.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatInviteLink
  /// Chat invite link.
  invite_link: Option<String>,
  
}



impl Object for ChatInviteLink {}
impl RObject for ChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::ChatInviteLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatInviteLink {
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a chat invite link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatInviteLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatInviteLinkInfo
  /// Chat identifier of the invite link; 0 if the user is not a member of this chat.
  chat_id: Option<i64>,
  /// Contains information about the type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Title of the chat.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Number of members.
  member_count: Option<i32>,
  /// User identifiers of some chat members that may be known to the current user.
  member_user_ids: Option<Vec<i32>>,
  /// True, if the chat is a public supergroup or channel with a username.
  is_public: Option<bool>,
  
}


impl Clone for ChatInviteLinkInfo {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatInviteLinkInfo {}
impl RObject for ChatInviteLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatInviteLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::ChatInviteLinkInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatInviteLinkInfo {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn type_(&self) -> Option<Box<ChatType>> { self.type_.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn is_public(&self) -> Option<bool> { self.is_public.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A user with information about joining/leaving a chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMember
  /// User identifier of the chat member.
  user_id: Option<i32>,
  /// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown.
  inviter_user_id: Option<i32>,
  /// Point in time (Unix timestamp) when the user joined a chat.
  joined_chat_date: Option<i32>,
  /// Status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,
  /// If the user is a bot, information about the bot; may be null. Can be null even for a bot if the bot is not a chat member.
  bot_info: Option<BotInfo>,
  
}


impl Clone for ChatMember {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ChatMember {}
impl RObject for ChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMember" }
  fn td_type(&self) -> RTDType { RTDType::ChatMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatMember {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn inviter_user_id(&self) -> Option<i32> { self.inviter_user_id.clone() }
  
  pub fn joined_chat_date(&self) -> Option<i32> { self.joined_chat_date.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn bot_info(&self) -> Option<BotInfo> { self.bot_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Provides information about the status of a member in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatMemberStatus: Object + RObject + Debug {}






impl ChatMemberStatus {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatMemberStatus> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatMemberStatusType {
  ChatMemberStatusAdministrator,
  ChatMemberStatusBanned,
  ChatMemberStatusCreator,
  ChatMemberStatusLeft,
  ChatMemberStatusMember,
  ChatMemberStatusRestricted,
  
}
impl RTDChatMemberStatusType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatMemberStatusType)(text.as_ref()) }
}



/// The user is the creator of a chat and has all the administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusCreator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusCreator
  /// True, if the user is a member of the chat.
  is_member: Option<bool>,
  
}



impl Object for ChatMemberStatusCreator {}
impl RObject for ChatMemberStatusCreator {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusCreator" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusCreator }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusCreator {}


impl ChatMemberStatusCreator {
  
  pub fn is_member(&self) -> Option<bool> { self.is_member.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusAdministrator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusAdministrator
  /// True, if the current user can edit the administrator privileges for the called user.
  can_be_edited: Option<bool>,
  /// True, if the administrator can change the chat title, photo, and other settings.
  can_change_info: Option<bool>,
  /// True, if the administrator can create channel posts; applicable to channels only.
  can_post_messages: Option<bool>,
  /// True, if the administrator can edit messages of other users and pin messages; applicable to channels only.
  can_edit_messages: Option<bool>,
  /// True, if the administrator can delete messages of other users.
  can_delete_messages: Option<bool>,
  /// True, if the administrator can invite new users to the chat.
  can_invite_users: Option<bool>,
  /// True, if the administrator can restrict, ban, or unban chat members.
  can_restrict_members: Option<bool>,
  /// True, if the administrator can pin messages; applicable to groups only.
  can_pin_messages: Option<bool>,
  /// True, if the administrator can add new administrators with a subset of his own privileges or demote administrators that were directly or indirectly promoted by him.
  can_promote_members: Option<bool>,
  
}



impl Object for ChatMemberStatusAdministrator {}
impl RObject for ChatMemberStatusAdministrator {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusAdministrator" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusAdministrator }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusAdministrator {}


impl ChatMemberStatusAdministrator {
  
  pub fn can_be_edited(&self) -> Option<bool> { self.can_be_edited.clone() }
  
  pub fn can_change_info(&self) -> Option<bool> { self.can_change_info.clone() }
  
  pub fn can_post_messages(&self) -> Option<bool> { self.can_post_messages.clone() }
  
  pub fn can_edit_messages(&self) -> Option<bool> { self.can_edit_messages.clone() }
  
  pub fn can_delete_messages(&self) -> Option<bool> { self.can_delete_messages.clone() }
  
  pub fn can_invite_users(&self) -> Option<bool> { self.can_invite_users.clone() }
  
  pub fn can_restrict_members(&self) -> Option<bool> { self.can_restrict_members.clone() }
  
  pub fn can_pin_messages(&self) -> Option<bool> { self.can_pin_messages.clone() }
  
  pub fn can_promote_members(&self) -> Option<bool> { self.can_promote_members.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is a member of a chat, without any additional privileges or restrictions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusMember
  
}



impl Object for ChatMemberStatusMember {}
impl RObject for ChatMemberStatusMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusMember" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusMember {}


impl ChatMemberStatusMember {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is under certain restrictions in the chat. Not supported in basic groups and channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusRestricted
  /// True, if the user is a member of the chat.
  is_member: Option<bool>,
  /// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever.
  restricted_until_date: Option<i32>,
  /// True, if the user can send text messages, contacts, locations, and venues.
  can_send_messages: Option<bool>,
  /// True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions.
  can_send_media_messages: Option<bool>,
  /// True, if the user can send animations, games, and stickers and use inline bots. Implies can_send_media_messages permissions.
  can_send_other_messages: Option<bool>,
  /// True, if the user may add a web page preview to his messages. Implies can_send_messages permissions.
  can_add_web_page_previews: Option<bool>,
  
}



impl Object for ChatMemberStatusRestricted {}
impl RObject for ChatMemberStatusRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusRestricted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusRestricted {}


impl ChatMemberStatusRestricted {
  
  pub fn is_member(&self) -> Option<bool> { self.is_member.clone() }
  
  pub fn restricted_until_date(&self) -> Option<i32> { self.restricted_until_date.clone() }
  
  pub fn can_send_messages(&self) -> Option<bool> { self.can_send_messages.clone() }
  
  pub fn can_send_media_messages(&self) -> Option<bool> { self.can_send_media_messages.clone() }
  
  pub fn can_send_other_messages(&self) -> Option<bool> { self.can_send_other_messages.clone() }
  
  pub fn can_add_web_page_previews(&self) -> Option<bool> { self.can_add_web_page_previews.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is not a chat member. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusLeft
  
}



impl Object for ChatMemberStatusLeft {}
impl RObject for ChatMemberStatusLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusLeft" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusLeft }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusLeft {}


impl ChatMemberStatusLeft {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMemberStatusBanned
  /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever.
  banned_until_date: Option<i32>,
  
}



impl Object for ChatMemberStatusBanned {}
impl RObject for ChatMemberStatusBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMemberStatusBanned" }
  fn td_type(&self) -> RTDType { RTDType::ChatMemberStatusBanned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMemberStatus for ChatMemberStatusBanned {}


impl ChatMemberStatusBanned {
  
  pub fn banned_until_date(&self) -> Option<i32> { self.banned_until_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembers
  /// Approximate total count of chat members found.
  total_count: Option<i32>,
  /// A list of chat members.
  members: Option<Vec<ChatMember>>,
  
}



impl Object for ChatMembers {}
impl RObject for ChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembers" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatMembers {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn members(&self) -> Option<Vec<ChatMember>> { self.members.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait ChatMembersFilter: Object + RObject + Debug {}






impl ChatMembersFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatMembersFilter> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatMembersFilterType {
  ChatMembersFilterAdministrators,
  ChatMembersFilterBanned,
  ChatMembersFilterBots,
  ChatMembersFilterMembers,
  ChatMembersFilterRestricted,
  
}
impl RTDChatMembersFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatMembersFilterType)(text.as_ref()) }
}



/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterAdministrators
  
}



impl Object for ChatMembersFilterAdministrators {}
impl RObject for ChatMembersFilterAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterAdministrators }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterAdministrators {}


impl ChatMembersFilterAdministrators {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all chat members, including restricted chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterMembers
  
}



impl Object for ChatMembersFilterMembers {}
impl RObject for ChatMembersFilterMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterMembers" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterMembers {}


impl ChatMembersFilterMembers {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterRestricted
  
}



impl Object for ChatMembersFilterRestricted {}
impl RObject for ChatMembersFilterRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterRestricted" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterRestricted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterRestricted {}


impl ChatMembersFilterRestricted {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterBanned
  
}



impl Object for ChatMembersFilterBanned {}
impl RObject for ChatMembersFilterBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterBanned" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterBanned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterBanned {}


impl ChatMembersFilterBanned {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns bot members of the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatMembersFilterBots
  
}



impl Object for ChatMembersFilterBots {}
impl RObject for ChatMembersFilterBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatMembersFilterBots" }
  fn td_type(&self) -> RTDType { RTDType::ChatMembersFilterBots }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatMembersFilter for ChatMembersFilterBots {}


impl ChatMembersFilterBots {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about notification settings for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatNotificationSettings
  /// If true, mute_for is ignored and the value for the relevant type of chat is used instead.
  use_default_mute_for: Option<bool>,
  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// If true, sound is ignored and the value for the relevant type of chat is used instead.
  use_default_sound: Option<bool>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// If true, show_preview is ignored and the value for the relevant type of chat is used instead.
  use_default_show_preview: Option<bool>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_pinned_message_notifications: Option<bool>,
  /// If true, notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_mention_notifications: Option<bool>,
  /// If true, notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,
  
}



impl Object for ChatNotificationSettings {}
impl RObject for ChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ChatNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatNotificationSettings {
  
  pub fn use_default_mute_for(&self) -> Option<bool> { self.use_default_mute_for.clone() }
  
  pub fn mute_for(&self) -> Option<i32> { self.mute_for.clone() }
  
  pub fn use_default_sound(&self) -> Option<bool> { self.use_default_sound.clone() }
  
  pub fn sound(&self) -> Option<String> { self.sound.clone() }
  
  pub fn use_default_show_preview(&self) -> Option<bool> { self.use_default_show_preview.clone() }
  
  pub fn show_preview(&self) -> Option<bool> { self.show_preview.clone() }
  
  pub fn use_default_disable_pinned_message_notifications(&self) -> Option<bool> { self.use_default_disable_pinned_message_notifications.clone() }
  
  pub fn disable_pinned_message_notifications(&self) -> Option<bool> { self.disable_pinned_message_notifications.clone() }
  
  pub fn use_default_disable_mention_notifications(&self) -> Option<bool> { self.use_default_disable_mention_notifications.clone() }
  
  pub fn disable_mention_notifications(&self) -> Option<bool> { self.disable_mention_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes the photo of a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatPhoto
  /// A small (160x160) chat photo.
  small: Option<File>,
  /// A big (640x640) chat photo.
  big: Option<File>,
  
}



impl Object for ChatPhoto {}
impl RObject for ChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::ChatPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatPhoto {
  
  pub fn small(&self) -> Option<File> { self.small.clone() }
  
  pub fn big(&self) -> Option<File> { self.big.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the reason why a chat is reported. 
#[typetag::serde(tag = "@struct")]
pub trait ChatReportReason: Object + RObject + Debug {}






impl ChatReportReason {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatReportReason> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatReportReasonType {
  ChatReportReasonChildAbuse,
  ChatReportReasonCopyright,
  ChatReportReasonCustom,
  ChatReportReasonPornography,
  ChatReportReasonSpam,
  ChatReportReasonViolence,
  
}
impl RTDChatReportReasonType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatReportReasonType)(text.as_ref()) }
}



/// The chat contains spam messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonSpam
  
}



impl Object for ChatReportReasonSpam {}
impl RObject for ChatReportReasonSpam {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonSpam" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonSpam }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonSpam {}


impl ChatReportReasonSpam {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat promotes violence. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonViolence {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonViolence
  
}



impl Object for ChatReportReasonViolence {}
impl RObject for ChatReportReasonViolence {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonViolence" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonViolence }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonViolence {}


impl ChatReportReasonViolence {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat contains pornographic messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonPornography {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonPornography
  
}



impl Object for ChatReportReasonPornography {}
impl RObject for ChatReportReasonPornography {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonPornography" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonPornography }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonPornography {}


impl ChatReportReasonPornography {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat has child abuse related content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonChildAbuse {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonChildAbuse
  
}



impl Object for ChatReportReasonChildAbuse {}
impl RObject for ChatReportReasonChildAbuse {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonChildAbuse" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonChildAbuse }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonChildAbuse {}


impl ChatReportReasonChildAbuse {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat contains copyrighted content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCopyright {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonCopyright
  
}



impl Object for ChatReportReasonCopyright {}
impl RObject for ChatReportReasonCopyright {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonCopyright" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonCopyright }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonCopyright {}


impl ChatReportReasonCopyright {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A custom reason provided by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCustom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportReasonCustom
  /// Report text.
  text: Option<String>,
  
}



impl Object for ChatReportReasonCustom {}
impl RObject for ChatReportReasonCustom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportReasonCustom" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportReasonCustom }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatReportReason for ChatReportReasonCustom {}


impl ChatReportReasonCustom {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about the availability of the "Report spam" action for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatReportSpamState
  /// True, if a prompt with the "Report spam" action should be shown to the user.
  can_report_spam: Option<bool>,
  
}



impl Object for ChatReportSpamState {}
impl RObject for ChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::ChatReportSpamState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ChatReportSpamState {
  
  pub fn can_report_spam(&self) -> Option<bool> { self.can_report_spam.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the type of a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatType: Object + RObject + Debug {}






impl ChatType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ChatType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDChatTypeType {
  ChatTypeBasicGroup,
  ChatTypePrivate,
  ChatTypeSecret,
  ChatTypeSupergroup,
  
}
impl RTDChatTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDChatTypeType)(text.as_ref()) }
}



/// An ordinary chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypePrivate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypePrivate
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for ChatTypePrivate {}
impl RObject for ChatTypePrivate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypePrivate" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypePrivate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatType for ChatTypePrivate {}


impl ChatTypePrivate {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A basic group (i.e., a chat with 0-200 other users). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeBasicGroup
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for ChatTypeBasicGroup {}
impl RObject for ChatTypeBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeBasicGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatType for ChatTypeBasicGroup {}


impl ChatTypeBasicGroup {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeSupergroup
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,
  
}



impl Object for ChatTypeSupergroup {}
impl RObject for ChatTypeSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeSupergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatType for ChatTypeSupergroup {}


impl ChatTypeSupergroup {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A secret chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chatTypeSecret
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  /// User identifier of the secret chat peer.
  user_id: Option<i32>,
  
}



impl Object for ChatTypeSecret {}
impl RObject for ChatTypeSecret {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chatTypeSecret" }
  fn td_type(&self) -> RTDType { RTDType::ChatTypeSecret }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ChatType for ChatTypeSecret {}


impl ChatTypeSecret {
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Chats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // chats
  /// List of chat identifiers.
  chat_ids: Option<Vec<i64>>,
  
}



impl Object for Chats {}
impl RObject for Chats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "chats" }
  fn td_type(&self) -> RTDType { RTDType::Chats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Chats {
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents result of checking whether a username can be set for a chat. 
#[typetag::serde(tag = "@struct")]
pub trait CheckChatUsernameResult: Object + RObject + Debug {}






impl CheckChatUsernameResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<CheckChatUsernameResult> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDCheckChatUsernameResultType {
  CheckChatUsernameResultOk,
  CheckChatUsernameResultPublicChatsTooMuch,
  CheckChatUsernameResultPublicGroupsUnavailable,
  CheckChatUsernameResultUsernameInvalid,
  CheckChatUsernameResultUsernameOccupied,
  
}
impl RTDCheckChatUsernameResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDCheckChatUsernameResultType)(text.as_ref()) }
}



/// The username can be set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultOk {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultOk
  
}



impl Object for CheckChatUsernameResultOk {}
impl RObject for CheckChatUsernameResultOk {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultOk" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultOk }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultOk {}


impl CheckChatUsernameResultOk {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The username is invalid. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameInvalid {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultUsernameInvalid
  
}



impl Object for CheckChatUsernameResultUsernameInvalid {}
impl RObject for CheckChatUsernameResultUsernameInvalid {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultUsernameInvalid" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultUsernameInvalid }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultUsernameInvalid {}


impl CheckChatUsernameResultUsernameInvalid {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The username is occupied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameOccupied {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultUsernameOccupied
  
}



impl Object for CheckChatUsernameResultUsernameOccupied {}
impl RObject for CheckChatUsernameResultUsernameOccupied {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultUsernameOccupied" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultUsernameOccupied }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultUsernameOccupied {}


impl CheckChatUsernameResultUsernameOccupied {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has too much public chats, one of them should be made private first. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicChatsTooMuch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultPublicChatsTooMuch
  
}



impl Object for CheckChatUsernameResultPublicChatsTooMuch {}
impl RObject for CheckChatUsernameResultPublicChatsTooMuch {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultPublicChatsTooMuch" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultPublicChatsTooMuch }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultPublicChatsTooMuch {}


impl CheckChatUsernameResultPublicChatsTooMuch {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user can't be a member of a public supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicGroupsUnavailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsernameResultPublicGroupsUnavailable
  
}



impl Object for CheckChatUsernameResultPublicGroupsUnavailable {}
impl RObject for CheckChatUsernameResultPublicGroupsUnavailable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsernameResultPublicGroupsUnavailable" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsernameResultPublicGroupsUnavailable }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl CheckChatUsernameResult for CheckChatUsernameResultPublicGroupsUnavailable {}


impl CheckChatUsernameResultPublicGroupsUnavailable {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about one website the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectedWebsite
  /// Website identifier.
  id: Option<i64>,
  /// The domain name of the website.
  domain_name: Option<String>,
  /// User identifier of a bot linked with the website.
  bot_user_id: Option<i32>,
  /// The version of a browser used to log in.
  browser: Option<String>,
  /// Operating system the browser is running on.
  platform: Option<String>,
  /// Point in time (Unix timestamp) when the user was logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when obtained authorization was last used.
  last_active_date: Option<i32>,
  /// IP address from which the user was logged in, in human-readable format.
  ip: Option<String>,
  /// Human-readable description of a country and a region, from which the user was logged in, based on the IP address.
  location: Option<String>,
  
}



impl Object for ConnectedWebsite {}
impl RObject for ConnectedWebsite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectedWebsite" }
  fn td_type(&self) -> RTDType { RTDType::ConnectedWebsite }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ConnectedWebsite {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn domain_name(&self) -> Option<String> { self.domain_name.clone() }
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn browser(&self) -> Option<String> { self.browser.clone() }
  
  pub fn platform(&self) -> Option<String> { self.platform.clone() }
  
  pub fn log_in_date(&self) -> Option<i32> { self.log_in_date.clone() }
  
  pub fn last_active_date(&self) -> Option<i32> { self.last_active_date.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn location(&self) -> Option<String> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of websites the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectedWebsites
  /// List of connected websites.
  websites: Option<Vec<ConnectedWebsite>>,
  
}



impl Object for ConnectedWebsites {}
impl RObject for ConnectedWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectedWebsites" }
  fn td_type(&self) -> RTDType { RTDType::ConnectedWebsites }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ConnectedWebsites {
  
  pub fn websites(&self) -> Option<Vec<ConnectedWebsite>> { self.websites.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the current state of the connection to Telegram servers. 
#[typetag::serde(tag = "@struct")]
pub trait ConnectionState: Object + RObject + Debug {}






impl ConnectionState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ConnectionState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDConnectionStateType {
  ConnectionStateConnecting,
  ConnectionStateConnectingToProxy,
  ConnectionStateReady,
  ConnectionStateUpdating,
  ConnectionStateWaitingForNetwork,
  
}
impl RTDConnectionStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDConnectionStateType)(text.as_ref()) }
}



/// Currently waiting for the network to become available. Use SetNetworkType to change the available network type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateWaitingForNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateWaitingForNetwork
  
}



impl Object for ConnectionStateWaitingForNetwork {}
impl RObject for ConnectionStateWaitingForNetwork {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateWaitingForNetwork" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateWaitingForNetwork }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateWaitingForNetwork {}


impl ConnectionStateWaitingForNetwork {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Currently establishing a connection with a proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnectingToProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateConnectingToProxy
  
}



impl Object for ConnectionStateConnectingToProxy {}
impl RObject for ConnectionStateConnectingToProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateConnectingToProxy" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateConnectingToProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateConnectingToProxy {}


impl ConnectionStateConnectingToProxy {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Currently establishing a connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnecting {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateConnecting
  
}



impl Object for ConnectionStateConnecting {}
impl RObject for ConnectionStateConnecting {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateConnecting" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateConnecting }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateConnecting {}


impl ConnectionStateConnecting {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Downloading data received while the client was offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateUpdating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateUpdating
  
}



impl Object for ConnectionStateUpdating {}
impl RObject for ConnectionStateUpdating {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateUpdating" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateUpdating }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateUpdating {}


impl ConnectionStateUpdating {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// There is a working connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // connectionStateReady
  
}



impl Object for ConnectionStateReady {}
impl RObject for ConnectionStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "connectionStateReady" }
  fn td_type(&self) -> RTDType { RTDType::ConnectionStateReady }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ConnectionState for ConnectionStateReady {}


impl ConnectionStateReady {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // contact
  /// Phone number of the user.
  phone_number: Option<String>,
  /// First name of the user; 1-255 characters in length.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Additional data about the user in a form of vCard; 0-2048 bytes in length.
  vcard: Option<String>,
  /// Identifier of the user, if known; otherwise 0.
  user_id: Option<i32>,
  
}



impl Object for Contact {}
impl RObject for Contact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "contact" }
  fn td_type(&self) -> RTDType { RTDType::Contact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Contact {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn vcard(&self) -> Option<String> { self.vcard.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a counter. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Count {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // count
  /// Count.
  count: Option<i32>,
  
}



impl Object for Count {}
impl RObject for Count {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "count" }
  fn td_type(&self) -> RTDType { RTDType::Count }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Count {
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the result of a custom request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomRequestResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // customRequestResult
  /// A JSON-serialized result.
  result: Option<String>,
  
}



impl Object for CustomRequestResult {}
impl RObject for CustomRequestResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "customRequestResult" }
  fn td_type(&self) -> RTDType { RTDType::CustomRequestResult }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl CustomRequestResult {
  
  pub fn result(&self) -> Option<String> { self.result.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains database statistics. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // databaseStatistics
  /// Database statistics in an unspecified human-readable format.
  statistics: Option<String>,
  
}



impl Object for DatabaseStatistics {}
impl RObject for DatabaseStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "databaseStatistics" }
  fn td_type(&self) -> RTDType { RTDType::DatabaseStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl DatabaseStatistics {
  
  pub fn statistics(&self) -> Option<String> { self.statistics.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a date according to the Gregorian calendar. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Date {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // date
  /// Day of the month, 1-31.
  day: Option<i32>,
  /// Month, 1-12.
  month: Option<i32>,
  /// Year, 1-9999.
  year: Option<i32>,
  
}



impl Object for Date {}
impl RObject for Date {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "date" }
  fn td_type(&self) -> RTDType { RTDType::Date }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Date {
  
  pub fn day(&self) -> Option<i32> { self.day.clone() }
  
  pub fn month(&self) -> Option<i32> { self.month.clone() }
  
  pub fn year(&self) -> Option<i32> { self.year.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// File with the date it was uploaded. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatedFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // datedFile
  /// The file.
  file: Option<File>,
  /// Point in time (Unix timestamp) when the file was uploaded.
  date: Option<i32>,
  
}



impl Object for DatedFile {}
impl RObject for DatedFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "datedFile" }
  fn td_type(&self) -> RTDType { RTDType::DatedFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl DatedFile {
  
  pub fn file(&self) -> Option<File> { self.file.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a tg:// deep link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deepLinkInfo
  /// Text to be shown to the user.
  text: Option<FormattedText>,
  /// True, if user should be asked to update the application.
  need_update_application: Option<bool>,
  
}



impl Object for DeepLinkInfo {}
impl RObject for DeepLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deepLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::DeepLinkInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl DeepLinkInfo {
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn need_update_application(&self) -> Option<bool> { self.need_update_application.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a data needed to subscribe for push notifications through 
#[typetag::serde(tag = "@struct")]
pub trait DeviceToken: Object + RObject + Debug {}






impl DeviceToken {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<DeviceToken> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDDeviceTokenType {
  DeviceTokenApplePush,
  DeviceTokenApplePushVoIP,
  DeviceTokenBlackBerryPush,
  DeviceTokenFirebaseCloudMessaging,
  DeviceTokenMicrosoftPush,
  DeviceTokenMicrosoftPushVoIP,
  DeviceTokenSimplePush,
  DeviceTokenTizenPush,
  DeviceTokenUbuntuPush,
  DeviceTokenWebPush,
  DeviceTokenWindowsPush,
  
}
impl RTDDeviceTokenType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDDeviceTokenType)(text.as_ref()) }
}



/// A token for Firebase Cloud Messaging. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenFirebaseCloudMessaging {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenFirebaseCloudMessaging
  /// Device registration token; may be empty to de-register a device.
  token: Option<String>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,
  
}



impl Object for DeviceTokenFirebaseCloudMessaging {}
impl RObject for DeviceTokenFirebaseCloudMessaging {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenFirebaseCloudMessaging" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenFirebaseCloudMessaging }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenFirebaseCloudMessaging {}


impl DeviceTokenFirebaseCloudMessaging {
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn encrypt(&self) -> Option<bool> { self.encrypt.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Apple Push Notification service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenApplePush
  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,
  
}



impl Object for DeviceTokenApplePush {}
impl RObject for DeviceTokenApplePush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenApplePush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenApplePush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenApplePush {}


impl DeviceTokenApplePush {
  
  pub fn device_token(&self) -> Option<String> { self.device_token.clone() }
  
  pub fn is_app_sandbox(&self) -> Option<bool> { self.is_app_sandbox.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Apple Push Notification service VoIP notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenApplePushVoIP
  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,
  
}



impl Object for DeviceTokenApplePushVoIP {}
impl RObject for DeviceTokenApplePushVoIP {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenApplePushVoIP" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenApplePushVoIP }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenApplePushVoIP {}


impl DeviceTokenApplePushVoIP {
  
  pub fn device_token(&self) -> Option<String> { self.device_token.clone() }
  
  pub fn is_app_sandbox(&self) -> Option<bool> { self.is_app_sandbox.clone() }
  
  pub fn encrypt(&self) -> Option<bool> { self.encrypt.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Windows Push Notification Services. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWindowsPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenWindowsPush
  /// The access token that will be used to send notifications; may be empty to de-register a device.
  access_token: Option<String>,
  
}



impl Object for DeviceTokenWindowsPush {}
impl RObject for DeviceTokenWindowsPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenWindowsPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenWindowsPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenWindowsPush {}


impl DeviceTokenWindowsPush {
  
  pub fn access_token(&self) -> Option<String> { self.access_token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Microsoft Push Notification Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenMicrosoftPush
  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,
  
}



impl Object for DeviceTokenMicrosoftPush {}
impl RObject for DeviceTokenMicrosoftPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenMicrosoftPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenMicrosoftPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenMicrosoftPush {}


impl DeviceTokenMicrosoftPush {
  
  pub fn channel_uri(&self) -> Option<String> { self.channel_uri.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Microsoft Push Notification Service VoIP channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenMicrosoftPushVoIP
  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,
  
}



impl Object for DeviceTokenMicrosoftPushVoIP {}
impl RObject for DeviceTokenMicrosoftPushVoIP {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenMicrosoftPushVoIP" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenMicrosoftPushVoIP }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenMicrosoftPushVoIP {}


impl DeviceTokenMicrosoftPushVoIP {
  
  pub fn channel_uri(&self) -> Option<String> { self.channel_uri.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for web Push API. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWebPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenWebPush
  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,
  /// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key.
  p256dh_base64url: Option<String>,
  /// Base64url-encoded authentication secret.
  auth_base64url: Option<String>,
  
}



impl Object for DeviceTokenWebPush {}
impl RObject for DeviceTokenWebPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenWebPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenWebPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenWebPush {}


impl DeviceTokenWebPush {
  
  pub fn endpoint(&self) -> Option<String> { self.endpoint.clone() }
  
  pub fn p256dh_base64url(&self) -> Option<String> { self.p256dh_base64url.clone() }
  
  pub fn auth_base64url(&self) -> Option<String> { self.auth_base64url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Simple Push API for Firefox OS. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenSimplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenSimplePush
  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,
  
}



impl Object for DeviceTokenSimplePush {}
impl RObject for DeviceTokenSimplePush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenSimplePush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenSimplePush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenSimplePush {}


impl DeviceTokenSimplePush {
  
  pub fn endpoint(&self) -> Option<String> { self.endpoint.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Ubuntu Push 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenUbuntuPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenUbuntuPush
  /// Token; may be empty to de-register a device.
  token: Option<String>,
  
}



impl Object for DeviceTokenUbuntuPush {}
impl RObject for DeviceTokenUbuntuPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenUbuntuPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenUbuntuPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenUbuntuPush {}


impl DeviceTokenUbuntuPush {
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for BlackBerry Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenBlackBerryPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenBlackBerryPush
  /// Token; may be empty to de-register a device.
  token: Option<String>,
  
}



impl Object for DeviceTokenBlackBerryPush {}
impl RObject for DeviceTokenBlackBerryPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenBlackBerryPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenBlackBerryPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenBlackBerryPush {}


impl DeviceTokenBlackBerryPush {
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A token for Tizen Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenTizenPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deviceTokenTizenPush
  /// Push service registration identifier; may be empty to de-register a device.
  reg_id: Option<String>,
  
}



impl Object for DeviceTokenTizenPush {}
impl RObject for DeviceTokenTizenPush {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deviceTokenTizenPush" }
  fn td_type(&self) -> RTDType { RTDType::DeviceTokenTizenPush }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl DeviceToken for DeviceTokenTizenPush {}


impl DeviceTokenTizenPush {
  
  pub fn reg_id(&self) -> Option<String> { self.reg_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a document of any type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Document {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // document
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// Document thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the document.
  document: Option<File>,
  
}



impl Object for Document {}
impl RObject for Document {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "document" }
  fn td_type(&self) -> RTDType { RTDType::Document }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Document {
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn document(&self) -> Option<File> { self.document.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a message draft. 
#[derive(Debug, Serialize, Deserialize)]
pub struct DraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // draftMessage
  /// Identifier of the message to reply to; 0 if none.
  reply_to_message_id: Option<i64>,
  /// Content of the message draft; this should always be of type inputMessageText.
  input_message_text: Option<Box<InputMessageContent>>,
  
}


impl Clone for DraftMessage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for DraftMessage {}
impl RObject for DraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "draftMessage" }
  fn td_type(&self) -> RTDType { RTDType::DraftMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl DraftMessage {
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn input_message_text(&self) -> Option<Box<InputMessageContent>> { self.input_message_text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Information about the email address authentication code that was sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmailAddressAuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // emailAddressAuthenticationCodeInfo
  /// Pattern of the email address to which an authentication code was sent.
  email_address_pattern: Option<String>,
  /// Length of the code; 0 if unknown.
  length: Option<i32>,
  
}



impl Object for EmailAddressAuthenticationCodeInfo {}
impl RObject for EmailAddressAuthenticationCodeInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "emailAddressAuthenticationCodeInfo" }
  fn td_type(&self) -> RTDType { RTDType::EmailAddressAuthenticationCodeInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl EmailAddressAuthenticationCodeInfo {
  
  pub fn email_address_pattern(&self) -> Option<String> { self.email_address_pattern.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains encrypted Telegram Passport data credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // encryptedCredentials
  /// The encrypted credentials.
  data: Option<String>,
  /// The decrypted data hash.
  hash: Option<String>,
  /// Secret for data decryption, encrypted with the service's public key.
  secret: Option<String>,
  
}



impl Object for EncryptedCredentials {}
impl RObject for EncryptedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "encryptedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::EncryptedCredentials }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl EncryptedCredentials {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn secret(&self) -> Option<String> { self.secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about an encrypted Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // encryptedPassportElement
  /// Type of Telegram Passport element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Encrypted JSON-encoded data about the user.
  data: Option<String>,
  /// The front side of an identity document.
  front_side: Option<DatedFile>,
  /// The reverse side of an identity document; may be null.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  /// List of attached files.
  files: Option<Vec<DatedFile>>,
  /// Unencrypted data, phone number or email address.
  value: Option<String>,
  /// Hash of the entire element.
  hash: Option<String>,
  
}


impl Clone for EncryptedPassportElement {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EncryptedPassportElement {}
impl RObject for EncryptedPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "encryptedPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::EncryptedPassportElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl EncryptedPassportElement {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn front_side(&self) -> Option<DatedFile> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<DatedFile> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<DatedFile> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn files(&self) -> Option<Vec<DatedFile>> { self.files.clone() }
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An object of this type can be returned on every function call, in case of an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // error
  /// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user.
  code: Option<i32>,
  /// Error message; subject to future changes.
  message: Option<String>,
  
}



impl Object for Error {}
impl RObject for Error {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "error" }
  fn td_type(&self) -> RTDType { RTDType::Error }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Error {
  
  pub fn code(&self) -> Option<i32> { self.code.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // file
  /// Unique file identifier.
  id: Option<i32>,
  /// File size; 0 if unknown.
  size: Option<i32>,
  /// Expected file size in case the exact file size is unknown, but an approximate size is known. Can be used to show download/upload progress.
  expected_size: Option<i32>,
  /// Information about the local copy of the file.
  local: Option<LocalFile>,
  /// Information about the remote copy of the file.
  remote: Option<RemoteFile>,
  
}



impl Object for File {}
impl RObject for File {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "file" }
  fn td_type(&self) -> RTDType { RTDType::File }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl File {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn size(&self) -> Option<i32> { self.size.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn local(&self) -> Option<LocalFile> { self.local.clone() }
  
  pub fn remote(&self) -> Option<RemoteFile> { self.remote.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a part of a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // filePart
  /// File bytes.
  data: Option<String>,
  
}



impl Object for FilePart {}
impl RObject for FilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "filePart" }
  fn td_type(&self) -> RTDType { RTDType::FilePart }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl FilePart {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the type of a file. 
#[typetag::serde(tag = "@struct")]
pub trait FileType: Object + RObject + Debug {}






impl FileType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<FileType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDFileTypeType {
  FileTypeAnimation,
  FileTypeAudio,
  FileTypeDocument,
  FileTypeNone,
  FileTypePhoto,
  FileTypeProfilePhoto,
  FileTypeSecret,
  FileTypeSecretThumbnail,
  FileTypeSecure,
  FileTypeSticker,
  FileTypeThumbnail,
  FileTypeUnknown,
  FileTypeVideo,
  FileTypeVideoNote,
  FileTypeVoiceNote,
  FileTypeWallpaper,
  
}
impl RTDFileTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDFileTypeType)(text.as_ref()) }
}



/// The data is not a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeNone
  
}



impl Object for FileTypeNone {}
impl RObject for FileTypeNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeNone" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeNone }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeNone {}


impl FileTypeNone {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is an animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeAnimation
  
}



impl Object for FileTypeAnimation {}
impl RObject for FileTypeAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeAnimation" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeAnimation {}


impl FileTypeAnimation {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeAudio
  
}



impl Object for FileTypeAudio {}
impl RObject for FileTypeAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeAudio" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeAudio {}


impl FileTypeAudio {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeDocument
  
}



impl Object for FileTypeDocument {}
impl RObject for FileTypeDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeDocument" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeDocument {}


impl FileTypeDocument {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypePhoto
  
}



impl Object for FileTypePhoto {}
impl RObject for FileTypePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypePhoto" }
  fn td_type(&self) -> RTDType { RTDType::FileTypePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypePhoto {}


impl FileTypePhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeProfilePhoto
  
}



impl Object for FileTypeProfilePhoto {}
impl RObject for FileTypeProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeProfilePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeProfilePhoto {}


impl FileTypeProfilePhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file was sent to a secret chat (the file type is not known to the server). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecret
  
}



impl Object for FileTypeSecret {}
impl RObject for FileTypeSecret {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecret" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecret }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeSecret {}


impl FileTypeSecret {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a thumbnail of a file from a secret chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecretThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecretThumbnail
  
}



impl Object for FileTypeSecretThumbnail {}
impl RObject for FileTypeSecretThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecretThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecretThumbnail }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeSecretThumbnail {}


impl FileTypeSecretThumbnail {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a file from Secure storage used for storing Telegram Passport files. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecure {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSecure
  
}



impl Object for FileTypeSecure {}
impl RObject for FileTypeSecure {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSecure" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSecure }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeSecure {}


impl FileTypeSecure {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeSticker
  
}



impl Object for FileTypeSticker {}
impl RObject for FileTypeSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeSticker" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeSticker {}


impl FileTypeSticker {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a thumbnail of another file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeThumbnail
  
}



impl Object for FileTypeThumbnail {}
impl RObject for FileTypeThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeThumbnail }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeThumbnail {}


impl FileTypeThumbnail {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file type is not yet known. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeUnknown
  
}



impl Object for FileTypeUnknown {}
impl RObject for FileTypeUnknown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeUnknown" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeUnknown }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeUnknown {}


impl FileTypeUnknown {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVideo
  
}



impl Object for FileTypeVideo {}
impl RObject for FileTypeVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVideo" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeVideo {}


impl FileTypeVideo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVideoNote
  
}



impl Object for FileTypeVideoNote {}
impl RObject for FileTypeVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeVideoNote {}


impl FileTypeVideoNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeVoiceNote
  
}



impl Object for FileTypeVoiceNote {}
impl RObject for FileTypeVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeVoiceNote {}


impl FileTypeVoiceNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file is a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeWallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // fileTypeWallpaper
  
}



impl Object for FileTypeWallpaper {}
impl RObject for FileTypeWallpaper {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "fileTypeWallpaper" }
  fn td_type(&self) -> RTDType { RTDType::FileTypeWallpaper }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl FileType for FileTypeWallpaper {}


impl FileTypeWallpaper {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A text with some entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormattedText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // formattedText
  /// The text.
  text: Option<String>,
  /// Entities contained in the text.
  entities: Option<Vec<TextEntity>>,
  
}



impl Object for FormattedText {}
impl RObject for FormattedText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "formattedText" }
  fn td_type(&self) -> RTDType { RTDType::FormattedText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl FormattedText {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn entities(&self) -> Option<Vec<TextEntity>> { self.entities.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of messages found by a search. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FoundMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // foundMessages
  /// List of messages.
  messages: Option<Vec<Message>>,
  /// Value to pass as from_search_id to get more results.
  next_from_search_id: Option<i64>,
  
}



impl Object for FoundMessages {}
impl RObject for FoundMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "foundMessages" }
  fn td_type(&self) -> RTDType { RTDType::FoundMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl FoundMessages {
  
  pub fn messages(&self) -> Option<Vec<Message>> { self.messages.clone() }
  
  pub fn next_from_search_id(&self) -> Option<i64> { self.next_from_search_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Game {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // game
  /// Game ID.
  id: Option<i64>,
  /// Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}.
  short_name: Option<String>,
  /// Game title.
  title: Option<String>,
  /// Game text, usually containing scoreboards for a game.
  text: Option<FormattedText>,
  /// Game description.
  description: Option<String>,
  /// Game photo.
  photo: Option<Photo>,
  /// Game animation; may be null.
  animation: Option<Animation>,
  
}



impl Object for Game {}
impl RObject for Game {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "game" }
  fn td_type(&self) -> RTDType { RTDType::Game }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Game {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn short_name(&self) -> Option<String> { self.short_name.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains one row of the game high score table. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // gameHighScore
  /// Position in the high score table.
  position: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// User score.
  score: Option<i32>,
  
}



impl Object for GameHighScore {}
impl RObject for GameHighScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "gameHighScore" }
  fn td_type(&self) -> RTDType { RTDType::GameHighScore }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl GameHighScore {
  
  pub fn position(&self) -> Option<i32> { self.position.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of game high scores. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // gameHighScores
  /// A list of game high scores.
  scores: Option<Vec<GameHighScore>>,
  
}



impl Object for GameHighScores {}
impl RObject for GameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "gameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GameHighScores }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl GameHighScores {
  
  pub fn scores(&self) -> Option<Vec<GameHighScore>> { self.scores.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of hashtags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // hashtags
  /// A list of hashtags.
  hashtags: Option<Vec<String>>,
  
}



impl Object for Hashtags {}
impl RObject for Hashtags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "hashtags" }
  fn td_type(&self) -> RTDType { RTDType::Hashtags }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Hashtags {
  
  pub fn hashtags(&self) -> Option<Vec<String>> { self.hashtags.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains an HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // httpUrl
  /// The URL.
  url: Option<String>,
  
}



impl Object for HttpUrl {}
impl RObject for HttpUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "httpUrl" }
  fn td_type(&self) -> RTDType { RTDType::HttpUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl HttpUrl {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An identity document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // identityDocument
  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date; may be null.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<DatedFile>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  
}



impl Object for IdentityDocument {}
impl RObject for IdentityDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "identityDocument" }
  fn td_type(&self) -> RTDType { RTDType::IdentityDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl IdentityDocument {
  
  pub fn number(&self) -> Option<String> { self.number.clone() }
  
  pub fn expiry_date(&self) -> Option<Date> { self.expiry_date.clone() }
  
  pub fn front_side(&self) -> Option<DatedFile> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<DatedFile> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<DatedFile> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents the result of an ImportContacts request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // importedContacts
  /// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user.
  user_ids: Option<Vec<i32>>,
  /// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable.
  importer_count: Option<Vec<i32>>,
  
}



impl Object for ImportedContacts {}
impl RObject for ImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "importedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ImportedContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ImportedContacts {
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn importer_count(&self) -> Option<Vec<i32>> { self.importer_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a single button in an inline keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineKeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButton
  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<InlineKeyboardButtonType>>,
  
}


impl Clone for InlineKeyboardButton {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InlineKeyboardButton {}
impl RObject for InlineKeyboardButton {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButton" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButton }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InlineKeyboardButton {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn type_(&self) -> Option<Box<InlineKeyboardButtonType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the type of an inline keyboard button. 
#[typetag::serde(tag = "@struct")]
pub trait InlineKeyboardButtonType: Object + RObject + Debug {}






impl InlineKeyboardButtonType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InlineKeyboardButtonType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInlineKeyboardButtonTypeType {
  InlineKeyboardButtonTypeBuy,
  InlineKeyboardButtonTypeCallback,
  InlineKeyboardButtonTypeCallbackGame,
  InlineKeyboardButtonTypeSwitchInline,
  InlineKeyboardButtonTypeUrl,
  
}
impl RTDInlineKeyboardButtonTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInlineKeyboardButtonTypeType)(text.as_ref()) }
}



/// A button that opens a specified URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeUrl
  /// HTTP or tg:// URL to open.
  url: Option<String>,
  
}



impl Object for InlineKeyboardButtonTypeUrl {}
impl RObject for InlineKeyboardButtonTypeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeUrl" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeUrl {}


impl InlineKeyboardButtonTypeUrl {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button that sends a special callback query to a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallback {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeCallback
  /// Data to be sent to the bot via a callback query.
  data: Option<String>,
  
}



impl Object for InlineKeyboardButtonTypeCallback {}
impl RObject for InlineKeyboardButtonTypeCallback {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeCallback" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeCallback }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallback {}


impl InlineKeyboardButtonTypeCallback {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button with a game that sends a special callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallbackGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeCallbackGame
  
}



impl Object for InlineKeyboardButtonTypeCallbackGame {}
impl RObject for InlineKeyboardButtonTypeCallbackGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeCallbackGame" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeCallbackGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallbackGame {}


impl InlineKeyboardButtonTypeCallbackGame {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button that forces an inline query to the bot to be inserted in the input field. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeSwitchInline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeSwitchInline
  /// Inline query to be sent to the bot.
  query: Option<String>,
  /// True, if the inline query should be sent from the current chat.
  in_current_chat: Option<bool>,
  
}



impl Object for InlineKeyboardButtonTypeSwitchInline {}
impl RObject for InlineKeyboardButtonTypeSwitchInline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeSwitchInline" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeSwitchInline }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeSwitchInline {}


impl InlineKeyboardButtonTypeSwitchInline {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn in_current_chat(&self) -> Option<bool> { self.in_current_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeBuy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineKeyboardButtonTypeBuy
  
}



impl Object for InlineKeyboardButtonTypeBuy {}
impl RObject for InlineKeyboardButtonTypeBuy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineKeyboardButtonTypeBuy" }
  fn td_type(&self) -> RTDType { RTDType::InlineKeyboardButtonTypeBuy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineKeyboardButtonType for InlineKeyboardButtonTypeBuy {}


impl InlineKeyboardButtonTypeBuy {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a single result of an inline query. 
#[typetag::serde(tag = "@struct")]
pub trait InlineQueryResult: Object + RObject + Debug {}






impl InlineQueryResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InlineQueryResult> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInlineQueryResultType {
  InlineQueryResultAnimation,
  InlineQueryResultArticle,
  InlineQueryResultAudio,
  InlineQueryResultContact,
  InlineQueryResultDocument,
  InlineQueryResultGame,
  InlineQueryResultLocation,
  InlineQueryResultPhoto,
  InlineQueryResultSticker,
  InlineQueryResultVenue,
  InlineQueryResultVideo,
  InlineQueryResultVoiceNote,
  
}
impl RTDInlineQueryResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInlineQueryResultType)(text.as_ref()) }
}



/// Represents a link to an article or web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultArticle
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultArticle {}
impl RObject for InlineQueryResultArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultArticle" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultArticle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultArticle {}


impl InlineQueryResultArticle {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn hide_url(&self) -> Option<bool> { self.hide_url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultContact
  /// Unique identifier of the query result.
  id: Option<String>,
  /// A user contact.
  contact: Option<Contact>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultContact {}
impl RObject for InlineQueryResultContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultContact" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultContact {}


impl InlineQueryResultContact {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a point on the map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultLocation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Title of the result.
  title: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultLocation {}
impl RObject for InlineQueryResultLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultLocation" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultLocation {}


impl InlineQueryResultLocation {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVenue
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  
}



impl Object for InlineQueryResultVenue {}
impl RObject for InlineQueryResultVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVenue" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVenue }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVenue {}


impl InlineQueryResultVenue {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents information about a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultGame
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Game result.
  game: Option<Game>,
  
}



impl Object for InlineQueryResultGame {}
impl RObject for InlineQueryResultGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultGame" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultGame {}


impl InlineQueryResultGame {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn game(&self) -> Option<Game> { self.game.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents an animation file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultAnimation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Animation file.
  animation: Option<Animation>,
  /// Animation title.
  title: Option<String>,
  
}



impl Object for InlineQueryResultAnimation {}
impl RObject for InlineQueryResultAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultAnimation" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultAnimation {}


impl InlineQueryResultAnimation {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultAudio
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Audio file.
  audio: Option<Audio>,
  
}



impl Object for InlineQueryResultAudio {}
impl RObject for InlineQueryResultAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultAudio" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultAudio {}


impl InlineQueryResultAudio {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultDocument
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Document.
  document: Option<Document>,
  /// Document title.
  title: Option<String>,
  /// Document description.
  description: Option<String>,
  
}



impl Object for InlineQueryResultDocument {}
impl RObject for InlineQueryResultDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultDocument" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultDocument {}


impl InlineQueryResultDocument {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultPhoto
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Photo.
  photo: Option<Photo>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  
}



impl Object for InlineQueryResultPhoto {}
impl RObject for InlineQueryResultPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultPhoto" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultPhoto {}


impl InlineQueryResultPhoto {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultSticker
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Sticker.
  sticker: Option<Sticker>,
  
}



impl Object for InlineQueryResultSticker {}
impl RObject for InlineQueryResultSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultSticker" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultSticker {}


impl InlineQueryResultSticker {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVideo
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Video.
  video: Option<Video>,
  /// Title of the video.
  title: Option<String>,
  /// Description of the video.
  description: Option<String>,
  
}



impl Object for InlineQueryResultVideo {}
impl RObject for InlineQueryResultVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVideo" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVideo {}


impl InlineQueryResultVideo {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResultVoiceNote
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Voice note.
  voice_note: Option<VoiceNote>,
  /// Title of the voice note.
  title: Option<String>,
  
}



impl Object for InlineQueryResultVoiceNote {}
impl RObject for InlineQueryResultVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResultVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResultVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InlineQueryResult for InlineQueryResultVoiceNote {}


impl InlineQueryResultVoiceNote {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents the results of the inline query. Use 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inlineQueryResults
  /// Unique identifier of the inline query.
  inline_query_id: Option<i64>,
  /// The offset for the next request. If empty, there are no more results.
  next_offset: Option<String>,
  /// Results of the query.
  results: Option<Vec<Box<InlineQueryResult>>>,
  /// If non-empty, this text should be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// Parameter for the bot start message.
  switch_pm_parameter: Option<String>,
  
}


impl Clone for InlineQueryResults {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InlineQueryResults {}
impl RObject for InlineQueryResults {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inlineQueryResults" }
  fn td_type(&self) -> RTDType { RTDType::InlineQueryResults }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InlineQueryResults {
  
  pub fn inline_query_id(&self) -> Option<i64> { self.inline_query_id.clone() }
  
  pub fn next_offset(&self) -> Option<String> { self.next_offset.clone() }
  
  pub fn results(&self) -> Option<Vec<Box<InlineQueryResult>>> { self.results.clone() }
  
  pub fn switch_pm_text(&self) -> Option<String> { self.switch_pm_text.clone() }
  
  pub fn switch_pm_parameter(&self) -> Option<String> { self.switch_pm_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains information about the payment method chosen by the user. 
#[typetag::serde(tag = "@struct")]
pub trait InputCredentials: Object + RObject + Debug {}






impl InputCredentials {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputCredentials> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputCredentialsType {
  InputCredentialsAndroidPay,
  InputCredentialsApplePay,
  InputCredentialsNew,
  InputCredentialsSaved,
  
}
impl RTDInputCredentialsType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputCredentialsType)(text.as_ref()) }
}



/// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsSaved {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsSaved
  /// Identifier of the saved credentials.
  saved_credentials_id: Option<String>,
  
}



impl Object for InputCredentialsSaved {}
impl RObject for InputCredentialsSaved {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsSaved" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsSaved }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsSaved {}


impl InputCredentialsSaved {
  
  pub fn saved_credentials_id(&self) -> Option<String> { self.saved_credentials_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Applies if a user enters new credentials on a payment provider website. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsNew {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsNew
  /// Contains JSON-encoded data with a credential identifier from the payment provider.
  data: Option<String>,
  /// True, if the credential identifier can be saved on the server side.
  allow_save: Option<bool>,
  
}



impl Object for InputCredentialsNew {}
impl RObject for InputCredentialsNew {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsNew" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsNew }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsNew {}


impl InputCredentialsNew {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn allow_save(&self) -> Option<bool> { self.allow_save.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Applies if a user enters new credentials using Android Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsAndroidPay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsAndroidPay
  /// JSON-encoded data with the credential identifier.
  data: Option<String>,
  
}



impl Object for InputCredentialsAndroidPay {}
impl RObject for InputCredentialsAndroidPay {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsAndroidPay" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsAndroidPay }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsAndroidPay {}


impl InputCredentialsAndroidPay {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Applies if a user enters new credentials using Apple Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsApplePay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputCredentialsApplePay
  /// JSON-encoded data with the credential identifier.
  data: Option<String>,
  
}



impl Object for InputCredentialsApplePay {}
impl RObject for InputCredentialsApplePay {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputCredentialsApplePay" }
  fn td_type(&self) -> RTDType { RTDType::InputCredentialsApplePay }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputCredentials for InputCredentialsApplePay {}


impl InputCredentialsApplePay {
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Points to a file. 
#[typetag::serde(tag = "@struct")]
pub trait InputFile: Object + RObject + Debug {}






impl InputFile {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputFile> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputFileType {
  InputFileGenerated,
  InputFileId,
  InputFileLocal,
  InputFileRemote,
  
}
impl RTDInputFileType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputFileType)(text.as_ref()) }
}



/// A file defined by its unique ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileId
  /// Unique file identifier.
  id: Option<i32>,
  
}



impl Object for InputFileId {}
impl RObject for InputFileId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileId" }
  fn td_type(&self) -> RTDType { RTDType::InputFileId }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputFile for InputFileId {}


impl InputFileId {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A file defined by its remote ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileRemote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileRemote
  /// Remote file identifier.
  id: Option<String>,
  
}



impl Object for InputFileRemote {}
impl RObject for InputFileRemote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileRemote" }
  fn td_type(&self) -> RTDType { RTDType::InputFileRemote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputFile for InputFileRemote {}


impl InputFileRemote {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A file defined by a local path. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileLocal {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileLocal
  /// Local path to the file.
  path: Option<String>,
  
}



impl Object for InputFileLocal {}
impl RObject for InputFileLocal {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileLocal" }
  fn td_type(&self) -> RTDType { RTDType::InputFileLocal }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputFile for InputFileLocal {}


impl InputFileLocal {
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A file generated by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileGenerated {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputFileGenerated
  /// Local path to a file from which the file is generated; may be empty if there is no such file.
  original_path: Option<String>,
  /// String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage.
  conversion: Option<String>,
  /// Expected size of the generated file; 0 if unknown.
  expected_size: Option<i32>,
  
}



impl Object for InputFileGenerated {}
impl RObject for InputFileGenerated {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputFileGenerated" }
  fn td_type(&self) -> RTDType { RTDType::InputFileGenerated }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputFile for InputFileGenerated {}


impl InputFileGenerated {
  
  pub fn original_path(&self) -> Option<String> { self.original_path.clone() }
  
  pub fn conversion(&self) -> Option<String> { self.conversion.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An identity document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputIdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputIdentityDocument
  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date, if available.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<Box<InputFile>>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<Box<InputFile>>,
  /// Selfie with the document, if available.
  selfie: Option<Box<InputFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,
  
}


impl Clone for InputIdentityDocument {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputIdentityDocument {}
impl RObject for InputIdentityDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputIdentityDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputIdentityDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InputIdentityDocument {
  
  pub fn number(&self) -> Option<String> { self.number.clone() }
  
  pub fn expiry_date(&self) -> Option<Date> { self.expiry_date.clone() }
  
  pub fn front_side(&self) -> Option<Box<InputFile>> { self.front_side.clone() }
  
  pub fn reverse_side(&self) -> Option<Box<InputFile>> { self.reverse_side.clone() }
  
  pub fn selfie(&self) -> Option<Box<InputFile>> { self.selfie.clone() }
  
  pub fn translation(&self) -> Option<Vec<Box<InputFile>>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a single result of an inline query; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputInlineQueryResult: Object + RObject + Debug {}






impl InputInlineQueryResult {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputInlineQueryResult> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputInlineQueryResultType {
  InputInlineQueryResultAnimatedGif,
  InputInlineQueryResultAnimatedMpeg4,
  InputInlineQueryResultArticle,
  InputInlineQueryResultAudio,
  InputInlineQueryResultContact,
  InputInlineQueryResultDocument,
  InputInlineQueryResultGame,
  InputInlineQueryResultLocation,
  InputInlineQueryResultPhoto,
  InputInlineQueryResultSticker,
  InputInlineQueryResultVenue,
  InputInlineQueryResultVideo,
  InputInlineQueryResultVoiceNote,
  
}
impl RTDInputInlineQueryResultType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputInlineQueryResultType)(text.as_ref()) }
}



/// Represents a link to an animated GIF. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedGif {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAnimatedGif
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the query result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the GIF-file (file size must not exceed 1MB).
  gif_url: Option<String>,
  /// Duration of the GIF, in seconds.
  gif_duration: Option<i32>,
  /// Width of the GIF.
  gif_width: Option<i32>,
  /// Height of the GIF.
  gif_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAnimatedGif {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultAnimatedGif {}
impl RObject for InputInlineQueryResultAnimatedGif {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAnimatedGif" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAnimatedGif }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAnimatedGif {}


impl InputInlineQueryResultAnimatedGif {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn gif_url(&self) -> Option<String> { self.gif_url.clone() }
  
  pub fn gif_duration(&self) -> Option<i32> { self.gif_duration.clone() }
  
  pub fn gif_width(&self) -> Option<i32> { self.gif_width.clone() }
  
  pub fn gif_height(&self) -> Option<i32> { self.gif_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to an animated (i.e. without sound) H.264/MPEG-4 AVC video. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedMpeg4 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAnimatedMpeg4
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the MPEG4-file (file size must not exceed 1MB).
  mpeg4_url: Option<String>,
  /// Duration of the video, in seconds.
  mpeg4_duration: Option<i32>,
  /// Width of the video.
  mpeg4_width: Option<i32>,
  /// Height of the video.
  mpeg4_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAnimatedMpeg4 {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultAnimatedMpeg4 {}
impl RObject for InputInlineQueryResultAnimatedMpeg4 {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAnimatedMpeg4" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAnimatedMpeg4 }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAnimatedMpeg4 {}


impl InputInlineQueryResultAnimatedMpeg4 {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn mpeg4_url(&self) -> Option<String> { self.mpeg4_url.clone() }
  
  pub fn mpeg4_duration(&self) -> Option<i32> { self.mpeg4_duration.clone() }
  
  pub fn mpeg4_width(&self) -> Option<i32> { self.mpeg4_width.clone() }
  
  pub fn mpeg4_height(&self) -> Option<i32> { self.mpeg4_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to an article or web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultArticle
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultArticle {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultArticle {}
impl RObject for InputInlineQueryResultArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultArticle" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultArticle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultArticle {}


impl InputInlineQueryResultArticle {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn hide_url(&self) -> Option<bool> { self.hide_url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to an MP3 audio file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultAudio
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the audio file.
  title: Option<String>,
  /// Performer of the audio file.
  performer: Option<String>,
  /// The URL of the audio file.
  audio_url: Option<String>,
  /// Audio file duration, in seconds.
  audio_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAudio, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultAudio {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultAudio {}
impl RObject for InputInlineQueryResultAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultAudio" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultAudio {}


impl InputInlineQueryResultAudio {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn audio_url(&self) -> Option<String> { self.audio_url.clone() }
  
  pub fn audio_duration(&self) -> Option<i32> { self.audio_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a user contact. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultContact
  /// Unique identifier of the query result.
  id: Option<String>,
  /// User contact.
  contact: Option<Contact>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultContact {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultContact {}
impl RObject for InputInlineQueryResultContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultContact" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultContact {}


impl InputInlineQueryResultContact {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to a file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultDocument
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the resulting file.
  title: Option<String>,
  /// Short description of the result, if known.
  description: Option<String>,
  /// URL of the file.
  document_url: Option<String>,
  /// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed.
  mime_type: Option<String>,
  /// The URL of the file thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Width of the thumbnail.
  thumbnail_width: Option<i32>,
  /// Height of the thumbnail.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageDocument, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultDocument {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultDocument {}
impl RObject for InputInlineQueryResultDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultDocument {}


impl InputInlineQueryResultDocument {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn document_url(&self) -> Option<String> { self.document_url.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a game. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultGame
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Short name of the game.
  game_short_name: Option<String>,
  /// Message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for InputInlineQueryResultGame {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultGame {}
impl RObject for InputInlineQueryResultGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultGame" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultGame {}


impl InputInlineQueryResultGame {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a point on the map. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultLocation
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Amount of time relative to the message sent time until the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultLocation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultLocation {}
impl RObject for InputInlineQueryResultLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultLocation" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultLocation {}


impl InputInlineQueryResultLocation {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents link to a JPEG image. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultPhoto
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// URL of the photo thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the JPEG photo (photo size must not exceed 5MB).
  photo_url: Option<String>,
  /// Width of the photo.
  photo_width: Option<i32>,
  /// Height of the photo.
  photo_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessagePhoto, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultPhoto {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultPhoto {}
impl RObject for InputInlineQueryResultPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultPhoto" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultPhoto {}


impl InputInlineQueryResultPhoto {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn photo_url(&self) -> Option<String> { self.photo_url.clone() }
  
  pub fn photo_width(&self) -> Option<i32> { self.photo_width.clone() }
  
  pub fn photo_height(&self) -> Option<i32> { self.photo_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to a WEBP sticker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultSticker
  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the sticker thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the WEBP sticker (sticker file size must not exceed 5MB).
  sticker_url: Option<String>,
  /// Width of the sticker.
  sticker_width: Option<i32>,
  /// Height of the sticker.
  sticker_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, inputMessageSticker, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultSticker {}
impl RObject for InputInlineQueryResultSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultSticker {}


impl InputInlineQueryResultSticker {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn sticker_url(&self) -> Option<String> { self.sticker_url.clone() }
  
  pub fn sticker_width(&self) -> Option<i32> { self.sticker_width.clone() }
  
  pub fn sticker_height(&self) -> Option<i32> { self.sticker_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents information about a venue. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVenue
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVenue {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultVenue {}
impl RObject for InputInlineQueryResultVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVenue" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVenue }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVenue {}


impl InputInlineQueryResultVenue {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn thumbnail_width(&self) -> Option<i32> { self.thumbnail_width.clone() }
  
  pub fn thumbnail_height(&self) -> Option<i32> { self.thumbnail_height.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to a page containing an embedded video player or a video file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVideo
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// The URL of the video thumbnail (JPEG), if it exists.
  thumbnail_url: Option<String>,
  /// URL of the embedded video player or video file.
  video_url: Option<String>,
  /// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported.
  mime_type: Option<String>,
  /// Width of the video.
  video_width: Option<i32>,
  /// Height of the video.
  video_height: Option<i32>,
  /// Video duration, in seconds.
  video_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVideo, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVideo {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultVideo {}
impl RObject for InputInlineQueryResultVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVideo" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVideo {}


impl InputInlineQueryResultVideo {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn thumbnail_url(&self) -> Option<String> { self.thumbnail_url.clone() }
  
  pub fn video_url(&self) -> Option<String> { self.video_url.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn video_width(&self) -> Option<i32> { self.video_width.clone() }
  
  pub fn video_height(&self) -> Option<i32> { self.video_height.clone() }
  
  pub fn video_duration(&self) -> Option<i32> { self.video_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a link to an opus-encoded audio file within an OGG container, single channel audio. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputInlineQueryResultVoiceNote
  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the voice note.
  title: Option<String>,
  /// The URL of the voice note file.
  voice_note_url: Option<String>,
  /// Duration of the voice note, in seconds.
  voice_note_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVoiceNote, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for InputInlineQueryResultVoiceNote {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputInlineQueryResultVoiceNote {}
impl RObject for InputInlineQueryResultVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputInlineQueryResultVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InputInlineQueryResultVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputInlineQueryResult for InputInlineQueryResultVoiceNote {}


impl InputInlineQueryResultVoiceNote {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn voice_note_url(&self) -> Option<String> { self.voice_note_url.clone() }
  
  pub fn voice_note_duration(&self) -> Option<i32> { self.voice_note_duration.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. The content of a message to send. 
#[typetag::serde(tag = "@struct")]
pub trait InputMessageContent: Object + RObject + Debug {}






impl InputMessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputMessageContent> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputMessageContentType {
  InputMessageAnimation,
  InputMessageAudio,
  InputMessageContact,
  InputMessageDocument,
  InputMessageForwarded,
  InputMessageGame,
  InputMessageInvoice,
  InputMessageLocation,
  InputMessagePhoto,
  InputMessagePoll,
  InputMessageSticker,
  InputMessageText,
  InputMessageVenue,
  InputMessageVideo,
  InputMessageVideoNote,
  InputMessageVoiceNote,
  
}
impl RTDInputMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputMessageContentType)(text.as_ref()) }
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageText
  /// Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Code, Pre, PreCode and TextUrl entities are allowed to be specified manually.
  text: Option<FormattedText>,
  /// True, if rich web page previews for URLs in the message text should be disabled.
  disable_web_page_preview: Option<bool>,
  /// True, if a chat message draft should be deleted.
  clear_draft: Option<bool>,
  
}



impl Object for InputMessageText {}
impl RObject for InputMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageText" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageText {}


impl InputMessageText {
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn disable_web_page_preview(&self) -> Option<bool> { self.disable_web_page_preview.clone() }
  
  pub fn clear_draft(&self) -> Option<bool> { self.clear_draft.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An animation message (GIF-style). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageAnimation
  /// Animation file to be sent.
  animation: Option<Box<InputFile>>,
  /// Animation thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the animation, in seconds.
  duration: Option<i32>,
  /// Width of the animation; may be replaced by the server.
  width: Option<i32>,
  /// Height of the animation; may be replaced by the server.
  height: Option<i32>,
  /// Animation caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageAnimation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageAnimation {}
impl RObject for InputMessageAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageAnimation" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageAnimation {}


impl InputMessageAnimation {
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An audio message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageAudio
  /// Audio file to be sent.
  audio: Option<Box<InputFile>>,
  /// Thumbnail of the cover for the album, if available.
  album_cover_thumbnail: Option<InputThumbnail>,
  /// Duration of the audio, in seconds; may be replaced by the server.
  duration: Option<i32>,
  /// Title of the audio; 0-64 characters; may be replaced by the server.
  title: Option<String>,
  /// Performer of the audio; 0-64 characters, may be replaced by the server.
  performer: Option<String>,
  /// Audio caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageAudio {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageAudio {}
impl RObject for InputMessageAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageAudio" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageAudio {}


impl InputMessageAudio {
  
  pub fn audio(&self) -> Option<Box<InputFile>> { self.audio.clone() }
  
  pub fn album_cover_thumbnail(&self) -> Option<InputThumbnail> { self.album_cover_thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn performer(&self) -> Option<String> { self.performer.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A document message (general file). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageDocument
  /// Document to be sent.
  document: Option<Box<InputFile>>,
  /// Document thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Document caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageDocument {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageDocument {}
impl RObject for InputMessageDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageDocument {}


impl InputMessageDocument {
  
  pub fn document(&self) -> Option<Box<InputFile>> { self.document.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A photo message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessagePhoto
  /// Photo to send.
  photo: Option<Box<InputFile>>,
  /// Photo thumbnail to be sent, this is sent to the other party in secret chats only.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the photo, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,
  /// Photo caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,
  
}


impl Clone for InputMessagePhoto {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessagePhoto {}
impl RObject for InputMessagePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessagePhoto" }
  fn td_type(&self) -> RTDType { RTDType::InputMessagePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessagePhoto {}


impl InputMessagePhoto {
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn added_sticker_file_ids(&self) -> Option<Vec<i32>> { self.added_sticker_file_ids.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A sticker message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageSticker
  /// Sticker to be sent.
  sticker: Option<Box<InputFile>>,
  /// Sticker thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Sticker width.
  width: Option<i32>,
  /// Sticker height.
  height: Option<i32>,
  
}


impl Clone for InputMessageSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageSticker {}
impl RObject for InputMessageSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageSticker {}


impl InputMessageSticker {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVideo
  /// Video to be sent.
  video: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the video, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width.
  width: Option<i32>,
  /// Video height.
  height: Option<i32>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,
  
}


impl Clone for InputMessageVideo {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageVideo {}
impl RObject for InputMessageVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVideo" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVideo {}


impl InputMessageVideo {
  
  pub fn video(&self) -> Option<Box<InputFile>> { self.video.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn added_sticker_file_ids(&self) -> Option<Vec<i32>> { self.added_sticker_file_ids.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn supports_streaming(&self) -> Option<bool> { self.supports_streaming.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVideoNote
  /// Video note to be sent.
  video_note: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width and height; must be positive and not greater than 640.
  length: Option<i32>,
  
}


impl Clone for InputMessageVideoNote {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageVideoNote {}
impl RObject for InputMessageVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVideoNote {}


impl InputMessageVideoNote {
  
  pub fn video_note(&self) -> Option<Box<InputFile>> { self.video_note.clone() }
  
  pub fn thumbnail(&self) -> Option<InputThumbnail> { self.thumbnail.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A voice note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVoiceNote
  /// Voice note to be sent.
  voice_note: Option<Box<InputFile>>,
  /// Duration of the voice note, in seconds.
  duration: Option<i32>,
  /// Waveform representation of the voice note, in 5-bit format.
  waveform: Option<String>,
  /// Voice note caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for InputMessageVoiceNote {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputMessageVoiceNote {}
impl RObject for InputMessageVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVoiceNote {}


impl InputMessageVoiceNote {
  
  pub fn voice_note(&self) -> Option<Box<InputFile>> { self.voice_note.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn waveform(&self) -> Option<String> { self.waveform.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageLocation
  /// Location to be sent.
  location: Option<Location>,
  /// Period for which the location can be updated, in seconds; should bebetween 60 and 86400 for a live location and 0 otherwise.
  live_period: Option<i32>,
  
}



impl Object for InputMessageLocation {}
impl RObject for InputMessageLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageLocation" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageLocation {}


impl InputMessageLocation {
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageVenue
  /// Venue to send.
  venue: Option<Venue>,
  
}



impl Object for InputMessageVenue {}
impl RObject for InputMessageVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageVenue" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageVenue }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageVenue {}


impl InputMessageVenue {
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message containing a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageContact
  /// Contact to send.
  contact: Option<Contact>,
  
}



impl Object for InputMessageContact {}
impl RObject for InputMessageContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageContact" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageContact {}


impl InputMessageContact {
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a game; not supported for channels or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageGame
  /// User identifier of the bot that owns the game.
  bot_user_id: Option<i32>,
  /// Short name of the game.
  game_short_name: Option<String>,
  
}



impl Object for InputMessageGame {}
impl RObject for InputMessageGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageGame" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageGame {}


impl InputMessageGame {
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn game_short_name(&self) -> Option<String> { self.game_short_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with an invoice; can be used only by bots and only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageInvoice
  /// Invoice.
  invoice: Option<Invoice>,
  /// Product title; 1-32 characters.
  title: Option<String>,
  /// Product description; 0-255 characters.
  description: Option<String>,
  /// Product photo URL; optional.
  photo_url: Option<String>,
  /// Product photo size.
  photo_size: Option<i32>,
  /// Product photo width.
  photo_width: Option<i32>,
  /// Product photo height.
  photo_height: Option<i32>,
  /// The invoice payload.
  payload: Option<String>,
  /// Payment provider token.
  provider_token: Option<String>,
  /// JSON-encoded data about the invoice, which will be shared with the payment provider.
  provider_data: Option<String>,
  /// Unique invoice bot start_parameter for the generation of this invoice.
  start_parameter: Option<String>,
  
}



impl Object for InputMessageInvoice {}
impl RObject for InputMessageInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageInvoice" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageInvoice }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageInvoice {}


impl InputMessageInvoice {
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo_url(&self) -> Option<String> { self.photo_url.clone() }
  
  pub fn photo_size(&self) -> Option<i32> { self.photo_size.clone() }
  
  pub fn photo_width(&self) -> Option<i32> { self.photo_width.clone() }
  
  pub fn photo_height(&self) -> Option<i32> { self.photo_height.clone() }
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn provider_token(&self) -> Option<String> { self.provider_token.clone() }
  
  pub fn provider_data(&self) -> Option<String> { self.provider_data.clone() }
  
  pub fn start_parameter(&self) -> Option<String> { self.start_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a poll. Polls can't be sent to private or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessagePoll
  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options, 2-10 strings 1-100 characters each.
  options: Option<Vec<String>>,
  
}



impl Object for InputMessagePoll {}
impl RObject for InputMessagePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessagePoll" }
  fn td_type(&self) -> RTDType { RTDType::InputMessagePoll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessagePoll {}


impl InputMessagePoll {
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn options(&self) -> Option<Vec<String>> { self.options.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A forwarded message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageForwarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputMessageForwarded
  /// Identifier for the chat this forwarded message came from.
  from_chat_id: Option<i64>,
  /// Identifier of the message to forward.
  message_id: Option<i64>,
  /// True, if a game message should be shared within a launched game; applies only to game messages.
  in_game_share: Option<bool>,
  
}



impl Object for InputMessageForwarded {}
impl RObject for InputMessageForwarded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputMessageForwarded" }
  fn td_type(&self) -> RTDType { RTDType::InputMessageForwarded }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputMessageContent for InputMessageForwarded {}


impl InputMessageForwarded {
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn in_game_share(&self) -> Option<bool> { self.in_game_share.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains information about a Telegram Passport element to be saved. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElement: Object + RObject + Debug {}






impl InputPassportElement {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputPassportElement> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputPassportElementType {
  InputPassportElementAddress,
  InputPassportElementBankStatement,
  InputPassportElementDriverLicense,
  InputPassportElementEmailAddress,
  InputPassportElementIdentityCard,
  InputPassportElementInternalPassport,
  InputPassportElementPassport,
  InputPassportElementPassportRegistration,
  InputPassportElementPersonalDetails,
  InputPassportElementPhoneNumber,
  InputPassportElementRentalAgreement,
  InputPassportElementTemporaryRegistration,
  InputPassportElementUtilityBill,
  
}
impl RTDInputPassportElementType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputPassportElementType)(text.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPersonalDetails
  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,
  
}



impl Object for InputPassportElementPersonalDetails {}
impl RObject for InputPassportElementPersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPersonalDetails }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPersonalDetails {}


impl InputPassportElementPersonalDetails {
  
  pub fn personal_details(&self) -> Option<PersonalDetails> { self.personal_details.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPassport
  /// The passport to be saved.
  passport: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementPassport {}
impl RObject for InputPassportElementPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPassport" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPassport {}


impl InputPassportElementPassport {
  
  pub fn passport(&self) -> Option<InputIdentityDocument> { self.passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementDriverLicense
  /// The driver license to be saved.
  driver_license: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementDriverLicense {}
impl RObject for InputPassportElementDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementDriverLicense }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementDriverLicense {}


impl InputPassportElementDriverLicense {
  
  pub fn driver_license(&self) -> Option<InputIdentityDocument> { self.driver_license.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementIdentityCard
  /// The identity card to be saved.
  identity_card: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementIdentityCard {}
impl RObject for InputPassportElementIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementIdentityCard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementIdentityCard {}


impl InputPassportElementIdentityCard {
  
  pub fn identity_card(&self) -> Option<InputIdentityDocument> { self.identity_card.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementInternalPassport
  /// The internal passport to be saved.
  internal_passport: Option<InputIdentityDocument>,
  
}



impl Object for InputPassportElementInternalPassport {}
impl RObject for InputPassportElementInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementInternalPassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementInternalPassport {}


impl InputPassportElementInternalPassport {
  
  pub fn internal_passport(&self) -> Option<InputIdentityDocument> { self.internal_passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementAddress
  /// The address to be saved.
  address: Option<Address>,
  
}



impl Object for InputPassportElementAddress {}
impl RObject for InputPassportElementAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementAddress" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementAddress {}


impl InputPassportElementAddress {
  
  pub fn address(&self) -> Option<Address> { self.address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementUtilityBill
  /// The utility bill to be saved.
  utility_bill: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementUtilityBill {}
impl RObject for InputPassportElementUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementUtilityBill }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementUtilityBill {}


impl InputPassportElementUtilityBill {
  
  pub fn utility_bill(&self) -> Option<InputPersonalDocument> { self.utility_bill.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementBankStatement
  /// The bank statement to be saved.
  bank_statement: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementBankStatement {}
impl RObject for InputPassportElementBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementBankStatement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementBankStatement {}


impl InputPassportElementBankStatement {
  
  pub fn bank_statement(&self) -> Option<InputPersonalDocument> { self.bank_statement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementRentalAgreement
  /// The rental agreement to be saved.
  rental_agreement: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementRentalAgreement {}
impl RObject for InputPassportElementRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementRentalAgreement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementRentalAgreement {}


impl InputPassportElementRentalAgreement {
  
  pub fn rental_agreement(&self) -> Option<InputPersonalDocument> { self.rental_agreement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's passport registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPassportRegistration
  /// The passport registration page to be saved.
  passport_registration: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementPassportRegistration {}
impl RObject for InputPassportElementPassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPassportRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPassportRegistration {}


impl InputPassportElementPassportRegistration {
  
  pub fn passport_registration(&self) -> Option<InputPersonalDocument> { self.passport_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementTemporaryRegistration
  /// The temporary registration document to be saved.
  temporary_registration: Option<InputPersonalDocument>,
  
}



impl Object for InputPassportElementTemporaryRegistration {}
impl RObject for InputPassportElementTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementTemporaryRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementTemporaryRegistration {}


impl InputPassportElementTemporaryRegistration {
  
  pub fn temporary_registration(&self) -> Option<InputPersonalDocument> { self.temporary_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementPhoneNumber
  /// The phone number to be saved.
  phone_number: Option<String>,
  
}



impl Object for InputPassportElementPhoneNumber {}
impl RObject for InputPassportElementPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementPhoneNumber {}


impl InputPassportElementPhoneNumber {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element to be saved containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementEmailAddress
  /// The email address to be saved.
  email_address: Option<String>,
  
}



impl Object for InputPassportElementEmailAddress {}
impl RObject for InputPassportElementEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElement for InputPassportElementEmailAddress {}


impl InputPassportElementEmailAddress {
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the description of an error in a Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementError
  /// Type of Telegram Passport element that has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<InputPassportElementErrorSource>>,
  
}


impl Clone for InputPassportElementError {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputPassportElementError {}
impl RObject for InputPassportElementError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementError" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementError }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InputPassportElementError {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn source(&self) -> Option<Box<InputPassportElementErrorSource>> { self.source.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElementErrorSource: Object + RObject + Debug {}






impl InputPassportElementErrorSource {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<InputPassportElementErrorSource> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDInputPassportElementErrorSourceType {
  InputPassportElementErrorSourceDataField,
  InputPassportElementErrorSourceFile,
  InputPassportElementErrorSourceFiles,
  InputPassportElementErrorSourceFrontSide,
  InputPassportElementErrorSourceReverseSide,
  InputPassportElementErrorSourceSelfie,
  InputPassportElementErrorSourceTranslationFile,
  InputPassportElementErrorSourceTranslationFiles,
  InputPassportElementErrorSourceUnspecified,
  
}
impl RTDInputPassportElementErrorSourceType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDInputPassportElementErrorSourceType)(text.as_ref()) }
}



/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceUnspecified
  /// Current hash of the entire element.
  element_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceUnspecified {}
impl RObject for InputPassportElementErrorSourceUnspecified {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceUnspecified" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceUnspecified }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceUnspecified {}


impl InputPassportElementErrorSourceUnspecified {
  
  pub fn element_hash(&self) -> Option<String> { self.element_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A data field contains an error. The error is considered resolved when the field's value changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceDataField
  /// Field name.
  field_name: Option<String>,
  /// Current data hash.
  data_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceDataField {}
impl RObject for InputPassportElementErrorSourceDataField {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceDataField" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceDataField }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceDataField {}


impl InputPassportElementErrorSourceDataField {
  
  pub fn field_name(&self) -> Option<String> { self.field_name.clone() }
  
  pub fn data_hash(&self) -> Option<String> { self.data_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFrontSide
  /// Current hash of the file containing the front side.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceFrontSide {}
impl RObject for InputPassportElementErrorSourceFrontSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFrontSide" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFrontSide }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFrontSide {}


impl InputPassportElementErrorSourceFrontSide {
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceReverseSide
  /// Current hash of the file containing the reverse side.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceReverseSide {}
impl RObject for InputPassportElementErrorSourceReverseSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceReverseSide" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceReverseSide }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceReverseSide {}


impl InputPassportElementErrorSourceReverseSide {
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The selfie contains an error. The error is considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceSelfie
  /// Current hash of the file containing the selfie.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceSelfie {}
impl RObject for InputPassportElementErrorSourceSelfie {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceSelfie" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceSelfie }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceSelfie {}


impl InputPassportElementErrorSourceSelfie {
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceTranslationFile
  /// Current hash of the file containing the translation.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceTranslationFile {}
impl RObject for InputPassportElementErrorSourceTranslationFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceTranslationFile" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceTranslationFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFile {}


impl InputPassportElementErrorSourceTranslationFile {
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The translation of the document contains an error. The error is considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceTranslationFiles
  /// Current hashes of all files with the translation.
  file_hashes: Option<Vec<String>>,
  
}



impl Object for InputPassportElementErrorSourceTranslationFiles {}
impl RObject for InputPassportElementErrorSourceTranslationFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceTranslationFiles" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceTranslationFiles }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFiles {}


impl InputPassportElementErrorSourceTranslationFiles {
  
  pub fn file_hashes(&self) -> Option<Vec<String>> { self.file_hashes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file contains an error. The error is considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFile
  /// Current hash of the file which has the error.
  file_hash: Option<String>,
  
}



impl Object for InputPassportElementErrorSourceFile {}
impl RObject for InputPassportElementErrorSourceFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFile" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFile {}


impl InputPassportElementErrorSourceFile {
  
  pub fn file_hash(&self) -> Option<String> { self.file_hash.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of attached files contains an error. The error is considered resolved when the file list changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPassportElementErrorSourceFiles
  /// Current hashes of all attached files.
  file_hashes: Option<Vec<String>>,
  
}



impl Object for InputPassportElementErrorSourceFiles {}
impl RObject for InputPassportElementErrorSourceFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPassportElementErrorSourceFiles" }
  fn td_type(&self) -> RTDType { RTDType::InputPassportElementErrorSourceFiles }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl InputPassportElementErrorSource for InputPassportElementErrorSourceFiles {}


impl InputPassportElementErrorSourceFiles {
  
  pub fn file_hashes(&self) -> Option<Vec<String>> { self.file_hashes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A personal document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputPersonalDocument
  /// List of files containing the pages of the document.
  files: Option<Vec<Box<InputFile>>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,
  
}


impl Clone for InputPersonalDocument {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputPersonalDocument {}
impl RObject for InputPersonalDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputPersonalDocument" }
  fn td_type(&self) -> RTDType { RTDType::InputPersonalDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InputPersonalDocument {
  
  pub fn files(&self) -> Option<Vec<Box<InputFile>>> { self.files.clone() }
  
  pub fn translation(&self) -> Option<Vec<Box<InputFile>>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a sticker that should be added to a sticker set. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputSticker
  /// PNG image with the sticker; must be up to 512 kB in size and fit in a 512x512 square.
  png_sticker: Option<Box<InputFile>>,
  /// Emoji corresponding to the sticker.
  emojis: Option<String>,
  /// For masks, position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,
  
}


impl Clone for InputSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputSticker {}
impl RObject for InputSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputSticker" }
  fn td_type(&self) -> RTDType { RTDType::InputSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InputSticker {
  
  pub fn png_sticker(&self) -> Option<Box<InputFile>> { self.png_sticker.clone() }
  
  pub fn emojis(&self) -> Option<String> { self.emojis.clone() }
  
  pub fn mask_position(&self) -> Option<MaskPosition> { self.mask_position.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A thumbnail to be sent along with a file; should be in JPEG or WEBP format for stickers, and less than 200 kB in size. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // inputThumbnail
  /// Thumbnail file to send. Sending thumbnails by file_id is currently not supported.
  thumbnail: Option<Box<InputFile>>,
  /// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown.
  width: Option<i32>,
  /// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown.
  height: Option<i32>,
  
}


impl Clone for InputThumbnail {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for InputThumbnail {}
impl RObject for InputThumbnail {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "inputThumbnail" }
  fn td_type(&self) -> RTDType { RTDType::InputThumbnail }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl InputThumbnail {
  
  pub fn thumbnail(&self) -> Option<Box<InputFile>> { self.thumbnail.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Product invoice. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Invoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // invoice
  /// ISO 4217 currency code.
  currency: Option<String>,
  /// A list of objects used to calculate the total price of the product.
  price_parts: Option<Vec<LabeledPricePart>>,
  /// True, if the payment is a test payment.
  is_test: Option<bool>,
  /// True, if the user's name is needed for payment.
  need_name: Option<bool>,
  /// True, if the user's phone number is needed for payment.
  need_phone_number: Option<bool>,
  /// True, if the user's email address is needed for payment.
  need_email_address: Option<bool>,
  /// True, if the user's shipping address is needed for payment.
  need_shipping_address: Option<bool>,
  /// True, if the user's phone number will be sent to the provider.
  send_phone_number_to_provider: Option<bool>,
  /// True, if the user's email address will be sent to the provider.
  send_email_address_to_provider: Option<bool>,
  /// True, if the total price depends on the shipping method.
  is_flexible: Option<bool>,
  
}



impl Object for Invoice {}
impl RObject for Invoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "invoice" }
  fn td_type(&self) -> RTDType { RTDType::Invoice }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Invoice {
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn price_parts(&self) -> Option<Vec<LabeledPricePart>> { self.price_parts.clone() }
  
  pub fn is_test(&self) -> Option<bool> { self.is_test.clone() }
  
  pub fn need_name(&self) -> Option<bool> { self.need_name.clone() }
  
  pub fn need_phone_number(&self) -> Option<bool> { self.need_phone_number.clone() }
  
  pub fn need_email_address(&self) -> Option<bool> { self.need_email_address.clone() }
  
  pub fn need_shipping_address(&self) -> Option<bool> { self.need_shipping_address.clone() }
  
  pub fn send_phone_number_to_provider(&self) -> Option<bool> { self.send_phone_number_to_provider.clone() }
  
  pub fn send_email_address_to_provider(&self) -> Option<bool> { self.send_email_address_to_provider.clone() }
  
  pub fn is_flexible(&self) -> Option<bool> { self.is_flexible.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a single button in a bot keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct KeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButton
  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<KeyboardButtonType>>,
  
}


impl Clone for KeyboardButton {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for KeyboardButton {}
impl RObject for KeyboardButton {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButton" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButton }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl KeyboardButton {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn type_(&self) -> Option<Box<KeyboardButtonType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a keyboard button type. 
#[typetag::serde(tag = "@struct")]
pub trait KeyboardButtonType: Object + RObject + Debug {}






impl KeyboardButtonType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<KeyboardButtonType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDKeyboardButtonTypeType {
  KeyboardButtonTypeRequestLocation,
  KeyboardButtonTypeRequestPhoneNumber,
  KeyboardButtonTypeText,
  
}
impl RTDKeyboardButtonTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDKeyboardButtonTypeType)(text.as_ref()) }
}



/// A simple button, with text that should be sent when the button is pressed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeText
  
}



impl Object for KeyboardButtonTypeText {}
impl RObject for KeyboardButtonTypeText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeText" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeText {}


impl KeyboardButtonTypeText {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button that sends the user's phone number when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeRequestPhoneNumber
  
}



impl Object for KeyboardButtonTypeRequestPhoneNumber {}
impl RObject for KeyboardButtonTypeRequestPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeRequestPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeRequestPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeRequestPhoneNumber {}


impl KeyboardButtonTypeRequestPhoneNumber {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A button that sends the user's location when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // keyboardButtonTypeRequestLocation
  
}



impl Object for KeyboardButtonTypeRequestLocation {}
impl RObject for KeyboardButtonTypeRequestLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "keyboardButtonTypeRequestLocation" }
  fn td_type(&self) -> RTDType { RTDType::KeyboardButtonTypeRequestLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl KeyboardButtonType for KeyboardButtonTypeRequestLocation {}


impl KeyboardButtonTypeRequestLocation {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Portion of the price of a product (e.g., "delivery cost", "tax amount"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabeledPricePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // labeledPricePart
  /// Label for this portion of the product price.
  label: Option<String>,
  /// Currency amount in minimal quantity of the currency.
  amount: Option<i64>,
  
}



impl Object for LabeledPricePart {}
impl RObject for LabeledPricePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "labeledPricePart" }
  fn td_type(&self) -> RTDType { RTDType::LabeledPricePart }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LabeledPricePart {
  
  pub fn label(&self) -> Option<String> { self.label.clone() }
  
  pub fn amount(&self) -> Option<i64> { self.amount.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackInfo
  /// Unique language pack identifier.
  id: Option<String>,
  /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs.
  base_language_pack_id: Option<String>,
  /// Language name.
  name: Option<String>,
  /// Name of the language in that language.
  native_name: Option<String>,
  /// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info.
  plural_code: Option<String>,
  /// True, if the language pack is official.
  is_official: Option<bool>,
  /// True, if the language pack strings are RTL.
  is_rtl: Option<bool>,
  /// True, if the language pack is a beta language pack.
  is_beta: Option<bool>,
  /// True, if the language pack is installed by the current user.
  is_installed: Option<bool>,
  /// Total number of non-deleted strings from the language pack.
  total_string_count: Option<i32>,
  /// Total number of translated strings from the language pack.
  translated_string_count: Option<i32>,
  /// Total number of non-deleted strings from the language pack available locally.
  local_string_count: Option<i32>,
  /// Link to language translation interface; empty for custom local language packs.
  translation_url: Option<String>,
  
}



impl Object for LanguagePackInfo {}
impl RObject for LanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LanguagePackInfo {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn base_language_pack_id(&self) -> Option<String> { self.base_language_pack_id.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn native_name(&self) -> Option<String> { self.native_name.clone() }
  
  pub fn plural_code(&self) -> Option<String> { self.plural_code.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_rtl(&self) -> Option<bool> { self.is_rtl.clone() }
  
  pub fn is_beta(&self) -> Option<bool> { self.is_beta.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn total_string_count(&self) -> Option<i32> { self.total_string_count.clone() }
  
  pub fn translated_string_count(&self) -> Option<i32> { self.translated_string_count.clone() }
  
  pub fn local_string_count(&self) -> Option<i32> { self.local_string_count.clone() }
  
  pub fn translation_url(&self) -> Option<String> { self.translation_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents one language pack string. 
#[derive(Debug, Serialize, Deserialize)]
pub struct LanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackString
  /// String key.
  key: Option<String>,
  /// String value.
  value: Option<Box<LanguagePackStringValue>>,
  
}


impl Clone for LanguagePackString {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for LanguagePackString {}
impl RObject for LanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackString" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LanguagePackString {
  
  pub fn key(&self) -> Option<String> { self.key.clone() }
  
  pub fn value(&self) -> Option<Box<LanguagePackStringValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the value of a string in a language pack. 
#[typetag::serde(tag = "@struct")]
pub trait LanguagePackStringValue: Object + RObject + Debug {}






impl LanguagePackStringValue {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<LanguagePackStringValue> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLanguagePackStringValueType {
  LanguagePackStringValueDeleted,
  LanguagePackStringValueOrdinary,
  LanguagePackStringValuePluralized,
  
}
impl RTDLanguagePackStringValueType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDLanguagePackStringValueType)(text.as_ref()) }
}



/// An ordinary language pack string. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueOrdinary {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValueOrdinary
  /// String value.
  value: Option<String>,
  
}



impl Object for LanguagePackStringValueOrdinary {}
impl RObject for LanguagePackStringValueOrdinary {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValueOrdinary" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValueOrdinary }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValueOrdinary {}


impl LanguagePackStringValueOrdinary {
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A language pack string which has different forms based on the number of some object it mentions. See 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValuePluralized {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValuePluralized
  /// Value for zero objects.
  zero_value: Option<String>,
  /// Value for one object.
  one_value: Option<String>,
  /// Value for two objects.
  two_value: Option<String>,
  /// Value for few objects.
  few_value: Option<String>,
  /// Value for many objects.
  many_value: Option<String>,
  /// Default value.
  other_value: Option<String>,
  
}



impl Object for LanguagePackStringValuePluralized {}
impl RObject for LanguagePackStringValuePluralized {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValuePluralized" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValuePluralized }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValuePluralized {}


impl LanguagePackStringValuePluralized {
  
  pub fn zero_value(&self) -> Option<String> { self.zero_value.clone() }
  
  pub fn one_value(&self) -> Option<String> { self.one_value.clone() }
  
  pub fn two_value(&self) -> Option<String> { self.two_value.clone() }
  
  pub fn few_value(&self) -> Option<String> { self.few_value.clone() }
  
  pub fn many_value(&self) -> Option<String> { self.many_value.clone() }
  
  pub fn other_value(&self) -> Option<String> { self.other_value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A deleted language pack string, the value should be taken from the built-in english language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStringValueDeleted
  
}



impl Object for LanguagePackStringValueDeleted {}
impl RObject for LanguagePackStringValueDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStringValueDeleted" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStringValueDeleted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LanguagePackStringValue for LanguagePackStringValueDeleted {}


impl LanguagePackStringValueDeleted {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of language pack strings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // languagePackStrings
  /// A list of language pack strings.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for LanguagePackStrings {}
impl RObject for LanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "languagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::LanguagePackStrings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LanguagePackStrings {
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the relationship between user A and user B. For incoming_link, user A is the current user; for outgoing_link, user B is the current user. 
#[typetag::serde(tag = "@struct")]
pub trait LinkState: Object + RObject + Debug {}






impl LinkState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<LinkState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLinkStateType {
  LinkStateIsContact,
  LinkStateKnowsPhoneNumber,
  LinkStateNone,
  
}
impl RTDLinkStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDLinkStateType)(text.as_ref()) }
}



/// The phone number of user A is not known to user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateNone
  
}



impl Object for LinkStateNone {}
impl RObject for LinkStateNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateNone" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateNone }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LinkState for LinkStateNone {}


impl LinkStateNone {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The phone number of user A is known but that number has not been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateKnowsPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateKnowsPhoneNumber
  
}



impl Object for LinkStateKnowsPhoneNumber {}
impl RObject for LinkStateKnowsPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateKnowsPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateKnowsPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LinkState for LinkStateKnowsPhoneNumber {}


impl LinkStateKnowsPhoneNumber {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The phone number of user A has been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateIsContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // linkStateIsContact
  
}



impl Object for LinkStateIsContact {}
impl RObject for LinkStateIsContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "linkStateIsContact" }
  fn td_type(&self) -> RTDType { RTDType::LinkStateIsContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LinkState for LinkStateIsContact {}


impl LinkStateIsContact {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a local file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // localFile
  /// Local path to the locally available file part; may be empty.
  path: Option<String>,
  /// True, if it is possible to try to download or generate the file.
  can_be_downloaded: Option<bool>,
  /// True, if the file can be deleted.
  can_be_deleted: Option<bool>,
  /// True, if the file is currently being downloaded (or a local copy is being generated by some other means).
  is_downloading_active: Option<bool>,
  /// True, if the local copy is fully available.
  is_downloading_completed: Option<bool>,
  /// Download will be started from this offset. downloaded_prefix_size is calculated from this offset.
  download_offset: Option<i32>,
  /// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix.
  downloaded_prefix_size: Option<i32>,
  /// Total downloaded file bytes. Should be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage.
  downloaded_size: Option<i32>,
  
}



impl Object for LocalFile {}
impl RObject for LocalFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "localFile" }
  fn td_type(&self) -> RTDType { RTDType::LocalFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LocalFile {
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn can_be_downloaded(&self) -> Option<bool> { self.can_be_downloaded.clone() }
  
  pub fn can_be_deleted(&self) -> Option<bool> { self.can_be_deleted.clone() }
  
  pub fn is_downloading_active(&self) -> Option<bool> { self.is_downloading_active.clone() }
  
  pub fn is_downloading_completed(&self) -> Option<bool> { self.is_downloading_completed.clone() }
  
  pub fn download_offset(&self) -> Option<i32> { self.download_offset.clone() }
  
  pub fn downloaded_prefix_size(&self) -> Option<i32> { self.downloaded_prefix_size.clone() }
  
  pub fn downloaded_size(&self) -> Option<i32> { self.downloaded_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about the current localization target. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // localizationTargetInfo
  /// List of available language packs for this application.
  language_packs: Option<Vec<LanguagePackInfo>>,
  
}



impl Object for LocalizationTargetInfo {}
impl RObject for LocalizationTargetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "localizationTargetInfo" }
  fn td_type(&self) -> RTDType { RTDType::LocalizationTargetInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LocalizationTargetInfo {
  
  pub fn language_packs(&self) -> Option<Vec<LanguagePackInfo>> { self.language_packs.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a location on planet Earth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // location
  /// Latitude of the location in degrees; as defined by the sender.
  latitude: Option<f64>,
  /// Longitude of the location, in degrees; as defined by the sender.
  longitude: Option<f64>,
  
}



impl Object for Location {}
impl RObject for Location {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "location" }
  fn td_type(&self) -> RTDType { RTDType::Location }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Location {
  
  pub fn latitude(&self) -> Option<f64> { self.latitude.clone() }
  
  pub fn longitude(&self) -> Option<f64> { self.longitude.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a stream to which TDLib internal log is written. 
#[typetag::serde(tag = "@struct")]
pub trait LogStream: Object + RObject + Debug {}






impl LogStream {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<LogStream> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDLogStreamType {
  LogStreamDefault,
  LogStreamEmpty,
  LogStreamFile,
  
}
impl RTDLogStreamType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDLogStreamType)(text.as_ref()) }
}



/// The log is written to stderr or an OS specific log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamDefault {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamDefault
  
}



impl Object for LogStreamDefault {}
impl RObject for LogStreamDefault {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamDefault" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamDefault }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LogStream for LogStreamDefault {}


impl LogStreamDefault {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The log is written to a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamFile
  /// Path to the file to where the internal TDLib log will be written.
  path: Option<String>,
  /// Maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated.
  max_file_size: Option<i64>,
  
}



impl Object for LogStreamFile {}
impl RObject for LogStreamFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamFile" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LogStream for LogStreamFile {}


impl LogStreamFile {
  
  pub fn path(&self) -> Option<String> { self.path.clone() }
  
  pub fn max_file_size(&self) -> Option<i64> { self.max_file_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The log is written nowhere. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logStreamEmpty
  
}



impl Object for LogStreamEmpty {}
impl RObject for LogStreamEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logStreamEmpty" }
  fn td_type(&self) -> RTDType { RTDType::LogStreamEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl LogStream for LogStreamEmpty {}


impl LogStreamEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of available TDLib internal log tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logTags
  /// List of log tags.
  tags: Option<Vec<String>>,
  
}



impl Object for LogTags {}
impl RObject for LogTags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logTags" }
  fn td_type(&self) -> RTDType { RTDType::LogTags }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LogTags {
  
  pub fn tags(&self) -> Option<Vec<String>> { self.tags.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a TDLib internal log verbosity level. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logVerbosityLevel
  /// Log verbosity level.
  verbosity_level: Option<i32>,
  
}



impl Object for LogVerbosityLevel {}
impl RObject for LogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::LogVerbosityLevel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl LogVerbosityLevel {
  
  pub fn verbosity_level(&self) -> Option<i32> { self.verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Part of the face, relative to which a mask should be placed. 
#[typetag::serde(tag = "@struct")]
pub trait MaskPoint: Object + RObject + Debug {}






impl MaskPoint {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<MaskPoint> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMaskPointType {
  MaskPointChin,
  MaskPointEyes,
  MaskPointForehead,
  MaskPointMouth,
  
}
impl RTDMaskPointType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDMaskPointType)(text.as_ref()) }
}



/// A mask should be placed relatively to the forehead. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointForehead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointForehead
  
}



impl Object for MaskPointForehead {}
impl RObject for MaskPointForehead {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointForehead" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointForehead }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MaskPoint for MaskPointForehead {}


impl MaskPointForehead {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A mask should be placed relatively to the eyes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointEyes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointEyes
  
}



impl Object for MaskPointEyes {}
impl RObject for MaskPointEyes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointEyes" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointEyes }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MaskPoint for MaskPointEyes {}


impl MaskPointEyes {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A mask should be placed relatively to the mouth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointMouth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointMouth
  
}



impl Object for MaskPointMouth {}
impl RObject for MaskPointMouth {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointMouth" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointMouth }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MaskPoint for MaskPointMouth {}


impl MaskPointMouth {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A mask should be placed relatively to the chin. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointChin {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPointChin
  
}



impl Object for MaskPointChin {}
impl RObject for MaskPointChin {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPointChin" }
  fn td_type(&self) -> RTDType { RTDType::MaskPointChin }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MaskPoint for MaskPointChin {}


impl MaskPointChin {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Position on a photo where a mask should be placed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MaskPosition {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // maskPosition
  /// Part of the face, relative to which the mask should be placed.
  point: Option<Box<MaskPoint>>,
  /// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position.)
  x_shift: Option<f64>,
  /// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position.)
  y_shift: Option<f64>,
  /// Mask scaling coefficient. (For example, 2.0 means a doubled size.)
  scale: Option<f64>,
  
}


impl Clone for MaskPosition {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for MaskPosition {}
impl RObject for MaskPosition {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "maskPosition" }
  fn td_type(&self) -> RTDType { RTDType::MaskPosition }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl MaskPosition {
  
  pub fn point(&self) -> Option<Box<MaskPoint>> { self.point.clone() }
  
  pub fn x_shift(&self) -> Option<f64> { self.x_shift.clone() }
  
  pub fn y_shift(&self) -> Option<f64> { self.y_shift.clone() }
  
  pub fn scale(&self) -> Option<f64> { self.scale.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // message
  /// Message identifier, unique for the chat to which the message belongs.
  id: Option<i64>,
  /// Identifier of the user who sent the message; 0 if unknown. It is unknown for channel posts.
  sender_user_id: Option<i32>,
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Information about the sending state of the message; may be null.
  sending_state: Option<Box<MessageSendingState>>,
  /// True, if the message is outgoing.
  is_outgoing: Option<bool>,
  /// True, if the message can be edited. For live location and poll messages this fields shows, whether editMessageLiveLocation or stopPoll can be used with this message by the client.
  can_be_edited: Option<bool>,
  /// True, if the message can be forwarded.
  can_be_forwarded: Option<bool>,
  /// True, if the message can be deleted only for the current user while other users will continue to see it.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the message can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts.
  is_channel_post: Option<bool>,
  /// True, if the message contains an unread mention for the current user.
  contains_unread_mention: Option<bool>,
  /// Point in time (Unix timestamp) when the message was sent.
  date: Option<i32>,
  /// Point in time (Unix timestamp) when the message was last edited.
  edit_date: Option<i32>,
  /// Information about the initial message sender; may be null.
  forward_info: Option<MessageForwardInfo>,
  /// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message.
  reply_to_message_id: Option<i64>,
  /// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires.
  ttl: Option<i32>,
  /// Time left before the message expires, in seconds.
  ttl_expires_in: Option<f64>,
  /// If non-zero, the user identifier of the bot through which this message was sent.
  via_bot_user_id: Option<i32>,
  /// For channel posts, optional author signature.
  author_signature: Option<String>,
  /// Number of times this message was viewed.
  views: Option<i32>,
  /// Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums.
  media_album_id: Option<String>,
  /// Content of the message.
  content: Option<Box<MessageContent>>,
  /// Reply markup for the message; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for Message {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Message {}
impl RObject for Message {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "message" }
  fn td_type(&self) -> RTDType { RTDType::Message }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Message {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn sending_state(&self) -> Option<Box<MessageSendingState>> { self.sending_state.clone() }
  
  pub fn is_outgoing(&self) -> Option<bool> { self.is_outgoing.clone() }
  
  pub fn can_be_edited(&self) -> Option<bool> { self.can_be_edited.clone() }
  
  pub fn can_be_forwarded(&self) -> Option<bool> { self.can_be_forwarded.clone() }
  
  pub fn can_be_deleted_only_for_self(&self) -> Option<bool> { self.can_be_deleted_only_for_self.clone() }
  
  pub fn can_be_deleted_for_all_users(&self) -> Option<bool> { self.can_be_deleted_for_all_users.clone() }
  
  pub fn is_channel_post(&self) -> Option<bool> { self.is_channel_post.clone() }
  
  pub fn contains_unread_mention(&self) -> Option<bool> { self.contains_unread_mention.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn edit_date(&self) -> Option<i32> { self.edit_date.clone() }
  
  pub fn forward_info(&self) -> Option<MessageForwardInfo> { self.forward_info.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn ttl_expires_in(&self) -> Option<f64> { self.ttl_expires_in.clone() }
  
  pub fn via_bot_user_id(&self) -> Option<i32> { self.via_bot_user_id.clone() }
  
  pub fn author_signature(&self) -> Option<String> { self.author_signature.clone() }
  
  pub fn views(&self) -> Option<i32> { self.views.clone() }
  
  pub fn media_album_id(&self) -> Option<String> { self.media_album_id.clone() }
  
  pub fn content(&self) -> Option<Box<MessageContent>> { self.content.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains the content of a message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageContent: Object + RObject + Debug {}






impl MessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<MessageContent> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageContentType {
  MessageAnimation,
  MessageAudio,
  MessageBasicGroupChatCreate,
  MessageCall,
  MessageChatAddMembers,
  MessageChatChangePhoto,
  MessageChatChangeTitle,
  MessageChatDeleteMember,
  MessageChatDeletePhoto,
  MessageChatJoinByLink,
  MessageChatSetTtl,
  MessageChatUpgradeFrom,
  MessageChatUpgradeTo,
  MessageContact,
  MessageContactRegistered,
  MessageCustomServiceAction,
  MessageDocument,
  MessageExpiredPhoto,
  MessageExpiredVideo,
  MessageGame,
  MessageGameScore,
  MessageInvoice,
  MessageLocation,
  MessagePassportDataReceived,
  MessagePassportDataSent,
  MessagePaymentSuccessful,
  MessagePaymentSuccessfulBot,
  MessagePhoto,
  MessagePinMessage,
  MessagePoll,
  MessageScreenshotTaken,
  MessageSticker,
  MessageSupergroupChatCreate,
  MessageText,
  MessageUnsupported,
  MessageVenue,
  MessageVideo,
  MessageVideoNote,
  MessageVoiceNote,
  MessageWebsiteConnected,
  
}
impl RTDMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDMessageContentType)(text.as_ref()) }
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageText
  /// Text of the message.
  text: Option<FormattedText>,
  /// A preview of the web page that's mentioned in the text; may be null.
  web_page: Option<WebPage>,
  
}



impl Object for MessageText {}
impl RObject for MessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageText" }
  fn td_type(&self) -> RTDType { RTDType::MessageText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageText {}


impl MessageText {
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn web_page(&self) -> Option<WebPage> { self.web_page.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An animation message (GIF-style). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageAnimation
  /// Message content.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<FormattedText>,
  /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageAnimation {}
impl RObject for MessageAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageAnimation" }
  fn td_type(&self) -> RTDType { RTDType::MessageAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageAnimation {}


impl MessageAnimation {
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageAudio
  /// Message content.
  audio: Option<Audio>,
  /// Audio caption.
  caption: Option<FormattedText>,
  
}



impl Object for MessageAudio {}
impl RObject for MessageAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageAudio" }
  fn td_type(&self) -> RTDType { RTDType::MessageAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageAudio {}


impl MessageAudio {
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A document message (general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageDocument
  /// Message content.
  document: Option<Document>,
  /// Document caption.
  caption: Option<FormattedText>,
  
}



impl Object for MessageDocument {}
impl RObject for MessageDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageDocument" }
  fn td_type(&self) -> RTDType { RTDType::MessageDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageDocument {}


impl MessageDocument {
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePhoto
  /// Message content.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<FormattedText>,
  /// True, if the photo must be blurred and must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessagePhoto {}
impl RObject for MessagePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessagePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePhoto {}


impl MessagePhoto {
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An expired photo message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageExpiredPhoto
  
}



impl Object for MessageExpiredPhoto {}
impl RObject for MessageExpiredPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageExpiredPhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageExpiredPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageExpiredPhoto {}


impl MessageExpiredPhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A sticker message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSticker
  /// Message content.
  sticker: Option<Sticker>,
  
}



impl Object for MessageSticker {}
impl RObject for MessageSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSticker" }
  fn td_type(&self) -> RTDType { RTDType::MessageSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageSticker {}


impl MessageSticker {
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVideo
  /// Message content.
  video: Option<Video>,
  /// Video caption.
  caption: Option<FormattedText>,
  /// True, if the video thumbnail must be blurred and the video must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageVideo {}
impl RObject for MessageVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVideo" }
  fn td_type(&self) -> RTDType { RTDType::MessageVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageVideo {}


impl MessageVideo {
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An expired video message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageExpiredVideo
  
}



impl Object for MessageExpiredVideo {}
impl RObject for MessageExpiredVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageExpiredVideo" }
  fn td_type(&self) -> RTDType { RTDType::MessageExpiredVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageExpiredVideo {}


impl MessageExpiredVideo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVideoNote
  /// Message content.
  video_note: Option<VideoNote>,
  /// True, if at least one of the recipients has viewed the video note.
  is_viewed: Option<bool>,
  /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped.
  is_secret: Option<bool>,
  
}



impl Object for MessageVideoNote {}
impl RObject for MessageVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::MessageVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageVideoNote {}


impl MessageVideoNote {
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVoiceNote
  /// Message content.
  voice_note: Option<VoiceNote>,
  /// Voice note caption.
  caption: Option<FormattedText>,
  /// True, if at least one of the recipients has listened to the voice note.
  is_listened: Option<bool>,
  
}



impl Object for MessageVoiceNote {}
impl RObject for MessageVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::MessageVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageVoiceNote {}


impl MessageVoiceNote {
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn is_listened(&self) -> Option<bool> { self.is_listened.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageLocation
  /// Message content.
  location: Option<Location>,
  /// Time relative to the message sent date until which the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes.
  expires_in: Option<i32>,
  
}



impl Object for MessageLocation {}
impl RObject for MessageLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageLocation" }
  fn td_type(&self) -> RTDType { RTDType::MessageLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageLocation {}


impl MessageLocation {
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn live_period(&self) -> Option<i32> { self.live_period.clone() }
  
  pub fn expires_in(&self) -> Option<i32> { self.expires_in.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageVenue
  /// Message content.
  venue: Option<Venue>,
  
}



impl Object for MessageVenue {}
impl RObject for MessageVenue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageVenue" }
  fn td_type(&self) -> RTDType { RTDType::MessageVenue }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageVenue {}


impl MessageVenue {
  
  pub fn venue(&self) -> Option<Venue> { self.venue.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageContact
  /// Message content.
  contact: Option<Contact>,
  
}



impl Object for MessageContact {}
impl RObject for MessageContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageContact" }
  fn td_type(&self) -> RTDType { RTDType::MessageContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageContact {}


impl MessageContact {
  
  pub fn contact(&self) -> Option<Contact> { self.contact.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageGame
  /// Game.
  game: Option<Game>,
  
}



impl Object for MessageGame {}
impl RObject for MessageGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageGame" }
  fn td_type(&self) -> RTDType { RTDType::MessageGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageGame {}


impl MessageGame {
  
  pub fn game(&self) -> Option<Game> { self.game.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePoll
  /// Poll.
  poll: Option<Poll>,
  
}



impl Object for MessagePoll {}
impl RObject for MessagePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePoll" }
  fn td_type(&self) -> RTDType { RTDType::MessagePoll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePoll {}


impl MessagePoll {
  
  pub fn poll(&self) -> Option<Poll> { self.poll.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageInvoice
  /// Product title.
  title: Option<String>,
  /// Product description.
  description: Option<String>,
  /// Product photo; may be null.
  photo: Option<Photo>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Product total price in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}.
  start_parameter: Option<String>,
  /// True, if the invoice is a test invoice.
  is_test: Option<bool>,
  /// True, if the shipping address should be specified.
  need_shipping_address: Option<bool>,
  /// The identifier of the message with the receipt, after the product has been purchased.
  receipt_message_id: Option<i64>,
  
}



impl Object for MessageInvoice {}
impl RObject for MessageInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageInvoice" }
  fn td_type(&self) -> RTDType { RTDType::MessageInvoice }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageInvoice {}


impl MessageInvoice {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn start_parameter(&self) -> Option<String> { self.start_parameter.clone() }
  
  pub fn is_test(&self) -> Option<bool> { self.is_test.clone() }
  
  pub fn need_shipping_address(&self) -> Option<bool> { self.need_shipping_address.clone() }
  
  pub fn receipt_message_id(&self) -> Option<i64> { self.receipt_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with information about an ended call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageCall
  /// Reason why the call was discarded.
  discard_reason: Option<Box<CallDiscardReason>>,
  /// Call duration, in seconds.
  duration: Option<i32>,
  
}


impl Clone for MessageCall {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for MessageCall {}
impl RObject for MessageCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageCall" }
  fn td_type(&self) -> RTDType { RTDType::MessageCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageCall {}


impl MessageCall {
  
  pub fn discard_reason(&self) -> Option<Box<CallDiscardReason>> { self.discard_reason.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageBasicGroupChatCreate
  /// Title of the basic group.
  title: Option<String>,
  /// User identifiers of members in the basic group.
  member_user_ids: Option<Vec<i32>>,
  
}



impl Object for MessageBasicGroupChatCreate {}
impl RObject for MessageBasicGroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageBasicGroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::MessageBasicGroupChatCreate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageBasicGroupChatCreate {}


impl MessageBasicGroupChatCreate {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A newly created supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSupergroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSupergroupChatCreate
  /// Title of the supergroup or channel.
  title: Option<String>,
  
}



impl Object for MessageSupergroupChatCreate {}
impl RObject for MessageSupergroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSupergroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::MessageSupergroupChatCreate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageSupergroupChatCreate {}


impl MessageSupergroupChatCreate {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An updated chat title. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatChangeTitle
  /// New chat title.
  title: Option<String>,
  
}



impl Object for MessageChatChangeTitle {}
impl RObject for MessageChatChangeTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatChangeTitle" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatChangeTitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatChangeTitle {}


impl MessageChatChangeTitle {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An updated chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatChangePhoto
  /// New chat photo.
  photo: Option<Photo>,
  
}



impl Object for MessageChatChangePhoto {}
impl RObject for MessageChatChangePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatChangePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatChangePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatChangePhoto {}


impl MessageChatChangePhoto {
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A deleted chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeletePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatDeletePhoto
  
}



impl Object for MessageChatDeletePhoto {}
impl RObject for MessageChatDeletePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatDeletePhoto" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatDeletePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatDeletePhoto {}


impl MessageChatDeletePhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New chat members were added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatAddMembers
  /// User identifiers of the new members.
  member_user_ids: Option<Vec<i32>>,
  
}



impl Object for MessageChatAddMembers {}
impl RObject for MessageChatAddMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatAddMembers" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatAddMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatAddMembers {}


impl MessageChatAddMembers {
  
  pub fn member_user_ids(&self) -> Option<Vec<i32>> { self.member_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatJoinByLink
  
}



impl Object for MessageChatJoinByLink {}
impl RObject for MessageChatJoinByLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatJoinByLink" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatJoinByLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatJoinByLink {}


impl MessageChatJoinByLink {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatDeleteMember
  /// User identifier of the deleted chat member.
  user_id: Option<i32>,
  
}



impl Object for MessageChatDeleteMember {}
impl RObject for MessageChatDeleteMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatDeleteMember" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatDeleteMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatDeleteMember {}


impl MessageChatDeleteMember {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A basic group was upgraded to a supergroup and was deactivated as the result. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeTo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatUpgradeTo
  /// Identifier of the supergroup to which the basic group was upgraded.
  supergroup_id: Option<i32>,
  
}



impl Object for MessageChatUpgradeTo {}
impl RObject for MessageChatUpgradeTo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatUpgradeTo" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatUpgradeTo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatUpgradeTo {}


impl MessageChatUpgradeTo {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A supergroup has been created from a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeFrom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatUpgradeFrom
  /// Title of the newly created supergroup.
  title: Option<String>,
  /// The identifier of the original basic group.
  basic_group_id: Option<i32>,
  
}



impl Object for MessageChatUpgradeFrom {}
impl RObject for MessageChatUpgradeFrom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatUpgradeFrom" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatUpgradeFrom }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatUpgradeFrom {}


impl MessageChatUpgradeFrom {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message has been pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePinMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePinMessage
  /// Identifier of the pinned message, can be an identifier of a deleted message or 0.
  message_id: Option<i64>,
  
}



impl Object for MessagePinMessage {}
impl RObject for MessagePinMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePinMessage" }
  fn td_type(&self) -> RTDType { RTDType::MessagePinMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePinMessage {}


impl MessagePinMessage {
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageScreenshotTaken
  
}



impl Object for MessageScreenshotTaken {}
impl RObject for MessageScreenshotTaken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageScreenshotTaken" }
  fn td_type(&self) -> RTDType { RTDType::MessageScreenshotTaken }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageScreenshotTaken {}


impl MessageScreenshotTaken {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The TTL (Time To Live) setting messages in a secret chat has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatSetTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageChatSetTtl
  /// New TTL.
  ttl: Option<i32>,
  
}



impl Object for MessageChatSetTtl {}
impl RObject for MessageChatSetTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageChatSetTtl" }
  fn td_type(&self) -> RTDType { RTDType::MessageChatSetTtl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageChatSetTtl {}


impl MessageChatSetTtl {
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A non-standard action has happened in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageCustomServiceAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageCustomServiceAction
  /// Message text to be shown in the chat.
  text: Option<String>,
  
}



impl Object for MessageCustomServiceAction {}
impl RObject for MessageCustomServiceAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageCustomServiceAction" }
  fn td_type(&self) -> RTDType { RTDType::MessageCustomServiceAction }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageCustomServiceAction {}


impl MessageCustomServiceAction {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageGameScore
  /// Identifier of the message with the game, can be an identifier of a deleted message.
  game_message_id: Option<i64>,
  /// Identifier of the game; may be different from the games presented in the message with the game.
  game_id: Option<i64>,
  /// New score.
  score: Option<i32>,
  
}



impl Object for MessageGameScore {}
impl RObject for MessageGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageGameScore" }
  fn td_type(&self) -> RTDType { RTDType::MessageGameScore }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageGameScore {}


impl MessageGameScore {
  
  pub fn game_message_id(&self) -> Option<i64> { self.game_message_id.clone() }
  
  pub fn game_id(&self) -> Option<i64> { self.game_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A payment has been completed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessful {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePaymentSuccessful
  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for the price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  
}



impl Object for MessagePaymentSuccessful {}
impl RObject for MessagePaymentSuccessful {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePaymentSuccessful" }
  fn td_type(&self) -> RTDType { RTDType::MessagePaymentSuccessful }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePaymentSuccessful {}


impl MessagePaymentSuccessful {
  
  pub fn invoice_message_id(&self) -> Option<i64> { self.invoice_message_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A payment has been completed; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessfulBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePaymentSuccessfulBot
  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of the shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,
  /// Telegram payment identifier.
  telegram_payment_charge_id: Option<String>,
  /// Provider payment identifier.
  provider_payment_charge_id: Option<String>,
  
}



impl Object for MessagePaymentSuccessfulBot {}
impl RObject for MessagePaymentSuccessfulBot {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePaymentSuccessfulBot" }
  fn td_type(&self) -> RTDType { RTDType::MessagePaymentSuccessfulBot }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePaymentSuccessfulBot {}


impl MessagePaymentSuccessfulBot {
  
  pub fn invoice_message_id(&self) -> Option<i64> { self.invoice_message_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn telegram_payment_charge_id(&self) -> Option<String> { self.telegram_payment_charge_id.clone() }
  
  pub fn provider_payment_charge_id(&self) -> Option<String> { self.provider_payment_charge_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageContactRegistered
  
}



impl Object for MessageContactRegistered {}
impl RObject for MessageContactRegistered {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageContactRegistered" }
  fn td_type(&self) -> RTDType { RTDType::MessageContactRegistered }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageContactRegistered {}


impl MessageContactRegistered {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The current user has connected a website by logging in using Telegram Login Widget on it. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageWebsiteConnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageWebsiteConnected
  /// Domain name of the connected website.
  domain_name: Option<String>,
  
}



impl Object for MessageWebsiteConnected {}
impl RObject for MessageWebsiteConnected {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageWebsiteConnected" }
  fn td_type(&self) -> RTDType { RTDType::MessageWebsiteConnected }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageWebsiteConnected {}


impl MessageWebsiteConnected {
  
  pub fn domain_name(&self) -> Option<String> { self.domain_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Telegram Passport data has been sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessagePassportDataSent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePassportDataSent
  /// List of Telegram Passport element types sent.
  types: Option<Vec<Box<PassportElementType>>>,
  
}


impl Clone for MessagePassportDataSent {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for MessagePassportDataSent {}
impl RObject for MessagePassportDataSent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePassportDataSent" }
  fn td_type(&self) -> RTDType { RTDType::MessagePassportDataSent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePassportDataSent {}


impl MessagePassportDataSent {
  
  pub fn types(&self) -> Option<Vec<Box<PassportElementType>>> { self.types.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Telegram Passport data has been received; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePassportDataReceived {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messagePassportDataReceived
  /// List of received Telegram Passport elements.
  elements: Option<Vec<EncryptedPassportElement>>,
  /// Encrypted data credentials.
  credentials: Option<EncryptedCredentials>,
  
}



impl Object for MessagePassportDataReceived {}
impl RObject for MessagePassportDataReceived {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messagePassportDataReceived" }
  fn td_type(&self) -> RTDType { RTDType::MessagePassportDataReceived }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessagePassportDataReceived {}


impl MessagePassportDataReceived {
  
  pub fn elements(&self) -> Option<Vec<EncryptedPassportElement>> { self.elements.clone() }
  
  pub fn credentials(&self) -> Option<EncryptedCredentials> { self.credentials.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Message content that is not supported by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageUnsupported {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageUnsupported
  
}



impl Object for MessageUnsupported {}
impl RObject for MessageUnsupported {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageUnsupported" }
  fn td_type(&self) -> RTDType { RTDType::MessageUnsupported }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageContent for MessageUnsupported {}


impl MessageUnsupported {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a forwarded message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageForwardInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardInfo
  /// Origin of a forwarded message.
  origin: Option<Box<MessageForwardOrigin>>,
  /// Point in time (Unix timestamp) when the message was originally sent.
  date: Option<i32>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the chat from which the message was forwarded last time; 0 if unknown.
  from_chat_id: Option<i64>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the original message from which the new message was forwarded last time; 0 if unknown.
  from_message_id: Option<i64>,
  
}


impl Clone for MessageForwardInfo {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for MessageForwardInfo {}
impl RObject for MessageForwardInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardInfo" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl MessageForwardInfo {
  
  pub fn origin(&self) -> Option<Box<MessageForwardOrigin>> { self.origin.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains information about the origin of a forwarded message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageForwardOrigin: Object + RObject + Debug {}






impl MessageForwardOrigin {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<MessageForwardOrigin> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageForwardOriginType {
  MessageForwardOriginChannel,
  MessageForwardOriginHiddenUser,
  MessageForwardOriginUser,
  
}
impl RTDMessageForwardOriginType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDMessageForwardOriginType)(text.as_ref()) }
}



/// The message was originally written by a known user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginUser
  /// Identifier of the user that originally sent the message.
  sender_user_id: Option<i32>,
  
}



impl Object for MessageForwardOriginUser {}
impl RObject for MessageForwardOriginUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginUser" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginUser {}


impl MessageForwardOriginUser {
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The message was originally written by a user, which is hidden by his privacy settings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginHiddenUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginHiddenUser
  /// Name of the sender.
  sender_name: Option<String>,
  
}



impl Object for MessageForwardOriginHiddenUser {}
impl RObject for MessageForwardOriginHiddenUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginHiddenUser" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginHiddenUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginHiddenUser {}


impl MessageForwardOriginHiddenUser {
  
  pub fn sender_name(&self) -> Option<String> { self.sender_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The message was originally a post in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginChannel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageForwardOriginChannel
  /// Identifier of the chat from which the message was originally forwarded.
  chat_id: Option<i64>,
  /// Message identifier of the original message; 0 if unknown.
  message_id: Option<i64>,
  /// Original post author signature.
  author_signature: Option<String>,
  
}



impl Object for MessageForwardOriginChannel {}
impl RObject for MessageForwardOriginChannel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageForwardOriginChannel" }
  fn td_type(&self) -> RTDType { RTDType::MessageForwardOriginChannel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageForwardOrigin for MessageForwardOriginChannel {}


impl MessageForwardOriginChannel {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn author_signature(&self) -> Option<String> { self.author_signature.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains information about the sending state of the message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageSendingState: Object + RObject + Debug {}






impl MessageSendingState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<MessageSendingState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDMessageSendingStateType {
  MessageSendingStateFailed,
  MessageSendingStatePending,
  
}
impl RTDMessageSendingStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDMessageSendingStateType)(text.as_ref()) }
}



/// The message is being sent now, but has not yet been delivered to the server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSendingStatePending
  
}



impl Object for MessageSendingStatePending {}
impl RObject for MessageSendingStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSendingStatePending" }
  fn td_type(&self) -> RTDType { RTDType::MessageSendingStatePending }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageSendingState for MessageSendingStatePending {}


impl MessageSendingStatePending {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The message failed to be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStateFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messageSendingStateFailed
  
}



impl Object for MessageSendingStateFailed {}
impl RObject for MessageSendingStateFailed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messageSendingStateFailed" }
  fn td_type(&self) -> RTDType { RTDType::MessageSendingStateFailed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl MessageSendingState for MessageSendingStateFailed {}


impl MessageSendingStateFailed {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Messages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // messages
  /// Approximate total count of messages found.
  total_count: Option<i32>,
  /// List of messages; messages may be null.
  messages: Option<Vec<Message>>,
  
}



impl Object for Messages {}
impl RObject for Messages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "messages" }
  fn td_type(&self) -> RTDType { RTDType::Messages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Messages {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn messages(&self) -> Option<Vec<Message>> { self.messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A full list of available network statistic entries. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatistics
  /// Point in time (Unix timestamp) when the app began collecting statistics.
  since_date: Option<i32>,
  /// Network statistics entries.
  entries: Option<Vec<Box<NetworkStatisticsEntry>>>,
  
}


impl Clone for NetworkStatistics {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for NetworkStatistics {}
impl RObject for NetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl NetworkStatistics {
  
  pub fn since_date(&self) -> Option<i32> { self.since_date.clone() }
  
  pub fn entries(&self) -> Option<Vec<Box<NetworkStatisticsEntry>>> { self.entries.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains statistics about network usage. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkStatisticsEntry: Object + RObject + Debug {}






impl NetworkStatisticsEntry {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<NetworkStatisticsEntry> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNetworkStatisticsEntryType {
  NetworkStatisticsEntryCall,
  NetworkStatisticsEntryFile,
  
}
impl RTDNetworkStatisticsEntryType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDNetworkStatisticsEntryType)(text.as_ref()) }
}



/// Contains information about the total amount of data that was used to send and receive files. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatisticsEntryFile
  /// Type of the file the data is part of.
  file_type: Option<Box<FileType>>,
  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,
  
}


impl Clone for NetworkStatisticsEntryFile {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for NetworkStatisticsEntryFile {}
impl RObject for NetworkStatisticsEntryFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatisticsEntryFile" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatisticsEntryFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkStatisticsEntry for NetworkStatisticsEntryFile {}


impl NetworkStatisticsEntryFile {
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn network_type(&self) -> Option<Box<NetworkType>> { self.network_type.clone() }
  
  pub fn sent_bytes(&self) -> Option<i64> { self.sent_bytes.clone() }
  
  pub fn received_bytes(&self) -> Option<i64> { self.received_bytes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about the total amount of data that was used for calls. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkStatisticsEntryCall
  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,
  /// Total call duration, in seconds.
  duration: Option<f64>,
  
}


impl Clone for NetworkStatisticsEntryCall {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for NetworkStatisticsEntryCall {}
impl RObject for NetworkStatisticsEntryCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkStatisticsEntryCall" }
  fn td_type(&self) -> RTDType { RTDType::NetworkStatisticsEntryCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkStatisticsEntry for NetworkStatisticsEntryCall {}


impl NetworkStatisticsEntryCall {
  
  pub fn network_type(&self) -> Option<Box<NetworkType>> { self.network_type.clone() }
  
  pub fn sent_bytes(&self) -> Option<i64> { self.sent_bytes.clone() }
  
  pub fn received_bytes(&self) -> Option<i64> { self.received_bytes.clone() }
  
  pub fn duration(&self) -> Option<f64> { self.duration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the type of a network. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkType: Object + RObject + Debug {}






impl NetworkType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<NetworkType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNetworkTypeType {
  NetworkTypeMobile,
  NetworkTypeMobileRoaming,
  NetworkTypeNone,
  NetworkTypeOther,
  NetworkTypeWiFi,
  
}
impl RTDNetworkTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDNetworkTypeType)(text.as_ref()) }
}



/// The network is not available. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeNone
  
}



impl Object for NetworkTypeNone {}
impl RObject for NetworkTypeNone {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeNone" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeNone }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkType for NetworkTypeNone {}


impl NetworkTypeNone {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A mobile network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeMobile
  
}



impl Object for NetworkTypeMobile {}
impl RObject for NetworkTypeMobile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeMobile" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeMobile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkType for NetworkTypeMobile {}


impl NetworkTypeMobile {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A mobile roaming network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobileRoaming {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeMobileRoaming
  
}



impl Object for NetworkTypeMobileRoaming {}
impl RObject for NetworkTypeMobileRoaming {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeMobileRoaming" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeMobileRoaming }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkType for NetworkTypeMobileRoaming {}


impl NetworkTypeMobileRoaming {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Wi-Fi network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeWiFi {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeWiFi
  
}



impl Object for NetworkTypeWiFi {}
impl RObject for NetworkTypeWiFi {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeWiFi" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeWiFi }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkType for NetworkTypeWiFi {}


impl NetworkTypeWiFi {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A different network type (e.g., Ethernet network). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeOther {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // networkTypeOther
  
}



impl Object for NetworkTypeOther {}
impl RObject for NetworkTypeOther {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "networkTypeOther" }
  fn td_type(&self) -> RTDType { RTDType::NetworkTypeOther }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NetworkType for NetworkTypeOther {}


impl NetworkTypeOther {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Notification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notification
  /// Unique persistent identifier of this notification.
  id: Option<i32>,
  /// Notification date.
  date: Option<i32>,
  /// Notification type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationType>>,
  
}


impl Clone for Notification {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Notification {}
impl RObject for Notification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notification" }
  fn td_type(&self) -> RTDType { RTDType::Notification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Notification {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a group of notifications. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroup
  /// Unique persistent auto-incremented from 1 identifier of the notification group.
  id: Option<i32>,
  /// Type of the group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Total number of active notifications in the group.
  total_count: Option<i32>,
  /// The list of active notifications.
  notifications: Option<Vec<Notification>>,
  
}


impl Clone for NotificationGroup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for NotificationGroup {}
impl RObject for NotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl NotificationGroup {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationGroupType>> { self.type_.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn notifications(&self) -> Option<Vec<Notification>> { self.notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes type of notifications in the group. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationGroupType: Object + RObject + Debug {}






impl NotificationGroupType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<NotificationGroupType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationGroupTypeType {
  NotificationGroupTypeCalls,
  NotificationGroupTypeMentions,
  NotificationGroupTypeMessages,
  NotificationGroupTypeSecretChat,
  
}
impl RTDNotificationGroupTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDNotificationGroupTypeType)(text.as_ref()) }
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeMessages
  
}



impl Object for NotificationGroupTypeMessages {}
impl RObject for NotificationGroupTypeMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeMessages" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeMessages {}


impl NotificationGroupTypeMessages {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeMentions
  
}



impl Object for NotificationGroupTypeMentions {}
impl RObject for NotificationGroupTypeMentions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeMentions" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeMentions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeMentions {}


impl NotificationGroupTypeMentions {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A group containing a notification of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeSecretChat
  
}



impl Object for NotificationGroupTypeSecretChat {}
impl RObject for NotificationGroupTypeSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeSecretChat {}


impl NotificationGroupTypeSecretChat {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationGroupTypeCalls
  
}



impl Object for NotificationGroupTypeCalls {}
impl RObject for NotificationGroupTypeCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationGroupTypeCalls" }
  fn td_type(&self) -> RTDType { RTDType::NotificationGroupTypeCalls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationGroupType for NotificationGroupTypeCalls {}


impl NotificationGroupTypeCalls {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the types of chats to which notification settings are applied. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationSettingsScope: Object + RObject + Debug {}






impl NotificationSettingsScope {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<NotificationSettingsScope> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationSettingsScopeType {
  NotificationSettingsScopeChannelChats,
  NotificationSettingsScopeGroupChats,
  NotificationSettingsScopePrivateChats,
  
}
impl RTDNotificationSettingsScopeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDNotificationSettingsScopeType)(text.as_ref()) }
}



/// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopePrivateChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopePrivateChats
  
}



impl Object for NotificationSettingsScopePrivateChats {}
impl RObject for NotificationSettingsScopePrivateChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopePrivateChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopePrivateChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopePrivateChats {}


impl NotificationSettingsScopePrivateChats {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeGroupChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopeGroupChats
  
}



impl Object for NotificationSettingsScopeGroupChats {}
impl RObject for NotificationSettingsScopeGroupChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopeGroupChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopeGroupChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopeGroupChats {}


impl NotificationSettingsScopeGroupChats {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Notification settings applied to all channels when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeChannelChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationSettingsScopeChannelChats
  
}



impl Object for NotificationSettingsScopeChannelChats {}
impl RObject for NotificationSettingsScopeChannelChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationSettingsScopeChannelChats" }
  fn td_type(&self) -> RTDType { RTDType::NotificationSettingsScopeChannelChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationSettingsScope for NotificationSettingsScopeChannelChats {}


impl NotificationSettingsScopeChannelChats {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains detailed information about a notification. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationType: Object + RObject + Debug {}






impl NotificationType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<NotificationType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDNotificationTypeType {
  NotificationTypeNewCall,
  NotificationTypeNewMessage,
  NotificationTypeNewPushMessage,
  NotificationTypeNewSecretChat,
  
}
impl RTDNotificationTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDNotificationTypeType)(text.as_ref()) }
}



/// New message was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewMessage
  /// The message.
  message: Option<Message>,
  
}



impl Object for NotificationTypeNewMessage {}
impl RObject for NotificationTypeNewMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewMessage" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewMessage {}


impl NotificationTypeNewMessage {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New secret chat was created. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewSecretChat
  
}



impl Object for NotificationTypeNewSecretChat {}
impl RObject for NotificationTypeNewSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewSecretChat {}


impl NotificationTypeNewSecretChat {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New call was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewCall
  /// Call identifier.
  call_id: Option<i32>,
  
}



impl Object for NotificationTypeNewCall {}
impl RObject for NotificationTypeNewCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewCall" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewCall {}


impl NotificationTypeNewCall {
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New message was received through a push notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationTypeNewPushMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // notificationTypeNewPushMessage
  /// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages and as reply_to_message_id.
  message_id: Option<i64>,
  /// Sender of the message. Corresponding user may be inaccessible.
  sender_user_id: Option<i32>,
  /// Push message content.
  content: Option<Box<PushMessageContent>>,
  
}


impl Clone for NotificationTypeNewPushMessage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for NotificationTypeNewPushMessage {}
impl RObject for NotificationTypeNewPushMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "notificationTypeNewPushMessage" }
  fn td_type(&self) -> RTDType { RTDType::NotificationTypeNewPushMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl NotificationType for NotificationTypeNewPushMessage {}


impl NotificationTypeNewPushMessage {
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn content(&self) -> Option<Box<PushMessageContent>> { self.content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An object of this type is returned on a successful function call for certain functions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ok {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // ok
  
}



impl Object for Ok {}
impl RObject for Ok {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "ok" }
  fn td_type(&self) -> RTDType { RTDType::Ok }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Ok {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the value of an option. 
#[typetag::serde(tag = "@struct")]
pub trait OptionValue: Object + RObject + Debug {}






impl OptionValue {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<OptionValue> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDOptionValueType {
  OptionValueBoolean,
  OptionValueEmpty,
  OptionValueInteger,
  OptionValueString,
  
}
impl RTDOptionValueType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDOptionValueType)(text.as_ref()) }
}



/// Represents a boolean option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueBoolean {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueBoolean
  /// The value of the option.
  value: Option<bool>,
  
}



impl Object for OptionValueBoolean {}
impl RObject for OptionValueBoolean {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueBoolean" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueBoolean }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl OptionValue for OptionValueBoolean {}


impl OptionValueBoolean {
  
  pub fn value(&self) -> Option<bool> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents an unknown option or an option which has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueEmpty
  
}



impl Object for OptionValueEmpty {}
impl RObject for OptionValueEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueEmpty" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl OptionValue for OptionValueEmpty {}


impl OptionValueEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents an integer option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueInteger {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueInteger
  /// The value of the option.
  value: Option<i32>,
  
}



impl Object for OptionValueInteger {}
impl RObject for OptionValueInteger {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueInteger" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueInteger }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl OptionValue for OptionValueInteger {}


impl OptionValueInteger {
  
  pub fn value(&self) -> Option<i32> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a string option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optionValueString
  /// The value of the option.
  value: Option<String>,
  
}



impl Object for OptionValueString {}
impl RObject for OptionValueString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optionValueString" }
  fn td_type(&self) -> RTDType { RTDType::OptionValueString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl OptionValue for OptionValueString {}


impl OptionValueString {
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Order information. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // orderInfo
  /// Name of the user.
  name: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Email address of the user.
  email_address: Option<String>,
  /// Shipping address for this order; may be null.
  shipping_address: Option<Address>,
  
}



impl Object for OrderInfo {}
impl RObject for OrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "orderInfo" }
  fn td_type(&self) -> RTDType { RTDType::OrderInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl OrderInfo {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn shipping_address(&self) -> Option<Address> { self.shipping_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a block of an instant view web page. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlock: Object + RObject + Debug {}






impl PageBlock {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PageBlock> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockType {
  PageBlockAnchor,
  PageBlockAnimation,
  PageBlockAudio,
  PageBlockAuthorDate,
  PageBlockBlockQuote,
  PageBlockChatLink,
  PageBlockCollage,
  PageBlockCover,
  PageBlockDetails,
  PageBlockDivider,
  PageBlockEmbedded,
  PageBlockEmbeddedPost,
  PageBlockFooter,
  PageBlockHeader,
  PageBlockKicker,
  PageBlockList,
  PageBlockMap,
  PageBlockParagraph,
  PageBlockPhoto,
  PageBlockPreformatted,
  PageBlockPullQuote,
  PageBlockRelatedArticles,
  PageBlockSlideshow,
  PageBlockSubheader,
  PageBlockSubtitle,
  PageBlockTable,
  PageBlockTitle,
  PageBlockVideo,
  
}
impl RTDPageBlockType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPageBlockType)(text.as_ref()) }
}



/// The title of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTitle
  /// Title.
  title: Option<Box<RichText>>,
  
}


impl Clone for PageBlockTitle {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockTitle {}
impl RObject for PageBlockTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTitle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockTitle {}


impl PageBlockTitle {
  
  pub fn title(&self) -> Option<Box<RichText>> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The subtitle of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubtitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSubtitle
  /// Subtitle.
  subtitle: Option<Box<RichText>>,
  
}


impl Clone for PageBlockSubtitle {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockSubtitle {}
impl RObject for PageBlockSubtitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSubtitle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSubtitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockSubtitle {}


impl PageBlockSubtitle {
  
  pub fn subtitle(&self) -> Option<Box<RichText>> { self.subtitle.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The author and publishing date of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockAuthorDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAuthorDate
  /// Author.
  author: Option<Box<RichText>>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,
  
}


impl Clone for PageBlockAuthorDate {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockAuthorDate {}
impl RObject for PageBlockAuthorDate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAuthorDate" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAuthorDate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockAuthorDate {}


impl PageBlockAuthorDate {
  
  pub fn author(&self) -> Option<Box<RichText>> { self.author.clone() }
  
  pub fn publish_date(&self) -> Option<i32> { self.publish_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A header. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockHeader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHeader
  /// Header.
  header: Option<Box<RichText>>,
  
}


impl Clone for PageBlockHeader {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockHeader {}
impl RObject for PageBlockHeader {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHeader" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHeader }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockHeader {}


impl PageBlockHeader {
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A subheader. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubheader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSubheader
  /// Subheader.
  subheader: Option<Box<RichText>>,
  
}


impl Clone for PageBlockSubheader {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockSubheader {}
impl RObject for PageBlockSubheader {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSubheader" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSubheader }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockSubheader {}


impl PageBlockSubheader {
  
  pub fn subheader(&self) -> Option<Box<RichText>> { self.subheader.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A kicker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockKicker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockKicker
  /// Kicker.
  kicker: Option<Box<RichText>>,
  
}


impl Clone for PageBlockKicker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockKicker {}
impl RObject for PageBlockKicker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockKicker" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockKicker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockKicker {}


impl PageBlockKicker {
  
  pub fn kicker(&self) -> Option<Box<RichText>> { self.kicker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockParagraph {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockParagraph
  /// Paragraph text.
  text: Option<Box<RichText>>,
  
}


impl Clone for PageBlockParagraph {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockParagraph {}
impl RObject for PageBlockParagraph {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockParagraph" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockParagraph }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockParagraph {}


impl PageBlockParagraph {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A preformatted text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPreformatted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPreformatted
  /// Paragraph text.
  text: Option<Box<RichText>>,
  /// Programming language for which the text should be formatted.
  language: Option<String>,
  
}


impl Clone for PageBlockPreformatted {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockPreformatted {}
impl RObject for PageBlockPreformatted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPreformatted" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPreformatted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockPreformatted {}


impl PageBlockPreformatted {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn language(&self) -> Option<String> { self.language.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The footer of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockFooter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockFooter
  /// Footer.
  footer: Option<Box<RichText>>,
  
}


impl Clone for PageBlockFooter {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockFooter {}
impl RObject for PageBlockFooter {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockFooter" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockFooter }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockFooter {}


impl PageBlockFooter {
  
  pub fn footer(&self) -> Option<Box<RichText>> { self.footer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An empty block separating a page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockDivider {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockDivider
  
}



impl Object for PageBlockDivider {}
impl RObject for PageBlockDivider {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockDivider" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockDivider }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockDivider {}


impl PageBlockDivider {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAnchor
  /// Name of the anchor.
  name: Option<String>,
  
}



impl Object for PageBlockAnchor {}
impl RObject for PageBlockAnchor {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAnchor" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAnchor }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockAnchor {}


impl PageBlockAnchor {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A list of data blocks. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockList {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockList
  /// The items of the list.
  items: Option<Vec<PageBlockListItem>>,
  
}



impl Object for PageBlockList {}
impl RObject for PageBlockList {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockList" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockList }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockList {}


impl PageBlockList {
  
  pub fn items(&self) -> Option<Vec<PageBlockListItem>> { self.items.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A block quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockBlockQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockBlockQuote
  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockBlockQuote {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockBlockQuote {}
impl RObject for PageBlockBlockQuote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockBlockQuote" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockBlockQuote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockBlockQuote {}


impl PageBlockBlockQuote {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A pull quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPullQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPullQuote
  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockPullQuote {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockPullQuote {}
impl RObject for PageBlockPullQuote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPullQuote" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPullQuote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockPullQuote {}


impl PageBlockPullQuote {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAnimation
  /// Animation file; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<PageBlockCaption>,
  /// True, if the animation should be played automatically.
  need_autoplay: Option<bool>,
  
}



impl Object for PageBlockAnimation {}
impl RObject for PageBlockAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAnimation" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockAnimation {}


impl PageBlockAnimation {
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn need_autoplay(&self) -> Option<bool> { self.need_autoplay.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockAudio
  /// Audio file; may be null.
  audio: Option<Audio>,
  /// Audio file caption.
  caption: Option<PageBlockCaption>,
  
}



impl Object for PageBlockAudio {}
impl RObject for PageBlockAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockAudio" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockAudio {}


impl PageBlockAudio {
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockPhoto
  /// Photo file; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<PageBlockCaption>,
  /// URL that needs to be opened when the photo is clicked.
  url: Option<String>,
  
}



impl Object for PageBlockPhoto {}
impl RObject for PageBlockPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockPhoto" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockPhoto {}


impl PageBlockPhoto {
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVideo
  /// Video file; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<PageBlockCaption>,
  /// True, if the video should be played automatically.
  need_autoplay: Option<bool>,
  /// True, if the video should be looped.
  is_looped: Option<bool>,
  
}



impl Object for PageBlockVideo {}
impl RObject for PageBlockVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVideo" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockVideo {}


impl PageBlockVideo {
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn need_autoplay(&self) -> Option<bool> { self.need_autoplay.clone() }
  
  pub fn is_looped(&self) -> Option<bool> { self.is_looped.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A page cover. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCover {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCover
  /// Cover.
  cover: Option<Box<PageBlock>>,
  
}


impl Clone for PageBlockCover {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockCover {}
impl RObject for PageBlockCover {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCover" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCover }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockCover {}


impl PageBlockCover {
  
  pub fn cover(&self) -> Option<Box<PageBlock>> { self.cover.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An embedded web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockEmbedded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockEmbedded
  /// Web page URL, if available.
  url: Option<String>,
  /// HTML-markup of the embedded page.
  html: Option<String>,
  /// Poster photo, if available; may be null.
  poster_photo: Option<Photo>,
  /// Block width, 0 if unknown.
  width: Option<i32>,
  /// Block height, 0 if unknown.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  /// True, if the block should be full width.
  is_full_width: Option<bool>,
  /// True, if scrolling should be allowed.
  allow_scrolling: Option<bool>,
  
}



impl Object for PageBlockEmbedded {}
impl RObject for PageBlockEmbedded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockEmbedded" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockEmbedded }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockEmbedded {}


impl PageBlockEmbedded {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn html(&self) -> Option<String> { self.html.clone() }
  
  pub fn poster_photo(&self) -> Option<Photo> { self.poster_photo.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn is_full_width(&self) -> Option<bool> { self.is_full_width.clone() }
  
  pub fn allow_scrolling(&self) -> Option<bool> { self.allow_scrolling.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An embedded post. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockEmbeddedPost {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockEmbeddedPost
  /// Web page URL.
  url: Option<String>,
  /// Post author.
  author: Option<String>,
  /// Post author photo.
  author_photo: Option<Photo>,
  /// Point in time (Unix timestamp) when the post was created; 0 if unknown.
  date: Option<i32>,
  /// Post content.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Post caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockEmbeddedPost {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockEmbeddedPost {}
impl RObject for PageBlockEmbeddedPost {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockEmbeddedPost" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockEmbeddedPost }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockEmbeddedPost {}


impl PageBlockEmbeddedPost {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn author_photo(&self) -> Option<Photo> { self.author_photo.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A collage. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCollage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCollage
  /// Collage item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockCollage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockCollage {}
impl RObject for PageBlockCollage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCollage" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCollage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockCollage {}


impl PageBlockCollage {
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A slideshow. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSlideshow {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockSlideshow
  /// Slideshow item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}


impl Clone for PageBlockSlideshow {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockSlideshow {}
impl RObject for PageBlockSlideshow {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockSlideshow" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockSlideshow }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockSlideshow {}


impl PageBlockSlideshow {
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A link to a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockChatLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockChatLink
  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Chat username, by which all other information about the chat should be resolved.
  username: Option<String>,
  
}



impl Object for PageBlockChatLink {}
impl RObject for PageBlockChatLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockChatLink" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockChatLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockChatLink {}


impl PageBlockChatLink {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTable
  /// Table caption.
  caption: Option<Box<RichText>>,
  /// Table cells.
  cells: Option<Vec<Vec<PageBlockTableCell>>>,
  /// True, if the table is bordered.
  is_bordered: Option<bool>,
  /// True, if the table is striped.
  is_striped: Option<bool>,
  
}


impl Clone for PageBlockTable {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockTable {}
impl RObject for PageBlockTable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTable" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTable }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockTable {}


impl PageBlockTable {
  
  pub fn caption(&self) -> Option<Box<RichText>> { self.caption.clone() }
  
  pub fn cells(&self) -> Option<Vec<Vec<PageBlockTableCell>>> { self.cells.clone() }
  
  pub fn is_bordered(&self) -> Option<bool> { self.is_bordered.clone() }
  
  pub fn is_striped(&self) -> Option<bool> { self.is_striped.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A collapsible block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockDetails
  /// Always visible heading for the block.
  header: Option<Box<RichText>>,
  /// Block contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// True, if the block is open by default.
  is_open: Option<bool>,
  
}


impl Clone for PageBlockDetails {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockDetails {}
impl RObject for PageBlockDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockDetails" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockDetails }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockDetails {}


impl PageBlockDetails {
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn is_open(&self) -> Option<bool> { self.is_open.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Related articles. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockRelatedArticles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockRelatedArticles
  /// Block header.
  header: Option<Box<RichText>>,
  /// List of related articles.
  articles: Option<Vec<PageBlockRelatedArticle>>,
  
}


impl Clone for PageBlockRelatedArticles {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockRelatedArticles {}
impl RObject for PageBlockRelatedArticles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockRelatedArticles" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockRelatedArticles }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockRelatedArticles {}


impl PageBlockRelatedArticles {
  
  pub fn header(&self) -> Option<Box<RichText>> { self.header.clone() }
  
  pub fn articles(&self) -> Option<Vec<PageBlockRelatedArticle>> { self.articles.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockMap {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockMap
  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level.
  zoom: Option<i32>,
  /// Map width.
  width: Option<i32>,
  /// Map height.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  
}



impl Object for PageBlockMap {}
impl RObject for PageBlockMap {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockMap" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockMap }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlock for PageBlockMap {}


impl PageBlockMap {
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn zoom(&self) -> Option<i32> { self.zoom.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn caption(&self) -> Option<PageBlockCaption> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a caption of an instant view web page block, consisting of a text and a trailing credit. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockCaption
  /// Content of the caption.
  text: Option<Box<RichText>>,
  /// Block credit (like HTML tag <cite>).
  credit: Option<Box<RichText>>,
  
}


impl Clone for PageBlockCaption {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockCaption {}
impl RObject for PageBlockCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockCaption" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockCaption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PageBlockCaption {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn credit(&self) -> Option<Box<RichText>> { self.credit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a horizontal alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockHorizontalAlignment: Object + RObject + Debug {}






impl PageBlockHorizontalAlignment {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PageBlockHorizontalAlignment> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockHorizontalAlignmentType {
  PageBlockHorizontalAlignmentCenter,
  PageBlockHorizontalAlignmentLeft,
  PageBlockHorizontalAlignmentRight,
  
}
impl RTDPageBlockHorizontalAlignmentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPageBlockHorizontalAlignmentType)(text.as_ref()) }
}



/// The content should be left-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentLeft
  
}



impl Object for PageBlockHorizontalAlignmentLeft {}
impl RObject for PageBlockHorizontalAlignmentLeft {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentLeft" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentLeft }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentLeft {}


impl PageBlockHorizontalAlignmentLeft {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The content should be center-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentCenter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentCenter
  
}



impl Object for PageBlockHorizontalAlignmentCenter {}
impl RObject for PageBlockHorizontalAlignmentCenter {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentCenter" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentCenter }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentCenter {}


impl PageBlockHorizontalAlignmentCenter {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The content should be right-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentRight {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockHorizontalAlignmentRight
  
}



impl Object for PageBlockHorizontalAlignmentRight {}
impl RObject for PageBlockHorizontalAlignmentRight {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockHorizontalAlignmentRight" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockHorizontalAlignmentRight }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentRight {}


impl PageBlockHorizontalAlignmentRight {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes an item of a list page block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockListItem {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockListItem
  /// Item label.
  label: Option<String>,
  /// Item blocks.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  
}


impl Clone for PageBlockListItem {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockListItem {}
impl RObject for PageBlockListItem {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockListItem" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockListItem }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PageBlockListItem {
  
  pub fn label(&self) -> Option<String> { self.label.clone() }
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a related article. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockRelatedArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockRelatedArticle
  /// Related article URL.
  url: Option<String>,
  /// Article title; may be empty.
  title: Option<String>,
  /// Article description; may be empty.
  description: Option<String>,
  /// Article photo; may be null.
  photo: Option<Photo>,
  /// Article author; may be empty.
  author: Option<String>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,
  
}



impl Object for PageBlockRelatedArticle {}
impl RObject for PageBlockRelatedArticle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockRelatedArticle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockRelatedArticle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PageBlockRelatedArticle {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn publish_date(&self) -> Option<i32> { self.publish_date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a cell of a table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTableCell {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockTableCell
  /// Cell text.
  text: Option<Box<RichText>>,
  /// True, if it is a header cell.
  is_header: Option<bool>,
  /// The number of columns the cell should span.
  colspan: Option<i32>,
  /// The number of rows the cell should span.
  rowspan: Option<i32>,
  /// Horizontal cell content alignment.
  align: Option<Box<PageBlockHorizontalAlignment>>,
  /// Vertical cell content alignment.
  valign: Option<Box<PageBlockVerticalAlignment>>,
  
}


impl Clone for PageBlockTableCell {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PageBlockTableCell {}
impl RObject for PageBlockTableCell {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockTableCell" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockTableCell }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PageBlockTableCell {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn is_header(&self) -> Option<bool> { self.is_header.clone() }
  
  pub fn colspan(&self) -> Option<i32> { self.colspan.clone() }
  
  pub fn rowspan(&self) -> Option<i32> { self.rowspan.clone() }
  
  pub fn align(&self) -> Option<Box<PageBlockHorizontalAlignment>> { self.align.clone() }
  
  pub fn valign(&self) -> Option<Box<PageBlockVerticalAlignment>> { self.valign.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a Vertical alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockVerticalAlignment: Object + RObject + Debug {}






impl PageBlockVerticalAlignment {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PageBlockVerticalAlignment> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPageBlockVerticalAlignmentType {
  PageBlockVerticalAlignmentBottom,
  PageBlockVerticalAlignmentMiddle,
  PageBlockVerticalAlignmentTop,
  
}
impl RTDPageBlockVerticalAlignmentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPageBlockVerticalAlignmentType)(text.as_ref()) }
}



/// The content should be top-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentTop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentTop
  
}



impl Object for PageBlockVerticalAlignmentTop {}
impl RObject for PageBlockVerticalAlignmentTop {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentTop" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentTop }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentTop {}


impl PageBlockVerticalAlignmentTop {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The content should be middle-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentMiddle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentMiddle
  
}



impl Object for PageBlockVerticalAlignmentMiddle {}
impl RObject for PageBlockVerticalAlignmentMiddle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentMiddle" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentMiddle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentMiddle {}


impl PageBlockVerticalAlignmentMiddle {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The content should be bottom-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentBottom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pageBlockVerticalAlignmentBottom
  
}



impl Object for PageBlockVerticalAlignmentBottom {}
impl RObject for PageBlockVerticalAlignmentBottom {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pageBlockVerticalAlignmentBottom" }
  fn td_type(&self) -> RTDType { RTDType::PageBlockVerticalAlignmentBottom }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentBottom {}


impl PageBlockVerticalAlignmentBottom {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a Telegram Passport authorization form that was requested. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportAuthorizationForm
  /// Unique identifier of the authorization form.
  id: Option<i32>,
  /// Information about the Telegram Passport elements that need to be provided to complete the form.
  required_elements: Option<Vec<PassportRequiredElement>>,
  /// URL for the privacy policy of the service; may be empty.
  privacy_policy_url: Option<String>,
  
}



impl Object for PassportAuthorizationForm {}
impl RObject for PassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::PassportAuthorizationForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportAuthorizationForm {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn required_elements(&self) -> Option<Vec<PassportRequiredElement>> { self.required_elements.clone() }
  
  pub fn privacy_policy_url(&self) -> Option<String> { self.privacy_policy_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains information about a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElement: Object + RObject + Debug {}






impl PassportElement {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PassportElement> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementType {
  PassportElementAddress,
  PassportElementBankStatement,
  PassportElementDriverLicense,
  PassportElementEmailAddress,
  PassportElementIdentityCard,
  PassportElementInternalPassport,
  PassportElementPassport,
  PassportElementPassportRegistration,
  PassportElementPersonalDetails,
  PassportElementPhoneNumber,
  PassportElementRentalAgreement,
  PassportElementTemporaryRegistration,
  PassportElementUtilityBill,
  
}
impl RTDPassportElementType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPassportElementType)(text.as_ref()) }
}



/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPersonalDetails
  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,
  
}



impl Object for PassportElementPersonalDetails {}
impl RObject for PassportElementPersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPersonalDetails }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementPersonalDetails {}


impl PassportElementPersonalDetails {
  
  pub fn personal_details(&self) -> Option<PersonalDetails> { self.personal_details.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPassport
  /// Passport.
  passport: Option<IdentityDocument>,
  
}



impl Object for PassportElementPassport {}
impl RObject for PassportElementPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementPassport {}


impl PassportElementPassport {
  
  pub fn passport(&self) -> Option<IdentityDocument> { self.passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementDriverLicense
  /// Driver license.
  driver_license: Option<IdentityDocument>,
  
}



impl Object for PassportElementDriverLicense {}
impl RObject for PassportElementDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementDriverLicense }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementDriverLicense {}


impl PassportElementDriverLicense {
  
  pub fn driver_license(&self) -> Option<IdentityDocument> { self.driver_license.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementIdentityCard
  /// Identity card.
  identity_card: Option<IdentityDocument>,
  
}



impl Object for PassportElementIdentityCard {}
impl RObject for PassportElementIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementIdentityCard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementIdentityCard {}


impl PassportElementIdentityCard {
  
  pub fn identity_card(&self) -> Option<IdentityDocument> { self.identity_card.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementInternalPassport
  /// Internal passport.
  internal_passport: Option<IdentityDocument>,
  
}



impl Object for PassportElementInternalPassport {}
impl RObject for PassportElementInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementInternalPassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementInternalPassport {}


impl PassportElementInternalPassport {
  
  pub fn internal_passport(&self) -> Option<IdentityDocument> { self.internal_passport.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementAddress
  /// Address.
  address: Option<Address>,
  
}



impl Object for PassportElementAddress {}
impl RObject for PassportElementAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementAddress {}


impl PassportElementAddress {
  
  pub fn address(&self) -> Option<Address> { self.address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementUtilityBill
  /// Utility bill.
  utility_bill: Option<PersonalDocument>,
  
}



impl Object for PassportElementUtilityBill {}
impl RObject for PassportElementUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementUtilityBill }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementUtilityBill {}


impl PassportElementUtilityBill {
  
  pub fn utility_bill(&self) -> Option<PersonalDocument> { self.utility_bill.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementBankStatement
  /// Bank statement.
  bank_statement: Option<PersonalDocument>,
  
}



impl Object for PassportElementBankStatement {}
impl RObject for PassportElementBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementBankStatement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementBankStatement {}


impl PassportElementBankStatement {
  
  pub fn bank_statement(&self) -> Option<PersonalDocument> { self.bank_statement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementRentalAgreement
  /// Rental agreement.
  rental_agreement: Option<PersonalDocument>,
  
}



impl Object for PassportElementRentalAgreement {}
impl RObject for PassportElementRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementRentalAgreement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementRentalAgreement {}


impl PassportElementRentalAgreement {
  
  pub fn rental_agreement(&self) -> Option<PersonalDocument> { self.rental_agreement.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's passport registration pages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPassportRegistration
  /// Passport registration pages.
  passport_registration: Option<PersonalDocument>,
  
}



impl Object for PassportElementPassportRegistration {}
impl RObject for PassportElementPassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPassportRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementPassportRegistration {}


impl PassportElementPassportRegistration {
  
  pub fn passport_registration(&self) -> Option<PersonalDocument> { self.passport_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTemporaryRegistration
  /// Temporary registration.
  temporary_registration: Option<PersonalDocument>,
  
}



impl Object for PassportElementTemporaryRegistration {}
impl RObject for PassportElementTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTemporaryRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementTemporaryRegistration {}


impl PassportElementTemporaryRegistration {
  
  pub fn temporary_registration(&self) -> Option<PersonalDocument> { self.temporary_registration.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementPhoneNumber
  /// Phone number.
  phone_number: Option<String>,
  
}



impl Object for PassportElementPhoneNumber {}
impl RObject for PassportElementPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementPhoneNumber {}


impl PassportElementPhoneNumber {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementEmailAddress
  /// Email address.
  email_address: Option<String>,
  
}



impl Object for PassportElementEmailAddress {}
impl RObject for PassportElementEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElement for PassportElementEmailAddress {}


impl PassportElementEmailAddress {
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the description of an error in a Telegram Passport element. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementError
  /// Type of the Telegram Passport element which has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<PassportElementErrorSource>>,
  
}


impl Clone for PassportElementError {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PassportElementError {}
impl RObject for PassportElementError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementError" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementError }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportElementError {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn message(&self) -> Option<String> { self.message.clone() }
  
  pub fn source(&self) -> Option<Box<PassportElementErrorSource>> { self.source.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementErrorSource: Object + RObject + Debug {}






impl PassportElementErrorSource {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PassportElementErrorSource> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementErrorSourceType {
  PassportElementErrorSourceDataField,
  PassportElementErrorSourceFile,
  PassportElementErrorSourceFiles,
  PassportElementErrorSourceFrontSide,
  PassportElementErrorSourceReverseSide,
  PassportElementErrorSourceSelfie,
  PassportElementErrorSourceTranslationFile,
  PassportElementErrorSourceTranslationFiles,
  PassportElementErrorSourceUnspecified,
  
}
impl RTDPassportElementErrorSourceType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPassportElementErrorSourceType)(text.as_ref()) }
}



/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceUnspecified
  
}



impl Object for PassportElementErrorSourceUnspecified {}
impl RObject for PassportElementErrorSourceUnspecified {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceUnspecified" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceUnspecified }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceUnspecified {}


impl PassportElementErrorSourceUnspecified {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// One of the data fields contains an error. The error will be considered resolved when the value of the field changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceDataField
  /// Field name.
  field_name: Option<String>,
  
}



impl Object for PassportElementErrorSourceDataField {}
impl RObject for PassportElementErrorSourceDataField {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceDataField" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceDataField }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceDataField {}


impl PassportElementErrorSourceDataField {
  
  pub fn field_name(&self) -> Option<String> { self.field_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFrontSide
  
}



impl Object for PassportElementErrorSourceFrontSide {}
impl RObject for PassportElementErrorSourceFrontSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFrontSide" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFrontSide }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFrontSide {}


impl PassportElementErrorSourceFrontSide {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceReverseSide
  
}



impl Object for PassportElementErrorSourceReverseSide {}
impl RObject for PassportElementErrorSourceReverseSide {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceReverseSide" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceReverseSide }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceReverseSide {}


impl PassportElementErrorSourceReverseSide {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceSelfie
  
}



impl Object for PassportElementErrorSourceSelfie {}
impl RObject for PassportElementErrorSourceSelfie {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceSelfie" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceSelfie }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceSelfie {}


impl PassportElementErrorSourceSelfie {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceTranslationFile
  /// Index of a file with the error.
  file_index: Option<i32>,
  
}



impl Object for PassportElementErrorSourceTranslationFile {}
impl RObject for PassportElementErrorSourceTranslationFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceTranslationFile" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceTranslationFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceTranslationFile {}


impl PassportElementErrorSourceTranslationFile {
  
  pub fn file_index(&self) -> Option<i32> { self.file_index.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceTranslationFiles
  
}



impl Object for PassportElementErrorSourceTranslationFiles {}
impl RObject for PassportElementErrorSourceTranslationFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceTranslationFiles" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceTranslationFiles }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceTranslationFiles {}


impl PassportElementErrorSourceTranslationFiles {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFile
  /// Index of a file with the error.
  file_index: Option<i32>,
  
}



impl Object for PassportElementErrorSourceFile {}
impl RObject for PassportElementErrorSourceFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFile" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFile {}


impl PassportElementErrorSourceFile {
  
  pub fn file_index(&self) -> Option<i32> { self.file_index.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of attached files contains an error. The error will be considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementErrorSourceFiles
  
}



impl Object for PassportElementErrorSourceFiles {}
impl RObject for PassportElementErrorSourceFiles {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementErrorSourceFiles" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementErrorSourceFiles }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementErrorSource for PassportElementErrorSourceFiles {}


impl PassportElementErrorSourceFiles {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains the type of a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementType: Object + RObject + Debug {}






impl PassportElementType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PassportElementType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPassportElementTypeType {
  PassportElementTypeAddress,
  PassportElementTypeBankStatement,
  PassportElementTypeDriverLicense,
  PassportElementTypeEmailAddress,
  PassportElementTypeIdentityCard,
  PassportElementTypeInternalPassport,
  PassportElementTypePassport,
  PassportElementTypePassportRegistration,
  PassportElementTypePersonalDetails,
  PassportElementTypePhoneNumber,
  PassportElementTypeRentalAgreement,
  PassportElementTypeTemporaryRegistration,
  PassportElementTypeUtilityBill,
  
}
impl RTDPassportElementTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPassportElementTypeType)(text.as_ref()) }
}



/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePersonalDetails
  
}



impl Object for PassportElementTypePersonalDetails {}
impl RObject for PassportElementTypePersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePersonalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePersonalDetails }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePersonalDetails {}


impl PassportElementTypePersonalDetails {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePassport
  
}



impl Object for PassportElementTypePassport {}
impl RObject for PassportElementTypePassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePassport {}


impl PassportElementTypePassport {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeDriverLicense
  
}



impl Object for PassportElementTypeDriverLicense {}
impl RObject for PassportElementTypeDriverLicense {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeDriverLicense" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeDriverLicense }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeDriverLicense {}


impl PassportElementTypeDriverLicense {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeIdentityCard
  
}



impl Object for PassportElementTypeIdentityCard {}
impl RObject for PassportElementTypeIdentityCard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeIdentityCard" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeIdentityCard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeIdentityCard {}


impl PassportElementTypeIdentityCard {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeInternalPassport
  
}



impl Object for PassportElementTypeInternalPassport {}
impl RObject for PassportElementTypeInternalPassport {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeInternalPassport" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeInternalPassport }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeInternalPassport {}


impl PassportElementTypeInternalPassport {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeAddress
  
}



impl Object for PassportElementTypeAddress {}
impl RObject for PassportElementTypeAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeAddress {}


impl PassportElementTypeAddress {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeUtilityBill
  
}



impl Object for PassportElementTypeUtilityBill {}
impl RObject for PassportElementTypeUtilityBill {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeUtilityBill" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeUtilityBill }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeUtilityBill {}


impl PassportElementTypeUtilityBill {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeBankStatement
  
}



impl Object for PassportElementTypeBankStatement {}
impl RObject for PassportElementTypeBankStatement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeBankStatement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeBankStatement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeBankStatement {}


impl PassportElementTypeBankStatement {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeRentalAgreement
  
}



impl Object for PassportElementTypeRentalAgreement {}
impl RObject for PassportElementTypeRentalAgreement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeRentalAgreement" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeRentalAgreement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeRentalAgreement {}


impl PassportElementTypeRentalAgreement {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the registration page of the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePassportRegistration
  
}



impl Object for PassportElementTypePassportRegistration {}
impl RObject for PassportElementTypePassportRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePassportRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePassportRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePassportRegistration {}


impl PassportElementTypePassportRegistration {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeTemporaryRegistration
  
}



impl Object for PassportElementTypeTemporaryRegistration {}
impl RObject for PassportElementTypeTemporaryRegistration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeTemporaryRegistration" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeTemporaryRegistration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeTemporaryRegistration {}


impl PassportElementTypeTemporaryRegistration {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypePhoneNumber
  
}



impl Object for PassportElementTypePhoneNumber {}
impl RObject for PassportElementTypePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypePhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypePhoneNumber {}


impl PassportElementTypePhoneNumber {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementTypeEmailAddress
  
}



impl Object for PassportElementTypeEmailAddress {}
impl RObject for PassportElementTypeEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementTypeEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementTypeEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PassportElementType for PassportElementTypeEmailAddress {}


impl PassportElementTypeEmailAddress {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about saved Telegram Passport elements. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElements
  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,
  
}


impl Clone for PassportElements {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PassportElements {}
impl RObject for PassportElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElements" }
  fn td_type(&self) -> RTDType { RTDType::PassportElements }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportElements {
  
  pub fn elements(&self) -> Option<Vec<Box<PassportElement>>> { self.elements.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a Telegram Passport elements and corresponding errors. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementsWithErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportElementsWithErrors
  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,
  /// Errors in the elements that are already available.
  errors: Option<Vec<PassportElementError>>,
  
}


impl Clone for PassportElementsWithErrors {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PassportElementsWithErrors {}
impl RObject for PassportElementsWithErrors {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportElementsWithErrors" }
  fn td_type(&self) -> RTDType { RTDType::PassportElementsWithErrors }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportElementsWithErrors {
  
  pub fn elements(&self) -> Option<Vec<Box<PassportElement>>> { self.elements.clone() }
  
  pub fn errors(&self) -> Option<Vec<PassportElementError>> { self.errors.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a description of the required Telegram Passport element that was requested by a service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportRequiredElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportRequiredElement
  /// List of Telegram Passport elements any of which is enough to provide.
  suitable_elements: Option<Vec<PassportSuitableElement>>,
  
}



impl Object for PassportRequiredElement {}
impl RObject for PassportRequiredElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportRequiredElement" }
  fn td_type(&self) -> RTDType { RTDType::PassportRequiredElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportRequiredElement {
  
  pub fn suitable_elements(&self) -> Option<Vec<PassportSuitableElement>> { self.suitable_elements.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a Telegram Passport element that was requested by a service. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportSuitableElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passportSuitableElement
  /// Type of the element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// True, if a selfie is required with the identity document.
  is_selfie_required: Option<bool>,
  /// True, if a certified English translation is required with the document.
  is_translation_required: Option<bool>,
  /// True, if personal details must include the user's name in the language of their country of residence.
  is_native_name_required: Option<bool>,
  
}


impl Clone for PassportSuitableElement {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for PassportSuitableElement {}
impl RObject for PassportSuitableElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passportSuitableElement" }
  fn td_type(&self) -> RTDType { RTDType::PassportSuitableElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PassportSuitableElement {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn is_selfie_required(&self) -> Option<bool> { self.is_selfie_required.clone() }
  
  pub fn is_translation_required(&self) -> Option<bool> { self.is_translation_required.clone() }
  
  pub fn is_native_name_required(&self) -> Option<bool> { self.is_native_name_required.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents the current state of 2-step verification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // passwordState
  /// True, if a 2-step verification password is set.
  has_password: Option<bool>,
  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True, if a recovery email is set.
  has_recovery_email_address: Option<bool>,
  /// True, if some Telegram Passport elements were saved.
  has_passport_data: Option<bool>,
  /// Information about the recovery email address to which the confirmation email was sent; may be null.
  recovery_email_address_code_info: Option<EmailAddressAuthenticationCodeInfo>,
  
}



impl Object for PasswordState {}
impl RObject for PasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "passwordState" }
  fn td_type(&self) -> RTDType { RTDType::PasswordState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PasswordState {
  
  pub fn has_password(&self) -> Option<bool> { self.has_password.clone() }
  
  pub fn password_hint(&self) -> Option<String> { self.password_hint.clone() }
  
  pub fn has_recovery_email_address(&self) -> Option<bool> { self.has_recovery_email_address.clone() }
  
  pub fn has_passport_data(&self) -> Option<bool> { self.has_passport_data.clone() }
  
  pub fn recovery_email_address_code_info(&self) -> Option<EmailAddressAuthenticationCodeInfo> { self.recovery_email_address_code_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about an invoice payment form. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentForm
  /// Full information of the invoice.
  invoice: Option<Invoice>,
  /// Payment form URL.
  url: Option<String>,
  /// Contains information about the payment provider, if available, to support it natively without the need for opening the URL; may be null.
  payments_provider: Option<PaymentsProviderStripe>,
  /// Saved server-side order information; may be null.
  saved_order_info: Option<OrderInfo>,
  /// Contains information about saved card credentials; may be null.
  saved_credentials: Option<SavedCredentials>,
  /// True, if the user can choose to save credentials.
  can_save_credentials: Option<bool>,
  /// True, if the user will be able to save credentials protected by a password they set up.
  need_password: Option<bool>,
  
}



impl Object for PaymentForm {}
impl RObject for PaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentForm" }
  fn td_type(&self) -> RTDType { RTDType::PaymentForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PaymentForm {
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn payments_provider(&self) -> Option<PaymentsProviderStripe> { self.payments_provider.clone() }
  
  pub fn saved_order_info(&self) -> Option<OrderInfo> { self.saved_order_info.clone() }
  
  pub fn saved_credentials(&self) -> Option<SavedCredentials> { self.saved_credentials.clone() }
  
  pub fn can_save_credentials(&self) -> Option<bool> { self.can_save_credentials.clone() }
  
  pub fn need_password(&self) -> Option<bool> { self.need_password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a successful payment. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentReceipt
  /// Point in time (Unix timestamp) when the payment was made.
  date: Option<i32>,
  /// User identifier of the payment provider bot.
  payments_provider_user_id: Option<i32>,
  /// Contains information about the invoice.
  invoice: Option<Invoice>,
  /// Contains order information; may be null.
  order_info: Option<OrderInfo>,
  /// Chosen shipping option; may be null.
  shipping_option: Option<ShippingOption>,
  /// Title of the saved credentials.
  credentials_title: Option<String>,
  
}



impl Object for PaymentReceipt {}
impl RObject for PaymentReceipt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentReceipt" }
  fn td_type(&self) -> RTDType { RTDType::PaymentReceipt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PaymentReceipt {
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn payments_provider_user_id(&self) -> Option<i32> { self.payments_provider_user_id.clone() }
  
  pub fn invoice(&self) -> Option<Invoice> { self.invoice.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn shipping_option(&self) -> Option<ShippingOption> { self.shipping_option.clone() }
  
  pub fn credentials_title(&self) -> Option<String> { self.credentials_title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the result of a payment request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentResult
  /// True, if the payment request was successful; otherwise the verification_url will be not empty.
  success: Option<bool>,
  /// URL for additional payment credentials verification.
  verification_url: Option<String>,
  
}



impl Object for PaymentResult {}
impl RObject for PaymentResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentResult" }
  fn td_type(&self) -> RTDType { RTDType::PaymentResult }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PaymentResult {
  
  pub fn success(&self) -> Option<bool> { self.success.clone() }
  
  pub fn verification_url(&self) -> Option<String> { self.verification_url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Stripe payment provider. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentsProviderStripe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // paymentsProviderStripe
  /// Stripe API publishable key.
  publishable_key: Option<String>,
  /// True, if the user country must be provided.
  need_country: Option<bool>,
  /// True, if the user ZIP/postal code must be provided.
  need_postal_code: Option<bool>,
  /// True, if the cardholder name must be provided.
  need_cardholder_name: Option<bool>,
  
}



impl Object for PaymentsProviderStripe {}
impl RObject for PaymentsProviderStripe {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "paymentsProviderStripe" }
  fn td_type(&self) -> RTDType { RTDType::PaymentsProviderStripe }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PaymentsProviderStripe {
  
  pub fn publishable_key(&self) -> Option<String> { self.publishable_key.clone() }
  
  pub fn need_country(&self) -> Option<bool> { self.need_country.clone() }
  
  pub fn need_postal_code(&self) -> Option<bool> { self.need_postal_code.clone() }
  
  pub fn need_cardholder_name(&self) -> Option<bool> { self.need_cardholder_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // personalDetails
  /// First name of the user written in English; 1-255 characters.
  first_name: Option<String>,
  /// Middle name of the user written in English; 0-255 characters.
  middle_name: Option<String>,
  /// Last name of the user written in English; 1-255 characters.
  last_name: Option<String>,
  /// Native first name of the user; 1-255 characters.
  native_first_name: Option<String>,
  /// Native middle name of the user; 0-255 characters.
  native_middle_name: Option<String>,
  /// Native last name of the user; 1-255 characters.
  native_last_name: Option<String>,
  /// Birthdate of the user.
  birthdate: Option<Date>,
  /// Gender of the user, "male" or "female".
  gender: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's country.
  country_code: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country.
  residence_country_code: Option<String>,
  
}



impl Object for PersonalDetails {}
impl RObject for PersonalDetails {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "personalDetails" }
  fn td_type(&self) -> RTDType { RTDType::PersonalDetails }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PersonalDetails {
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn middle_name(&self) -> Option<String> { self.middle_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn native_first_name(&self) -> Option<String> { self.native_first_name.clone() }
  
  pub fn native_middle_name(&self) -> Option<String> { self.native_middle_name.clone() }
  
  pub fn native_last_name(&self) -> Option<String> { self.native_last_name.clone() }
  
  pub fn birthdate(&self) -> Option<Date> { self.birthdate.clone() }
  
  pub fn gender(&self) -> Option<String> { self.gender.clone() }
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn residence_country_code(&self) -> Option<String> { self.residence_country_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A personal document, containing some information about a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // personalDocument
  /// List of files containing the pages of the document.
  files: Option<Vec<DatedFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  
}



impl Object for PersonalDocument {}
impl RObject for PersonalDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "personalDocument" }
  fn td_type(&self) -> RTDType { RTDType::PersonalDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PersonalDocument {
  
  pub fn files(&self) -> Option<Vec<DatedFile>> { self.files.clone() }
  
  pub fn translation(&self) -> Option<Vec<DatedFile>> { self.translation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Photo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // photo
  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// Available variants of the photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,
  
}



impl Object for Photo {}
impl RObject for Photo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "photo" }
  fn td_type(&self) -> RTDType { RTDType::Photo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Photo {
  
  pub fn has_stickers(&self) -> Option<bool> { self.has_stickers.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Photo description. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhotoSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // photoSize
  /// Thumbnail type (see https://core.telegram.org/constructor/photoSize).
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Information about the photo file.
  photo: Option<File>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,
  
}



impl Object for PhotoSize {}
impl RObject for PhotoSize {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "photoSize" }
  fn td_type(&self) -> RTDType { RTDType::PhotoSize }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PhotoSize {
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn photo(&self) -> Option<File> { self.photo.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Poll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // poll
  /// Unique poll identifier.
  id: Option<i64>,
  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options.
  options: Option<Vec<PollOption>>,
  /// Total number of voters, participating in the poll.
  total_voter_count: Option<i32>,
  /// True, if the poll is closed.
  is_closed: Option<bool>,
  
}



impl Object for Poll {}
impl RObject for Poll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "poll" }
  fn td_type(&self) -> RTDType { RTDType::Poll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Poll {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn options(&self) -> Option<Vec<PollOption>> { self.options.clone() }
  
  pub fn total_voter_count(&self) -> Option<i32> { self.total_voter_count.clone() }
  
  pub fn is_closed(&self) -> Option<bool> { self.is_closed.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes one answer option of a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PollOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pollOption
  /// Option text, 1-100 characters.
  text: Option<String>,
  /// Number of voters for this option, available only for closed or voted polls.
  voter_count: Option<i32>,
  /// The percentage of votes for this option, 0-100.
  vote_percentage: Option<i32>,
  /// True, if the option was chosen by the user.
  is_chosen: Option<bool>,
  /// True, if the option is being chosen by a pending setPollAnswer request.
  is_being_chosen: Option<bool>,
  
}



impl Object for PollOption {}
impl RObject for PollOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pollOption" }
  fn td_type(&self) -> RTDType { RTDType::PollOption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PollOption {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn voter_count(&self) -> Option<i32> { self.voter_count.clone() }
  
  pub fn vote_percentage(&self) -> Option<i32> { self.vote_percentage.clone() }
  
  pub fn is_chosen(&self) -> Option<bool> { self.is_chosen.clone() }
  
  pub fn is_being_chosen(&self) -> Option<bool> { self.is_being_chosen.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // profilePhoto
  /// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of userProfilePhotos.
  id: Option<String>,
  /// A small (160x160) user profile photo.
  small: Option<File>,
  /// A big (640x640) user profile photo.
  big: Option<File>,
  
}



impl Object for ProfilePhoto {}
impl RObject for ProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "profilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::ProfilePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ProfilePhoto {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn small(&self) -> Option<File> { self.small.clone() }
  
  pub fn big(&self) -> Option<File> { self.big.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of proxy servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxies
  /// List of proxy servers.
  proxies: Option<Vec<Proxy>>,
  
}



impl Object for Proxies {}
impl RObject for Proxies {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxies" }
  fn td_type(&self) -> RTDType { RTDType::Proxies }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Proxies {
  
  pub fn proxies(&self) -> Option<Vec<Proxy>> { self.proxies.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a proxy server. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Proxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxy
  /// Unique identifier of the proxy.
  id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// Point in time (Unix timestamp) when the proxy was last used; 0 if never.
  last_used_date: Option<i32>,
  /// True, if the proxy is enabled now.
  is_enabled: Option<bool>,
  /// Type of the proxy.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for Proxy {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Proxy {}
impl RObject for Proxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxy" }
  fn td_type(&self) -> RTDType { RTDType::Proxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Proxy {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn last_used_date(&self) -> Option<i32> { self.last_used_date.clone() }
  
  pub fn is_enabled(&self) -> Option<bool> { self.is_enabled.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the type of the proxy server. 
#[typetag::serde(tag = "@struct")]
pub trait ProxyType: Object + RObject + Debug {}






impl ProxyType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ProxyType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDProxyTypeType {
  ProxyTypeHttp,
  ProxyTypeMtproto,
  ProxyTypeSocks5,
  
}
impl RTDProxyTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDProxyTypeType)(text.as_ref()) }
}



/// A SOCKS5 proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeSocks5 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeSocks5
  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,
  
}



impl Object for ProxyTypeSocks5 {}
impl RObject for ProxyTypeSocks5 {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeSocks5" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeSocks5 }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ProxyType for ProxyTypeSocks5 {}


impl ProxyTypeSocks5 {
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A HTTP transparent proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeHttp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeHttp
  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,
  /// Pass true, if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method.
  http_only: Option<bool>,
  
}



impl Object for ProxyTypeHttp {}
impl RObject for ProxyTypeHttp {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeHttp" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeHttp }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ProxyType for ProxyTypeHttp {}


impl ProxyTypeHttp {
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn http_only(&self) -> Option<bool> { self.http_only.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An MTProto proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeMtproto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // proxyTypeMtproto
  /// The proxy's secret in hexadecimal encoding.
  secret: Option<String>,
  
}



impl Object for ProxyTypeMtproto {}
impl RObject for ProxyTypeMtproto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "proxyTypeMtproto" }
  fn td_type(&self) -> RTDType { RTDType::ProxyTypeMtproto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ProxyType for ProxyTypeMtproto {}


impl ProxyTypeMtproto {
  
  pub fn secret(&self) -> Option<String> { self.secret.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a public HTTPS link to a message in a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // publicMessageLink
  /// Message link.
  link: Option<String>,
  /// HTML-code for embedding the message.
  html: Option<String>,
  
}



impl Object for PublicMessageLink {}
impl RObject for PublicMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "publicMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::PublicMessageLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PublicMessageLink {
  
  pub fn link(&self) -> Option<String> { self.link.clone() }
  
  pub fn html(&self) -> Option<String> { self.html.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains content of a push message notification. 
#[typetag::serde(tag = "@struct")]
pub trait PushMessageContent: Object + RObject + Debug {}






impl PushMessageContent {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<PushMessageContent> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDPushMessageContentType {
  PushMessageContentAnimation,
  PushMessageContentAudio,
  PushMessageContentBasicGroupChatCreate,
  PushMessageContentChatAddMembers,
  PushMessageContentChatChangePhoto,
  PushMessageContentChatChangeTitle,
  PushMessageContentChatDeleteMember,
  PushMessageContentChatJoinByLink,
  PushMessageContentContact,
  PushMessageContentContactRegistered,
  PushMessageContentDocument,
  PushMessageContentGame,
  PushMessageContentGameScore,
  PushMessageContentHidden,
  PushMessageContentInvoice,
  PushMessageContentLocation,
  PushMessageContentMediaAlbum,
  PushMessageContentMessageForwards,
  PushMessageContentPhoto,
  PushMessageContentPoll,
  PushMessageContentScreenshotTaken,
  PushMessageContentSticker,
  PushMessageContentText,
  PushMessageContentVideo,
  PushMessageContentVideoNote,
  PushMessageContentVoiceNote,
  
}
impl RTDPushMessageContentType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDPushMessageContentType)(text.as_ref()) }
}



/// A general message with hidden content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentHidden {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentHidden
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentHidden {}
impl RObject for PushMessageContentHidden {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentHidden" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentHidden }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentHidden {}


impl PushMessageContentHidden {
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An animation message (GIF-style.) 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentAnimation
  /// Message content; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentAnimation {}
impl RObject for PushMessageContentAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentAnimation" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentAnimation {}


impl PushMessageContentAnimation {
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentAudio
  /// Message content; may be null.
  audio: Option<Audio>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentAudio {}
impl RObject for PushMessageContentAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentAudio" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentAudio {}


impl PushMessageContentAudio {
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentContact
  /// Contact's name.
  name: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentContact {}
impl RObject for PushMessageContentContact {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentContact" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentContact }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentContact {}


impl PushMessageContentContact {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentContactRegistered
  
}



impl Object for PushMessageContentContactRegistered {}
impl RObject for PushMessageContentContactRegistered {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentContactRegistered" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentContactRegistered }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentContactRegistered {}


impl PushMessageContentContactRegistered {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A document message (a general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentDocument
  /// Message content; may be null.
  document: Option<Document>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentDocument {}
impl RObject for PushMessageContentDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentDocument" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentDocument {}


impl PushMessageContentDocument {
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentGame
  /// Game title, empty for pinned game message.
  title: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentGame {}
impl RObject for PushMessageContentGame {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentGame" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentGame }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentGame {}


impl PushMessageContentGame {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentGameScore
  /// Game title, empty for pinned message.
  title: Option<String>,
  /// New score, 0 for pinned message.
  score: Option<i32>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentGameScore {}
impl RObject for PushMessageContentGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentGameScore" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentGameScore }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentGameScore {}


impl PushMessageContentGameScore {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentInvoice
  /// Product price.
  price: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentInvoice {}
impl RObject for PushMessageContentInvoice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentInvoice" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentInvoice }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentInvoice {}


impl PushMessageContentInvoice {
  
  pub fn price(&self) -> Option<String> { self.price.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentLocation
  /// True, if the location is live.
  is_live: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentLocation {}
impl RObject for PushMessageContentLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentLocation" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentLocation {}


impl PushMessageContentLocation {
  
  pub fn is_live(&self) -> Option<bool> { self.is_live.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentPhoto
  /// Message content; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<String>,
  /// True, if the photo is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentPhoto {}
impl RObject for PushMessageContentPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentPhoto" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentPhoto {}


impl PushMessageContentPhoto {
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentPoll
  /// Poll question.
  question: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentPoll {}
impl RObject for PushMessageContentPoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentPoll" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentPoll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentPoll {}


impl PushMessageContentPoll {
  
  pub fn question(&self) -> Option<String> { self.question.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentScreenshotTaken
  
}



impl Object for PushMessageContentScreenshotTaken {}
impl RObject for PushMessageContentScreenshotTaken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentScreenshotTaken" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentScreenshotTaken }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentScreenshotTaken {}


impl PushMessageContentScreenshotTaken {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentSticker
  /// Message content; may be null.
  sticker: Option<Sticker>,
  /// Emoji corresponding to the sticker; may be empty.
  emoji: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentSticker {}
impl RObject for PushMessageContentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentSticker" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentSticker {}


impl PushMessageContentSticker {
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentText
  /// Message text.
  text: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentText {}
impl RObject for PushMessageContentText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentText" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentText {}


impl PushMessageContentText {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVideo
  /// Message content; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<String>,
  /// True, if the video is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVideo {}
impl RObject for PushMessageContentVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVideo" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVideo {}


impl PushMessageContentVideo {
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn caption(&self) -> Option<String> { self.caption.clone() }
  
  pub fn is_secret(&self) -> Option<bool> { self.is_secret.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVideoNote
  /// Message content; may be null.
  video_note: Option<VideoNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVideoNote {}
impl RObject for PushMessageContentVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVideoNote {}


impl PushMessageContentVideoNote {
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentVoiceNote
  /// Message content; may be null.
  voice_note: Option<VoiceNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,
  
}



impl Object for PushMessageContentVoiceNote {}
impl RObject for PushMessageContentVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentVoiceNote {}


impl PushMessageContentVoiceNote {
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentBasicGroupChatCreate
  
}



impl Object for PushMessageContentBasicGroupChatCreate {}
impl RObject for PushMessageContentBasicGroupChatCreate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentBasicGroupChatCreate" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentBasicGroupChatCreate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentBasicGroupChatCreate {}


impl PushMessageContentBasicGroupChatCreate {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New chat members were invited to a group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatAddMembers
  /// Name of the added member.
  member_name: Option<String>,
  /// True, if the current user was added to the group.
  is_current_user: Option<bool>,
  /// True, if the user has returned to the group himself.
  is_returned: Option<bool>,
  
}



impl Object for PushMessageContentChatAddMembers {}
impl RObject for PushMessageContentChatAddMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatAddMembers" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatAddMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatAddMembers {}


impl PushMessageContentChatAddMembers {
  
  pub fn member_name(&self) -> Option<String> { self.member_name.clone() }
  
  pub fn is_current_user(&self) -> Option<bool> { self.is_current_user.clone() }
  
  pub fn is_returned(&self) -> Option<bool> { self.is_returned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat photo was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatChangePhoto
  
}



impl Object for PushMessageContentChatChangePhoto {}
impl RObject for PushMessageContentChatChangePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatChangePhoto" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatChangePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatChangePhoto {}


impl PushMessageContentChatChangePhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat title was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatChangeTitle
  /// New chat title.
  title: Option<String>,
  
}



impl Object for PushMessageContentChatChangeTitle {}
impl RObject for PushMessageContentChatChangeTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatChangeTitle" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatChangeTitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatChangeTitle {}


impl PushMessageContentChatChangeTitle {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatDeleteMember
  /// Name of the deleted member.
  member_name: Option<String>,
  /// True, if the current user was deleted from the group.
  is_current_user: Option<bool>,
  /// True, if the user has left the group himself.
  is_left: Option<bool>,
  
}



impl Object for PushMessageContentChatDeleteMember {}
impl RObject for PushMessageContentChatDeleteMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatDeleteMember" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatDeleteMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatDeleteMember {}


impl PushMessageContentChatDeleteMember {
  
  pub fn member_name(&self) -> Option<String> { self.member_name.clone() }
  
  pub fn is_current_user(&self) -> Option<bool> { self.is_current_user.clone() }
  
  pub fn is_left(&self) -> Option<bool> { self.is_left.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentChatJoinByLink
  
}



impl Object for PushMessageContentChatJoinByLink {}
impl RObject for PushMessageContentChatJoinByLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentChatJoinByLink" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentChatJoinByLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentChatJoinByLink {}


impl PushMessageContentChatJoinByLink {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A forwarded messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMessageForwards {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentMessageForwards
  /// Number of forwarded messages.
  total_count: Option<i32>,
  
}



impl Object for PushMessageContentMessageForwards {}
impl RObject for PushMessageContentMessageForwards {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentMessageForwards" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentMessageForwards }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentMessageForwards {}


impl PushMessageContentMessageForwards {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A media album. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMediaAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushMessageContentMediaAlbum
  /// Number of messages in the album.
  total_count: Option<i32>,
  /// True, if the album has at least one photo.
  has_photos: Option<bool>,
  /// True, if the album has at least one video.
  has_videos: Option<bool>,
  
}



impl Object for PushMessageContentMediaAlbum {}
impl RObject for PushMessageContentMediaAlbum {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushMessageContentMediaAlbum" }
  fn td_type(&self) -> RTDType { RTDType::PushMessageContentMediaAlbum }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl PushMessageContent for PushMessageContentMediaAlbum {}


impl PushMessageContentMediaAlbum {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn has_photos(&self) -> Option<bool> { self.has_photos.clone() }
  
  pub fn has_videos(&self) -> Option<bool> { self.has_videos.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pushReceiverId
  /// The globally unique identifier of push notification subscription.
  id: Option<i64>,
  
}



impl Object for PushReceiverId {}
impl RObject for PushReceiverId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pushReceiverId" }
  fn td_type(&self) -> RTDType { RTDType::PushReceiverId }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl PushReceiverId {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about the current recovery email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoveryEmailAddress
  /// Recovery email address.
  recovery_email_address: Option<String>,
  
}



impl Object for RecoveryEmailAddress {}
impl RObject for RecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::RecoveryEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl RecoveryEmailAddress {
  
  pub fn recovery_email_address(&self) -> Option<String> { self.recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a remote file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // remoteFile
  /// Remote file identifier; may be empty. Can be used across application restarts or even from other devices for the current user. If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and "#url#" as the conversion string. Clients should generate the file by downloading it to the specified location.
  id: Option<String>,
  /// True, if the file is currently being uploaded (or a remote copy is being generated by some other means).
  is_uploading_active: Option<bool>,
  /// True, if a remote copy is fully available.
  is_uploading_completed: Option<bool>,
  /// Size of the remote available part of the file; 0 if unknown.
  uploaded_size: Option<i32>,
  
}



impl Object for RemoteFile {}
impl RObject for RemoteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "remoteFile" }
  fn td_type(&self) -> RTDType { RTDType::RemoteFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl RemoteFile {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn is_uploading_active(&self) -> Option<bool> { self.is_uploading_active.clone() }
  
  pub fn is_uploading_completed(&self) -> Option<bool> { self.is_uploading_completed.clone() }
  
  pub fn uploaded_size(&self) -> Option<i32> { self.uploaded_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots. 
#[typetag::serde(tag = "@struct")]
pub trait ReplyMarkup: Object + RObject + Debug {}






impl ReplyMarkup {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<ReplyMarkup> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDReplyMarkupType {
  ReplyMarkupForceReply,
  ReplyMarkupInlineKeyboard,
  ReplyMarkupRemoveKeyboard,
  ReplyMarkupShowKeyboard,
  
}
impl RTDReplyMarkupType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDReplyMarkupType)(text.as_ref()) }
}



/// Instructs clients to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupRemoveKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupRemoveKeyboard
  /// True, if the keyboard is removed only for the mentioned users or the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupRemoveKeyboard {}
impl RObject for ReplyMarkupRemoveKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupRemoveKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupRemoveKeyboard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupRemoveKeyboard {}


impl ReplyMarkupRemoveKeyboard {
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Instructs clients to force a reply to this message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupForceReply {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupForceReply
  /// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupForceReply {}
impl RObject for ReplyMarkupForceReply {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupForceReply" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupForceReply }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupForceReply {}


impl ReplyMarkupForceReply {
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a custom keyboard layout to quickly reply to bots. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupShowKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupShowKeyboard
  /// A list of rows of bot keyboard buttons.
  rows: Option<Vec<Vec<KeyboardButton>>>,
  /// True, if the client needs to resize the keyboard vertically.
  resize_keyboard: Option<bool>,
  /// True, if the client needs to hide the keyboard after use.
  one_time: Option<bool>,
  /// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,
  
}



impl Object for ReplyMarkupShowKeyboard {}
impl RObject for ReplyMarkupShowKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupShowKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupShowKeyboard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupShowKeyboard {}


impl ReplyMarkupShowKeyboard {
  
  pub fn rows(&self) -> Option<Vec<Vec<KeyboardButton>>> { self.rows.clone() }
  
  pub fn resize_keyboard(&self) -> Option<bool> { self.resize_keyboard.clone() }
  
  pub fn one_time(&self) -> Option<bool> { self.one_time.clone() }
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains an inline keyboard layout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupInlineKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // replyMarkupInlineKeyboard
  /// A list of rows of inline keyboard buttons.
  rows: Option<Vec<Vec<InlineKeyboardButton>>>,
  
}



impl Object for ReplyMarkupInlineKeyboard {}
impl RObject for ReplyMarkupInlineKeyboard {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "replyMarkupInlineKeyboard" }
  fn td_type(&self) -> RTDType { RTDType::ReplyMarkupInlineKeyboard }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl ReplyMarkup for ReplyMarkupInlineKeyboard {}


impl ReplyMarkupInlineKeyboard {
  
  pub fn rows(&self) -> Option<Vec<Vec<InlineKeyboardButton>>> { self.rows.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes a text object inside an instant-view web page. 
#[typetag::serde(tag = "@struct")]
pub trait RichText: Object + RObject + Debug {}






impl RichText {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<RichText> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDRichTextType {
  RichTextAnchor,
  RichTextBold,
  RichTextEmailAddress,
  RichTextFixed,
  RichTextIcon,
  RichTextItalic,
  RichTextMarked,
  RichTextPhoneNumber,
  RichTextPlain,
  RichTexts,
  RichTextStrikethrough,
  RichTextSubscript,
  RichTextSuperscript,
  RichTextUnderline,
  RichTextUrl,
  
}
impl RTDRichTextType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDRichTextType)(text.as_ref()) }
}



/// A plain text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextPlain {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextPlain
  /// Text.
  text: Option<String>,
  
}



impl Object for RichTextPlain {}
impl RObject for RichTextPlain {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextPlain" }
  fn td_type(&self) -> RTDType { RTDType::RichTextPlain }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextPlain {}


impl RichTextPlain {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A bold rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextBold
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextBold {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextBold {}
impl RObject for RichTextBold {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextBold" }
  fn td_type(&self) -> RTDType { RTDType::RichTextBold }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextBold {}


impl RichTextBold {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An italicized rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextItalic
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextItalic {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextItalic {}
impl RObject for RichTextItalic {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextItalic" }
  fn td_type(&self) -> RTDType { RTDType::RichTextItalic }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextItalic {}


impl RichTextItalic {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An underlined rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUnderline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextUnderline
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextUnderline {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextUnderline {}
impl RObject for RichTextUnderline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextUnderline" }
  fn td_type(&self) -> RTDType { RTDType::RichTextUnderline }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextUnderline {}


impl RichTextUnderline {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A strike-through rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextStrikethrough {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextStrikethrough
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextStrikethrough {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextStrikethrough {}
impl RObject for RichTextStrikethrough {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextStrikethrough" }
  fn td_type(&self) -> RTDType { RTDType::RichTextStrikethrough }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextStrikethrough {}


impl RichTextStrikethrough {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A fixed-width rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextFixed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextFixed
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextFixed {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextFixed {}
impl RObject for RichTextFixed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextFixed" }
  fn td_type(&self) -> RTDType { RTDType::RichTextFixed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextFixed {}


impl RichTextFixed {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rich text URL link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextUrl
  /// Text.
  text: Option<Box<RichText>>,
  /// URL.
  url: Option<String>,
  
}


impl Clone for RichTextUrl {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextUrl {}
impl RObject for RichTextUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextUrl" }
  fn td_type(&self) -> RTDType { RTDType::RichTextUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextUrl {}


impl RichTextUrl {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rich text email link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextEmailAddress
  /// Text.
  text: Option<Box<RichText>>,
  /// Email address.
  email_address: Option<String>,
  
}


impl Clone for RichTextEmailAddress {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextEmailAddress {}
impl RObject for RichTextEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::RichTextEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextEmailAddress {}


impl RichTextEmailAddress {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A subscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSubscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextSubscript
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextSubscript {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextSubscript {}
impl RObject for RichTextSubscript {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextSubscript" }
  fn td_type(&self) -> RTDType { RTDType::RichTextSubscript }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextSubscript {}


impl RichTextSubscript {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A superscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSuperscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextSuperscript
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextSuperscript {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextSuperscript {}
impl RObject for RichTextSuperscript {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextSuperscript" }
  fn td_type(&self) -> RTDType { RTDType::RichTextSuperscript }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextSuperscript {}


impl RichTextSuperscript {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A marked rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextMarked {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextMarked
  /// Text.
  text: Option<Box<RichText>>,
  
}


impl Clone for RichTextMarked {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextMarked {}
impl RObject for RichTextMarked {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextMarked" }
  fn td_type(&self) -> RTDType { RTDType::RichTextMarked }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextMarked {}


impl RichTextMarked {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rich text phone number. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextPhoneNumber
  /// Text.
  text: Option<Box<RichText>>,
  /// Phone number.
  phone_number: Option<String>,
  
}


impl Clone for RichTextPhoneNumber {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextPhoneNumber {}
impl RObject for RichTextPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::RichTextPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextPhoneNumber {}


impl RichTextPhoneNumber {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A small image inside the text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextIcon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextIcon
  /// The image represented as a document. The image can be in GIF, JPEG or PNG format.
  document: Option<Document>,
  /// Width of a bounding box in which the image should be shown, 0 if unknown.
  width: Option<i32>,
  /// Height of a bounding box in which the image should be shown, 0 if unknown.
  height: Option<i32>,
  
}



impl Object for RichTextIcon {}
impl RObject for RichTextIcon {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextIcon" }
  fn td_type(&self) -> RTDType { RTDType::RichTextIcon }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextIcon {}


impl RichTextIcon {
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rich text anchor. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTextAnchor
  /// Text.
  text: Option<Box<RichText>>,
  /// Anchor name.
  name: Option<String>,
  
}


impl Clone for RichTextAnchor {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTextAnchor {}
impl RObject for RichTextAnchor {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTextAnchor" }
  fn td_type(&self) -> RTDType { RTDType::RichTextAnchor }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTextAnchor {}


impl RichTextAnchor {
  
  pub fn text(&self) -> Option<Box<RichText>> { self.text.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A concatenation of rich texts. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTexts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // richTexts
  /// Texts.
  texts: Option<Vec<Box<RichText>>>,
  
}


impl Clone for RichTexts {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RichTexts {}
impl RObject for RichTexts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "richTexts" }
  fn td_type(&self) -> RTDType { RTDType::RichTexts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl RichText for RichTexts {}


impl RichTexts {
  
  pub fn texts(&self) -> Option<Vec<Box<RichText>>> { self.texts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about saved card credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // savedCredentials
  /// Unique identifier of the saved credentials.
  id: Option<String>,
  /// Title of the saved credentials.
  title: Option<String>,
  
}



impl Object for SavedCredentials {}
impl RObject for SavedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "savedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::SavedCredentials }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl SavedCredentials {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about notification settings for several chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // scopeNotificationSettings
  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// True, if notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// True, if notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,
  
}



impl Object for ScopeNotificationSettings {}
impl RObject for ScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "scopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ScopeNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ScopeNotificationSettings {
  
  pub fn mute_for(&self) -> Option<i32> { self.mute_for.clone() }
  
  pub fn sound(&self) -> Option<String> { self.sound.clone() }
  
  pub fn show_preview(&self) -> Option<bool> { self.show_preview.clone() }
  
  pub fn disable_pinned_message_notifications(&self) -> Option<bool> { self.disable_pinned_message_notifications.clone() }
  
  pub fn disable_mention_notifications(&self) -> Option<bool> { self.disable_mention_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a filter for message search results. 
#[typetag::serde(tag = "@struct")]
pub trait SearchMessagesFilter: Object + RObject + Debug {}






impl SearchMessagesFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<SearchMessagesFilter> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSearchMessagesFilterType {
  SearchMessagesFilterAnimation,
  SearchMessagesFilterAudio,
  SearchMessagesFilterCall,
  SearchMessagesFilterChatPhoto,
  SearchMessagesFilterDocument,
  SearchMessagesFilterEmpty,
  SearchMessagesFilterMention,
  SearchMessagesFilterMissedCall,
  SearchMessagesFilterPhoto,
  SearchMessagesFilterPhotoAndVideo,
  SearchMessagesFilterUnreadMention,
  SearchMessagesFilterUrl,
  SearchMessagesFilterVideo,
  SearchMessagesFilterVideoNote,
  SearchMessagesFilterVoiceAndVideoNote,
  SearchMessagesFilterVoiceNote,
  
}
impl RTDSearchMessagesFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDSearchMessagesFilterType)(text.as_ref()) }
}



/// Returns all found messages, no filter is applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterEmpty
  
}



impl Object for SearchMessagesFilterEmpty {}
impl RObject for SearchMessagesFilterEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterEmpty" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterEmpty {}


impl SearchMessagesFilterEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only animation messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterAnimation
  
}



impl Object for SearchMessagesFilterAnimation {}
impl RObject for SearchMessagesFilterAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterAnimation" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterAnimation {}


impl SearchMessagesFilterAnimation {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only audio messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterAudio
  
}



impl Object for SearchMessagesFilterAudio {}
impl RObject for SearchMessagesFilterAudio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterAudio" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterAudio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterAudio {}


impl SearchMessagesFilterAudio {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only document messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterDocument
  
}



impl Object for SearchMessagesFilterDocument {}
impl RObject for SearchMessagesFilterDocument {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterDocument" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterDocument }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterDocument {}


impl SearchMessagesFilterDocument {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only photo messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterPhoto
  
}



impl Object for SearchMessagesFilterPhoto {}
impl RObject for SearchMessagesFilterPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterPhoto {}


impl SearchMessagesFilterPhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVideo
  
}



impl Object for SearchMessagesFilterVideo {}
impl RObject for SearchMessagesFilterVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVideo" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVideo {}


impl SearchMessagesFilterVideo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only voice note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVoiceNote
  
}



impl Object for SearchMessagesFilterVoiceNote {}
impl RObject for SearchMessagesFilterVoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVoiceNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVoiceNote {}


impl SearchMessagesFilterVoiceNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only photo and video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhotoAndVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterPhotoAndVideo
  
}



impl Object for SearchMessagesFilterPhotoAndVideo {}
impl RObject for SearchMessagesFilterPhotoAndVideo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterPhotoAndVideo" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterPhotoAndVideo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterPhotoAndVideo {}


impl SearchMessagesFilterPhotoAndVideo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only messages containing URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterUrl
  
}



impl Object for SearchMessagesFilterUrl {}
impl RObject for SearchMessagesFilterUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterUrl" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterUrl {}


impl SearchMessagesFilterUrl {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only messages containing chat photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterChatPhoto
  
}



impl Object for SearchMessagesFilterChatPhoto {}
impl RObject for SearchMessagesFilterChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterChatPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterChatPhoto {}


impl SearchMessagesFilterChatPhoto {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only call messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterCall
  
}



impl Object for SearchMessagesFilterCall {}
impl RObject for SearchMessagesFilterCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterCall" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterCall {}


impl SearchMessagesFilterCall {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only incoming call messages with missed/declined discard reasons. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMissedCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterMissedCall
  
}



impl Object for SearchMessagesFilterMissedCall {}
impl RObject for SearchMessagesFilterMissedCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterMissedCall" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterMissedCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterMissedCall {}


impl SearchMessagesFilterMissedCall {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVideoNote
  
}



impl Object for SearchMessagesFilterVideoNote {}
impl RObject for SearchMessagesFilterVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVideoNote {}


impl SearchMessagesFilterVideoNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only voice and video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceAndVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterVoiceAndVideoNote
  
}



impl Object for SearchMessagesFilterVoiceAndVideoNote {}
impl RObject for SearchMessagesFilterVoiceAndVideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterVoiceAndVideoNote" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterVoiceAndVideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterVoiceAndVideoNote {}


impl SearchMessagesFilterVoiceAndVideoNote {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only messages with mentions of the current user, or messages that are replies to their messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterMention
  
}



impl Object for SearchMessagesFilterMention {}
impl RObject for SearchMessagesFilterMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterMention" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterMention }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterMention {}


impl SearchMessagesFilterMention {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query or by the sending user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUnreadMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessagesFilterUnreadMention
  
}



impl Object for SearchMessagesFilterUnreadMention {}
impl RObject for SearchMessagesFilterUnreadMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessagesFilterUnreadMention" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessagesFilterUnreadMention }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SearchMessagesFilter for SearchMessagesFilterUnreadMention {}


impl SearchMessagesFilterUnreadMention {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a value representing a number of seconds. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Seconds {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // seconds
  /// Number of seconds.
  seconds: Option<f64>,
  
}



impl Object for Seconds {}
impl RObject for Seconds {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "seconds" }
  fn td_type(&self) -> RTDType { RTDType::Seconds }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Seconds {
  
  pub fn seconds(&self) -> Option<f64> { self.seconds.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a secret chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct SecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChat
  /// Secret chat identifier.
  id: Option<i32>,
  /// Identifier of the chat partner.
  user_id: Option<i32>,
  /// State of the secret chat.
  state: Option<Box<SecretChatState>>,
  /// True, if the chat was created by the current user; otherwise false.
  is_outbound: Option<bool>,
  /// Current message Time To Live setting (self-destruct timer) for the chat, in seconds.
  ttl: Option<i32>,
  /// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 bytes, which must be used to make a 12x12 square image with a color depth of 4. The first 16 bytes should be used to make a central 8x8 square, while the remaining 20 bytes should be used to construct a 2-pixel-wide border around that square. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers.
  key_hash: Option<String>,
  /// Secret chat layer; determines features supported by the other client. Video notes are supported if the layer >= 66.
  layer: Option<i32>,
  
}


impl Clone for SecretChat {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SecretChat {}
impl RObject for SecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChat" }
  fn td_type(&self) -> RTDType { RTDType::SecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl SecretChat {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn state(&self) -> Option<Box<SecretChatState>> { self.state.clone() }
  
  pub fn is_outbound(&self) -> Option<bool> { self.is_outbound.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn key_hash(&self) -> Option<String> { self.key_hash.clone() }
  
  pub fn layer(&self) -> Option<i32> { self.layer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the current secret chat state. 
#[typetag::serde(tag = "@struct")]
pub trait SecretChatState: Object + RObject + Debug {}






impl SecretChatState {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<SecretChatState> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSecretChatStateType {
  SecretChatStateClosed,
  SecretChatStatePending,
  SecretChatStateReady,
  
}
impl RTDSecretChatStateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDSecretChatStateType)(text.as_ref()) }
}



/// The secret chat is not yet created; waiting for the other user to get online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStatePending
  
}



impl Object for SecretChatStatePending {}
impl RObject for SecretChatStatePending {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStatePending" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStatePending }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SecretChatState for SecretChatStatePending {}


impl SecretChatStatePending {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The secret chat is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStateReady
  
}



impl Object for SecretChatStateReady {}
impl RObject for SecretChatStateReady {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStateReady" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStateReady }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SecretChatState for SecretChatStateReady {}


impl SecretChatStateReady {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The secret chat is closed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // secretChatStateClosed
  
}



impl Object for SecretChatStateClosed {}
impl RObject for SecretChatStateClosed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "secretChatStateClosed" }
  fn td_type(&self) -> RTDType { RTDType::SecretChatStateClosed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SecretChatState for SecretChatStateClosed {}


impl SecretChatStateClosed {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Session {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // session
  /// Session identifier.
  id: Option<i64>,
  /// True, if this session is the current session.
  is_current: Option<bool>,
  /// True, if a password is needed to complete authorization of the session.
  is_password_pending: Option<bool>,
  /// Telegram API identifier, as provided by the application.
  api_id: Option<i32>,
  /// Name of the application, as provided by the application.
  application_name: Option<String>,
  /// The version of the application, as provided by the application.
  application_version: Option<String>,
  /// True, if the application is an official application or uses the api_id of an official application.
  is_official_application: Option<bool>,
  /// Model of the device the application has been run or is running on, as provided by the application.
  device_model: Option<String>,
  /// Operating system the application has been run or is running on, as provided by the application.
  platform: Option<String>,
  /// Version of the operating system the application has been run or is running on, as provided by the application.
  system_version: Option<String>,
  /// Point in time (Unix timestamp) when the user has logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when the session was last used.
  last_active_date: Option<i32>,
  /// IP address from which the session was created, in human-readable format.
  ip: Option<String>,
  /// A two-letter country code for the country from which the session was created, based on the IP address.
  country: Option<String>,
  /// Region code from which the session was created, based on the IP address.
  region: Option<String>,
  
}



impl Object for Session {}
impl RObject for Session {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "session" }
  fn td_type(&self) -> RTDType { RTDType::Session }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Session {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn is_current(&self) -> Option<bool> { self.is_current.clone() }
  
  pub fn is_password_pending(&self) -> Option<bool> { self.is_password_pending.clone() }
  
  pub fn api_id(&self) -> Option<i32> { self.api_id.clone() }
  
  pub fn application_name(&self) -> Option<String> { self.application_name.clone() }
  
  pub fn application_version(&self) -> Option<String> { self.application_version.clone() }
  
  pub fn is_official_application(&self) -> Option<bool> { self.is_official_application.clone() }
  
  pub fn device_model(&self) -> Option<String> { self.device_model.clone() }
  
  pub fn platform(&self) -> Option<String> { self.platform.clone() }
  
  pub fn system_version(&self) -> Option<String> { self.system_version.clone() }
  
  pub fn log_in_date(&self) -> Option<i32> { self.log_in_date.clone() }
  
  pub fn last_active_date(&self) -> Option<i32> { self.last_active_date.clone() }
  
  pub fn ip(&self) -> Option<String> { self.ip.clone() }
  
  pub fn country(&self) -> Option<String> { self.country.clone() }
  
  pub fn region(&self) -> Option<String> { self.region.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of sessions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sessions
  /// List of sessions.
  sessions: Option<Vec<Session>>,
  
}



impl Object for Sessions {}
impl RObject for Sessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sessions" }
  fn td_type(&self) -> RTDType { RTDType::Sessions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Sessions {
  
  pub fn sessions(&self) -> Option<Vec<Session>> { self.sessions.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// One shipping option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // shippingOption
  /// Shipping option identifier.
  id: Option<String>,
  /// Option title.
  title: Option<String>,
  /// A list of objects used to calculate the total shipping costs.
  price_parts: Option<Vec<LabeledPricePart>>,
  
}



impl Object for ShippingOption {}
impl RObject for ShippingOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "shippingOption" }
  fn td_type(&self) -> RTDType { RTDType::ShippingOption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ShippingOption {
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn price_parts(&self) -> Option<Vec<LabeledPricePart>> { self.price_parts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sticker
  /// The identifier of the sticker set to which the sticker belongs; 0 if none.
  set_id: Option<i64>,
  /// Sticker width; as defined by the sender.
  width: Option<i32>,
  /// Sticker height; as defined by the sender.
  height: Option<i32>,
  /// Emoji corresponding to the sticker.
  emoji: Option<String>,
  /// True, if the sticker is a mask.
  is_mask: Option<bool>,
  /// Position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,
  /// Sticker thumbnail in WEBP or JPEG format; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the sticker.
  sticker: Option<File>,
  
}



impl Object for Sticker {}
impl RObject for Sticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sticker" }
  fn td_type(&self) -> RTDType { RTDType::Sticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Sticker {
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn is_mask(&self) -> Option<bool> { self.is_mask.clone() }
  
  pub fn mask_position(&self) -> Option<MaskPosition> { self.mask_position.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn sticker(&self) -> Option<File> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of all emoji corresponding to a sticker in a sticker set. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerEmojis
  /// List of emojis.
  emojis: Option<Vec<String>>,
  
}



impl Object for StickerEmojis {}
impl RObject for StickerEmojis {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerEmojis" }
  fn td_type(&self) -> RTDType { RTDType::StickerEmojis }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StickerEmojis {
  
  pub fn emojis(&self) -> Option<Vec<String>> { self.emojis.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSet
  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by the current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// List of stickers in this set.
  stickers: Option<Vec<Sticker>>,
  /// A list of emoji corresponding to the stickers in the same order.
  emojis: Option<Vec<StickerEmojis>>,
  
}



impl Object for StickerSet {}
impl RObject for StickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSet" }
  fn td_type(&self) -> RTDType { RTDType::StickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StickerSet {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn stickers(&self) -> Option<Vec<Sticker>> { self.stickers.clone() }
  
  pub fn emojis(&self) -> Option<Vec<StickerEmojis>> { self.emojis.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents short information about a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSetInfo
  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// Total number of stickers in the set.
  size: Option<i32>,
  /// Contains up to the first 5 stickers from the set, depending on the context. If the client needs more stickers the full set should be requested.
  covers: Option<Vec<Sticker>>,
  
}



impl Object for StickerSetInfo {}
impl RObject for StickerSetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSetInfo" }
  fn td_type(&self) -> RTDType { RTDType::StickerSetInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StickerSetInfo {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn is_official(&self) -> Option<bool> { self.is_official.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn is_viewed(&self) -> Option<bool> { self.is_viewed.clone() }
  
  pub fn size(&self) -> Option<i32> { self.size.clone() }
  
  pub fn covers(&self) -> Option<Vec<Sticker>> { self.covers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of sticker sets. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickerSets
  /// Approximate total number of sticker sets found.
  total_count: Option<i32>,
  /// List of sticker sets.
  sets: Option<Vec<StickerSetInfo>>,
  
}



impl Object for StickerSets {}
impl RObject for StickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickerSets" }
  fn td_type(&self) -> RTDType { RTDType::StickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StickerSets {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn sets(&self) -> Option<Vec<StickerSetInfo>> { self.sets.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of stickers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Stickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stickers
  /// List of stickers.
  stickers: Option<Vec<Sticker>>,
  
}



impl Object for Stickers {}
impl RObject for Stickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stickers" }
  fn td_type(&self) -> RTDType { RTDType::Stickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Stickers {
  
  pub fn stickers(&self) -> Option<Vec<Sticker>> { self.stickers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the exact storage usage statistics split by chats and file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatistics
  /// Total size of files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,
  /// Statistics split by chats.
  by_chat: Option<Vec<StorageStatisticsByChat>>,
  
}



impl Object for StorageStatistics {}
impl RObject for StorageStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatistics" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StorageStatistics {
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn by_chat(&self) -> Option<Vec<StorageStatisticsByChat>> { self.by_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the storage usage statistics for a specific chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsByChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsByChat
  /// Chat identifier; 0 if none.
  chat_id: Option<i64>,
  /// Total size of the files in the chat.
  size: Option<i64>,
  /// Total number of files in the chat.
  count: Option<i32>,
  /// Statistics split by file types.
  by_file_type: Option<Vec<StorageStatisticsByFileType>>,
  
}



impl Object for StorageStatisticsByChat {}
impl RObject for StorageStatisticsByChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsByChat" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsByChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StorageStatisticsByChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn by_file_type(&self) -> Option<Vec<StorageStatisticsByFileType>> { self.by_file_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains the storage usage statistics for a specific file type. 
#[derive(Debug, Serialize, Deserialize)]
pub struct StorageStatisticsByFileType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsByFileType
  /// File type.
  file_type: Option<Box<FileType>>,
  /// Total size of the files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,
  
}


impl Clone for StorageStatisticsByFileType {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for StorageStatisticsByFileType {}
impl RObject for StorageStatisticsByFileType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsByFileType" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsByFileType }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StorageStatisticsByFileType {
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains approximate storage usage statistics, excluding files of unknown file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // storageStatisticsFast
  /// Approximate total size of files.
  files_size: Option<i64>,
  /// Approximate number of files.
  file_count: Option<i32>,
  /// Size of the database.
  database_size: Option<i64>,
  /// Size of the language pack database.
  language_pack_database_size: Option<i64>,
  /// Size of the TDLib internal log.
  log_size: Option<i64>,
  
}



impl Object for StorageStatisticsFast {}
impl RObject for StorageStatisticsFast {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "storageStatisticsFast" }
  fn td_type(&self) -> RTDType { RTDType::StorageStatisticsFast }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl StorageStatisticsFast {
  
  pub fn files_size(&self) -> Option<i64> { self.files_size.clone() }
  
  pub fn file_count(&self) -> Option<i32> { self.file_count.clone() }
  
  pub fn database_size(&self) -> Option<i64> { self.database_size.clone() }
  
  pub fn language_pack_database_size(&self) -> Option<i64> { self.language_pack_database_size.clone() }
  
  pub fn log_size(&self) -> Option<i64> { self.log_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Supergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroup
  /// Supergroup or channel identifier.
  id: Option<i32>,
  /// Username of the supergroup or channel; empty for private supergroups or channels.
  username: Option<String>,
  /// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member.
  date: Option<i32>,
  /// Status of the current user in the supergroup or channel.
  status: Option<Box<ChatMemberStatus>>,
  /// Member count; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was found through SearchPublicChats.
  member_count: Option<i32>,
  /// True, if any member of the supergroup can invite other members. This field has no meaning for channels.
  anyone_can_invite: Option<bool>,
  /// True, if messages sent to the channel should contain information about the sender. This field is only applicable to channels.
  sign_messages: Option<bool>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,
  /// True, if the supergroup or channel is verified.
  is_verified: Option<bool>,
  /// If non-empty, contains the reason why access to this supergroup or channel must be restricted. Format of the string is "{type}: {description}". {type} Contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,
  
}


impl Clone for Supergroup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Supergroup {}
impl RObject for Supergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroup" }
  fn td_type(&self) -> RTDType { RTDType::Supergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Supergroup {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn is_verified(&self) -> Option<bool> { self.is_verified.clone() }
  
  pub fn restriction_reason(&self) -> Option<String> { self.restriction_reason.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains full information about a supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupFullInfo
  /// Supergroup or channel description.
  description: Option<String>,
  /// Number of members in the supergroup or channel; 0 if unknown.
  member_count: Option<i32>,
  /// Number of privileged users in the supergroup or channel; 0 if unknown.
  administrator_count: Option<i32>,
  /// Number of restricted users in the supergroup; 0 if unknown.
  restricted_count: Option<i32>,
  /// Number of users banned from chat; 0 if unknown.
  banned_count: Option<i32>,
  /// True, if members of the chat can be retrieved.
  can_get_members: Option<bool>,
  /// True, if the chat can be made public.
  can_set_username: Option<bool>,
  /// True, if the supergroup sticker set can be changed.
  can_set_sticker_set: Option<bool>,
  /// True, if the channel statistics is available through getChatStatisticsUrl.
  can_view_statistics: Option<bool>,
  /// True, if new chat members will have access to old messages. In public supergroups and both public and private channels, old messages are always available, so this option affects only private supergroups. The value of this field is only available for chat administrators.
  is_all_history_available: Option<bool>,
  /// Identifier of the supergroup sticker set; 0 if none.
  sticker_set_id: Option<i64>,
  /// Invite link for this chat.
  invite_link: Option<String>,
  /// Identifier of the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_basic_group_id: Option<i32>,
  /// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_max_message_id: Option<i64>,
  
}



impl Object for SupergroupFullInfo {}
impl RObject for SupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl SupergroupFullInfo {
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn member_count(&self) -> Option<i32> { self.member_count.clone() }
  
  pub fn administrator_count(&self) -> Option<i32> { self.administrator_count.clone() }
  
  pub fn restricted_count(&self) -> Option<i32> { self.restricted_count.clone() }
  
  pub fn banned_count(&self) -> Option<i32> { self.banned_count.clone() }
  
  pub fn can_get_members(&self) -> Option<bool> { self.can_get_members.clone() }
  
  pub fn can_set_username(&self) -> Option<bool> { self.can_set_username.clone() }
  
  pub fn can_set_sticker_set(&self) -> Option<bool> { self.can_set_sticker_set.clone() }
  
  pub fn can_view_statistics(&self) -> Option<bool> { self.can_view_statistics.clone() }
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn upgraded_from_basic_group_id(&self) -> Option<i32> { self.upgraded_from_basic_group_id.clone() }
  
  pub fn upgraded_from_max_message_id(&self) -> Option<i64> { self.upgraded_from_max_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait SupergroupMembersFilter: Object + RObject + Debug {}






impl SupergroupMembersFilter {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<SupergroupMembersFilter> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDSupergroupMembersFilterType {
  SupergroupMembersFilterAdministrators,
  SupergroupMembersFilterBanned,
  SupergroupMembersFilterBots,
  SupergroupMembersFilterRecent,
  SupergroupMembersFilterRestricted,
  SupergroupMembersFilterSearch,
  
}
impl RTDSupergroupMembersFilterType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDSupergroupMembersFilterType)(text.as_ref()) }
}



/// Returns recently active users in reverse chronological order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRecent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterRecent
  
}



impl Object for SupergroupMembersFilterRecent {}
impl RObject for SupergroupMembersFilterRecent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterRecent" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterRecent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterRecent {}


impl SupergroupMembersFilterRecent {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterAdministrators
  
}



impl Object for SupergroupMembersFilterAdministrators {}
impl RObject for SupergroupMembersFilterAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterAdministrators }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterAdministrators {}


impl SupergroupMembersFilterAdministrators {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Used to search for supergroup or channel members via a (string) query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterSearch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterSearch
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterSearch {}
impl RObject for SupergroupMembersFilterSearch {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterSearch" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterSearch }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterSearch {}


impl SupergroupMembersFilterSearch {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns restricted supergroup members; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterRestricted
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterRestricted {}
impl RObject for SupergroupMembersFilterRestricted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterRestricted" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterRestricted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterRestricted {}


impl SupergroupMembersFilterRestricted {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns users banned from the supergroup or channel; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterBanned
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SupergroupMembersFilterBanned {}
impl RObject for SupergroupMembersFilterBanned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterBanned" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterBanned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterBanned {}


impl SupergroupMembersFilterBanned {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns bot members of the supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // supergroupMembersFilterBots
  
}



impl Object for SupergroupMembersFilterBots {}
impl RObject for SupergroupMembersFilterBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "supergroupMembersFilterBots" }
  fn td_type(&self) -> RTDType { RTDType::SupergroupMembersFilterBots }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl SupergroupMembersFilter for SupergroupMembersFilterBots {}


impl SupergroupMembersFilterBots {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a URL linking to an internal Telegram entity. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TMeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrl
  /// URL.
  url: Option<String>,
  /// Type of the URL.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TMeUrlType>>,
  
}


impl Clone for TMeUrl {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for TMeUrl {}
impl RObject for TMeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrl" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TMeUrl {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn type_(&self) -> Option<Box<TMeUrlType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the type of a URL linking to an internal Telegram entity. 
#[typetag::serde(tag = "@struct")]
pub trait TMeUrlType: Object + RObject + Debug {}






impl TMeUrlType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<TMeUrlType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTMeUrlTypeType {
  TMeUrlTypeChatInvite,
  TMeUrlTypeStickerSet,
  TMeUrlTypeSupergroup,
  TMeUrlTypeUser,
  
}
impl RTDTMeUrlTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDTMeUrlTypeType)(text.as_ref()) }
}



/// A URL linking to a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeUser
  /// Identifier of the user.
  user_id: Option<i32>,
  
}



impl Object for TMeUrlTypeUser {}
impl RObject for TMeUrlTypeUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeUser" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeUser {}


impl TMeUrlTypeUser {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A URL linking to a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeSupergroup
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i64>,
  
}



impl Object for TMeUrlTypeSupergroup {}
impl RObject for TMeUrlTypeSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeSupergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeSupergroup {}


impl TMeUrlTypeSupergroup {
  
  pub fn supergroup_id(&self) -> Option<i64> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeChatInvite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeChatInvite
  /// Chat invite link info.
  info: Option<ChatInviteLinkInfo>,
  
}



impl Object for TMeUrlTypeChatInvite {}
impl RObject for TMeUrlTypeChatInvite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeChatInvite" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeChatInvite }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeChatInvite {}


impl TMeUrlTypeChatInvite {
  
  pub fn info(&self) -> Option<ChatInviteLinkInfo> { self.info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A URL linking to a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrlTypeStickerSet
  /// Identifier of the sticker set.
  sticker_set_id: Option<i64>,
  
}



impl Object for TMeUrlTypeStickerSet {}
impl RObject for TMeUrlTypeStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrlTypeStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrlTypeStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TMeUrlType for TMeUrlTypeStickerSet {}


impl TMeUrlTypeStickerSet {
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of t.me URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tMeUrls
  /// List of URLs.
  urls: Option<Vec<TMeUrl>>,
  
}



impl Object for TMeUrls {}
impl RObject for TMeUrls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tMeUrls" }
  fn td_type(&self) -> RTDType { RTDType::TMeUrls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TMeUrls {
  
  pub fn urls(&self) -> Option<Vec<TMeUrl>> { self.urls.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains parameters for TDLib initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // tdlibParameters
  /// If set to true, the Telegram test environment will be used instead of the production environment.
  use_test_dc: Option<bool>,
  /// The path to the directory for the persistent database; if empty, the current working directory will be used.
  database_directory: Option<String>,
  /// The path to the directory for storing files; if empty, database_directory will be used.
  files_directory: Option<String>,
  /// If set to true, information about downloaded and uploaded files will be saved between application restarts.
  use_file_database: Option<bool>,
  /// If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database.
  use_chat_info_database: Option<bool>,
  /// If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database.
  use_message_database: Option<bool>,
  /// If set to true, support for secret chats will be enabled.
  use_secret_chats: Option<bool>,
  /// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org.
  api_id: Option<i32>,
  /// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org.
  api_hash: Option<String>,
  /// IETF language tag of the user's operating system language; must be non-empty.
  system_language_code: Option<String>,
  /// Model of the device the application is being run on; must be non-empty.
  device_model: Option<String>,
  /// Version of the operating system the application is being run on; must be non-empty.
  system_version: Option<String>,
  /// Application version; must be non-empty.
  application_version: Option<String>,
  /// If set to true, old files will automatically be deleted.
  enable_storage_optimizer: Option<bool>,
  /// If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name.
  ignore_file_names: Option<bool>,
  
}



impl Object for TdlibParameters {}
impl RObject for TdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "tdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::TdlibParameters }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TdlibParameters {
  
  pub fn use_test_dc(&self) -> Option<bool> { self.use_test_dc.clone() }
  
  pub fn database_directory(&self) -> Option<String> { self.database_directory.clone() }
  
  pub fn files_directory(&self) -> Option<String> { self.files_directory.clone() }
  
  pub fn use_file_database(&self) -> Option<bool> { self.use_file_database.clone() }
  
  pub fn use_chat_info_database(&self) -> Option<bool> { self.use_chat_info_database.clone() }
  
  pub fn use_message_database(&self) -> Option<bool> { self.use_message_database.clone() }
  
  pub fn use_secret_chats(&self) -> Option<bool> { self.use_secret_chats.clone() }
  
  pub fn api_id(&self) -> Option<i32> { self.api_id.clone() }
  
  pub fn api_hash(&self) -> Option<String> { self.api_hash.clone() }
  
  pub fn system_language_code(&self) -> Option<String> { self.system_language_code.clone() }
  
  pub fn device_model(&self) -> Option<String> { self.device_model.clone() }
  
  pub fn system_version(&self) -> Option<String> { self.system_version.clone() }
  
  pub fn application_version(&self) -> Option<String> { self.application_version.clone() }
  
  pub fn enable_storage_optimizer(&self) -> Option<bool> { self.enable_storage_optimizer.clone() }
  
  pub fn ignore_file_names(&self) -> Option<bool> { self.ignore_file_names.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about the availability of a temporary password, which can be used for payments. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // temporaryPasswordState
  /// True, if a temporary password is available.
  has_password: Option<bool>,
  /// Time left before the temporary password expires, in seconds.
  valid_for: Option<i32>,
  
}



impl Object for TemporaryPasswordState {}
impl RObject for TemporaryPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "temporaryPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::TemporaryPasswordState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TemporaryPasswordState {
  
  pub fn has_password(&self) -> Option<bool> { self.has_password.clone() }
  
  pub fn valid_for(&self) -> Option<i32> { self.valid_for.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains Telegram terms of service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // termsOfService
  /// Text of the terms of service.
  text: Option<FormattedText>,
  /// Mininum age of a user to be able to accept the terms; 0 if any.
  min_user_age: Option<i32>,
  /// True, if a blocking popup with terms of service must be shown to the user.
  show_popup: Option<bool>,
  
}



impl Object for TermsOfService {}
impl RObject for TermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "termsOfService" }
  fn td_type(&self) -> RTDType { RTDType::TermsOfService }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TermsOfService {
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn min_user_age(&self) -> Option<i32> { self.min_user_age.clone() }
  
  pub fn show_popup(&self) -> Option<bool> { self.show_popup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a sequence of bytes; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testBytes
  /// Bytes.
  value: Option<String>,
  
}



impl Object for TestBytes {}
impl RObject for TestBytes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testBytes" }
  fn td_type(&self) -> RTDType { RTDType::TestBytes }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestBytes {
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testInt
  /// Number.
  value: Option<i32>,
  
}



impl Object for TestInt {}
impl RObject for TestInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testInt" }
  fn td_type(&self) -> RTDType { RTDType::TestInt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestInt {
  
  pub fn value(&self) -> Option<i32> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testString
  /// String.
  value: Option<String>,
  
}



impl Object for TestString {}
impl RObject for TestString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testString" }
  fn td_type(&self) -> RTDType { RTDType::TestString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestString {
  
  pub fn value(&self) -> Option<String> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a vector of numbers; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorInt
  /// Vector of numbers.
  value: Option<Vec<i32>>,
  
}



impl Object for TestVectorInt {}
impl RObject for TestVectorInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorInt" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorInt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestVectorInt {
  
  pub fn value(&self) -> Option<Vec<i32>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a vector of objects that hold a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorIntObject
  /// Vector of objects.
  value: Option<Vec<TestInt>>,
  
}



impl Object for TestVectorIntObject {}
impl RObject for TestVectorIntObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorIntObject" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorIntObject }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestVectorIntObject {
  
  pub fn value(&self) -> Option<Vec<TestInt>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a vector of strings; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorString
  /// Vector of strings.
  value: Option<Vec<String>>,
  
}



impl Object for TestVectorString {}
impl RObject for TestVectorString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorString" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestVectorString {
  
  pub fn value(&self) -> Option<Vec<String>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A simple object containing a vector of objects that hold a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testVectorStringObject
  /// Vector of objects.
  value: Option<Vec<TestString>>,
  
}



impl Object for TestVectorStringObject {}
impl RObject for TestVectorStringObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testVectorStringObject" }
  fn td_type(&self) -> RTDType { RTDType::TestVectorStringObject }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TestVectorStringObject {
  
  pub fn value(&self) -> Option<Vec<TestString>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains some text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Text {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // text
  /// Text.
  text: Option<String>,
  
}



impl Object for Text {}
impl RObject for Text {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "text" }
  fn td_type(&self) -> RTDType { RTDType::Text }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Text {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of text entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntities
  /// List of text entities.
  entities: Option<Vec<TextEntity>>,
  
}



impl Object for TextEntities {}
impl RObject for TextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntities" }
  fn td_type(&self) -> RTDType { RTDType::TextEntities }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TextEntities {
  
  pub fn entities(&self) -> Option<Vec<TextEntity>> { self.entities.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a part of the text that needs to be formatted in some unusual way. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TextEntity {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntity
  /// Offset of the entity in UTF-16 code points.
  offset: Option<i32>,
  /// Length of the entity, in UTF-16 code points.
  length: Option<i32>,
  /// Type of the entity.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TextEntityType>>,
  
}


impl Clone for TextEntity {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for TextEntity {}
impl RObject for TextEntity {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntity" }
  fn td_type(&self) -> RTDType { RTDType::TextEntity }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl TextEntity {
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn type_(&self) -> Option<Box<TextEntityType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a part of the text which must be formatted differently. 
#[typetag::serde(tag = "@struct")]
pub trait TextEntityType: Object + RObject + Debug {}






impl TextEntityType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<TextEntityType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTextEntityTypeType {
  TextEntityTypeBold,
  TextEntityTypeBotCommand,
  TextEntityTypeCashtag,
  TextEntityTypeCode,
  TextEntityTypeEmailAddress,
  TextEntityTypeHashtag,
  TextEntityTypeItalic,
  TextEntityTypeMention,
  TextEntityTypeMentionName,
  TextEntityTypePhoneNumber,
  TextEntityTypePre,
  TextEntityTypePreCode,
  TextEntityTypeTextUrl,
  TextEntityTypeUrl,
  
}
impl RTDTextEntityTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDTextEntityTypeType)(text.as_ref()) }
}



/// A mention of a user by their username. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeMention
  
}



impl Object for TextEntityTypeMention {}
impl RObject for TextEntityTypeMention {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeMention" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeMention }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeMention {}


impl TextEntityTypeMention {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A hashtag text, beginning with "#". 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeHashtag
  
}



impl Object for TextEntityTypeHashtag {}
impl RObject for TextEntityTypeHashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeHashtag" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeHashtag }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeHashtag {}


impl TextEntityTypeHashtag {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeCashtag
  
}



impl Object for TextEntityTypeCashtag {}
impl RObject for TextEntityTypeCashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeCashtag" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeCashtag }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeCashtag {}


impl TextEntityTypeCashtag {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeBotCommand
  
}



impl Object for TextEntityTypeBotCommand {}
impl RObject for TextEntityTypeBotCommand {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeBotCommand" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeBotCommand }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeBotCommand {}


impl TextEntityTypeBotCommand {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeUrl
  
}



impl Object for TextEntityTypeUrl {}
impl RObject for TextEntityTypeUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeUrl" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeUrl {}


impl TextEntityTypeUrl {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeEmailAddress
  
}



impl Object for TextEntityTypeEmailAddress {}
impl RObject for TextEntityTypeEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeEmailAddress {}


impl TextEntityTypeEmailAddress {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A bold text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeBold
  
}



impl Object for TextEntityTypeBold {}
impl RObject for TextEntityTypeBold {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeBold" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeBold }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeBold {}


impl TextEntityTypeBold {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An italic text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeItalic
  
}



impl Object for TextEntityTypeItalic {}
impl RObject for TextEntityTypeItalic {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeItalic" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeItalic }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeItalic {}


impl TextEntityTypeItalic {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Text that must be formatted as if inside a code HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeCode
  
}



impl Object for TextEntityTypeCode {}
impl RObject for TextEntityTypeCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeCode" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeCode {}


impl TextEntityTypeCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Text that must be formatted as if inside a pre HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePre {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePre
  
}



impl Object for TextEntityTypePre {}
impl RObject for TextEntityTypePre {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePre" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePre }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePre {}


impl TextEntityTypePre {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Text that must be formatted as if inside pre, and code HTML tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePreCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePreCode
  /// Programming language of the code; as defined by the sender.
  language: Option<String>,
  
}



impl Object for TextEntityTypePreCode {}
impl RObject for TextEntityTypePreCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePreCode" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePreCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePreCode {}


impl TextEntityTypePreCode {
  
  pub fn language(&self) -> Option<String> { self.language.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A text description shown instead of a raw URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeTextUrl
  /// HTTP or tg:// URL to be opened when the link is clicked.
  url: Option<String>,
  
}



impl Object for TextEntityTypeTextUrl {}
impl RObject for TextEntityTypeTextUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeTextUrl" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeTextUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeTextUrl {}


impl TextEntityTypeTextUrl {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A text shows instead of a raw mention of the user (e.g., when the user has no username). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMentionName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypeMentionName
  /// Identifier of the mentioned user.
  user_id: Option<i32>,
  
}



impl Object for TextEntityTypeMentionName {}
impl RObject for TextEntityTypeMentionName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypeMentionName" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypeMentionName }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypeMentionName {}


impl TextEntityTypeMentionName {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textEntityTypePhoneNumber
  
}



impl Object for TextEntityTypePhoneNumber {}
impl RObject for TextEntityTypePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textEntityTypePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::TextEntityTypePhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextEntityType for TextEntityTypePhoneNumber {}


impl TextEntityTypePhoneNumber {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the way the text should be parsed for TextEntities. 
#[typetag::serde(tag = "@struct")]
pub trait TextParseMode: Object + RObject + Debug {}






impl TextParseMode {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<TextParseMode> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTextParseModeType {
  TextParseModeHTML,
  TextParseModeMarkdown,
  
}
impl RTDTextParseModeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDTextParseModeType)(text.as_ref()) }
}



/// The text should be parsed in markdown-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeMarkdown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textParseModeMarkdown
  
}



impl Object for TextParseModeMarkdown {}
impl RObject for TextParseModeMarkdown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textParseModeMarkdown" }
  fn td_type(&self) -> RTDType { RTDType::TextParseModeMarkdown }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextParseMode for TextParseModeMarkdown {}


impl TextParseModeMarkdown {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The text should be parsed in HTML-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeHTML {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // textParseModeHTML
  
}



impl Object for TextParseModeHTML {}
impl RObject for TextParseModeHTML {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "textParseModeHTML" }
  fn td_type(&self) -> RTDType { RTDType::TextParseModeHTML }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TextParseMode for TextParseModeHTML {}


impl TextParseModeHTML {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the categories of chats for which a list of frequently used chats can be retrieved. 
#[typetag::serde(tag = "@struct")]
pub trait TopChatCategory: Object + RObject + Debug {}






impl TopChatCategory {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<TopChatCategory> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDTopChatCategoryType {
  TopChatCategoryBots,
  TopChatCategoryCalls,
  TopChatCategoryChannels,
  TopChatCategoryGroups,
  TopChatCategoryInlineBots,
  TopChatCategoryUsers,
  
}
impl RTDTopChatCategoryType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDTopChatCategoryType)(text.as_ref()) }
}



/// A category containing frequently used private chats with non-bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryUsers
  
}



impl Object for TopChatCategoryUsers {}
impl RObject for TopChatCategoryUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryUsers" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryUsers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryUsers {}


impl TopChatCategoryUsers {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A category containing frequently used private chats with bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryBots
  
}



impl Object for TopChatCategoryBots {}
impl RObject for TopChatCategoryBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryBots" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryBots }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryBots {}


impl TopChatCategoryBots {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A category containing frequently used basic groups and supergroups. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryGroups {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryGroups
  
}



impl Object for TopChatCategoryGroups {}
impl RObject for TopChatCategoryGroups {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryGroups" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryGroups }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryGroups {}


impl TopChatCategoryGroups {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A category containing frequently used channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryChannels {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryChannels
  
}



impl Object for TopChatCategoryChannels {}
impl RObject for TopChatCategoryChannels {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryChannels" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryChannels }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryChannels {}


impl TopChatCategoryChannels {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A category containing frequently used chats with inline bots sorted by their usage in inline mode. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryInlineBots
  
}



impl Object for TopChatCategoryInlineBots {}
impl RObject for TopChatCategoryInlineBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryInlineBots" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryInlineBots }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryInlineBots {}


impl TopChatCategoryInlineBots {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A category containing frequently used chats used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // topChatCategoryCalls
  
}



impl Object for TopChatCategoryCalls {}
impl RObject for TopChatCategoryCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "topChatCategoryCalls" }
  fn td_type(&self) -> RTDType { RTDType::TopChatCategoryCalls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl TopChatCategory for TopChatCategoryCalls {}


impl TopChatCategoryCalls {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Contains notifications about data changes. 
#[typetag::serde(tag = "@struct")]
pub trait Update: Object + RObject + Debug {}






impl Update {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<Update> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUpdateType {
  UpdateActiveNotifications,
  UpdateAuthorizationState,
  UpdateBasicGroup,
  UpdateBasicGroupFullInfo,
  UpdateCall,
  UpdateChatDefaultDisableNotification,
  UpdateChatDraftMessage,
  UpdateChatIsMarkedAsUnread,
  UpdateChatIsPinned,
  UpdateChatIsSponsored,
  UpdateChatLastMessage,
  UpdateChatNotificationSettings,
  UpdateChatOnlineMemberCount,
  UpdateChatOrder,
  UpdateChatPhoto,
  UpdateChatPinnedMessage,
  UpdateChatReadInbox,
  UpdateChatReadOutbox,
  UpdateChatReplyMarkup,
  UpdateChatTitle,
  UpdateChatUnreadMentionCount,
  UpdateConnectionState,
  UpdateDeleteMessages,
  UpdateFavoriteStickers,
  UpdateFile,
  UpdateFileGenerationStart,
  UpdateFileGenerationStop,
  UpdateHavePendingNotifications,
  UpdateInstalledStickerSets,
  UpdateLanguagePackStrings,
  UpdateMessageContent,
  UpdateMessageContentOpened,
  UpdateMessageEdited,
  UpdateMessageMentionRead,
  UpdateMessageSendAcknowledged,
  UpdateMessageSendFailed,
  UpdateMessageSendSucceeded,
  UpdateMessageViews,
  UpdateNewCallbackQuery,
  UpdateNewChat,
  UpdateNewChosenInlineResult,
  UpdateNewCustomEvent,
  UpdateNewCustomQuery,
  UpdateNewInlineCallbackQuery,
  UpdateNewInlineQuery,
  UpdateNewMessage,
  UpdateNewPreCheckoutQuery,
  UpdateNewShippingQuery,
  UpdateNotification,
  UpdateNotificationGroup,
  UpdateOption,
  UpdatePoll,
  UpdateRecentStickers,
  UpdateSavedAnimations,
  UpdateScopeNotificationSettings,
  UpdateSecretChat,
  UpdateServiceNotification,
  UpdateSupergroup,
  UpdateSupergroupFullInfo,
  UpdateTermsOfService,
  UpdateTrendingStickerSets,
  UpdateUnreadChatCount,
  UpdateUnreadMessageCount,
  UpdateUser,
  UpdateUserChatAction,
  UpdateUserFullInfo,
  UpdateUserPrivacySettingRules,
  UpdateUserStatus,
  
}
impl RTDUpdateType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDUpdateType)(text.as_ref()) }
}



/// The user authorization state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateAuthorizationState
  /// New authorization state.
  authorization_state: Option<Box<AuthorizationState>>,
  
}


impl Clone for UpdateAuthorizationState {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateAuthorizationState {}
impl RObject for UpdateAuthorizationState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateAuthorizationState" }
  fn td_type(&self) -> RTDType { RTDType::UpdateAuthorizationState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateAuthorizationState {}


impl UpdateAuthorizationState {
  
  pub fn authorization_state(&self) -> Option<Box<AuthorizationState>> { self.authorization_state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new message was received; can also be an outgoing message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewMessage
  /// The new message.
  message: Option<Message>,
  
}



impl Object for UpdateNewMessage {}
impl RObject for UpdateNewMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewMessage {}


impl UpdateNewMessage {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendAcknowledged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendAcknowledged
  /// The chat identifier of the sent message.
  chat_id: Option<i64>,
  /// A temporary message identifier.
  message_id: Option<i64>,
  
}



impl Object for UpdateMessageSendAcknowledged {}
impl RObject for UpdateMessageSendAcknowledged {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendAcknowledged" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendAcknowledged }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageSendAcknowledged {}


impl UpdateMessageSendAcknowledged {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message has been successfully sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendSucceeded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendSucceeded
  /// Information about the sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,
  
}



impl Object for UpdateMessageSendSucceeded {}
impl RObject for UpdateMessageSendSucceeded {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendSucceeded" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendSucceeded }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageSendSucceeded {}


impl UpdateMessageSendSucceeded {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn old_message_id(&self) -> Option<i64> { self.old_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageSendFailed
  /// Contains information about the message that failed to send.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,
  /// An error code.
  error_code: Option<i32>,
  /// Error message.
  error_message: Option<String>,
  
}



impl Object for UpdateMessageSendFailed {}
impl RObject for UpdateMessageSendFailed {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageSendFailed" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageSendFailed }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageSendFailed {}


impl UpdateMessageSendFailed {
  
  pub fn message(&self) -> Option<Message> { self.message.clone() }
  
  pub fn old_message_id(&self) -> Option<i64> { self.old_message_id.clone() }
  
  pub fn error_code(&self) -> Option<i32> { self.error_code.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The message content has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageContent
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New message content.
  new_content: Option<Box<MessageContent>>,
  
}


impl Clone for UpdateMessageContent {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateMessageContent {}
impl RObject for UpdateMessageContent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageContent" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageContent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageContent {}


impl UpdateMessageContent {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn new_content(&self) -> Option<Box<MessageContent>> { self.new_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message was edited. Changes in the message content will come in a separate 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageEdited
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Point in time (Unix timestamp) when the message was edited.
  edit_date: Option<i32>,
  /// New message reply markup; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for UpdateMessageEdited {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateMessageEdited {}
impl RObject for UpdateMessageEdited {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageEdited" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageEdited }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageEdited {}


impl UpdateMessageEdited {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn edit_date(&self) -> Option<i32> { self.edit_date.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The view count of the message has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageViews {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageViews
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New value of the view count.
  views: Option<i32>,
  
}



impl Object for UpdateMessageViews {}
impl RObject for UpdateMessageViews {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageViews" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageViews }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageViews {}


impl UpdateMessageViews {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn views(&self) -> Option<i32> { self.views.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageContentOpened {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageContentOpened
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for UpdateMessageContentOpened {}
impl RObject for UpdateMessageContentOpened {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageContentOpened" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageContentOpened }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageContentOpened {}


impl UpdateMessageContentOpened {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A message with an unread mention was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageMentionRead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateMessageMentionRead
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The new number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,
  
}



impl Object for UpdateMessageMentionRead {}
impl RObject for UpdateMessageMentionRead {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateMessageMentionRead" }
  fn td_type(&self) -> RTDType { RTDType::UpdateMessageMentionRead }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateMessageMentionRead {}


impl UpdateMessageMentionRead {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the client. The chat field changes will be reported through separate updates. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewChat
  /// The chat.
  chat: Option<Chat>,
  
}



impl Object for UpdateNewChat {}
impl RObject for UpdateNewChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewChat" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewChat {}


impl UpdateNewChat {
  
  pub fn chat(&self) -> Option<Chat> { self.chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The title of a chat was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatTitle
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat title.
  title: Option<String>,
  
}



impl Object for UpdateChatTitle {}
impl RObject for UpdateChatTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatTitle" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatTitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatTitle {}


impl UpdateChatTitle {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatPhoto
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat photo; may be null.
  photo: Option<ChatPhoto>,
  
}



impl Object for UpdateChatPhoto {}
impl RObject for UpdateChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatPhoto {}


impl UpdateChatPhoto {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn photo(&self) -> Option<ChatPhoto> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The last message of a chat was changed. If last_message is null then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatLastMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatLastMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new last message in the chat; may be null.
  last_message: Option<Message>,
  /// New value of the chat order.
  order: Option<String>,
  
}



impl Object for UpdateChatLastMessage {}
impl RObject for UpdateChatLastMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatLastMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatLastMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatLastMessage {}


impl UpdateChatLastMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_message(&self) -> Option<Message> { self.last_message.clone() }
  
  pub fn order(&self) -> Option<String> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The order of the chat in the chat list has changed. Instead of this update 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOrder {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatOrder
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of the order.
  order: Option<i64>,
  
}



impl Object for UpdateChatOrder {}
impl RObject for UpdateChatOrder {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatOrder" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatOrder }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatOrder {}


impl UpdateChatOrder {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat was pinned or unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsPinned
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,
  /// New value of the chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatIsPinned {}
impl RObject for UpdateChatIsPinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsPinned" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsPinned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatIsPinned {}


impl UpdateChatIsPinned {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat was marked as unread or was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsMarkedAsUnread
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,
  
}



impl Object for UpdateChatIsMarkedAsUnread {}
impl RObject for UpdateChatIsMarkedAsUnread {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsMarkedAsUnread" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsMarkedAsUnread }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatIsMarkedAsUnread {}


impl UpdateChatIsMarkedAsUnread {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat's is_sponsored field has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsSponsored {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatIsSponsored
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_sponsored.
  is_sponsored: Option<bool>,
  /// New value of chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatIsSponsored {}
impl RObject for UpdateChatIsSponsored {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatIsSponsored" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatIsSponsored }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatIsSponsored {}


impl UpdateChatIsSponsored {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_sponsored(&self) -> Option<bool> { self.is_sponsored.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatDefaultDisableNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new default_disable_notification value.
  default_disable_notification: Option<bool>,
  
}



impl Object for UpdateChatDefaultDisableNotification {}
impl RObject for UpdateChatDefaultDisableNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatDefaultDisableNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatDefaultDisableNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatDefaultDisableNotification {}


impl UpdateChatDefaultDisableNotification {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Incoming messages were read or number of unread messages has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadInbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReadInbox
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// The number of unread messages left in the chat.
  unread_count: Option<i32>,
  
}



impl Object for UpdateChatReadInbox {}
impl RObject for UpdateChatReadInbox {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReadInbox" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReadInbox }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatReadInbox {}


impl UpdateChatReadInbox {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_read_inbox_message_id(&self) -> Option<i64> { self.last_read_inbox_message_id.clone() }
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Outgoing messages were read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadOutbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReadOutbox
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of last read outgoing message.
  last_read_outbox_message_id: Option<i64>,
  
}



impl Object for UpdateChatReadOutbox {}
impl RObject for UpdateChatReadOutbox {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReadOutbox" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReadOutbox }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatReadOutbox {}


impl UpdateChatReadOutbox {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn last_read_outbox_message_id(&self) -> Option<i64> { self.last_read_outbox_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat unread_mention_count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatUnreadMentionCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatUnreadMentionCount
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,
  
}



impl Object for UpdateChatUnreadMentionCount {}
impl RObject for UpdateChatUnreadMentionCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatUnreadMentionCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatUnreadMentionCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatUnreadMentionCount {}


impl UpdateChatUnreadMentionCount {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn unread_mention_count(&self) -> Option<i32> { self.unread_mention_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Notification settings for a chat were changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatNotificationSettings
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new notification settings.
  notification_settings: Option<ChatNotificationSettings>,
  
}



impl Object for UpdateChatNotificationSettings {}
impl RObject for UpdateChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatNotificationSettings {}


impl UpdateChatNotificationSettings {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Notification settings for some type of chats were updated. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateScopeNotificationSettings
  /// Types of chats for which notification settings were updated.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings.
  notification_settings: Option<ScopeNotificationSettings>,
  
}


impl Clone for UpdateScopeNotificationSettings {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateScopeNotificationSettings {}
impl RObject for UpdateScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateScopeNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateScopeNotificationSettings {}


impl UpdateScopeNotificationSettings {
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn notification_settings(&self) -> Option<ScopeNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The chat pinned message was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatPinnedMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new identifier of the pinned message; 0 if there is no pinned message in the chat.
  pinned_message_id: Option<i64>,
  
}



impl Object for UpdateChatPinnedMessage {}
impl RObject for UpdateChatPinnedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatPinnedMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatPinnedMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatPinnedMessage {}


impl UpdateChatPinnedMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn pinned_message_id(&self) -> Option<i64> { self.pinned_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatReplyMarkup
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,
  
}



impl Object for UpdateChatReplyMarkup {}
impl RObject for UpdateChatReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatReplyMarkup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatReplyMarkup {}


impl UpdateChatReplyMarkup {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_markup_message_id(&self) -> Option<i64> { self.reply_markup_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatDraftMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new draft message; may be null.
  draft_message: Option<DraftMessage>,
  /// New value of the chat order.
  order: Option<i64>,
  
}



impl Object for UpdateChatDraftMessage {}
impl RObject for UpdateChatDraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatDraftMessage" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatDraftMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatDraftMessage {}


impl UpdateChatDraftMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn order(&self) -> Option<i64> { self.order.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOnlineMemberCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateChatOnlineMemberCount
  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// New number of online members in the chat, or 0 if unknown.
  online_member_count: Option<i32>,
  
}



impl Object for UpdateChatOnlineMemberCount {}
impl RObject for UpdateChatOnlineMemberCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateChatOnlineMemberCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateChatOnlineMemberCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateChatOnlineMemberCount {}


impl UpdateChatOnlineMemberCount {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn online_member_count(&self) -> Option<i32> { self.online_member_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A notification was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNotification
  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// Changed notification.
  notification: Option<Notification>,
  
}



impl Object for UpdateNotification {}
impl RObject for UpdateNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNotification {}


impl UpdateNotification {
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn notification(&self) -> Option<Notification> { self.notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A list of active notifications in a notification group has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNotificationGroup
  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// New type of the notification group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Chat identifier, which notification settings must be applied to the added notifications.
  notification_settings_chat_id: Option<i64>,
  /// True, if the notifications should be shown without sound.
  is_silent: Option<bool>,
  /// Total number of unread notifications in the group, can be bigger than number of active notifications.
  total_count: Option<i32>,
  /// List of added group notifications, sorted by notification ID.
  added_notifications: Option<Vec<Notification>>,
  /// Identifiers of removed group notifications, sorted by notification ID.
  removed_notification_ids: Option<Vec<i32>>,
  
}


impl Clone for UpdateNotificationGroup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateNotificationGroup {}
impl RObject for UpdateNotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNotificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNotificationGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNotificationGroup {}


impl UpdateNotificationGroup {
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn type_(&self) -> Option<Box<NotificationGroupType>> { self.type_.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings_chat_id(&self) -> Option<i64> { self.notification_settings_chat_id.clone() }
  
  pub fn is_silent(&self) -> Option<bool> { self.is_silent.clone() }
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn added_notifications(&self) -> Option<Vec<Notification>> { self.added_notifications.clone() }
  
  pub fn removed_notification_ids(&self) -> Option<Vec<i32>> { self.removed_notification_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains active notifications that was shown on previous application launches. This update is sent only if a message database is used. In that case it comes once before any 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateActiveNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateActiveNotifications
  /// Lists of active notification groups.
  groups: Option<Vec<NotificationGroup>>,
  
}



impl Object for UpdateActiveNotifications {}
impl RObject for UpdateActiveNotifications {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateActiveNotifications" }
  fn td_type(&self) -> RTDType { RTDType::UpdateActiveNotifications }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateActiveNotifications {}


impl UpdateActiveNotifications {
  
  pub fn groups(&self) -> Option<Vec<NotificationGroup>> { self.groups.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes, whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateHavePendingNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateHavePendingNotifications
  /// True, if there are some delayed notification updates, which will be sent soon.
  have_delayed_notifications: Option<bool>,
  /// True, if there can be some yet unreceived notifications, which are being fetched from the server.
  have_unreceived_notifications: Option<bool>,
  
}



impl Object for UpdateHavePendingNotifications {}
impl RObject for UpdateHavePendingNotifications {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateHavePendingNotifications" }
  fn td_type(&self) -> RTDType { RTDType::UpdateHavePendingNotifications }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateHavePendingNotifications {}


impl UpdateHavePendingNotifications {
  
  pub fn have_delayed_notifications(&self) -> Option<bool> { self.have_delayed_notifications.clone() }
  
  pub fn have_unreceived_notifications(&self) -> Option<bool> { self.have_unreceived_notifications.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some messages were deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateDeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateDeleteMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the deleted messages.
  message_ids: Option<Vec<i64>>,
  /// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible).
  is_permanent: Option<bool>,
  /// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future.
  from_cache: Option<bool>,
  
}



impl Object for UpdateDeleteMessages {}
impl RObject for UpdateDeleteMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateDeleteMessages" }
  fn td_type(&self) -> RTDType { RTDType::UpdateDeleteMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateDeleteMessages {}


impl UpdateDeleteMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn is_permanent(&self) -> Option<bool> { self.is_permanent.clone() }
  
  pub fn from_cache(&self) -> Option<bool> { self.from_cache.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// User activity in the chat has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserChatAction
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of a user performing an action.
  user_id: Option<i32>,
  /// The action description.
  action: Option<Box<ChatAction>>,
  
}


impl Clone for UpdateUserChatAction {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateUserChatAction {}
impl RObject for UpdateUserChatAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserChatAction" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserChatAction }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUserChatAction {}


impl UpdateUserChatAction {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user went online or offline. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserStatus
  /// User identifier.
  user_id: Option<i32>,
  /// New status of the user.
  status: Option<Box<UserStatus>>,
  
}


impl Clone for UpdateUserStatus {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateUserStatus {}
impl RObject for UpdateUserStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserStatus" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserStatus }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUserStatus {}


impl UpdateUserStatus {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<UserStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUser
  /// New data about the user.
  user: Option<User>,
  
}



impl Object for UpdateUser {}
impl RObject for UpdateUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUser" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUser {}


impl UpdateUser {
  
  pub fn user(&self) -> Option<User> { self.user.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateBasicGroup
  /// New data about the group.
  basic_group: Option<BasicGroup>,
  
}



impl Object for UpdateBasicGroup {}
impl RObject for UpdateBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateBasicGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateBasicGroup {}


impl UpdateBasicGroup {
  
  pub fn basic_group(&self) -> Option<BasicGroup> { self.basic_group.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSupergroup
  /// New data about the supergroup.
  supergroup: Option<Supergroup>,
  
}



impl Object for UpdateSupergroup {}
impl RObject for UpdateSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSupergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateSupergroup {}


impl UpdateSupergroup {
  
  pub fn supergroup(&self) -> Option<Supergroup> { self.supergroup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSecretChat
  /// New data about the secret chat.
  secret_chat: Option<SecretChat>,
  
}



impl Object for UpdateSecretChat {}
impl RObject for UpdateSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateSecretChat {}


impl UpdateSecretChat {
  
  pub fn secret_chat(&self) -> Option<SecretChat> { self.secret_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserFullInfo
  /// User identifier.
  user_id: Option<i32>,
  /// New full information about the user.
  user_full_info: Option<UserFullInfo>,
  
}



impl Object for UpdateUserFullInfo {}
impl RObject for UpdateUserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUserFullInfo {}


impl UpdateUserFullInfo {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn user_full_info(&self) -> Option<UserFullInfo> { self.user_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateBasicGroupFullInfo
  /// Identifier of a basic group.
  basic_group_id: Option<i32>,
  /// New full information about the group.
  basic_group_full_info: Option<BasicGroupFullInfo>,
  
}



impl Object for UpdateBasicGroupFullInfo {}
impl RObject for UpdateBasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateBasicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateBasicGroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateBasicGroupFullInfo {}


impl UpdateBasicGroupFullInfo {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn basic_group_full_info(&self) -> Option<BasicGroupFullInfo> { self.basic_group_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSupergroupFullInfo
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New full information about the supergroup.
  supergroup_full_info: Option<SupergroupFullInfo>,
  
}



impl Object for UpdateSupergroupFullInfo {}
impl RObject for UpdateSupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSupergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSupergroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateSupergroupFullInfo {}


impl UpdateSupergroupFullInfo {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn supergroup_full_info(&self) -> Option<SupergroupFullInfo> { self.supergroup_full_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Service notification from the server. Upon receiving this the client must show a popup with the content of the notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateServiceNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateServiceNotification
  /// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" should be shown under notification; if user presses the second, all local data should be destroyed using Destroy method.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Notification content.
  content: Option<Box<MessageContent>>,
  
}


impl Clone for UpdateServiceNotification {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateServiceNotification {}
impl RObject for UpdateServiceNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateServiceNotification" }
  fn td_type(&self) -> RTDType { RTDType::UpdateServiceNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateServiceNotification {}


impl UpdateServiceNotification {
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn content(&self) -> Option<Box<MessageContent>> { self.content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Information about a file was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFile
  /// New data about the file.
  file: Option<File>,
  
}



impl Object for UpdateFile {}
impl RObject for UpdateFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFile" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateFile {}


impl UpdateFile {
  
  pub fn file(&self) -> Option<File> { self.file.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The file generation process needs to be started by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFileGenerationStart
  /// Unique identifier for the generation process.
  generation_id: Option<i64>,
  /// The path to a file from which a new file is generated; may be empty.
  original_path: Option<String>,
  /// The path to a file that should be created and where the new file should be generated.
  destination_path: Option<String>,
  /// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which should be downloaded by the client.
  conversion: Option<String>,
  
}



impl Object for UpdateFileGenerationStart {}
impl RObject for UpdateFileGenerationStart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFileGenerationStart" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFileGenerationStart }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateFileGenerationStart {}


impl UpdateFileGenerationStart {
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn original_path(&self) -> Option<String> { self.original_path.clone() }
  
  pub fn destination_path(&self) -> Option<String> { self.destination_path.clone() }
  
  pub fn conversion(&self) -> Option<String> { self.conversion.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// File generation is no longer needed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFileGenerationStop
  /// Unique identifier for the generation process.
  generation_id: Option<i64>,
  
}



impl Object for UpdateFileGenerationStop {}
impl RObject for UpdateFileGenerationStop {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFileGenerationStop" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFileGenerationStop }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateFileGenerationStop {}


impl UpdateFileGenerationStop {
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New call was created or information about a call was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateCall
  /// New data about a call.
  call: Option<Call>,
  
}



impl Object for UpdateCall {}
impl RObject for UpdateCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateCall" }
  fn td_type(&self) -> RTDType { RTDType::UpdateCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateCall {}


impl UpdateCall {
  
  pub fn call(&self) -> Option<Call> { self.call.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some privacy setting rules have been changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// New privacy rules.
  rules: Option<UserPrivacySettingRules>,
  
}


impl Clone for UpdateUserPrivacySettingRules {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateUserPrivacySettingRules {}
impl RObject for UpdateUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUserPrivacySettingRules }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUserPrivacySettingRules {}


impl UpdateUserPrivacySettingRules {
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn rules(&self) -> Option<UserPrivacySettingRules> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Number of unread messages has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUnreadMessageCount
  /// Total number of unread messages.
  unread_count: Option<i32>,
  /// Total number of unread messages in unmuted chats.
  unread_unmuted_count: Option<i32>,
  
}



impl Object for UpdateUnreadMessageCount {}
impl RObject for UpdateUnreadMessageCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUnreadMessageCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUnreadMessageCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUnreadMessageCount {}


impl UpdateUnreadMessageCount {
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn unread_unmuted_count(&self) -> Option<i32> { self.unread_unmuted_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadChatCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateUnreadChatCount
  /// Total number of unread chats.
  unread_count: Option<i32>,
  /// Total number of unread unmuted chats.
  unread_unmuted_count: Option<i32>,
  /// Total number of chats marked as unread.
  marked_as_unread_count: Option<i32>,
  /// Total number of unmuted chats marked as unread.
  marked_as_unread_unmuted_count: Option<i32>,
  
}



impl Object for UpdateUnreadChatCount {}
impl RObject for UpdateUnreadChatCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateUnreadChatCount" }
  fn td_type(&self) -> RTDType { RTDType::UpdateUnreadChatCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateUnreadChatCount {}


impl UpdateUnreadChatCount {
  
  pub fn unread_count(&self) -> Option<i32> { self.unread_count.clone() }
  
  pub fn unread_unmuted_count(&self) -> Option<i32> { self.unread_unmuted_count.clone() }
  
  pub fn marked_as_unread_count(&self) -> Option<i32> { self.marked_as_unread_count.clone() }
  
  pub fn marked_as_unread_unmuted_count(&self) -> Option<i32> { self.marked_as_unread_unmuted_count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// An option changed its value. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateOption
  /// The option name.
  name: Option<String>,
  /// The new option value.
  value: Option<Box<OptionValue>>,
  
}


impl Clone for UpdateOption {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateOption {}
impl RObject for UpdateOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateOption" }
  fn td_type(&self) -> RTDType { RTDType::UpdateOption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateOption {}


impl UpdateOption {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn value(&self) -> Option<Box<OptionValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of installed sticker sets was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateInstalledStickerSets
  /// True, if the list of installed mask sticker sets was updated.
  is_masks: Option<bool>,
  /// The new list of installed ordinary sticker sets.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for UpdateInstalledStickerSets {}
impl RObject for UpdateInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::UpdateInstalledStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateInstalledStickerSets {}


impl UpdateInstalledStickerSets {
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of trending sticker sets was updated or some of them were viewed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateTrendingStickerSets
  /// The new list of trending sticker sets.
  sticker_sets: Option<StickerSets>,
  
}



impl Object for UpdateTrendingStickerSets {}
impl RObject for UpdateTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::UpdateTrendingStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateTrendingStickerSets {}


impl UpdateTrendingStickerSets {
  
  pub fn sticker_sets(&self) -> Option<StickerSets> { self.sticker_sets.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of recently used stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateRecentStickers
  /// True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated.
  is_attached: Option<bool>,
  /// The new list of file identifiers of recently used stickers.
  sticker_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateRecentStickers {}
impl RObject for UpdateRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::UpdateRecentStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateRecentStickers {}


impl UpdateRecentStickers {
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker_ids(&self) -> Option<Vec<i32>> { self.sticker_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of favorite stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateFavoriteStickers
  /// The new list of file identifiers of favorite stickers.
  sticker_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateFavoriteStickers {}
impl RObject for UpdateFavoriteStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateFavoriteStickers" }
  fn td_type(&self) -> RTDType { RTDType::UpdateFavoriteStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateFavoriteStickers {}


impl UpdateFavoriteStickers {
  
  pub fn sticker_ids(&self) -> Option<Vec<i32>> { self.sticker_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The list of saved animations was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateSavedAnimations
  /// The new list of file identifiers of saved animations.
  animation_ids: Option<Vec<i32>>,
  
}



impl Object for UpdateSavedAnimations {}
impl RObject for UpdateSavedAnimations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateSavedAnimations" }
  fn td_type(&self) -> RTDType { RTDType::UpdateSavedAnimations }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateSavedAnimations {}


impl UpdateSavedAnimations {
  
  pub fn animation_ids(&self) -> Option<Vec<i32>> { self.animation_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Some language pack strings have been updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateLanguagePackStrings
  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Identifier of the updated language pack.
  language_pack_id: Option<String>,
  /// List of changed language pack strings.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for UpdateLanguagePackStrings {}
impl RObject for UpdateLanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateLanguagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::UpdateLanguagePackStrings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateLanguagePackStrings {}


impl UpdateLanguagePackStrings {
  
  pub fn localization_target(&self) -> Option<String> { self.localization_target.clone() }
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The connection state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateConnectionState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateConnectionState
  /// The new connection state.
  state: Option<Box<ConnectionState>>,
  
}


impl Clone for UpdateConnectionState {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateConnectionState {}
impl RObject for UpdateConnectionState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateConnectionState" }
  fn td_type(&self) -> RTDType { RTDType::UpdateConnectionState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateConnectionState {}


impl UpdateConnectionState {
  
  pub fn state(&self) -> Option<Box<ConnectionState>> { self.state.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// New terms of service must be accepted by the user. If the terms of service are declined, then the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateTermsOfService
  /// Identifier of the terms of service.
  terms_of_service_id: Option<String>,
  /// The new terms of service.
  terms_of_service: Option<TermsOfService>,
  
}



impl Object for UpdateTermsOfService {}
impl RObject for UpdateTermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateTermsOfService" }
  fn td_type(&self) -> RTDType { RTDType::UpdateTermsOfService }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateTermsOfService {}


impl UpdateTermsOfService {
  
  pub fn terms_of_service_id(&self) -> Option<String> { self.terms_of_service_id.clone() }
  
  pub fn terms_of_service(&self) -> Option<TermsOfService> { self.terms_of_service.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewInlineQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,
  
}



impl Object for UpdateNewInlineQuery {}
impl RObject for UpdateNewInlineQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewInlineQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewInlineQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewInlineQuery {}


impl UpdateNewInlineQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset(&self) -> Option<String> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user has chosen a result of an inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChosenInlineResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewChosenInlineResult
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Identifier of the chosen result.
  result_id: Option<String>,
  /// Identifier of the sent inline message, if known.
  inline_message_id: Option<String>,
  
}



impl Object for UpdateNewChosenInlineResult {}
impl RObject for UpdateNewChosenInlineResult {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewChosenInlineResult" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewChosenInlineResult }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewChosenInlineResult {}


impl UpdateNewChosenInlineResult {
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn result_id(&self) -> Option<String> { self.result_id.clone() }
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming callback query; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCallbackQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the chat, in which the query was sent.
  chat_id: Option<i64>,
  /// Identifier of the message, from which the query originated.
  message_id: Option<i64>,
  /// Identifier that uniquely corresponds to the chat to which the message was sent.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for UpdateNewCallbackQuery {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateNewCallbackQuery {}
impl RObject for UpdateNewCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCallbackQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewCallbackQuery {}


impl UpdateNewCallbackQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn chat_instance(&self) -> Option<i64> { self.chat_instance.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming callback query from a message sent via a bot; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewInlineCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewInlineCallbackQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the inline message, from which the query originated.
  inline_message_id: Option<String>,
  /// An identifier uniquely corresponding to the chat a message was sent to.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for UpdateNewInlineCallbackQuery {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UpdateNewInlineCallbackQuery {}
impl RObject for UpdateNewInlineCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewInlineCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewInlineCallbackQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewInlineCallbackQuery {}


impl UpdateNewInlineCallbackQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn chat_instance(&self) -> Option<i64> { self.chat_instance.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming shipping query; for bots only. Only for invoices with flexible price. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewShippingQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// User shipping address.
  shipping_address: Option<Address>,
  
}



impl Object for UpdateNewShippingQuery {}
impl RObject for UpdateNewShippingQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewShippingQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewShippingQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewShippingQuery {}


impl UpdateNewShippingQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_address(&self) -> Option<Address> { self.shipping_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming pre-checkout query; for bots only. Contains full information about a checkout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewPreCheckoutQuery
  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of a shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,
  
}



impl Object for UpdateNewPreCheckoutQuery {}
impl RObject for UpdateNewPreCheckoutQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewPreCheckoutQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewPreCheckoutQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewPreCheckoutQuery {}


impl UpdateNewPreCheckoutQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn currency(&self) -> Option<String> { self.currency.clone() }
  
  pub fn total_amount(&self) -> Option<i64> { self.total_amount.clone() }
  
  pub fn invoice_payload(&self) -> Option<String> { self.invoice_payload.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming event; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCustomEvent
  /// A JSON-serialized event.
  event: Option<String>,
  
}



impl Object for UpdateNewCustomEvent {}
impl RObject for UpdateNewCustomEvent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCustomEvent" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCustomEvent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewCustomEvent {}


impl UpdateNewCustomEvent {
  
  pub fn event(&self) -> Option<String> { self.event.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A new incoming query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updateNewCustomQuery
  /// The query identifier.
  id: Option<i64>,
  /// JSON-serialized query data.
  data: Option<String>,
  /// Query timeout.
  timeout: Option<i32>,
  
}



impl Object for UpdateNewCustomQuery {}
impl RObject for UpdateNewCustomQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updateNewCustomQuery" }
  fn td_type(&self) -> RTDType { RTDType::UpdateNewCustomQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdateNewCustomQuery {}


impl UpdateNewCustomQuery {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn timeout(&self) -> Option<i32> { self.timeout.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Information about a poll was updated; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdatePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updatePoll
  /// New data about the poll.
  poll: Option<Poll>,
  
}



impl Object for UpdatePoll {}
impl RObject for UpdatePoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updatePoll" }
  fn td_type(&self) -> RTDType { RTDType::UpdatePoll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl Update for UpdatePoll {}


impl UpdatePoll {
  
  pub fn poll(&self) -> Option<Poll> { self.poll.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of updates. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Updates {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // updates
  /// List of updates.
  updates: Option<Vec<Box<Update>>>,
  
}


impl Clone for Updates {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for Updates {}
impl RObject for Updates {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "updates" }
  fn td_type(&self) -> RTDType { RTDType::Updates }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Updates {
  
  pub fn updates(&self) -> Option<Vec<Box<Update>>> { self.updates.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a user. 
#[derive(Debug, Serialize, Deserialize)]
pub struct User {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // user
  /// User identifier.
  id: Option<i32>,
  /// First name of the user.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Username of the user.
  username: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Current online status of the user.
  status: Option<Box<UserStatus>>,
  /// Profile photo of the user; may be null.
  profile_photo: Option<ProfilePhoto>,
  /// Relationship from the current user to the other user.
  outgoing_link: Option<Box<LinkState>>,
  /// Relationship from the other user to the current user.
  incoming_link: Option<Box<LinkState>>,
  /// True, if the user is verified.
  is_verified: Option<bool>,
  /// True, if the user is Telegram support account.
  is_support: Option<bool>,
  /// If non-empty, it contains the reason why access to this user must be restricted. The format of the string is "{type}: {description}". {type} contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,
  /// If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser.
  have_access: Option<bool>,
  /// Type of the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<UserType>>,
  /// IETF language tag of the user's language; only available to bots.
  language_code: Option<String>,
  
}


impl Clone for User {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for User {}
impl RObject for User {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "user" }
  fn td_type(&self) -> RTDType { RTDType::User }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl User {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn status(&self) -> Option<Box<UserStatus>> { self.status.clone() }
  
  pub fn profile_photo(&self) -> Option<ProfilePhoto> { self.profile_photo.clone() }
  
  pub fn outgoing_link(&self) -> Option<Box<LinkState>> { self.outgoing_link.clone() }
  
  pub fn incoming_link(&self) -> Option<Box<LinkState>> { self.incoming_link.clone() }
  
  pub fn is_verified(&self) -> Option<bool> { self.is_verified.clone() }
  
  pub fn is_support(&self) -> Option<bool> { self.is_support.clone() }
  
  pub fn restriction_reason(&self) -> Option<String> { self.restriction_reason.clone() }
  
  pub fn have_access(&self) -> Option<bool> { self.have_access.clone() }
  
  pub fn type_(&self) -> Option<Box<UserType>> { self.type_.clone() }
  
  pub fn language_code(&self) -> Option<String> { self.language_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains full information about a user (except the full list of profile photos). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userFullInfo
  /// True, if the user is blacklisted by the current user.
  is_blocked: Option<bool>,
  /// True, if the user can be called.
  can_be_called: Option<bool>,
  /// True, if the user can't be called due to their privacy settings.
  has_private_calls: Option<bool>,
  /// A short user bio.
  bio: Option<String>,
  /// For bots, the text that is included with the link when users share the bot.
  share_text: Option<String>,
  /// Number of group chats where both the other user and the current user are a member; 0 for the current user.
  group_in_common_count: Option<i32>,
  /// If the user is a bot, information about the bot; may be null.
  bot_info: Option<BotInfo>,
  
}



impl Object for UserFullInfo {}
impl RObject for UserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::UserFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl UserFullInfo {
  
  pub fn is_blocked(&self) -> Option<bool> { self.is_blocked.clone() }
  
  pub fn can_be_called(&self) -> Option<bool> { self.can_be_called.clone() }
  
  pub fn has_private_calls(&self) -> Option<bool> { self.has_private_calls.clone() }
  
  pub fn bio(&self) -> Option<String> { self.bio.clone() }
  
  pub fn share_text(&self) -> Option<String> { self.share_text.clone() }
  
  pub fn group_in_common_count(&self) -> Option<i32> { self.group_in_common_count.clone() }
  
  pub fn bot_info(&self) -> Option<BotInfo> { self.bot_info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes available user privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySetting: Object + RObject + Debug {}






impl UserPrivacySetting {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<UserPrivacySetting> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserPrivacySettingType {
  UserPrivacySettingAllowCalls,
  UserPrivacySettingAllowChatInvites,
  UserPrivacySettingAllowPeerToPeerCalls,
  UserPrivacySettingShowStatus,
  
}
impl RTDUserPrivacySettingType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDUserPrivacySettingType)(text.as_ref()) }
}



/// A privacy setting for managing whether the user's online status is visible. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingShowStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingShowStatus
  
}



impl Object for UserPrivacySettingShowStatus {}
impl RObject for UserPrivacySettingShowStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingShowStatus" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingShowStatus }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingShowStatus {}


impl UserPrivacySettingShowStatus {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A privacy setting for managing whether the user can be invited to chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowChatInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowChatInvites
  
}



impl Object for UserPrivacySettingAllowChatInvites {}
impl RObject for UserPrivacySettingAllowChatInvites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowChatInvites" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowChatInvites }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowChatInvites {}


impl UserPrivacySettingAllowChatInvites {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A privacy setting for managing whether the user can be called. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowCalls
  
}



impl Object for UserPrivacySettingAllowCalls {}
impl RObject for UserPrivacySettingAllowCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowCalls" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowCalls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowCalls {}


impl UserPrivacySettingAllowCalls {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A privacy setting for managing whether peer-to-peer connections can be used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowPeerToPeerCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingAllowPeerToPeerCalls
  
}



impl Object for UserPrivacySettingAllowPeerToPeerCalls {}
impl RObject for UserPrivacySettingAllowPeerToPeerCalls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingAllowPeerToPeerCalls" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingAllowPeerToPeerCalls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySetting for UserPrivacySettingAllowPeerToPeerCalls {}


impl UserPrivacySettingAllowPeerToPeerCalls {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents a single rule for managing privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySettingRule: Object + RObject + Debug {}






impl UserPrivacySettingRule {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<UserPrivacySettingRule> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserPrivacySettingRuleType {
  UserPrivacySettingRuleAllowAll,
  UserPrivacySettingRuleAllowContacts,
  UserPrivacySettingRuleAllowUsers,
  UserPrivacySettingRuleRestrictAll,
  UserPrivacySettingRuleRestrictContacts,
  UserPrivacySettingRuleRestrictUsers,
  
}
impl RTDUserPrivacySettingRuleType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDUserPrivacySettingRuleType)(text.as_ref()) }
}



/// A rule to allow all users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowAll
  
}



impl Object for UserPrivacySettingRuleAllowAll {}
impl RObject for UserPrivacySettingRuleAllowAll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowAll" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowAll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowAll {}


impl UserPrivacySettingRuleAllowAll {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rule to allow all of a user's contacts to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowContacts
  
}



impl Object for UserPrivacySettingRuleAllowContacts {}
impl RObject for UserPrivacySettingRuleAllowContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowContacts" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowContacts {}


impl UserPrivacySettingRuleAllowContacts {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rule to allow certain specified users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleAllowUsers
  /// The user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for UserPrivacySettingRuleAllowUsers {}
impl RObject for UserPrivacySettingRuleAllowUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleAllowUsers" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleAllowUsers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleAllowUsers {}


impl UserPrivacySettingRuleAllowUsers {
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rule to restrict all users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictAll
  
}



impl Object for UserPrivacySettingRuleRestrictAll {}
impl RObject for UserPrivacySettingRuleRestrictAll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictAll" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictAll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictAll {}


impl UserPrivacySettingRuleRestrictAll {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rule to restrict all contacts of a user from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictContacts
  
}



impl Object for UserPrivacySettingRuleRestrictContacts {}
impl RObject for UserPrivacySettingRuleRestrictContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictContacts" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictContacts {}


impl UserPrivacySettingRuleRestrictContacts {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A rule to restrict all specified users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRuleRestrictUsers
  /// The user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for UserPrivacySettingRuleRestrictUsers {}
impl RObject for UserPrivacySettingRuleRestrictUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRuleRestrictUsers" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRuleRestrictUsers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictUsers {}


impl UserPrivacySettingRuleRestrictUsers {
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userPrivacySettingRules
  /// A list of rules.
  rules: Option<Vec<Box<UserPrivacySettingRule>>>,
  
}


impl Clone for UserPrivacySettingRules {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UserPrivacySettingRules {}
impl RObject for UserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::UserPrivacySettingRules }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl UserPrivacySettingRules {
  
  pub fn rules(&self) -> Option<Vec<Box<UserPrivacySettingRule>>> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains full information about a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userProfilePhoto
  /// Unique user profile photo identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the photo has been added.
  added_date: Option<i32>,
  /// Available variants of the user photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,
  
}



impl Object for UserProfilePhoto {}
impl RObject for UserProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::UserProfilePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl UserProfilePhoto {
  
  pub fn id(&self) -> Option<i64> { self.id.clone() }
  
  pub fn added_date(&self) -> Option<i32> { self.added_date.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains part of the list of user photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userProfilePhotos
  /// Total number of user profile photos.
  total_count: Option<i32>,
  /// A list of photos.
  photos: Option<Vec<UserProfilePhoto>>,
  
}



impl Object for UserProfilePhotos {}
impl RObject for UserProfilePhotos {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userProfilePhotos" }
  fn td_type(&self) -> RTDType { RTDType::UserProfilePhotos }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl UserProfilePhotos {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn photos(&self) -> Option<Vec<UserProfilePhoto>> { self.photos.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Describes the last time the user was online. 
#[typetag::serde(tag = "@struct")]
pub trait UserStatus: Object + RObject + Debug {}






impl UserStatus {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<UserStatus> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserStatusType {
  UserStatusEmpty,
  UserStatusLastMonth,
  UserStatusLastWeek,
  UserStatusOffline,
  UserStatusOnline,
  UserStatusRecently,
  
}
impl RTDUserStatusType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDUserStatusType)(text.as_ref()) }
}



/// The user status was never changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusEmpty
  
}



impl Object for UserStatusEmpty {}
impl RObject for UserStatusEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusEmpty" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusEmpty {}


impl UserStatusEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOnline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusOnline
  /// Point in time (Unix timestamp) when the user's online status will expire.
  expires: Option<i32>,
  
}



impl Object for UserStatusOnline {}
impl RObject for UserStatusOnline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusOnline" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusOnline }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusOnline {}


impl UserStatusOnline {
  
  pub fn expires(&self) -> Option<i32> { self.expires.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOffline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusOffline
  /// Point in time (Unix timestamp) when the user was last online.
  was_online: Option<i32>,
  
}



impl Object for UserStatusOffline {}
impl RObject for UserStatusOffline {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusOffline" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusOffline }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusOffline {}


impl UserStatusOffline {
  
  pub fn was_online(&self) -> Option<i32> { self.was_online.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user was online recently. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusRecently {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusRecently
  
}



impl Object for UserStatusRecently {}
impl RObject for UserStatusRecently {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusRecently" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusRecently }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusRecently {}


impl UserStatusRecently {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is offline, but was online last week. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastWeek {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusLastWeek
  
}



impl Object for UserStatusLastWeek {}
impl RObject for UserStatusLastWeek {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusLastWeek" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusLastWeek }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusLastWeek {}


impl UserStatusLastWeek {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// The user is offline, but was online last month. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastMonth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userStatusLastMonth
  
}



impl Object for UserStatusLastMonth {}
impl RObject for UserStatusLastMonth {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userStatusLastMonth" }
  fn td_type(&self) -> RTDType { RTDType::UserStatusLastMonth }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserStatus for UserStatusLastMonth {}


impl UserStatusLastMonth {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// This class is an abstract base class. Represents the type of the user. The following types are possible: regular users, deleted users and bots. 
#[typetag::serde(tag = "@struct")]
pub trait UserType: Object + RObject + Debug {}






impl UserType {
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Box<Self>> { from_json!()(json.as_ref()) }
}
impl Clone for Box<UserType> {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


#[derive(Debug, Clone, PartialEq, PartialOrd, Eq, Ord, Hash, EnumString)]
pub enum RTDUserTypeType {
  UserTypeBot,
  UserTypeDeleted,
  UserTypeRegular,
  UserTypeUnknown,
  
}
impl RTDUserTypeType {
  pub fn of<S: AsRef<str>>(text: S) -> Option<Self> { rtd_of!(RTDUserTypeType)(text.as_ref()) }
}



/// A regular user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeRegular {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeRegular
  
}



impl Object for UserTypeRegular {}
impl RObject for UserTypeRegular {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeRegular" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeRegular }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserType for UserTypeRegular {}


impl UserTypeRegular {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A deleted user or deleted bot. No information on the user besides the user_id is available. It is not possible to perform any active actions on this type of user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeDeleted
  
}



impl Object for UserTypeDeleted {}
impl RObject for UserTypeDeleted {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeDeleted" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeDeleted }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserType for UserTypeDeleted {}


impl UserTypeDeleted {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// A bot (see 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeBot
  /// True, if the bot can be invited to basic group and supergroup chats.
  can_join_groups: Option<bool>,
  /// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages.
  can_read_all_group_messages: Option<bool>,
  /// True, if the bot supports inline queries.
  is_inline: Option<bool>,
  /// Placeholder for inline queries (displayed on the client input field).
  inline_query_placeholder: Option<String>,
  /// True, if the location of the user should be sent with every inline query to this bot.
  need_location: Option<bool>,
  
}



impl Object for UserTypeBot {}
impl RObject for UserTypeBot {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeBot" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeBot }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserType for UserTypeBot {}


impl UserTypeBot {
  
  pub fn can_join_groups(&self) -> Option<bool> { self.can_join_groups.clone() }
  
  pub fn can_read_all_group_messages(&self) -> Option<bool> { self.can_read_all_group_messages.clone() }
  
  pub fn is_inline(&self) -> Option<bool> { self.is_inline.clone() }
  
  pub fn inline_query_placeholder(&self) -> Option<String> { self.inline_query_placeholder.clone() }
  
  pub fn need_location(&self) -> Option<bool> { self.need_location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// No information on the user besides the user_id is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // userTypeUnknown
  
}



impl Object for UserTypeUnknown {}
impl RObject for UserTypeUnknown {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "userTypeUnknown" }
  fn td_type(&self) -> RTDType { RTDType::UserTypeUnknown }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


#[typetag::serde] impl UserType for UserTypeUnknown {}


impl UserTypeUnknown {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Represents a list of users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Users {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // users
  /// Approximate total count of users found.
  total_count: Option<i32>,
  /// A list of user identifiers.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for Users {}
impl RObject for Users {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "users" }
  fn td_type(&self) -> RTDType { RTDType::Users }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Users {
  
  pub fn total_count(&self) -> Option<i32> { self.total_count.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // validatedOrderInfo
  /// Temporary identifier of the order information.
  order_info_id: Option<String>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,
  
}



impl Object for ValidatedOrderInfo {}
impl RObject for ValidatedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "validatedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::ValidatedOrderInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl ValidatedOrderInfo {
  
  pub fn order_info_id(&self) -> Option<String> { self.order_info_id.clone() }
  
  pub fn shipping_options(&self) -> Option<Vec<ShippingOption>> { self.shipping_options.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Venue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // venue
  /// Venue location; as defined by the sender.
  location: Option<Location>,
  /// Venue name; as defined by the sender.
  title: Option<String>,
  /// Venue address; as defined by the sender.
  address: Option<String>,
  /// Provider of the venue database; as defined by the sender. Currently only "foursquare" needs to be supported.
  provider: Option<String>,
  /// Identifier of the venue in the provider database; as defined by the sender.
  id: Option<String>,
  /// Type of the venue in the provider database; as defined by the sender.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  
}



impl Object for Venue {}
impl RObject for Venue {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "venue" }
  fn td_type(&self) -> RTDType { RTDType::Venue }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Venue {
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn address(&self) -> Option<String> { self.address.clone() }
  
  pub fn provider(&self) -> Option<String> { self.provider.clone() }
  
  pub fn id(&self) -> Option<String> { self.id.clone() }
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a video file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Video {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // video
  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width; as defined by the sender.
  width: Option<i32>,
  /// Video height; as defined by the sender.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,
  
}



impl Object for Video {}
impl RObject for Video {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "video" }
  fn td_type(&self) -> RTDType { RTDType::Video }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Video {
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn has_stickers(&self) -> Option<bool> { self.has_stickers.clone() }
  
  pub fn supports_streaming(&self) -> Option<bool> { self.supports_streaming.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn video(&self) -> Option<File> { self.video.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // videoNote
  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width and height; as defined by the sender.
  length: Option<i32>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,
  
}



impl Object for VideoNote {}
impl RObject for VideoNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "videoNote" }
  fn td_type(&self) -> RTDType { RTDType::VideoNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl VideoNote {
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn length(&self) -> Option<i32> { self.length.clone() }
  
  pub fn thumbnail(&self) -> Option<PhotoSize> { self.thumbnail.clone() }
  
  pub fn video(&self) -> Option<File> { self.video.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // voiceNote
  /// Duration of the voice note, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// A waveform representation of the voice note in 5-bit format.
  waveform: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// File containing the voice note.
  voice: Option<File>,
  
}



impl Object for VoiceNote {}
impl RObject for VoiceNote {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "voiceNote" }
  fn td_type(&self) -> RTDType { RTDType::VoiceNote }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl VoiceNote {
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn waveform(&self) -> Option<String> { self.waveform.clone() }
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn voice(&self) -> Option<File> { self.voice.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains information about a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // wallpaper
  /// Unique persistent wallpaper identifier.
  id: Option<i32>,
  /// Available variants of the wallpaper in different sizes. These photos can only be downloaded; they can't be sent in a message.
  sizes: Option<Vec<PhotoSize>>,
  /// Main color of the wallpaper in RGB24 format; should be treated as background color if no photos are specified.
  color: Option<i32>,
  
}



impl Object for Wallpaper {}
impl RObject for Wallpaper {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "wallpaper" }
  fn td_type(&self) -> RTDType { RTDType::Wallpaper }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Wallpaper {
  
  pub fn id(&self) -> Option<i32> { self.id.clone() }
  
  pub fn sizes(&self) -> Option<Vec<PhotoSize>> { self.sizes.clone() }
  
  pub fn color(&self) -> Option<i32> { self.color.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Contains a list of wallpapers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // wallpapers
  /// A list of wallpapers.
  wallpapers: Option<Vec<Wallpaper>>,
  
}



impl Object for Wallpapers {}
impl RObject for Wallpapers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "wallpapers" }
  fn td_type(&self) -> RTDType { RTDType::Wallpapers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl Wallpapers {
  
  pub fn wallpapers(&self) -> Option<Vec<Wallpaper>> { self.wallpapers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes a web page preview. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebPage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // webPage
  /// Original URL of the link.
  url: Option<String>,
  /// URL to display.
  display_url: Option<String>,
  /// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Short name of the site (e.g., Google Docs, App Store).
  site_name: Option<String>,
  /// Title of the content.
  title: Option<String>,
  /// Description of the content.
  description: Option<String>,
  /// Image representing the content; may be null.
  photo: Option<Photo>,
  /// URL to show in the embedded preview.
  embed_url: Option<String>,
  /// MIME type of the embedded preview, (e.g., text/html or video/mp4).
  embed_type: Option<String>,
  /// Width of the embedded preview.
  embed_width: Option<i32>,
  /// Height of the embedded preview.
  embed_height: Option<i32>,
  /// Duration of the content, in seconds.
  duration: Option<i32>,
  /// Author of the content.
  author: Option<String>,
  /// Preview of the content as an animation, if available; may be null.
  animation: Option<Animation>,
  /// Preview of the content as an audio file, if available; may be null.
  audio: Option<Audio>,
  /// Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null.
  document: Option<Document>,
  /// Preview of the content as a sticker for small WEBP files, if available; may be null.
  sticker: Option<Sticker>,
  /// Preview of the content as a video, if available; may be null.
  video: Option<Video>,
  /// Preview of the content as a video note, if available; may be null.
  video_note: Option<VideoNote>,
  /// Preview of the content as a voice note, if available; may be null.
  voice_note: Option<VoiceNote>,
  /// Version of instant view, available for the web page (currently can be 1 or 2), 0 if none.
  instant_view_version: Option<i32>,
  
}



impl Object for WebPage {}
impl RObject for WebPage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "webPage" }
  fn td_type(&self) -> RTDType { RTDType::WebPage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl WebPage {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn display_url(&self) -> Option<String> { self.display_url.clone() }
  
  pub fn type_(&self) -> Option<String> { self.type_.clone() }
  
  pub fn site_name(&self) -> Option<String> { self.site_name.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn photo(&self) -> Option<Photo> { self.photo.clone() }
  
  pub fn embed_url(&self) -> Option<String> { self.embed_url.clone() }
  
  pub fn embed_type(&self) -> Option<String> { self.embed_type.clone() }
  
  pub fn embed_width(&self) -> Option<i32> { self.embed_width.clone() }
  
  pub fn embed_height(&self) -> Option<i32> { self.embed_height.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn author(&self) -> Option<String> { self.author.clone() }
  
  pub fn animation(&self) -> Option<Animation> { self.animation.clone() }
  
  pub fn audio(&self) -> Option<Audio> { self.audio.clone() }
  
  pub fn document(&self) -> Option<Document> { self.document.clone() }
  
  pub fn sticker(&self) -> Option<Sticker> { self.sticker.clone() }
  
  pub fn video(&self) -> Option<Video> { self.video.clone() }
  
  pub fn video_note(&self) -> Option<VideoNote> { self.video_note.clone() }
  
  pub fn voice_note(&self) -> Option<VoiceNote> { self.voice_note.clone() }
  
  pub fn instant_view_version(&self) -> Option<i32> { self.instant_view_version.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Describes an instant view page for a web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct WebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // webPageInstantView
  /// Content of the web page.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Version of the instant view, currently can be 1 or 2.
  version: Option<i32>,
  /// Instant view URL; may be different from WebPage.url and must be used for the correct anchors handling.
  url: Option<String>,
  /// True, if the instant view must be shown from right to left.
  is_rtl: Option<bool>,
  /// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view.
  is_full: Option<bool>,
  
}


impl Clone for WebPageInstantView {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for WebPageInstantView {}
impl RObject for WebPageInstantView {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "webPageInstantView" }
  fn td_type(&self) -> RTDType { RTDType::WebPageInstantView }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}



impl WebPageInstantView {
  
  pub fn page_blocks(&self) -> Option<Vec<Box<PageBlock>>> { self.page_blocks.clone() }
  
  pub fn version(&self) -> Option<i32> { self.version.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn is_rtl(&self) -> Option<bool> { self.is_rtl.clone() }
  
  pub fn is_full(&self) -> Option<bool> { self.is_full.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Accepts an incoming call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // acceptCall
  /// Call identifier.
  call_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,
  
}



impl Object for AcceptCall {}
impl RObject for AcceptCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "acceptCall" }
  fn td_type(&self) -> RTDType { RTDType::AcceptCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AcceptCall {}


impl AcceptCall {
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Accepts Telegram terms of services.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // acceptTermsOfService
  /// Terms of service identifier.
  terms_of_service_id: Option<String>,
  
}



impl Object for AcceptTermsOfService {}
impl RObject for AcceptTermsOfService {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "acceptTermsOfService" }
  fn td_type(&self) -> RTDType { RTDType::AcceptTermsOfService }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AcceptTermsOfService {}


impl AcceptTermsOfService {
  
  pub fn terms_of_service_id(&self) -> Option<String> { self.terms_of_service_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addChatMember
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the user.
  user_id: Option<i32>,
  /// The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels.
  forward_limit: Option<i32>,
  
}



impl Object for AddChatMember {}
impl RObject for AddChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addChatMember" }
  fn td_type(&self) -> RTDType { RTDType::AddChatMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddChatMember {}


impl AddChatMember {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn forward_limit(&self) -> Option<i32> { self.forward_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addChatMembers
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the users to be added to the chat.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for AddChatMembers {}
impl RObject for AddChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addChatMembers" }
  fn td_type(&self) -> RTDType { RTDType::AddChatMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddChatMembers {}


impl AddChatMembers {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddCustomServerLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addCustomServerLanguagePack
  /// Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link.
  language_pack_id: Option<String>,
  
}



impl Object for AddCustomServerLanguagePack {}
impl RObject for AddCustomServerLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addCustomServerLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::AddCustomServerLanguagePack }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddCustomServerLanguagePack {}


impl AddCustomServerLanguagePack {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addFavoriteSticker
  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for AddFavoriteSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddFavoriteSticker {}
impl RObject for AddFavoriteSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addFavoriteSticker" }
  fn td_type(&self) -> RTDType { RTDType::AddFavoriteSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddFavoriteSticker {}


impl AddFavoriteSticker {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddLocalMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addLocalMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the user who will be shown as the sender of the message; may be 0 for channel posts.
  sender_user_id: Option<i32>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message.
  disable_notification: Option<bool>,
  /// The content of the message to be added.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for AddLocalMessage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddLocalMessage {}
impl RObject for AddLocalMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addLocalMessage" }
  fn td_type(&self) -> RTDType { RTDType::AddLocalMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddLocalMessage {}


impl AddLocalMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a message to TDLib internal log. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddLogMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addLogMessage
  /// Minimum verbosity level needed for the message to be logged, 0-1023.
  verbosity_level: Option<i32>,
  /// Text of a message to log.
  text: Option<String>,
  
}



impl Object for AddLogMessage {}
impl RObject for AddLogMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addLogMessage" }
  fn td_type(&self) -> RTDType { RTDType::AddLogMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddLogMessage {}


impl AddLogMessage {
  
  pub fn verbosity_level(&self) -> Option<i32> { self.verbosity_level.clone() }
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds the specified data to data usage statistics. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addNetworkStatistics
  /// The network statistics entry with the data to be added to statistics.
  entry: Option<Box<NetworkStatisticsEntry>>,
  
}


impl Clone for AddNetworkStatistics {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddNetworkStatistics {}
impl RObject for AddNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::AddNetworkStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddNetworkStatistics {}


impl AddNetworkStatistics {
  
  pub fn entry(&self) -> Option<Box<NetworkStatisticsEntry>> { self.entry.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addProxy
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for AddProxy {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddProxy {}
impl RObject for AddProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addProxy" }
  fn td_type(&self) -> RTDType { RTDType::AddProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddProxy {}


impl AddProxy {
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn enable(&self) -> Option<bool> { self.enable.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addRecentSticker
  /// Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for AddRecentSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddRecentSticker {}
impl RObject for AddRecentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addRecentSticker" }
  fn td_type(&self) -> RTDType { RTDType::AddRecentSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddRecentSticker {}


impl AddRecentSticker {
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addRecentlyFoundChat
  /// Identifier of the chat to add.
  chat_id: Option<i64>,
  
}



impl Object for AddRecentlyFoundChat {}
impl RObject for AddRecentlyFoundChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addRecentlyFoundChat" }
  fn td_type(&self) -> RTDType { RTDType::AddRecentlyFoundChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddRecentlyFoundChat {}


impl AddRecentlyFoundChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addSavedAnimation
  /// The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list.
  animation: Option<Box<InputFile>>,
  
}


impl Clone for AddSavedAnimation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AddSavedAnimation {}
impl RObject for AddSavedAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addSavedAnimation" }
  fn td_type(&self) -> RTDType { RTDType::AddSavedAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddSavedAnimation {}


impl AddSavedAnimation {
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a new sticker to a set; for bots only. Returns the sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddStickerToSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // addStickerToSet
  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set name.
  name: Option<String>,
  /// Sticker to add to the set.
  sticker: Option<InputSticker>,
  
}



impl Object for AddStickerToSet {}
impl RObject for AddStickerToSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "addStickerToSet" }
  fn td_type(&self) -> RTDType { RTDType::AddStickerToSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AddStickerToSet {}


impl AddStickerToSet {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn sticker(&self) -> Option<InputSticker> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the result of a callback query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerCallbackQuery
  /// Identifier of the callback query.
  callback_query_id: Option<i64>,
  /// Text of the answer.
  text: Option<String>,
  /// If true, an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,
  /// Time during which the result of the query can be cached, in seconds.
  cache_time: Option<i32>,
  
}



impl Object for AnswerCallbackQuery {}
impl RObject for AnswerCallbackQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerCallbackQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerCallbackQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AnswerCallbackQuery {}


impl AnswerCallbackQuery {
  
  pub fn callback_query_id(&self) -> Option<i64> { self.callback_query_id.clone() }
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn show_alert(&self) -> Option<bool> { self.show_alert.clone() }
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn cache_time(&self) -> Option<i32> { self.cache_time.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Answers a custom query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerCustomQuery
  /// Identifier of a custom query.
  custom_query_id: Option<i64>,
  /// JSON-serialized answer to the query.
  data: Option<String>,
  
}



impl Object for AnswerCustomQuery {}
impl RObject for AnswerCustomQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerCustomQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerCustomQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AnswerCustomQuery {}


impl AnswerCustomQuery {
  
  pub fn custom_query_id(&self) -> Option<i64> { self.custom_query_id.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the result of an inline query; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct AnswerInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerInlineQuery
  /// Identifier of the inline query.
  inline_query_id: Option<i64>,
  /// True, if the result of the query can be cached for the specified user.
  is_personal: Option<bool>,
  /// The results of the query.
  results: Option<Vec<Box<InputInlineQueryResult>>>,
  /// Allowed time to cache the results of the query, in seconds.
  cache_time: Option<i32>,
  /// Offset for the next inline query; pass an empty string if there are no more results.
  next_offset: Option<String>,
  /// If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// The parameter for the bot start message.
  switch_pm_parameter: Option<String>,
  
}


impl Clone for AnswerInlineQuery {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for AnswerInlineQuery {}
impl RObject for AnswerInlineQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerInlineQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerInlineQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AnswerInlineQuery {}


impl AnswerInlineQuery {
  
  pub fn inline_query_id(&self) -> Option<i64> { self.inline_query_id.clone() }
  
  pub fn is_personal(&self) -> Option<bool> { self.is_personal.clone() }
  
  pub fn results(&self) -> Option<Vec<Box<InputInlineQueryResult>>> { self.results.clone() }
  
  pub fn cache_time(&self) -> Option<i32> { self.cache_time.clone() }
  
  pub fn next_offset(&self) -> Option<String> { self.next_offset.clone() }
  
  pub fn switch_pm_text(&self) -> Option<String> { self.switch_pm_text.clone() }
  
  pub fn switch_pm_parameter(&self) -> Option<String> { self.switch_pm_parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the result of a pre-checkout query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerPreCheckoutQuery
  /// Identifier of the pre-checkout query.
  pre_checkout_query_id: Option<i64>,
  /// An error message, empty on success.
  error_message: Option<String>,
  
}



impl Object for AnswerPreCheckoutQuery {}
impl RObject for AnswerPreCheckoutQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerPreCheckoutQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerPreCheckoutQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AnswerPreCheckoutQuery {}


impl AnswerPreCheckoutQuery {
  
  pub fn pre_checkout_query_id(&self) -> Option<i64> { self.pre_checkout_query_id.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the result of a shipping query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // answerShippingQuery
  /// Identifier of the shipping query.
  shipping_query_id: Option<i64>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,
  /// An error message, empty on success.
  error_message: Option<String>,
  
}



impl Object for AnswerShippingQuery {}
impl RObject for AnswerShippingQuery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "answerShippingQuery" }
  fn td_type(&self) -> RTDType { RTDType::AnswerShippingQuery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for AnswerShippingQuery {}


impl AnswerShippingQuery {
  
  pub fn shipping_query_id(&self) -> Option<i64> { self.shipping_query_id.clone() }
  
  pub fn shipping_options(&self) -> Option<Vec<ShippingOption>> { self.shipping_options.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds a user to the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // blockUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for BlockUser {}
impl RObject for BlockUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "blockUser" }
  fn td_type(&self) -> RTDType { RTDType::BlockUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for BlockUser {}


impl BlockUser {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Stops the downloading of a file. If a file has already been downloaded, does nothing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelDownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cancelDownloadFile
  /// Identifier of a file to stop downloading.
  file_id: Option<i32>,
  /// Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server.
  only_if_pending: Option<bool>,
  
}



impl Object for CancelDownloadFile {}
impl RObject for CancelDownloadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cancelDownloadFile" }
  fn td_type(&self) -> RTDType { RTDType::CancelDownloadFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CancelDownloadFile {}


impl CancelDownloadFile {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn only_if_pending(&self) -> Option<bool> { self.only_if_pending.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Stops the uploading of a file. Supported only for files uploaded by using 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelUploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cancelUploadFile
  /// Identifier of the file to stop uploading.
  file_id: Option<i32>,
  
}



impl Object for CancelUploadFile {}
impl RObject for CancelUploadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cancelUploadFile" }
  fn td_type(&self) -> RTDType { RTDType::CancelUploadFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CancelUploadFile {}


impl CancelUploadFile {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Reports to the server whether a chat is a spam chat or not. Can be used only if ChatReportSpamState.can_report_spam is true. After this request, ChatReportSpamState.can_report_spam becomes false forever.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeChatReportSpamState
  /// Chat identifier.
  chat_id: Option<i64>,
  /// If true, the chat will be reported as spam; otherwise it will be marked as not spam.
  is_spam_chat: Option<bool>,
  
}



impl Object for ChangeChatReportSpamState {}
impl RObject for ChangeChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeChatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::ChangeChatReportSpamState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ChangeChatReportSpamState {}


impl ChangeChatReportSpamState {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_spam_chat(&self) -> Option<bool> { self.is_spam_chat.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. Query result depends on the result of the previous query, so only one query is possible at the same time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeImportedContacts
  /// The new list of contacts, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,
  
}



impl Object for ChangeImportedContacts {}
impl RObject for ChangeImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeImportedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ChangeImportedContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ChangeImportedContacts {}


impl ChangeImportedContacts {
  
  pub fn contacts(&self) -> Option<Vec<Contact>> { self.contacts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changePhoneNumber
  /// The new phone number of the user in international format.
  phone_number: Option<String>,
  /// Pass true if the code can be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for ChangePhoneNumber {}
impl RObject for ChangePhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changePhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::ChangePhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ChangePhoneNumber {}


impl ChangePhoneNumber {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Installs/uninstalls or activates/archives a sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // changeStickerSet
  /// Identifier of the sticker set.
  set_id: Option<i64>,
  /// The new value of is_installed.
  is_installed: Option<bool>,
  /// The new value of is_archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  
}



impl Object for ChangeStickerSet {}
impl RObject for ChangeStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "changeStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::ChangeStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ChangeStickerSet {}


impl ChangeStickerSet {
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn is_installed(&self) -> Option<bool> { self.is_installed.clone() }
  
  pub fn is_archived(&self) -> Option<bool> { self.is_archived.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationBotToken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationBotToken
  /// The bot token.
  token: Option<String>,
  
}



impl Object for CheckAuthenticationBotToken {}
impl RObject for CheckAuthenticationBotToken {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationBotToken" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationBotToken }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckAuthenticationBotToken {}


impl CheckAuthenticationBotToken {
  
  pub fn token(&self) -> Option<String> { self.token.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the authentication code. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationCode
  /// The verification code received via SMS, Telegram message, phone call, or flash call.
  code: Option<String>,
  /// If the user is not yet registered, the first name of the user; 1-64 characters. You can also pass an empty string for unregistered user there to check verification code validness. In the latter case PHONE_NUMBER_UNOCCUPIED error will be returned for a valid code.
  first_name: Option<String>,
  /// If the user is not yet registered; the last name of the user; optional; 0-64 characters.
  last_name: Option<String>,
  
}



impl Object for CheckAuthenticationCode {}
impl RObject for CheckAuthenticationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckAuthenticationCode {}


impl CheckAuthenticationCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the authentication password for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkAuthenticationPassword
  /// The password to check.
  password: Option<String>,
  
}



impl Object for CheckAuthenticationPassword {}
impl RObject for CheckAuthenticationPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkAuthenticationPassword" }
  fn td_type(&self) -> RTDType { RTDType::CheckAuthenticationPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckAuthenticationPassword {}


impl CheckAuthenticationPassword {
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the authentication code sent to confirm a new phone number of the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChangePhoneNumberCode
  /// Verification code received by SMS, phone call or flash call.
  code: Option<String>,
  
}



impl Object for CheckChangePhoneNumberCode {}
impl RObject for CheckChangePhoneNumberCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChangePhoneNumberCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckChangePhoneNumberCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckChangePhoneNumberCode {}


impl CheckChangePhoneNumberCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the validity of an invite link for a chat and returns information about the corresponding chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatInviteLink
  /// Invite link to be checked; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,
  
}



impl Object for CheckChatInviteLink {}
impl RObject for CheckChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatInviteLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckChatInviteLink {}


impl CheckChatInviteLink {
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks whether a username can be set for a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkChatUsername
  /// Chat identifier; should be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if chat is being created.
  chat_id: Option<i64>,
  /// Username to be checked.
  username: Option<String>,
  
}



impl Object for CheckChatUsername {}
impl RObject for CheckChatUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkChatUsername" }
  fn td_type(&self) -> RTDType { RTDType::CheckChatUsername }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckChatUsername {}


impl CheckChatUsername {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the database encryption key for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkDatabaseEncryptionKey
  /// Encryption key to check or set up.
  encryption_key: Option<String>,
  
}



impl Object for CheckDatabaseEncryptionKey {}
impl RObject for CheckDatabaseEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkDatabaseEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::CheckDatabaseEncryptionKey }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckDatabaseEncryptionKey {}


impl CheckDatabaseEncryptionKey {
  
  pub fn encryption_key(&self) -> Option<String> { self.encryption_key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the email address verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkEmailAddressVerificationCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckEmailAddressVerificationCode {}
impl RObject for CheckEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckEmailAddressVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckEmailAddressVerificationCode {}


impl CheckEmailAddressVerificationCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkPhoneNumberConfirmationCode
  /// The phone number confirmation code.
  code: Option<String>,
  
}



impl Object for CheckPhoneNumberConfirmationCode {}
impl RObject for CheckPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckPhoneNumberConfirmationCode {}


impl CheckPhoneNumberConfirmationCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the phone number verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkPhoneNumberVerificationCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckPhoneNumberVerificationCode {}
impl RObject for CheckPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckPhoneNumberVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckPhoneNumberVerificationCode {}


impl CheckPhoneNumberVerificationCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Checks the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // checkRecoveryEmailAddressCode
  /// Verification code.
  code: Option<String>,
  
}



impl Object for CheckRecoveryEmailAddressCode {}
impl RObject for CheckRecoveryEmailAddressCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "checkRecoveryEmailAddressCode" }
  fn td_type(&self) -> RTDType { RTDType::CheckRecoveryEmailAddressCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CheckRecoveryEmailAddressCode {}


impl CheckRecoveryEmailAddressCode {
  
  pub fn code(&self) -> Option<String> { self.code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleanFileName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // cleanFileName
  /// File name or path to the file.
  file_name: Option<String>,
  
}



impl Object for CleanFileName {}
impl RObject for CleanFileName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "cleanFileName" }
  fn td_type(&self) -> RTDType { RTDType::CleanFileName }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CleanFileName {}


impl CleanFileName {
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Clears draft messages in all chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearAllDraftMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearAllDraftMessages
  /// If true, local draft messages in secret chats will not be cleared.
  exclude_secret_chats: Option<bool>,
  
}



impl Object for ClearAllDraftMessages {}
impl RObject for ClearAllDraftMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearAllDraftMessages" }
  fn td_type(&self) -> RTDType { RTDType::ClearAllDraftMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ClearAllDraftMessages {}


impl ClearAllDraftMessages {
  
  pub fn exclude_secret_chats(&self) -> Option<bool> { self.exclude_secret_chats.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Clears all imported contacts, contact list remains unchanged.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearImportedContacts
  
}



impl Object for ClearImportedContacts {}
impl RObject for ClearImportedContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearImportedContacts" }
  fn td_type(&self) -> RTDType { RTDType::ClearImportedContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ClearImportedContacts {}


impl ClearImportedContacts {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Clears the list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearRecentStickers
  /// Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers.
  is_attached: Option<bool>,
  
}



impl Object for ClearRecentStickers {}
impl RObject for ClearRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::ClearRecentStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ClearRecentStickers {}


impl ClearRecentStickers {
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Clears the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentlyFoundChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // clearRecentlyFoundChats
  
}



impl Object for ClearRecentlyFoundChats {}
impl RObject for ClearRecentlyFoundChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "clearRecentlyFoundChats" }
  fn td_type(&self) -> RTDType { RTDType::ClearRecentlyFoundChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ClearRecentlyFoundChats {}


impl ClearRecentlyFoundChats {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Close {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // close
  
}



impl Object for Close {}
impl RObject for Close {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "close" }
  fn td_type(&self) -> RTDType { RTDType::Close }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for Close {}


impl Close {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // closeChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for CloseChat {}
impl RObject for CloseChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "closeChat" }
  fn td_type(&self) -> RTDType { RTDType::CloseChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CloseChat {}


impl CloseChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Closes a secret chat, effectively transfering its state to 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // closeSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for CloseSecretChat {}
impl RObject for CloseSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "closeSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CloseSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CloseSecretChat {}


impl CloseSecretChat {
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an existing chat corresponding to a known basic group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createBasicGroupChat
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreateBasicGroupChat {}
impl RObject for CreateBasicGroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createBasicGroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateBasicGroupChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateBasicGroupChat {}


impl CreateBasicGroupChat {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createCall
  /// Identifier of the user to be called.
  user_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,
  
}



impl Object for CreateCall {}
impl RObject for CreateCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createCall" }
  fn td_type(&self) -> RTDType { RTDType::CreateCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateCall {}


impl CreateCall {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn protocol(&self) -> Option<CallProtocol> { self.protocol.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewBasicGroupChat
  /// Identifiers of users to be added to the basic group.
  user_ids: Option<Vec<i32>>,
  /// Title of the new basic group; 1-128 characters.
  title: Option<String>,
  
}



impl Object for CreateNewBasicGroupChat {}
impl RObject for CreateNewBasicGroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewBasicGroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewBasicGroupChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateNewBasicGroupChat {}


impl CreateNewBasicGroupChat {
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new secret chat. Returns the newly created chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewSecretChat
  /// Identifier of the target user.
  user_id: Option<i32>,
  
}



impl Object for CreateNewSecretChat {}
impl RObject for CreateNewSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateNewSecretChat {}


impl CreateNewSecretChat {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new sticker set; for bots only. Returns the newly created sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewStickerSet
  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set title; 1-64 characters.
  title: Option<String>,
  /// Sticker set name. Can contain only English letters, digits and underscores. Must end with "by<bot username>" (<bot_username> is case insensitive); 1-64 characters.
  name: Option<String>,
  /// True, if stickers are masks.
  is_masks: Option<bool>,
  /// List of stickers to be added to the set.
  stickers: Option<Vec<InputSticker>>,
  
}



impl Object for CreateNewStickerSet {}
impl RObject for CreateNewStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateNewStickerSet {}


impl CreateNewStickerSet {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn stickers(&self) -> Option<Vec<InputSticker>> { self.stickers.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new supergroup or channel and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createNewSupergroupChat
  /// Title of the new chat; 1-128 characters.
  title: Option<String>,
  /// True, if a channel chat should be created.
  is_channel: Option<bool>,
  /// Chat description; 0-255 characters.
  description: Option<String>,
  
}



impl Object for CreateNewSupergroupChat {}
impl RObject for CreateNewSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createNewSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateNewSupergroupChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateNewSupergroupChat {}


impl CreateNewSupergroupChat {
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn is_channel(&self) -> Option<bool> { self.is_channel.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an existing chat corresponding to a given user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePrivateChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createPrivateChat
  /// User identifier.
  user_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreatePrivateChat {}
impl RObject for CreatePrivateChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createPrivateChat" }
  fn td_type(&self) -> RTDType { RTDType::CreatePrivateChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreatePrivateChat {}


impl CreatePrivateChat {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an existing chat corresponding to a known secret chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for CreateSecretChat {}
impl RObject for CreateSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateSecretChat {}


impl CreateSecretChat {
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an existing chat corresponding to a known supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createSupergroupChat
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,
  
}



impl Object for CreateSupergroupChat {}
impl RObject for CreateSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::CreateSupergroupChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateSupergroupChat {}


impl CreateSupergroupChat {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new temporary password for processing payments.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateTemporaryPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // createTemporaryPassword
  /// Persistent user password.
  password: Option<String>,
  /// Time during which the temporary password will be valid, in seconds; should be between 60 and 86400.
  valid_for: Option<i32>,
  
}



impl Object for CreateTemporaryPassword {}
impl RObject for CreateTemporaryPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "createTemporaryPassword" }
  fn td_type(&self) -> RTDType { RTDType::CreateTemporaryPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for CreateTemporaryPassword {}


impl CreateTemporaryPassword {
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn valid_for(&self) -> Option<i32> { self.valid_for.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteAccount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteAccount
  /// The reason why the account was deleted; optional.
  reason: Option<String>,
  
}



impl Object for DeleteAccount {}
impl RObject for DeleteAccount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteAccount" }
  fn td_type(&self) -> RTDType { RTDType::DeleteAccount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteAccount {}


impl DeleteAccount {
  
  pub fn reason(&self) -> Option<String> { self.reason.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatHistory
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Pass true if the chat should be removed from the chat list.
  remove_from_chat_list: Option<bool>,
  /// Pass true to try to delete chat history for all users.
  revoke: Option<bool>,
  
}



impl Object for DeleteChatHistory {}
impl RObject for DeleteChatHistory {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatHistory" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatHistory }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteChatHistory {}


impl DeleteChatHistory {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn remove_from_chat_list(&self) -> Option<bool> { self.remove_from_chat_list.clone() }
  
  pub fn revoke(&self) -> Option<bool> { self.revoke.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes all messages sent by the specified user to a chat. Supported only in supergroups; requires can_delete_messages administrator privileges.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatMessagesFromUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatMessagesFromUser
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for DeleteChatMessagesFromUser {}
impl RObject for DeleteChatMessagesFromUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatMessagesFromUser" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatMessagesFromUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteChatMessagesFromUser {}


impl DeleteChatMessagesFromUser {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteChatReplyMarkup
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The message identifier of the used keyboard.
  message_id: Option<i64>,
  
}



impl Object for DeleteChatReplyMarkup {}
impl RObject for DeleteChatReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteChatReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::DeleteChatReplyMarkup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteChatReplyMarkup {}


impl DeleteChatReplyMarkup {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes a file from the TDLib file cache.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteFile
  /// Identifier of the file to delete.
  file_id: Option<i32>,
  
}



impl Object for DeleteFile {}
impl RObject for DeleteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteFile" }
  fn td_type(&self) -> RTDType { RTDType::DeleteFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteFile {}


impl DeleteFile {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteLanguagePack
  /// Identifier of the language pack to delete.
  language_pack_id: Option<String>,
  
}



impl Object for DeleteLanguagePack {}
impl RObject for DeleteLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::DeleteLanguagePack }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteLanguagePack {}


impl DeleteLanguagePack {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the messages to be deleted.
  message_ids: Option<Vec<i64>>,
  /// Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats.
  revoke: Option<bool>,
  
}



impl Object for DeleteMessages {}
impl RObject for DeleteMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteMessages" }
  fn td_type(&self) -> RTDType { RTDType::DeleteMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteMessages {}


impl DeleteMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn revoke(&self) -> Option<bool> { self.revoke.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes a Telegram Passport element.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeletePassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deletePassportElement
  /// Element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  
}


impl Clone for DeletePassportElement {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for DeletePassportElement {}
impl RObject for DeletePassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deletePassportElement" }
  fn td_type(&self) -> RTDType { RTDType::DeletePassportElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeletePassportElement {}


impl DeletePassportElement {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes a profile photo. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteProfilePhoto
  /// Identifier of the profile photo to delete.
  profile_photo_id: Option<i64>,
  
}



impl Object for DeleteProfilePhoto {}
impl RObject for DeleteProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::DeleteProfilePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteProfilePhoto {}


impl DeleteProfilePhoto {
  
  pub fn profile_photo_id(&self) -> Option<i64> { self.profile_photo_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes saved credentials for all payment provider bots.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSavedCredentials
  
}



impl Object for DeleteSavedCredentials {}
impl RObject for DeleteSavedCredentials {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSavedCredentials" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSavedCredentials }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteSavedCredentials {}


impl DeleteSavedCredentials {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes saved order info.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSavedOrderInfo
  
}



impl Object for DeleteSavedOrderInfo {}
impl RObject for DeleteSavedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSavedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSavedOrderInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteSavedOrderInfo {}


impl DeleteSavedOrderInfo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires creator privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // deleteSupergroup
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  
}



impl Object for DeleteSupergroup {}
impl RObject for DeleteSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "deleteSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::DeleteSupergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DeleteSupergroup {}


impl DeleteSupergroup {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Destroy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // destroy
  
}



impl Object for Destroy {}
impl RObject for Destroy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "destroy" }
  fn td_type(&self) -> RTDType { RTDType::Destroy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for Destroy {}


impl Destroy {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Disables the currently enabled proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disableProxy
  
}



impl Object for DisableProxy {}
impl RObject for DisableProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disableProxy" }
  fn td_type(&self) -> RTDType { RTDType::DisableProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DisableProxy {}


impl DisableProxy {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Discards a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscardCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // discardCall
  /// Call identifier.
  call_id: Option<i32>,
  /// True, if the user was disconnected.
  is_disconnected: Option<bool>,
  /// The call duration, in seconds.
  duration: Option<i32>,
  /// Identifier of the connection used during the call.
  connection_id: Option<i64>,
  
}



impl Object for DiscardCall {}
impl RObject for DiscardCall {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "discardCall" }
  fn td_type(&self) -> RTDType { RTDType::DiscardCall }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DiscardCall {}


impl DiscardCall {
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn is_disconnected(&self) -> Option<bool> { self.is_disconnected.clone() }
  
  pub fn duration(&self) -> Option<i32> { self.duration.clone() }
  
  pub fn connection_id(&self) -> Option<i64> { self.connection_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Disconnects all websites from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectAllWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disconnectAllWebsites
  
}



impl Object for DisconnectAllWebsites {}
impl RObject for DisconnectAllWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disconnectAllWebsites" }
  fn td_type(&self) -> RTDType { RTDType::DisconnectAllWebsites }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DisconnectAllWebsites {}


impl DisconnectAllWebsites {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Disconnects website from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // disconnectWebsite
  /// Website identifier.
  website_id: Option<i64>,
  
}



impl Object for DisconnectWebsite {}
impl RObject for DisconnectWebsite {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "disconnectWebsite" }
  fn td_type(&self) -> RTDType { RTDType::DisconnectWebsite }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DisconnectWebsite {}


impl DisconnectWebsite {
  
  pub fn website_id(&self) -> Option<i64> { self.website_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Downloads a file from the cloud. Download progress and completion of the download will be notified through 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // downloadFile
  /// Identifier of the file to download.
  file_id: Option<i32>,
  /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first.
  priority: Option<i32>,
  /// The starting position from which the file should be downloaded.
  offset: Option<i32>,
  /// Number of bytes which should be downloaded starting from the "offset" position before the download will be automatically cancelled; use 0 to download without a limit.
  limit: Option<i32>,
  /// If false, this request returns file state just after the download has been started. If true, this request returns file state only after the download has succeeded, has failed, has been cancelled or a new downloadFile request with different offset/limit parameters was sent.
  synchronous: Option<bool>,
  
}



impl Object for DownloadFile {}
impl RObject for DownloadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "downloadFile" }
  fn td_type(&self) -> RTDType { RTDType::DownloadFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for DownloadFile {}


impl DownloadFile {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn priority(&self) -> Option<i32> { self.priority.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn synchronous(&self) -> Option<bool> { self.synchronous.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits information about a custom local language pack in the current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditCustomLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editCustomLanguagePackInfo
  /// New information about the custom local language pack.
  info: Option<LanguagePackInfo>,
  
}



impl Object for EditCustomLanguagePackInfo {}
impl RObject for EditCustomLanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editCustomLanguagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::EditCustomLanguagePackInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditCustomLanguagePackInfo {}


impl EditCustomLanguagePackInfo {
  
  pub fn info(&self) -> Option<LanguagePackInfo> { self.info.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the caption of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageCaption
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for EditInlineMessageCaption {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditInlineMessageCaption {}
impl RObject for EditInlineMessageCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageCaption" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageCaption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditInlineMessageCaption {}


impl EditInlineMessageCaption {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the content of a live location in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageLiveLocation
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,
  
}


impl Clone for EditInlineMessageLiveLocation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditInlineMessageLiveLocation {}
impl RObject for EditInlineMessageLiveLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageLiveLocation" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageLiveLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditInlineMessageLiveLocation {}


impl EditInlineMessageLiveLocation {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageMedia
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditInlineMessageMedia {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditInlineMessageMedia {}
impl RObject for EditInlineMessageMedia {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageMedia" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageMedia }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditInlineMessageMedia {}


impl EditInlineMessageMedia {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the reply markup of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageReplyMarkup
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for EditInlineMessageReplyMarkup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditInlineMessageReplyMarkup {}
impl RObject for EditInlineMessageReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageReplyMarkup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditInlineMessageReplyMarkup {}


impl EditInlineMessageReplyMarkup {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the text of an inline text or game message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editInlineMessageText
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditInlineMessageText {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditInlineMessageText {}
impl RObject for EditInlineMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editInlineMessageText" }
  fn td_type(&self) -> RTDType { RTDType::EditInlineMessageText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditInlineMessageText {}


impl EditInlineMessageText {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the message content caption. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageCaption
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  
}


impl Clone for EditMessageCaption {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditMessageCaption {}
impl RObject for EditMessageCaption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageCaption" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageCaption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditMessageCaption {}


impl EditMessageCaption {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn caption(&self) -> Option<FormattedText> { self.caption.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageLiveLocation
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,
  
}


impl Clone for EditMessageLiveLocation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditMessageLiveLocation {}
impl RObject for EditMessageLiveLocation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageLiveLocation" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageLiveLocation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditMessageLiveLocation {}


impl EditMessageLiveLocation {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageMedia
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditMessageMedia {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditMessageMedia {}
impl RObject for EditMessageMedia {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageMedia" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageMedia }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditMessageMedia {}


impl EditMessageMedia {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageReplyMarkup
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for EditMessageReplyMarkup {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditMessageReplyMarkup {}
impl RObject for EditMessageReplyMarkup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageReplyMarkup" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageReplyMarkup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditMessageReplyMarkup {}


impl EditMessageReplyMarkup {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editMessageText
  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for EditMessageText {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditMessageText {}
impl RObject for EditMessageText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editMessageText" }
  fn td_type(&self) -> RTDType { RTDType::EditMessageText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditMessageText {}


impl EditMessageText {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Edits an existing proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // editProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,
  
}


impl Clone for EditProxy {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for EditProxy {}
impl RObject for EditProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "editProxy" }
  fn td_type(&self) -> RTDType { RTDType::EditProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EditProxy {}


impl EditProxy {
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn server(&self) -> Option<String> { self.server.clone() }
  
  pub fn port(&self) -> Option<i32> { self.port.clone() }
  
  pub fn enable(&self) -> Option<bool> { self.enable.clone() }
  
  pub fn type_(&self) -> Option<Box<ProxyType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // enableProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for EnableProxy {}
impl RObject for EnableProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "enableProxy" }
  fn td_type(&self) -> RTDType { RTDType::EnableProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for EnableProxy {}


impl EnableProxy {
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Finishes the file generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FinishFileGeneration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // finishFileGeneration
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// If set, means that file generation has failed and should be terminated.
  error: Option<Error>,
  
}



impl Object for FinishFileGeneration {}
impl RObject for FinishFileGeneration {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "finishFileGeneration" }
  fn td_type(&self) -> RTDType { RTDType::FinishFileGeneration }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for FinishFileGeneration {}


impl FinishFileGeneration {
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn error(&self) -> Option<Error> { self.error.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForwardMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // forwardMessages
  /// Identifier of the chat to which to forward messages.
  chat_id: Option<i64>,
  /// Identifier of the chat from which to forward messages.
  from_chat_id: Option<i64>,
  /// Identifiers of the messages to forward.
  message_ids: Option<Vec<i64>>,
  /// Pass true to disable notification for the message, doesn't work if messages are forwarded to a secret chat.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// True, if the messages should be grouped into an album after forwarding. For this to work, no more than 10 messages may be forwarded, and all of them must be photo or video messages.
  as_album: Option<bool>,
  
}



impl Object for ForwardMessages {}
impl RObject for ForwardMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "forwardMessages" }
  fn td_type(&self) -> RTDType { RTDType::ForwardMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ForwardMessages {}


impl ForwardMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_chat_id(&self) -> Option<i64> { self.from_chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn as_album(&self) -> Option<bool> { self.as_album.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. In basic groups this can be called only by the group's creator; in supergroups and channels this requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // generateChatInviteLink
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GenerateChatInviteLink {}
impl RObject for GenerateChatInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "generateChatInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::GenerateChatInviteLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GenerateChatInviteLink {}


impl GenerateChatInviteLink {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAccountTtl
  
}



impl Object for GetAccountTtl {}
impl RObject for GetAccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAccountTtl" }
  fn td_type(&self) -> RTDType { RTDType::GetAccountTtl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetAccountTtl {}


impl GetAccountTtl {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all active live locations that should be updated by the client. The list is persistent across application restarts only if the message database is used.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveLiveLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getActiveLiveLocationMessages
  
}



impl Object for GetActiveLiveLocationMessages {}
impl RObject for GetActiveLiveLocationMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getActiveLiveLocationMessages" }
  fn td_type(&self) -> RTDType { RTDType::GetActiveLiveLocationMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetActiveLiveLocationMessages {}


impl GetActiveLiveLocationMessages {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all active sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getActiveSessions
  
}



impl Object for GetActiveSessions {}
impl RObject for GetActiveSessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getActiveSessions" }
  fn td_type(&self) -> RTDType { RTDType::GetActiveSessions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetActiveSessions {}


impl GetActiveSessions {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all available Telegram Passport elements.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAllPassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAllPassportElements
  /// Password of the current user.
  password: Option<String>,
  
}



impl Object for GetAllPassportElements {}
impl RObject for GetAllPassportElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAllPassportElements" }
  fn td_type(&self) -> RTDType { RTDType::GetAllPassportElements }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetAllPassportElements {}


impl GetAllPassportElements {
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns application config, provided by the server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetApplicationConfig {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getApplicationConfig
  
}



impl Object for GetApplicationConfig {}
impl RObject for GetApplicationConfig {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getApplicationConfig" }
  fn td_type(&self) -> RTDType { RTDType::GetApplicationConfig }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetApplicationConfig {}


impl GetApplicationConfig {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of archived sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetArchivedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getArchivedStickerSets
  /// Pass true to return mask stickers sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifier of the sticker set from which to return the result.
  offset_sticker_set_id: Option<i64>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,
  
}



impl Object for GetArchivedStickerSets {}
impl RObject for GetArchivedStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getArchivedStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetArchivedStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetArchivedStickerSets {}


impl GetArchivedStickerSets {
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn offset_sticker_set_id(&self) -> Option<i64> { self.offset_sticker_set_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAttachedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAttachedStickerSets
  /// File identifier.
  file_id: Option<i32>,
  
}



impl Object for GetAttachedStickerSets {}
impl RObject for GetAttachedStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAttachedStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetAttachedStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetAttachedStickerSets {}


impl GetAttachedStickerSets {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the current authorization state; this is an offline request. For informational purposes only. Use 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getAuthorizationState
  
}



impl Object for GetAuthorizationState {}
impl RObject for GetAuthorizationState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getAuthorizationState" }
  fn td_type(&self) -> RTDType { RTDType::GetAuthorizationState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetAuthorizationState {}


impl GetAuthorizationState {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBasicGroup
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for GetBasicGroup {}
impl RObject for GetBasicGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBasicGroup" }
  fn td_type(&self) -> RTDType { RTDType::GetBasicGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetBasicGroup {}


impl GetBasicGroup {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns full information about a basic group by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBasicGroupFullInfo
  /// Basic group identifier.
  basic_group_id: Option<i32>,
  
}



impl Object for GetBasicGroupFullInfo {}
impl RObject for GetBasicGroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBasicGroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetBasicGroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetBasicGroupFullInfo {}


impl GetBasicGroupFullInfo {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns users that were blocked by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBlockedUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getBlockedUsers
  /// Number of users to skip in the result; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of users to return; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetBlockedUsers {}
impl RObject for GetBlockedUsers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getBlockedUsers" }
  fn td_type(&self) -> RTDType { RTDType::GetBlockedUsers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetBlockedUsers {}


impl GetBlockedUsers {
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetCallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCallbackQueryAnswer
  /// Identifier of the chat with the message.
  chat_id: Option<i64>,
  /// Identifier of the message from which the query originated.
  message_id: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,
  
}


impl Clone for GetCallbackQueryAnswer {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetCallbackQueryAnswer {}
impl RObject for GetCallbackQueryAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCallbackQueryAnswer" }
  fn td_type(&self) -> RTDType { RTDType::GetCallbackQueryAnswer }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetCallbackQueryAnswer {}


impl GetCallbackQueryAnswer {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn payload(&self) -> Option<Box<CallbackQueryPayload>> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChat {}
impl RObject for GetChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChat" }
  fn td_type(&self) -> RTDType { RTDType::GetChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChat {}


impl GetChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of users who are administrators of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatAdministrators
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChatAdministrators {}
impl RObject for GetChatAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::GetChatAdministrators }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatAdministrators {}


impl GetChatAdministrators {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only in supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatEventLog {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatEventLog
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Search query by which to filter events.
  query: Option<String>,
  /// Identifier of an event from which to return results. Use 0 to get results from the latest events.
  from_event_id: Option<i64>,
  /// Maximum number of events to return; up to 100.
  limit: Option<i32>,
  /// The types of events to return. By default, all types will be returned.
  filters: Option<ChatEventLogFilters>,
  /// User identifiers by which to filter events. By default, events relating to all users will be returned.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for GetChatEventLog {}
impl RObject for GetChatEventLog {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatEventLog" }
  fn td_type(&self) -> RTDType { RTDType::GetChatEventLog }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatEventLog {}


impl GetChatEventLog {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_event_id(&self) -> Option<i64> { self.from_event_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filters(&self) -> Option<ChatEventLogFilters> { self.filters.clone() }
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatHistory
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater or equal to -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages that are available locally without sending network requests.
  only_local: Option<bool>,
  
}



impl Object for GetChatHistory {}
impl RObject for GetChatHistory {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatHistory" }
  fn td_type(&self) -> RTDType { RTDType::GetChatHistory }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatHistory {}


impl GetChatHistory {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn only_local(&self) -> Option<bool> { self.only_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a single member of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMember
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetChatMember {}
impl RObject for GetChatMember {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMember" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMember }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatMember {}


impl GetChatMember {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the last message sent in a chat no later than the specified date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMessageByDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMessageByDate
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Point in time (Unix timestamp) relative to which to search for messages.
  date: Option<i32>,
  
}



impl Object for GetChatMessageByDate {}
impl RObject for GetChatMessageByDate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMessageByDate" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMessageByDate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatMessageByDate {}


impl GetChatMessageByDate {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn date(&self) -> Option<i32> { self.date.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns approximate number of messages of the specified type in the chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatMessageCount
  /// Identifier of the chat in which to count messages.
  chat_id: Option<i64>,
  /// Filter for message content; searchMessagesFilterEmpty is unsupported in this function.
  filter: Option<Box<SearchMessagesFilter>>,
  /// If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown.
  return_local: Option<bool>,
  
}


impl Clone for GetChatMessageCount {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetChatMessageCount {}
impl RObject for GetChatMessageCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatMessageCount" }
  fn td_type(&self) -> RTDType { RTDType::GetChatMessageCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatMessageCount {}


impl GetChatMessageCount {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn return_local(&self) -> Option<bool> { self.return_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns list of chats with non-default notification settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatNotificationSettingsExceptions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatNotificationSettingsExceptions
  /// If specified, only chats from the specified scope will be returned.
  scope: Option<Box<NotificationSettingsScope>>,
  /// If true, also chats with non-default sound will be returned.
  compare_sound: Option<bool>,
  
}


impl Clone for GetChatNotificationSettingsExceptions {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetChatNotificationSettingsExceptions {}
impl RObject for GetChatNotificationSettingsExceptions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatNotificationSettingsExceptions" }
  fn td_type(&self) -> RTDType { RTDType::GetChatNotificationSettingsExceptions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatNotificationSettingsExceptions {}


impl GetChatNotificationSettingsExceptions {
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn compare_sound(&self) -> Option<bool> { self.compare_sound.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a pinned chat message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatPinnedMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  
}



impl Object for GetChatPinnedMessage {}
impl RObject for GetChatPinnedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatPinnedMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetChatPinnedMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatPinnedMessage {}


impl GetChatPinnedMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information on whether the current chat can be reported as spam.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatReportSpamState
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for GetChatReportSpamState {}
impl RObject for GetChatReportSpamState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatReportSpamState" }
  fn td_type(&self) -> RTDType { RTDType::GetChatReportSpamState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatReportSpamState {}


impl GetChatReportSpamState {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns URL with the chat statistics. Currently this method can be used only for channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatStatisticsUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChatStatisticsUrl
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Parameters from "tg://statsrefresh?params=******" link.
  parameters: Option<String>,
  /// Pass true if a URL with the dark theme must be returned.
  is_dark: Option<bool>,
  
}



impl Object for GetChatStatisticsUrl {}
impl RObject for GetChatStatisticsUrl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChatStatisticsUrl" }
  fn td_type(&self) -> RTDType { RTDType::GetChatStatisticsUrl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChatStatisticsUrl {}


impl GetChatStatisticsUrl {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn parameters(&self) -> Option<String> { self.parameters.clone() }
  
  pub fn is_dark(&self) -> Option<bool> { self.is_dark.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an ordered list of chats. Chats are sorted by the pair (order, chat_id) in decreasing order. (For example, to get a list of chats from the beginning, the offset_order should be equal to a biggest signed 64-bit number 9223372036854775807 == 2^63 - 1). For optimal performance the number of returned chats is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getChats
  /// Chat order to return chats from.
  offset_order: Option<i64>,
  /// Chat identifier to return chats from.
  offset_chat_id: Option<i64>,
  /// The maximum number of chats to be returned. It is possible that fewer chats than the limit are returned even if the end of the list is not reached.
  limit: Option<i32>,
  
}



impl Object for GetChats {}
impl RObject for GetChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getChats" }
  fn td_type(&self) -> RTDType { RTDType::GetChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetChats {}


impl GetChats {
  
  pub fn offset_order(&self) -> Option<i64> { self.offset_order.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all website where the current user used Telegram to log in.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getConnectedWebsites
  
}



impl Object for GetConnectedWebsites {}
impl RObject for GetConnectedWebsites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getConnectedWebsites" }
  fn td_type(&self) -> RTDType { RTDType::GetConnectedWebsites }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetConnectedWebsites {}


impl GetConnectedWebsites {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getContacts
  
}



impl Object for GetContacts {}
impl RObject for GetContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getContacts" }
  fn td_type(&self) -> RTDType { RTDType::GetContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetContacts {}


impl GetContacts {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Uses current user IP to found his country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCountryCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCountryCode
  
}



impl Object for GetCountryCode {}
impl RObject for GetCountryCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCountryCode" }
  fn td_type(&self) -> RTDType { RTDType::GetCountryCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetCountryCode {}


impl GetCountryCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of public chats created by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCreatedPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCreatedPublicChats
  
}



impl Object for GetCreatedPublicChats {}
impl RObject for GetCreatedPublicChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCreatedPublicChats" }
  fn td_type(&self) -> RTDType { RTDType::GetCreatedPublicChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetCreatedPublicChats {}


impl GetCreatedPublicChats {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially usefull if TDLib is run in a separate process. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCurrentState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getCurrentState
  
}



impl Object for GetCurrentState {}
impl RObject for GetCurrentState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getCurrentState" }
  fn td_type(&self) -> RTDType { RTDType::GetCurrentState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetCurrentState {}


impl GetCurrentState {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns database statistics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getDatabaseStatistics
  
}



impl Object for GetDatabaseStatistics {}
impl RObject for GetDatabaseStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getDatabaseStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetDatabaseStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetDatabaseStatistics {}


impl GetDatabaseStatistics {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getDeepLinkInfo
  /// The link.
  link: Option<String>,
  
}



impl Object for GetDeepLinkInfo {}
impl RObject for GetDeepLinkInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getDeepLinkInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetDeepLinkInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetDeepLinkInfo {}


impl GetDeepLinkInfo {
  
  pub fn link(&self) -> Option<String> { self.link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns favorite stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFavoriteStickers
  
}



impl Object for GetFavoriteStickers {}
impl RObject for GetFavoriteStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFavoriteStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetFavoriteStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetFavoriteStickers {}


impl GetFavoriteStickers {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a file; this is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFile
  /// Identifier of the file to get.
  file_id: Option<i32>,
  
}



impl Object for GetFile {}
impl RObject for GetFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFile" }
  fn td_type(&self) -> RTDType { RTDType::GetFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetFile {}


impl GetFile {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns file downloaded prefix size from a given offset.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileDownloadedPrefixSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileDownloadedPrefixSize
  /// Identifier of the file.
  file_id: Option<i32>,
  /// Offset from which downloaded prefix size should be calculated.
  offset: Option<i32>,
  
}



impl Object for GetFileDownloadedPrefixSize {}
impl RObject for GetFileDownloadedPrefixSize {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileDownloadedPrefixSize" }
  fn td_type(&self) -> RTDType { RTDType::GetFileDownloadedPrefixSize }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetFileDownloadedPrefixSize {}


impl GetFileDownloadedPrefixSize {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileExtension {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileExtension
  /// The MIME type of the file.
  mime_type: Option<String>,
  
}



impl Object for GetFileExtension {}
impl RObject for GetFileExtension {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileExtension" }
  fn td_type(&self) -> RTDType { RTDType::GetFileExtension }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetFileExtension {}


impl GetFileExtension {
  
  pub fn mime_type(&self) -> Option<String> { self.mime_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileMimeType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getFileMimeType
  /// The name of the file or path to the file.
  file_name: Option<String>,
  
}



impl Object for GetFileMimeType {}
impl RObject for GetFileMimeType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getFileMimeType" }
  fn td_type(&self) -> RTDType { RTDType::GetFileMimeType }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetFileMimeType {}


impl GetFileMimeType {
  
  pub fn file_name(&self) -> Option<String> { self.file_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getGameHighScores
  /// The chat that contains the message with the game.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetGameHighScores {}
impl RObject for GetGameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getGameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GetGameHighScores }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetGameHighScores {}


impl GetGameHighScores {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGroupsInCommon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getGroupsInCommon
  /// User identifier.
  user_id: Option<i32>,
  /// Chat identifier starting from which to return chats; use 0 for the first request.
  offset_chat_id: Option<i64>,
  /// Maximum number of chats to be returned; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetGroupsInCommon {}
impl RObject for GetGroupsInCommon {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getGroupsInCommon" }
  fn td_type(&self) -> RTDType { RTDType::GetGroupsInCommon }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetGroupsInCommon {}


impl GetGroupsInCommon {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the total number of imported contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetImportedContactCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getImportedContactCount
  
}



impl Object for GetImportedContactCount {}
impl RObject for GetImportedContactCount {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getImportedContactCount" }
  fn td_type(&self) -> RTDType { RTDType::GetImportedContactCount }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetImportedContactCount {}


impl GetImportedContactCount {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns game high scores and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInlineGameHighScores
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetInlineGameHighScores {}
impl RObject for GetInlineGameHighScores {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInlineGameHighScores" }
  fn td_type(&self) -> RTDType { RTDType::GetInlineGameHighScores }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetInlineGameHighScores {}


impl GetInlineGameHighScores {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInlineQueryResults
  /// The identifier of the target bot.
  bot_user_id: Option<i32>,
  /// Identifier of the chat, where the query was sent.
  chat_id: Option<i64>,
  /// Location of the user, only if needed.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,
  
}



impl Object for GetInlineQueryResults {}
impl RObject for GetInlineQueryResults {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInlineQueryResults" }
  fn td_type(&self) -> RTDType { RTDType::GetInlineQueryResults }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetInlineQueryResults {}


impl GetInlineQueryResults {
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_location(&self) -> Option<Location> { self.user_location.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset(&self) -> Option<String> { self.offset.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInstalledStickerSets
  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  
}



impl Object for GetInstalledStickerSets {}
impl RObject for GetInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetInstalledStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetInstalledStickerSets {}


impl GetInstalledStickerSets {
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the default text for invitation messages to be used as a placeholder when the current user invites friends to Telegram.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInviteText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getInviteText
  
}



impl Object for GetInviteText {}
impl RObject for GetInviteText {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getInviteText" }
  fn td_type(&self) -> RTDType { RTDType::GetInviteText }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetInviteText {}


impl GetInviteText {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackInfo
  /// Language pack identifier.
  language_pack_id: Option<String>,
  
}



impl Object for GetLanguagePackInfo {}
impl RObject for GetLanguagePackInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLanguagePackInfo {}


impl GetLanguagePackInfo {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackString
  /// Path to the language pack database in which strings are stored.
  language_pack_database_path: Option<String>,
  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Language pack identifier.
  language_pack_id: Option<String>,
  /// Language pack key of the string to be returned.
  key: Option<String>,
  
}



impl Object for GetLanguagePackString {}
impl RObject for GetLanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackString" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLanguagePackString {}


impl GetLanguagePackString {
  
  pub fn language_pack_database_path(&self) -> Option<String> { self.language_pack_database_path.clone() }
  
  pub fn localization_target(&self) -> Option<String> { self.localization_target.clone() }
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn key(&self) -> Option<String> { self.key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLanguagePackStrings
  /// Language pack identifier of the strings to be returned.
  language_pack_id: Option<String>,
  /// Language pack keys of the strings to be returned; leave empty to request all available strings.
  keys: Option<Vec<String>>,
  
}



impl Object for GetLanguagePackStrings {}
impl RObject for GetLanguagePackStrings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLanguagePackStrings" }
  fn td_type(&self) -> RTDType { RTDType::GetLanguagePackStrings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLanguagePackStrings {}


impl GetLanguagePackStrings {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn keys(&self) -> Option<Vec<String>> { self.keys.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLocalizationTargetInfo
  /// If true, returns only locally available information without sending network requests.
  only_local: Option<bool>,
  
}



impl Object for GetLocalizationTargetInfo {}
impl RObject for GetLocalizationTargetInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLocalizationTargetInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetLocalizationTargetInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLocalizationTargetInfo {}


impl GetLocalizationTargetInfo {
  
  pub fn only_local(&self) -> Option<bool> { self.only_local.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about currently used log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogStream
  
}



impl Object for GetLogStream {}
impl RObject for GetLogStream {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogStream" }
  fn td_type(&self) -> RTDType { RTDType::GetLogStream }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLogStream {}


impl GetLogStream {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns current verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogTagVerbosityLevel
  /// Logging tag to change verbosity level.
  tag: Option<String>,
  
}



impl Object for GetLogTagVerbosityLevel {}
impl RObject for GetLogTagVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogTagVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::GetLogTagVerbosityLevel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLogTagVerbosityLevel {}


impl GetLogTagVerbosityLevel {
  
  pub fn tag(&self) -> Option<String> { self.tag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogTags
  
}



impl Object for GetLogTags {}
impl RObject for GetLogTags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogTags" }
  fn td_type(&self) -> RTDType { RTDType::GetLogTags }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLogTags {}


impl GetLogTags {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns current verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getLogVerbosityLevel
  
}



impl Object for GetLogVerbosityLevel {}
impl RObject for GetLogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getLogVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::GetLogVerbosityLevel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetLogVerbosityLevel {}


impl GetLogVerbosityLevel {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMapThumbnailFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMapThumbnailFile
  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level; 13-20.
  zoom: Option<i32>,
  /// Map width in pixels before applying scale; 16-1024.
  width: Option<i32>,
  /// Map height in pixels before applying scale; 16-1024.
  height: Option<i32>,
  /// Map scale; 1-3.
  scale: Option<i32>,
  /// Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown.
  chat_id: Option<i64>,
  
}



impl Object for GetMapThumbnailFile {}
impl RObject for GetMapThumbnailFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMapThumbnailFile" }
  fn td_type(&self) -> RTDType { RTDType::GetMapThumbnailFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMapThumbnailFile {}


impl GetMapThumbnailFile {
  
  pub fn location(&self) -> Option<Location> { self.location.clone() }
  
  pub fn zoom(&self) -> Option<i32> { self.zoom.clone() }
  
  pub fn width(&self) -> Option<i32> { self.width.clone() }
  
  pub fn height(&self) -> Option<i32> { self.height.clone() }
  
  pub fn scale(&self) -> Option<i32> { self.scale.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMe
  
}



impl Object for GetMe {}
impl RObject for GetMe {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMe" }
  fn td_type(&self) -> RTDType { RTDType::GetMe }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMe {}


impl GetMe {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,
  
}



impl Object for GetMessage {}
impl RObject for GetMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMessage {}


impl GetMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a private HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels. The link will work only for members of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessageLink
  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  
}



impl Object for GetMessageLink {}
impl RObject for GetMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::GetMessageLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMessageLink {}


impl GetMessageLink {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a message, if it is available locally without sending network request. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLocally {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessageLocally
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,
  
}



impl Object for GetMessageLocally {}
impl RObject for GetMessageLocally {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessageLocally" }
  fn td_type(&self) -> RTDType { RTDType::GetMessageLocally }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMessageLocally {}


impl GetMessageLocally {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about messages. If a message is not found, returns null on the corresponding position of the result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getMessages
  /// Identifier of the chat the messages belong to.
  chat_id: Option<i64>,
  /// Identifiers of the messages to get.
  message_ids: Option<Vec<i64>>,
  
}



impl Object for GetMessages {}
impl RObject for GetMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getMessages" }
  fn td_type(&self) -> RTDType { RTDType::GetMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetMessages {}


impl GetMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns network data usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getNetworkStatistics
  /// If true, returns only data for the current library launch.
  only_current: Option<bool>,
  
}



impl Object for GetNetworkStatistics {}
impl RObject for GetNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetNetworkStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetNetworkStatistics {}


impl GetNetworkStatistics {
  
  pub fn only_current(&self) -> Option<bool> { self.only_current.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the value of an option by its name. (Check the list of available options on 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getOption
  /// The name of the option.
  name: Option<String>,
  
}



impl Object for GetOption {}
impl RObject for GetOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getOption" }
  fn td_type(&self) -> RTDType { RTDType::GetOption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetOption {}


impl GetOption {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a Telegram Passport authorization form for sharing data with a service.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportAuthorizationForm
  /// User identifier of the service's bot.
  bot_user_id: Option<i32>,
  /// Telegram Passport element types requested by the service.
  scope: Option<String>,
  /// Service's public_key.
  public_key: Option<String>,
  /// Authorization form nonce provided by the service.
  nonce: Option<String>,
  
}



impl Object for GetPassportAuthorizationForm {}
impl RObject for GetPassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportAuthorizationForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPassportAuthorizationForm {}


impl GetPassportAuthorizationForm {
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn scope(&self) -> Option<String> { self.scope.clone() }
  
  pub fn public_key(&self) -> Option<String> { self.public_key.clone() }
  
  pub fn nonce(&self) -> Option<String> { self.nonce.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationFormAvailableElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportAuthorizationFormAvailableElements
  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Password of the current user.
  password: Option<String>,
  
}



impl Object for GetPassportAuthorizationFormAvailableElements {}
impl RObject for GetPassportAuthorizationFormAvailableElements {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportAuthorizationFormAvailableElements" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportAuthorizationFormAvailableElements }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPassportAuthorizationFormAvailableElements {}


impl GetPassportAuthorizationFormAvailableElements {
  
  pub fn autorization_form_id(&self) -> Option<i32> { self.autorization_form_id.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns one of the available Telegram Passport elements.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPassportElement
  /// Telegram Passport element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Password of the current user.
  password: Option<String>,
  
}


impl Clone for GetPassportElement {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetPassportElement {}
impl RObject for GetPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::GetPassportElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPassportElement {}


impl GetPassportElement {
  
  pub fn type_(&self) -> Option<Box<PassportElementType>> { self.type_.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the current state of 2-step verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPasswordState
  
}



impl Object for GetPasswordState {}
impl RObject for GetPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::GetPasswordState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPasswordState {}


impl GetPasswordState {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPaymentForm
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for GetPaymentForm {}
impl RObject for GetPaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPaymentForm" }
  fn td_type(&self) -> RTDType { RTDType::GetPaymentForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPaymentForm {}


impl GetPaymentForm {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a successful payment.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPaymentReceipt
  /// Chat identifier of the PaymentSuccessful message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  
}



impl Object for GetPaymentReceipt {}
impl RObject for GetPaymentReceipt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPaymentReceipt" }
  fn td_type(&self) -> RTDType { RTDType::GetPaymentReceipt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPaymentReceipt {}


impl GetPaymentReceipt {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPreferredCountryLanguage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPreferredCountryLanguage
  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,
  
}



impl Object for GetPreferredCountryLanguage {}
impl RObject for GetPreferredCountryLanguage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPreferredCountryLanguage" }
  fn td_type(&self) -> RTDType { RTDType::GetPreferredCountryLanguage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPreferredCountryLanguage {}


impl GetPreferredCountryLanguage {
  
  pub fn country_code(&self) -> Option<String> { self.country_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns list of proxies that are currently set up. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getProxies
  
}



impl Object for GetProxies {}
impl RObject for GetProxies {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getProxies" }
  fn td_type(&self) -> RTDType { RTDType::GetProxies }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetProxies {}


impl GetProxies {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxyLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getProxyLink
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for GetProxyLink {}
impl RObject for GetProxyLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getProxyLink" }
  fn td_type(&self) -> RTDType { RTDType::GetProxyLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetProxyLink {}


impl GetProxyLink {
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a public HTTPS link to a message. Available only for messages in public supergroups and channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPublicMessageLink
  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// Pass true if a link for a whole media album should be returned.
  for_album: Option<bool>,
  
}



impl Object for GetPublicMessageLink {}
impl RObject for GetPublicMessageLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPublicMessageLink" }
  fn td_type(&self) -> RTDType { RTDType::GetPublicMessageLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPublicMessageLink {}


impl GetPublicMessageLink {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn for_album(&self) -> Option<bool> { self.for_album.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getPushReceiverId
  /// JSON-encoded push notification payload.
  payload: Option<String>,
  
}



impl Object for GetPushReceiverId {}
impl RObject for GetPushReceiverId {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getPushReceiverId" }
  fn td_type(&self) -> RTDType { RTDType::GetPushReceiverId }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetPushReceiverId {}


impl GetPushReceiverId {
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns up to 20 recently used inline bots in the order of their last usage.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentInlineBots
  
}



impl Object for GetRecentInlineBots {}
impl RObject for GetRecentInlineBots {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentInlineBots" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentInlineBots }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRecentInlineBots {}


impl GetRecentInlineBots {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentStickers
  /// Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers.
  is_attached: Option<bool>,
  
}



impl Object for GetRecentStickers {}
impl RObject for GetRecentStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRecentStickers {}


impl GetRecentStickers {
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns t.me URLs recently visited by a newly registered user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentlyVisitedTMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecentlyVisitedTMeUrls
  /// Google Play referrer to identify the user.
  referrer: Option<String>,
  
}



impl Object for GetRecentlyVisitedTMeUrls {}
impl RObject for GetRecentlyVisitedTMeUrls {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecentlyVisitedTMeUrls" }
  fn td_type(&self) -> RTDType { RTDType::GetRecentlyVisitedTMeUrls }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRecentlyVisitedTMeUrls {}


impl GetRecentlyVisitedTMeUrls {
  
  pub fn referrer(&self) -> Option<String> { self.referrer.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRecoveryEmailAddress
  /// The password for the current user.
  password: Option<String>,
  
}



impl Object for GetRecoveryEmailAddress {}
impl RObject for GetRecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRecoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::GetRecoveryEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRecoveryEmailAddress {}


impl GetRecoveryEmailAddress {
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetRemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRemoteFile
  /// Remote identifier of the file to get.
  remote_file_id: Option<String>,
  /// File type, if known.
  file_type: Option<Box<FileType>>,
  
}


impl Clone for GetRemoteFile {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetRemoteFile {}
impl RObject for GetRemoteFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRemoteFile" }
  fn td_type(&self) -> RTDType { RTDType::GetRemoteFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRemoteFile {}


impl GetRemoteFile {
  
  pub fn remote_file_id(&self) -> Option<String> { self.remote_file_id.clone() }
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a message that is replied by given message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRepliedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getRepliedMessage
  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message reply to which get.
  message_id: Option<i64>,
  
}



impl Object for GetRepliedMessage {}
impl RObject for GetRepliedMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getRepliedMessage" }
  fn td_type(&self) -> RTDType { RTDType::GetRepliedMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetRepliedMessage {}


impl GetRepliedMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns saved animations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSavedAnimations
  
}



impl Object for GetSavedAnimations {}
impl RObject for GetSavedAnimations {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSavedAnimations" }
  fn td_type(&self) -> RTDType { RTDType::GetSavedAnimations }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSavedAnimations {}


impl GetSavedAnimations {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns saved order info, if any.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSavedOrderInfo
  
}



impl Object for GetSavedOrderInfo {}
impl RObject for GetSavedOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSavedOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetSavedOrderInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSavedOrderInfo {}


impl GetSavedOrderInfo {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getScopeNotificationSettings
  /// Types of chats for which to return the notification settings information.
  scope: Option<Box<NotificationSettingsScope>>,
  
}


impl Clone for GetScopeNotificationSettings {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetScopeNotificationSettings {}
impl RObject for GetScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::GetScopeNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetScopeNotificationSettings {}


impl GetScopeNotificationSettings {
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a secret chat by its identifier. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSecretChat
  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  
}



impl Object for GetSecretChat {}
impl RObject for GetSecretChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSecretChat" }
  fn td_type(&self) -> RTDType { RTDType::GetSecretChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSecretChat {}


impl GetSecretChat {
  
  pub fn secret_chat_id(&self) -> Option<i32> { self.secret_chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns emoji corresponding to a sticker.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetStickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickerEmojis
  /// Sticker file identifier.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for GetStickerEmojis {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetStickerEmojis {}
impl RObject for GetStickerEmojis {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickerEmojis" }
  fn td_type(&self) -> RTDType { RTDType::GetStickerEmojis }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetStickerEmojis {}


impl GetStickerEmojis {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a sticker set by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickerSet
  /// Identifier of the sticker set.
  set_id: Option<i64>,
  
}



impl Object for GetStickerSet {}
impl RObject for GetStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::GetStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetStickerSet {}


impl GetStickerSet {
  
  pub fn set_id(&self) -> Option<i64> { self.set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStickers
  /// String representation of emoji. If empty, returns all known installed stickers.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,
  
}



impl Object for GetStickers {}
impl RObject for GetStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStickers" }
  fn td_type(&self) -> RTDType { RTDType::GetStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetStickers {}


impl GetStickers {
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStorageStatistics
  /// Maximum number of chats with the largest storage usage for which separate statistics should be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0.
  chat_limit: Option<i32>,
  
}



impl Object for GetStorageStatistics {}
impl RObject for GetStorageStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStorageStatistics" }
  fn td_type(&self) -> RTDType { RTDType::GetStorageStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetStorageStatistics {}


impl GetStorageStatistics {
  
  pub fn chat_limit(&self) -> Option<i32> { self.chat_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Quickly returns approximate storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getStorageStatisticsFast
  
}



impl Object for GetStorageStatisticsFast {}
impl RObject for GetStorageStatisticsFast {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getStorageStatisticsFast" }
  fn td_type(&self) -> RTDType { RTDType::GetStorageStatisticsFast }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetStorageStatisticsFast {}


impl GetStorageStatisticsFast {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a supergroup or channel by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroup
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  
}



impl Object for GetSupergroup {}
impl RObject for GetSupergroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroup" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSupergroup {}


impl GetSupergroup {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns full information about a supergroup or channel by its identifier, cached for up to 1 minute.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroupFullInfo
  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  
}



impl Object for GetSupergroupFullInfo {}
impl RObject for GetSupergroupFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroupFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroupFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSupergroupFullInfo {}


impl GetSupergroupFullInfo {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetSupergroupMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupergroupMembers
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// The type of users to return. By default, supergroupMembersRecent.
  filter: Option<Box<SupergroupMembersFilter>>,
  /// Number of users to skip.
  offset: Option<i32>,
  /// The maximum number of users be returned; up to 200.
  limit: Option<i32>,
  
}


impl Clone for GetSupergroupMembers {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetSupergroupMembers {}
impl RObject for GetSupergroupMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupergroupMembers" }
  fn td_type(&self) -> RTDType { RTDType::GetSupergroupMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSupergroupMembers {}


impl GetSupergroupMembers {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn filter(&self) -> Option<Box<SupergroupMembersFilter>> { self.filter.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a user that can be contacted to get support.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupportUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getSupportUser
  
}



impl Object for GetSupportUser {}
impl RObject for GetSupportUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getSupportUser" }
  fn td_type(&self) -> RTDType { RTDType::GetSupportUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetSupportUser {}


impl GetSupportUser {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about the current temporary password.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTemporaryPasswordState
  
}



impl Object for GetTemporaryPasswordState {}
impl RObject for GetTemporaryPasswordState {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTemporaryPasswordState" }
  fn td_type(&self) -> RTDType { RTDType::GetTemporaryPasswordState }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetTemporaryPasswordState {}


impl GetTemporaryPasswordState {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns all entities (mentions, hashtags, cashtags, bot commands, URLs, and email addresses) contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTextEntities
  /// The text in which to look for entites.
  text: Option<String>,
  
}



impl Object for GetTextEntities {}
impl RObject for GetTextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTextEntities" }
  fn td_type(&self) -> RTDType { RTDType::GetTextEntities }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetTextEntities {}


impl GetTextEntities {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetTopChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTopChats
  /// Category of chats to be returned.
  category: Option<Box<TopChatCategory>>,
  /// Maximum number of chats to be returned; up to 30.
  limit: Option<i32>,
  
}


impl Clone for GetTopChats {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetTopChats {}
impl RObject for GetTopChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTopChats" }
  fn td_type(&self) -> RTDType { RTDType::GetTopChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetTopChats {}


impl GetTopChats {
  
  pub fn category(&self) -> Option<Box<TopChatCategory>> { self.category.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a list of trending sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getTrendingStickerSets
  
}



impl Object for GetTrendingStickerSets {}
impl RObject for GetTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::GetTrendingStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetTrendingStickerSets {}


impl GetTrendingStickerSets {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about a user by their identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetUser {}
impl RObject for GetUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUser" }
  fn td_type(&self) -> RTDType { RTDType::GetUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetUser {}


impl GetUser {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns full information about a user by their identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserFullInfo
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for GetUserFullInfo {}
impl RObject for GetUserFullInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserFullInfo" }
  fn td_type(&self) -> RTDType { RTDType::GetUserFullInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetUserFullInfo {}


impl GetUserFullInfo {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the current privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  
}


impl Clone for GetUserPrivacySettingRules {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for GetUserPrivacySettingRules {}
impl RObject for GetUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::GetUserPrivacySettingRules }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetUserPrivacySettingRules {}


impl GetUserPrivacySettingRules {
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getUserProfilePhotos
  /// User identifier.
  user_id: Option<i32>,
  /// The number of photos to skip; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of photos to be returned; up to 100.
  limit: Option<i32>,
  
}



impl Object for GetUserProfilePhotos {}
impl RObject for GetUserProfilePhotos {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getUserProfilePhotos" }
  fn td_type(&self) -> RTDType { RTDType::GetUserProfilePhotos }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetUserProfilePhotos {}


impl GetUserProfilePhotos {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns background wallpapers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWallpapers
  
}



impl Object for GetWallpapers {}
impl RObject for GetWallpapers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWallpapers" }
  fn td_type(&self) -> RTDType { RTDType::GetWallpapers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetWallpapers {}


impl GetWallpapers {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWebPageInstantView
  /// The web page URL.
  url: Option<String>,
  /// If true, the full instant view for the web page will be returned.
  force_full: Option<bool>,
  
}



impl Object for GetWebPageInstantView {}
impl RObject for GetWebPageInstantView {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWebPageInstantView" }
  fn td_type(&self) -> RTDType { RTDType::GetWebPageInstantView }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetWebPageInstantView {}


impl GetWebPageInstantView {
  
  pub fn url(&self) -> Option<String> { self.url.clone() }
  
  pub fn force_full(&self) -> Option<bool> { self.force_full.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPagePreview {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // getWebPagePreview
  /// Message text with formatting.
  text: Option<FormattedText>,
  
}



impl Object for GetWebPagePreview {}
impl RObject for GetWebPagePreview {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "getWebPagePreview" }
  fn td_type(&self) -> RTDType { RTDType::GetWebPagePreview }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for GetWebPagePreview {}


impl GetWebPagePreview {
  
  pub fn text(&self) -> Option<FormattedText> { self.text.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds new contacts or edits existing contacts; contacts' user identifiers are ignored.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // importContacts
  /// The list of contacts to import or edit, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,
  
}



impl Object for ImportContacts {}
impl RObject for ImportContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "importContacts" }
  fn td_type(&self) -> RTDType { RTDType::ImportContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ImportContacts {}


impl ImportContacts {
  
  pub fn contacts(&self) -> Option<Vec<Contact>> { self.contacts.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds current user as a new member to a chat. Private and secret chats can't be joined using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // joinChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for JoinChat {}
impl RObject for JoinChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "joinChat" }
  fn td_type(&self) -> RTDType { RTDType::JoinChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for JoinChat {}


impl JoinChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChatByInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // joinChatByInviteLink
  /// Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,
  
}



impl Object for JoinChatByInviteLink {}
impl RObject for JoinChatByInviteLink {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "joinChatByInviteLink" }
  fn td_type(&self) -> RTDType { RTDType::JoinChatByInviteLink }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for JoinChatByInviteLink {}


impl JoinChatByInviteLink {
  
  pub fn invite_link(&self) -> Option<String> { self.invite_link.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes current user from chat members. Private and secret chats can't be left using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LeaveChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // leaveChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for LeaveChat {}
impl RObject for LeaveChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "leaveChat" }
  fn td_type(&self) -> RTDType { RTDType::LeaveChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for LeaveChat {}


impl LeaveChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // logOut
  
}



impl Object for LogOut {}
impl RObject for LogOut {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "logOut" }
  fn td_type(&self) -> RTDType { RTDType::LogOut }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for LogOut {}


impl LogOut {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // openChat
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for OpenChat {}
impl RObject for OpenChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "openChat" }
  fn td_type(&self) -> RTDType { RTDType::OpenChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for OpenChat {}


impl OpenChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // openMessageContent
  /// Chat identifier of the message.
  chat_id: Option<i64>,
  /// Identifier of the message with the opened content.
  message_id: Option<i64>,
  
}



impl Object for OpenMessageContent {}
impl RObject for OpenMessageContent {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "openMessageContent" }
  fn td_type(&self) -> RTDType { RTDType::OpenMessageContent }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for OpenMessageContent {}


impl OpenMessageContent {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted.
#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizeStorage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // optimizeStorage
  /// Limit on the total size of files after deletion. Pass -1 to use the default limit.
  size: Option<i64>,
  /// Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit.
  ttl: Option<i32>,
  /// Limit on the total count of files after deletion. Pass -1 to use the default limit.
  count: Option<i32>,
  /// The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value.
  immunity_delay: Option<i32>,
  /// If not empty, only files with the given type(s) are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted.
  file_types: Option<Vec<Box<FileType>>>,
  /// If not empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos).
  chat_ids: Option<Vec<i64>>,
  /// If not empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos).
  exclude_chat_ids: Option<Vec<i64>>,
  /// Same as in getStorageStatistics. Affects only returned statistics.
  chat_limit: Option<i32>,
  
}


impl Clone for OptimizeStorage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for OptimizeStorage {}
impl RObject for OptimizeStorage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "optimizeStorage" }
  fn td_type(&self) -> RTDType { RTDType::OptimizeStorage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for OptimizeStorage {}


impl OptimizeStorage {
  
  pub fn size(&self) -> Option<i64> { self.size.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn immunity_delay(&self) -> Option<i32> { self.immunity_delay.clone() }
  
  pub fn file_types(&self) -> Option<Vec<Box<FileType>>> { self.file_types.clone() }
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn exclude_chat_ids(&self) -> Option<Vec<i64>> { self.exclude_chat_ids.clone() }
  
  pub fn chat_limit(&self) -> Option<i32> { self.chat_limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Parses Bold, Italic, Code, Pre, PreCode and TextUrl entities contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct ParseTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // parseTextEntities
  /// The text which should be parsed.
  text: Option<String>,
  /// Text parse mode.
  parse_mode: Option<Box<TextParseMode>>,
  
}


impl Clone for ParseTextEntities {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ParseTextEntities {}
impl RObject for ParseTextEntities {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "parseTextEntities" }
  fn td_type(&self) -> RTDType { RTDType::ParseTextEntities }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ParseTextEntities {}


impl ParseTextEntities {
  
  pub fn text(&self) -> Option<String> { self.text.clone() }
  
  pub fn parse_mode(&self) -> Option<Box<TextParseMode>> { self.parse_mode.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Pins a message in a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pinChatMessage
  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// Identifier of the new pinned message.
  message_id: Option<i64>,
  /// True, if there should be no notification about the pinned message.
  disable_notification: Option<bool>,
  
}



impl Object for PinChatMessage {}
impl RObject for PinChatMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pinChatMessage" }
  fn td_type(&self) -> RTDType { RTDType::PinChatMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for PinChatMessage {}


impl PinChatMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PingProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // pingProxy
  /// Proxy identifier. Use 0 to ping a Telegram server without a proxy.
  proxy_id: Option<i32>,
  
}



impl Object for PingProxy {}
impl RObject for PingProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "pingProxy" }
  fn td_type(&self) -> RTDType { RTDType::PingProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for PingProxy {}


impl PingProxy {
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessPushNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // processPushNotification
  /// JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added.
  payload: Option<String>,
  
}



impl Object for ProcessPushNotification {}
impl RObject for ProcessPushNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "processPushNotification" }
  fn td_type(&self) -> RTDType { RTDType::ProcessPushNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ProcessPushNotification {}


impl ProcessPushNotification {
  
  pub fn payload(&self) -> Option<String> { self.payload.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Marks all mentions in a chat as read.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadAllChatMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // readAllChatMentions
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for ReadAllChatMentions {}
impl RObject for ReadAllChatMentions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "readAllChatMentions" }
  fn td_type(&self) -> RTDType { RTDType::ReadAllChatMentions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ReadAllChatMentions {}


impl ReadAllChatMentions {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct read from the file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // readFilePart
  /// Identifier of the file. The file must be located in the TDLib file cache.
  file_id: Option<i32>,
  /// The offset from which to read the file.
  offset: Option<i32>,
  /// Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position.
  count: Option<i32>,
  
}



impl Object for ReadFilePart {}
impl RObject for ReadFilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "readFilePart" }
  fn td_type(&self) -> RTDType { RTDType::ReadFilePart }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ReadFilePart {}


impl ReadFilePart {
  
  pub fn file_id(&self) -> Option<i32> { self.file_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn count(&self) -> Option<i32> { self.count.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoverAuthenticationPassword
  /// Recovery code to check.
  recovery_code: Option<String>,
  
}



impl Object for RecoverAuthenticationPassword {}
impl RObject for RecoverAuthenticationPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoverAuthenticationPassword" }
  fn td_type(&self) -> RTDType { RTDType::RecoverAuthenticationPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RecoverAuthenticationPassword {}


impl RecoverAuthenticationPassword {
  
  pub fn recovery_code(&self) -> Option<String> { self.recovery_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Recovers the password using a recovery code sent to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // recoverPassword
  /// Recovery code to check.
  recovery_code: Option<String>,
  
}



impl Object for RecoverPassword {}
impl RObject for RecoverPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "recoverPassword" }
  fn td_type(&self) -> RTDType { RTDType::RecoverPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RecoverPassword {}


impl RecoverPassword {
  
  pub fn recovery_code(&self) -> Option<String> { self.recovery_code.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription.
#[derive(Debug, Serialize, Deserialize)]
pub struct RegisterDevice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // registerDevice
  /// Device token.
  device_token: Option<Box<DeviceToken>>,
  /// List of user identifiers of other users currently using the client.
  other_user_ids: Option<Vec<i32>>,
  
}


impl Clone for RegisterDevice {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RegisterDevice {}
impl RObject for RegisterDevice {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "registerDevice" }
  fn td_type(&self) -> RTDType { RTDType::RegisterDevice }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RegisterDevice {}


impl RegisterDevice {
  
  pub fn device_token(&self) -> Option<Box<DeviceToken>> { self.device_token.clone() }
  
  pub fn other_user_ids(&self) -> Option<Vec<i32>> { self.other_user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes users from the contact list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeContacts
  /// Identifiers of users to be deleted.
  user_ids: Option<Vec<i32>>,
  
}



impl Object for RemoveContacts {}
impl RObject for RemoveContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeContacts" }
  fn td_type(&self) -> RTDType { RTDType::RemoveContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveContacts {}


impl RemoveContacts {
  
  pub fn user_ids(&self) -> Option<Vec<i32>> { self.user_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a sticker from the list of favorite stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeFavoriteSticker
  /// Sticker file to delete from the list.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveFavoriteSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RemoveFavoriteSticker {}
impl RObject for RemoveFavoriteSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeFavoriteSticker" }
  fn td_type(&self) -> RTDType { RTDType::RemoveFavoriteSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveFavoriteSticker {}


impl RemoveFavoriteSticker {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeNotification
  /// Identifier of notification group to which the notification belongs.
  notification_group_id: Option<i32>,
  /// Identifier of removed notification.
  notification_id: Option<i32>,
  
}



impl Object for RemoveNotification {}
impl RObject for RemoveNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeNotification" }
  fn td_type(&self) -> RTDType { RTDType::RemoveNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveNotification {}


impl RemoveNotification {
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn notification_id(&self) -> Option<i32> { self.notification_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeNotificationGroup
  /// Notification group identifier.
  notification_group_id: Option<i32>,
  /// Maximum identifier of removed notifications.
  max_notification_id: Option<i32>,
  
}



impl Object for RemoveNotificationGroup {}
impl RObject for RemoveNotificationGroup {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeNotificationGroup" }
  fn td_type(&self) -> RTDType { RTDType::RemoveNotificationGroup }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveNotificationGroup {}


impl RemoveNotificationGroup {
  
  pub fn notification_group_id(&self) -> Option<i32> { self.notification_group_id.clone() }
  
  pub fn max_notification_id(&self) -> Option<i32> { self.max_notification_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a proxy server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeProxy
  /// Proxy identifier.
  proxy_id: Option<i32>,
  
}



impl Object for RemoveProxy {}
impl RObject for RemoveProxy {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeProxy" }
  fn td_type(&self) -> RTDType { RTDType::RemoveProxy }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveProxy {}


impl RemoveProxy {
  
  pub fn proxy_id(&self) -> Option<i32> { self.proxy_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a hashtag from the list of recently used hashtags.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentHashtag
  /// Hashtag to delete.
  hashtag: Option<String>,
  
}



impl Object for RemoveRecentHashtag {}
impl RObject for RemoveRecentHashtag {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentHashtag" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentHashtag }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveRecentHashtag {}


impl RemoveRecentHashtag {
  
  pub fn hashtag(&self) -> Option<String> { self.hashtag.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a sticker from the list of recently used stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentSticker
  /// Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to delete.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveRecentSticker {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RemoveRecentSticker {}
impl RObject for RemoveRecentSticker {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentSticker" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentSticker }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveRecentSticker {}


impl RemoveRecentSticker {
  
  pub fn is_attached(&self) -> Option<bool> { self.is_attached.clone() }
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a chat from the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeRecentlyFoundChat
  /// Identifier of the chat to be removed.
  chat_id: Option<i64>,
  
}



impl Object for RemoveRecentlyFoundChat {}
impl RObject for RemoveRecentlyFoundChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeRecentlyFoundChat" }
  fn td_type(&self) -> RTDType { RTDType::RemoveRecentlyFoundChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveRecentlyFoundChat {}


impl RemoveRecentlyFoundChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes an animation from the list of saved animations.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeSavedAnimation
  /// Animation file to be removed.
  animation: Option<Box<InputFile>>,
  
}


impl Clone for RemoveSavedAnimation {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RemoveSavedAnimation {}
impl RObject for RemoveSavedAnimation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeSavedAnimation" }
  fn td_type(&self) -> RTDType { RTDType::RemoveSavedAnimation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveSavedAnimation {}


impl RemoveSavedAnimation {
  
  pub fn animation(&self) -> Option<Box<InputFile>> { self.animation.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveStickerFromSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeStickerFromSet
  /// Sticker.
  sticker: Option<Box<InputFile>>,
  
}


impl Clone for RemoveStickerFromSet {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RemoveStickerFromSet {}
impl RObject for RemoveStickerFromSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeStickerFromSet" }
  fn td_type(&self) -> RTDType { RTDType::RemoveStickerFromSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveStickerFromSet {}


impl RemoveStickerFromSet {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveTopChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // removeTopChat
  /// Category of frequently used chats.
  category: Option<Box<TopChatCategory>>,
  /// Chat identifier.
  chat_id: Option<i64>,
  
}


impl Clone for RemoveTopChat {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for RemoveTopChat {}
impl RObject for RemoveTopChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "removeTopChat" }
  fn td_type(&self) -> RTDType { RTDType::RemoveTopChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RemoveTopChat {}


impl RemoveTopChat {
  
  pub fn category(&self) -> Option<Box<TopChatCategory>> { self.category.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the order of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReorderInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reorderInstalledStickerSets
  /// Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifiers of installed sticker sets in the new correct order.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for ReorderInstalledStickerSets {}
impl RObject for ReorderInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reorderInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::ReorderInstalledStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ReorderInstalledStickerSets {}


impl ReorderInstalledStickerSets {
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Reports a chat to the Telegram moderators. Supported only for supergroups, channels, or private chats with bots, since other chats can't be checked by moderators.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReportChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reportChat
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The reason for reporting the chat.
  reason: Option<Box<ChatReportReason>>,
  /// Identifiers of reported messages, if any.
  message_ids: Option<Vec<i64>>,
  
}


impl Clone for ReportChat {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for ReportChat {}
impl RObject for ReportChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reportChat" }
  fn td_type(&self) -> RTDType { RTDType::ReportChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ReportChat {}


impl ReportChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reason(&self) -> Option<Box<ChatReportReason>> { self.reason.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportSupergroupSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // reportSupergroupSpam
  /// Supergroup identifier.
  supergroup_id: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// Identifiers of messages sent in the supergroup by the user. This list must be non-empty.
  message_ids: Option<Vec<i64>>,
  
}



impl Object for ReportSupergroupSpam {}
impl RObject for ReportSupergroupSpam {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "reportSupergroupSpam" }
  fn td_type(&self) -> RTDType { RTDType::ReportSupergroupSpam }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ReportSupergroupSpam {}


impl ReportSupergroupSpam {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestAuthenticationPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // requestAuthenticationPasswordRecovery
  
}



impl Object for RequestAuthenticationPasswordRecovery {}
impl RObject for RequestAuthenticationPasswordRecovery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "requestAuthenticationPasswordRecovery" }
  fn td_type(&self) -> RTDType { RTDType::RequestAuthenticationPasswordRecovery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RequestAuthenticationPasswordRecovery {}


impl RequestAuthenticationPasswordRecovery {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Requests to send a password recovery code to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // requestPasswordRecovery
  
}



impl Object for RequestPasswordRecovery {}
impl RObject for RequestPasswordRecovery {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "requestPasswordRecovery" }
  fn td_type(&self) -> RTDType { RTDType::RequestPasswordRecovery }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for RequestPasswordRecovery {}


impl RequestPasswordRecovery {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Re-sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendAuthenticationCode
  
}



impl Object for ResendAuthenticationCode {}
impl RObject for ResendAuthenticationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendAuthenticationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendAuthenticationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendAuthenticationCode {}


impl ResendAuthenticationCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Re-sends the authentication code sent to confirm a new phone number for the user. Works only if the previously received 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendChangePhoneNumberCode
  
}



impl Object for ResendChangePhoneNumberCode {}
impl RObject for ResendChangePhoneNumberCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendChangePhoneNumberCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendChangePhoneNumberCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendChangePhoneNumberCode {}


impl ResendChangePhoneNumberCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Re-sends the code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendEmailAddressVerificationCode
  
}



impl Object for ResendEmailAddressVerificationCode {}
impl RObject for ResendEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendEmailAddressVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendEmailAddressVerificationCode {}


impl ResendEmailAddressVerificationCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Resends phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendPhoneNumberConfirmationCode
  
}



impl Object for ResendPhoneNumberConfirmationCode {}
impl RObject for ResendPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendPhoneNumberConfirmationCode {}


impl ResendPhoneNumberConfirmationCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Re-sends the code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendPhoneNumberVerificationCode
  
}



impl Object for ResendPhoneNumberVerificationCode {}
impl RObject for ResendPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendPhoneNumberVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendPhoneNumberVerificationCode {}


impl ResendPhoneNumberVerificationCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Resends the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resendRecoveryEmailAddressCode
  
}



impl Object for ResendRecoveryEmailAddressCode {}
impl RObject for ResendRecoveryEmailAddressCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resendRecoveryEmailAddressCode" }
  fn td_type(&self) -> RTDType { RTDType::ResendRecoveryEmailAddressCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResendRecoveryEmailAddressCode {}


impl ResendRecoveryEmailAddressCode {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetAllNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resetAllNotificationSettings
  
}



impl Object for ResetAllNotificationSettings {}
impl RObject for ResetAllNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resetAllNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::ResetAllNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResetAllNotificationSettings {}


impl ResetAllNotificationSettings {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Resets all network data usage statistics to zero. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // resetNetworkStatistics
  
}



impl Object for ResetNetworkStatistics {}
impl RObject for ResetNetworkStatistics {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "resetNetworkStatistics" }
  fn td_type(&self) -> RTDType { RTDType::ResetNetworkStatistics }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ResetNetworkStatistics {}


impl ResetNetworkStatistics {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchCallMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchCallMessages
  /// Identifier of the message from which to search; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages with missed calls.
  only_missed: Option<bool>,
  
}



impl Object for SearchCallMessages {}
impl RObject for SearchCallMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchCallMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchCallMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchCallMessages {}


impl SearchCallMessages {
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn only_missed(&self) -> Option<bool> { self.only_missed.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatMembers
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// The maximum number of users to be returned.
  limit: Option<i32>,
  /// The type of users to return. By default, chatMembersFilterMembers.
  filter: Option<Box<ChatMembersFilter>>,
  
}


impl Clone for SearchChatMembers {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SearchChatMembers {}
impl RObject for SearchChatMembers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatMembers" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatMembers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchChatMembers {}


impl SearchChatMembers {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<ChatMembersFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query (
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatMessages
  /// Identifier of the chat in which to search messages.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// If not 0, only messages sent by the specified user will be returned. Not supported in secret chats.
  sender_user_id: Option<i32>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// Filter for message content in the search results.
  filter: Option<Box<SearchMessagesFilter>>,
  
}


impl Clone for SearchChatMessages {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SearchChatMessages {}
impl RObject for SearchChatMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchChatMessages {}


impl SearchChatMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn sender_user_id(&self) -> Option<i32> { self.sender_user_id.clone() }
  
  pub fn from_message_id(&self) -> Option<i64> { self.from_message_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatRecentLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatRecentLocationMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Maximum number of messages to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChatRecentLocationMessages {}
impl RObject for SearchChatRecentLocationMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatRecentLocationMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatRecentLocationMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchChatRecentLocationMessages {}


impl SearchChatRecentLocationMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChats
  /// Query to search for. If the query is empty, returns up to 20 recently found chats.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChats {}
impl RObject for SearchChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChats" }
  fn td_type(&self) -> RTDType { RTDType::SearchChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchChats {}


impl SearchChats {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatsOnServer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchChatsOnServer
  /// Query to search for.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchChatsOnServer {}
impl RObject for SearchChatsOnServer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchChatsOnServer" }
  fn td_type(&self) -> RTDType { RTDType::SearchChatsOnServer }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchChatsOnServer {}


impl SearchChatsOnServer {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for the specified query in the first names, last names and usernames of the known user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchContacts
  /// Query to search for; may be empty to return all contacts.
  query: Option<String>,
  /// Maximum number of users to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchContacts {}
impl RObject for SearchContacts {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchContacts" }
  fn td_type(&self) -> RTDType { RTDType::SearchContacts }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchContacts {}


impl SearchContacts {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for recently used hashtags by their prefix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchHashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchHashtags
  /// Hashtag prefix to search for.
  prefix: Option<String>,
  /// Maximum number of hashtags to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchHashtags {}
impl RObject for SearchHashtags {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchHashtags" }
  fn td_type(&self) -> RTDType { RTDType::SearchHashtags }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchHashtags {}


impl SearchHashtags {
  
  pub fn prefix(&self) -> Option<String> { self.prefix.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for installed sticker sets by looking for specified query in their title and name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchInstalledStickerSets
  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Query to search for.
  query: Option<String>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,
  
}



impl Object for SearchInstalledStickerSets {}
impl RObject for SearchInstalledStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchInstalledStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::SearchInstalledStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchInstalledStickerSets {}


impl SearchInstalledStickerSets {
  
  pub fn is_masks(&self) -> Option<bool> { self.is_masks.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchMessages
  /// Query to search for.
  query: Option<String>,
  /// The date of the message starting from which the results should be fetched. Use 0 or any date in the future to get results from the last message.
  offset_date: Option<i32>,
  /// The chat identifier of the last found message, or 0 for the first request.
  offset_chat_id: Option<i64>,
  /// The message identifier of the last found message, or 0 for the first request.
  offset_message_id: Option<i64>,
  /// The maximum number of messages to be returned, up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  
}



impl Object for SearchMessages {}
impl RObject for SearchMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchMessages {}


impl SearchMessages {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn offset_date(&self) -> Option<i32> { self.offset_date.clone() }
  
  pub fn offset_chat_id(&self) -> Option<i64> { self.offset_chat_id.clone() }
  
  pub fn offset_message_id(&self) -> Option<i64> { self.offset_message_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchPublicChat
  /// Username to be resolved.
  username: Option<String>,
  
}



impl Object for SearchPublicChat {}
impl RObject for SearchPublicChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchPublicChat" }
  fn td_type(&self) -> RTDType { RTDType::SearchPublicChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchPublicChat {}


impl SearchPublicChat {
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchPublicChats
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SearchPublicChats {}
impl RObject for SearchPublicChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchPublicChats" }
  fn td_type(&self) -> RTDType { RTDType::SearchPublicChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchPublicChats {}


impl SearchPublicChats {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchSecretMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchSecretMessages
  /// Identifier of the chat in which to search. Specify 0 to search in all secret chats.
  chat_id: Option<i64>,
  /// Query to search for. If empty, searchChatMessages should be used instead.
  query: Option<String>,
  /// The identifier from the result of a previous request, use 0 to get results from the last message.
  from_search_id: Option<i64>,
  /// Maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// A filter for the content of messages in the search results.
  filter: Option<Box<SearchMessagesFilter>>,
  
}


impl Clone for SearchSecretMessages {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SearchSecretMessages {}
impl RObject for SearchSecretMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchSecretMessages" }
  fn td_type(&self) -> RTDType { RTDType::SearchSecretMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchSecretMessages {}


impl SearchSecretMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_search_id(&self) -> Option<i64> { self.from_search_id.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn filter(&self) -> Option<Box<SearchMessagesFilter>> { self.filter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for a sticker set by its name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickerSet
  /// Name of the sticker set.
  name: Option<String>,
  
}



impl Object for SearchStickerSet {}
impl RObject for SearchStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchStickerSet {}


impl SearchStickerSet {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickerSets
  /// Query to search for.
  query: Option<String>,
  
}



impl Object for SearchStickerSets {}
impl RObject for SearchStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchStickerSets {}


impl SearchStickerSets {
  
  pub fn query(&self) -> Option<String> { self.query.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Searches for stickers from public sticker sets that correspond to a given emoji.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // searchStickers
  /// String representation of emoji; must be non-empty.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,
  
}



impl Object for SearchStickers {}
impl RObject for SearchStickers {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "searchStickers" }
  fn td_type(&self) -> RTDType { RTDType::SearchStickers }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SearchStickers {}


impl SearchStickers {
  
  pub fn emoji(&self) -> Option<String> { self.emoji.clone() }
  
  pub fn limit(&self) -> Option<i32> { self.limit.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendBotStartMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendBotStartMessage
  /// Identifier of the bot.
  bot_user_id: Option<i32>,
  /// Identifier of the target chat.
  chat_id: Option<i64>,
  /// A hidden parameter sent to the bot for deep linking purposes (https://api.telegram.org/bots#deep-linking).
  parameter: Option<String>,
  
}



impl Object for SendBotStartMessage {}
impl RObject for SendBotStartMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendBotStartMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendBotStartMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendBotStartMessage {}


impl SendBotStartMessage {
  
  pub fn bot_user_id(&self) -> Option<i32> { self.bot_user_id.clone() }
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn parameter(&self) -> Option<String> { self.parameter.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends debug information for a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallDebugInformation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCallDebugInformation
  /// Call identifier.
  call_id: Option<i32>,
  /// Debug information in application-specific format.
  debug_information: Option<String>,
  
}



impl Object for SendCallDebugInformation {}
impl RObject for SendCallDebugInformation {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCallDebugInformation" }
  fn td_type(&self) -> RTDType { RTDType::SendCallDebugInformation }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendCallDebugInformation {}


impl SendCallDebugInformation {
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn debug_information(&self) -> Option<String> { self.debug_information.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a call rating.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallRating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCallRating
  /// Call identifier.
  call_id: Option<i32>,
  /// Call rating; 1-5.
  rating: Option<i32>,
  /// An optional user comment if the rating is less than 5.
  comment: Option<String>,
  
}



impl Object for SendCallRating {}
impl RObject for SendCallRating {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCallRating" }
  fn td_type(&self) -> RTDType { RTDType::SendCallRating }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendCallRating {}


impl SendCallRating {
  
  pub fn call_id(&self) -> Option<i32> { self.call_id.clone() }
  
  pub fn rating(&self) -> Option<i32> { self.rating.clone() }
  
  pub fn comment(&self) -> Option<String> { self.comment.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a notification about user activity in a chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatAction
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The action description.
  action: Option<Box<ChatAction>>,
  
}


impl Clone for SendChatAction {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SendChatAction {}
impl RObject for SendChatAction {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatAction" }
  fn td_type(&self) -> RTDType { RTDType::SendChatAction }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendChatAction {}


impl SendChatAction {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn action(&self) -> Option<Box<ChatAction>> { self.action.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatScreenshotTakenNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatScreenshotTakenNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  
}



impl Object for SendChatScreenshotTakenNotification {}
impl RObject for SendChatScreenshotTakenNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatScreenshotTakenNotification" }
  fn td_type(&self) -> RTDType { RTDType::SendChatScreenshotTakenNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendChatScreenshotTakenNotification {}


impl SendChatScreenshotTakenNotification {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatSetTtlMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendChatSetTtlMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New TTL value, in seconds.
  ttl: Option<i32>,
  
}



impl Object for SendChatSetTtlMessage {}
impl RObject for SendChatSetTtlMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendChatSetTtlMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendChatSetTtlMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendChatSetTtlMessage {}


impl SendChatSetTtlMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn ttl(&self) -> Option<i32> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a custom request; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCustomRequest {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendCustomRequest
  /// The method name.
  method: Option<String>,
  /// JSON-serialized method parameters.
  parameters: Option<String>,
  
}



impl Object for SendCustomRequest {}
impl RObject for SendCustomRequest {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendCustomRequest" }
  fn td_type(&self) -> RTDType { RTDType::SendCustomRequest }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendCustomRequest {}


impl SendCustomRequest {
  
  pub fn method(&self) -> Option<String> { self.method.clone() }
  
  pub fn parameters(&self) -> Option<String> { self.parameters.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendEmailAddressVerificationCode
  /// Email address.
  email_address: Option<String>,
  
}



impl Object for SendEmailAddressVerificationCode {}
impl RObject for SendEmailAddressVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendEmailAddressVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendEmailAddressVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendEmailAddressVerificationCode {}


impl SendEmailAddressVerificationCode {
  
  pub fn email_address(&self) -> Option<String> { self.email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendInlineQueryResultMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendInlineQueryResultMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from background.
  from_background: Option<bool>,
  /// Identifier of the inline query.
  query_id: Option<i64>,
  /// Identifier of the inline result.
  result_id: Option<String>,
  /// If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username").
  hide_via_bot: Option<bool>,
  
}



impl Object for SendInlineQueryResultMessage {}
impl RObject for SendInlineQueryResultMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendInlineQueryResultMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendInlineQueryResultMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendInlineQueryResultMessage {}


impl SendInlineQueryResultMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn query_id(&self) -> Option<i64> { self.query_id.clone() }
  
  pub fn result_id(&self) -> Option<String> { self.result_id.clone() }
  
  pub fn hide_via_bot(&self) -> Option<bool> { self.hide_via_bot.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a message. Returns the sent message.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendMessage
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// Markup for replying to the message; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent.
  input_message_content: Option<Box<InputMessageContent>>,
  
}


impl Clone for SendMessage {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SendMessage {}
impl RObject for SendMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendMessage" }
  fn td_type(&self) -> RTDType { RTDType::SendMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendMessage {}


impl SendMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn input_message_content(&self) -> Option<Box<InputMessageContent>> { self.input_message_content.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessageAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendMessageAlbum
  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the messages. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the messages are sent from the background.
  from_background: Option<bool>,
  /// Contents of messages to be sent.
  input_message_contents: Option<Vec<Box<InputMessageContent>>>,
  
}


impl Clone for SendMessageAlbum {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SendMessageAlbum {}
impl RObject for SendMessageAlbum {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendMessageAlbum" }
  fn td_type(&self) -> RTDType { RTDType::SendMessageAlbum }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendMessageAlbum {}


impl SendMessageAlbum {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn reply_to_message_id(&self) -> Option<i64> { self.reply_to_message_id.clone() }
  
  pub fn disable_notification(&self) -> Option<bool> { self.disable_notification.clone() }
  
  pub fn from_background(&self) -> Option<bool> { self.from_background.clone() }
  
  pub fn input_message_contents(&self) -> Option<Vec<Box<InputMessageContent>>> { self.input_message_contents.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after 
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPassportAuthorizationForm
  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Types of Telegram Passport elements chosen by user to complete the authorization form.
  types: Option<Vec<Box<PassportElementType>>>,
  
}


impl Clone for SendPassportAuthorizationForm {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SendPassportAuthorizationForm {}
impl RObject for SendPassportAuthorizationForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPassportAuthorizationForm" }
  fn td_type(&self) -> RTDType { RTDType::SendPassportAuthorizationForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendPassportAuthorizationForm {}


impl SendPassportAuthorizationForm {
  
  pub fn autorization_form_id(&self) -> Option<i32> { self.autorization_form_id.clone() }
  
  pub fn types(&self) -> Option<Vec<Box<PassportElementType>>> { self.types.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a filled-out payment form to the bot for final verification.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPaymentForm
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Identifier returned by ValidateOrderInfo, or an empty string.
  order_info_id: Option<String>,
  /// Identifier of a chosen shipping option, if applicable.
  shipping_option_id: Option<String>,
  /// The credentials chosen by user for payment.
  credentials: Option<Box<InputCredentials>>,
  
}


impl Clone for SendPaymentForm {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SendPaymentForm {}
impl RObject for SendPaymentForm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPaymentForm" }
  fn td_type(&self) -> RTDType { RTDType::SendPaymentForm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendPaymentForm {}


impl SendPaymentForm {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn order_info_id(&self) -> Option<String> { self.order_info_id.clone() }
  
  pub fn shipping_option_id(&self) -> Option<String> { self.shipping_option_id.clone() }
  
  pub fn credentials(&self) -> Option<Box<InputCredentials>> { self.credentials.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends phone number confirmation code. Should be called when user presses "
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPhoneNumberConfirmationCode
  /// Value of the "hash" parameter from the link.
  hash: Option<String>,
  /// Value of the "phone" parameter from the link.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SendPhoneNumberConfirmationCode {}
impl RObject for SendPhoneNumberConfirmationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPhoneNumberConfirmationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendPhoneNumberConfirmationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendPhoneNumberConfirmationCode {}


impl SendPhoneNumberConfirmationCode {
  
  pub fn hash(&self) -> Option<String> { self.hash.clone() }
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // sendPhoneNumberVerificationCode
  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SendPhoneNumberVerificationCode {}
impl RObject for SendPhoneNumberVerificationCode {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "sendPhoneNumberVerificationCode" }
  fn td_type(&self) -> RTDType { RTDType::SendPhoneNumberVerificationCode }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SendPhoneNumberVerificationCode {}


impl SendPhoneNumberVerificationCode {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAccountTtl
  /// New account TTL.
  ttl: Option<AccountTtl>,
  
}



impl Object for SetAccountTtl {}
impl RObject for SetAccountTtl {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAccountTtl" }
  fn td_type(&self) -> RTDType { RTDType::SetAccountTtl }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetAccountTtl {}


impl SetAccountTtl {
  
  pub fn ttl(&self) -> Option<AccountTtl> { self.ttl.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Succeeds after a specified amount of time has passed. Can be called before authorization. Can be called before initialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAlarm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAlarm
  /// Number of seconds before the function returns.
  seconds: Option<f64>,
  
}



impl Object for SetAlarm {}
impl RObject for SetAlarm {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAlarm" }
  fn td_type(&self) -> RTDType { RTDType::SetAlarm }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetAlarm {}


impl SetAlarm {
  
  pub fn seconds(&self) -> Option<f64> { self.seconds.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAuthenticationPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setAuthenticationPhoneNumber
  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,
  
}



impl Object for SetAuthenticationPhoneNumber {}
impl RObject for SetAuthenticationPhoneNumber {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setAuthenticationPhoneNumber" }
  fn td_type(&self) -> RTDType { RTDType::SetAuthenticationPhoneNumber }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetAuthenticationPhoneNumber {}


impl SetAuthenticationPhoneNumber {
  
  pub fn phone_number(&self) -> Option<String> { self.phone_number.clone() }
  
  pub fn allow_flash_call(&self) -> Option<bool> { self.allow_flash_call.clone() }
  
  pub fn is_current_phone_number(&self) -> Option<bool> { self.is_current_phone_number.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the bio of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setBio
  /// The new value of the user bio; 0-70 characters without line feeds.
  bio: Option<String>,
  
}



impl Object for SetBio {}
impl RObject for SetBio {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setBio" }
  fn td_type(&self) -> RTDType { RTDType::SetBio }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetBio {}


impl SetBio {
  
  pub fn bio(&self) -> Option<String> { self.bio.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBotUpdatesStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setBotUpdatesStatus
  /// The number of pending updates.
  pending_update_count: Option<i32>,
  /// The last error message.
  error_message: Option<String>,
  
}



impl Object for SetBotUpdatesStatus {}
impl RObject for SetBotUpdatesStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setBotUpdatesStatus" }
  fn td_type(&self) -> RTDType { RTDType::SetBotUpdatesStatus }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetBotUpdatesStatus {}


impl SetBotUpdatesStatus {
  
  pub fn pending_update_count(&self) -> Option<i32> { self.pending_update_count.clone() }
  
  pub fn error_message(&self) -> Option<String> { self.error_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes client data associated with a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatClientData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatClientData
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of client_data.
  client_data: Option<String>,
  
}



impl Object for SetChatClientData {}
impl RObject for SetChatClientData {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatClientData" }
  fn td_type(&self) -> RTDType { RTDType::SetChatClientData }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatClientData {}


impl SetChatClientData {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn client_data(&self) -> Option<String> { self.client_data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the draft message in a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatDraftMessage
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New draft message; may be null.
  draft_message: Option<DraftMessage>,
  
}



impl Object for SetChatDraftMessage {}
impl RObject for SetChatDraftMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatDraftMessage" }
  fn td_type(&self) -> RTDType { RTDType::SetChatDraftMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatDraftMessage {}


impl SetChatDraftMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn draft_message(&self) -> Option<DraftMessage> { self.draft_message.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat; instead, use 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatMemberStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatMemberStatus
  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,
  
}


impl Clone for SetChatMemberStatus {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetChatMemberStatus {}
impl RObject for SetChatMemberStatus {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatMemberStatus" }
  fn td_type(&self) -> RTDType { RTDType::SetChatMemberStatus }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatMemberStatus {}


impl SetChatMemberStatus {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn status(&self) -> Option<Box<ChatMemberStatus>> { self.status.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the notification settings of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatNotificationSettings
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New notification settings for the chat.
  notification_settings: Option<ChatNotificationSettings>,
  
}



impl Object for SetChatNotificationSettings {}
impl RObject for SetChatNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::SetChatNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatNotificationSettings {}


impl SetChatNotificationSettings {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn notification_settings(&self) -> Option<ChatNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The photo will not be changed before request to the server has been completed.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatPhoto
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New chat photo. You can use a zero InputFileId to delete the chat photo. Files that are accessible only by HTTP URL are not acceptable.
  photo: Option<Box<InputFile>>,
  
}


impl Clone for SetChatPhoto {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetChatPhoto {}
impl RObject for SetChatPhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatPhoto" }
  fn td_type(&self) -> RTDType { RTDType::SetChatPhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatPhoto {}


impl SetChatPhoto {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The title will not be changed until the request to the server has been completed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setChatTitle
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New title of the chat; 1-128 characters.
  title: Option<String>,
  
}



impl Object for SetChatTitle {}
impl RObject for SetChatTitle {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setChatTitle" }
  fn td_type(&self) -> RTDType { RTDType::SetChatTitle }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetChatTitle {}


impl SetChatTitle {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn title(&self) -> Option<String> { self.title.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds or changes a custom local language pack to the current localization target.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setCustomLanguagePack
  /// Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization.
  info: Option<LanguagePackInfo>,
  /// Strings of the new language pack.
  strings: Option<Vec<LanguagePackString>>,
  
}



impl Object for SetCustomLanguagePack {}
impl RObject for SetCustomLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setCustomLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::SetCustomLanguagePack }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetCustomLanguagePack {}


impl SetCustomLanguagePack {
  
  pub fn info(&self) -> Option<LanguagePackInfo> { self.info.clone() }
  
  pub fn strings(&self) -> Option<Vec<LanguagePackString>> { self.strings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setCustomLanguagePackString
  /// Identifier of a previously added custom local language pack in the current localization target.
  language_pack_id: Option<String>,
  /// New language pack string.
  new_string: Option<LanguagePackString>,
  
}



impl Object for SetCustomLanguagePackString {}
impl RObject for SetCustomLanguagePackString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setCustomLanguagePackString" }
  fn td_type(&self) -> RTDType { RTDType::SetCustomLanguagePackString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetCustomLanguagePackString {}


impl SetCustomLanguagePackString {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn new_string(&self) -> Option<LanguagePackString> { self.new_string.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setDatabaseEncryptionKey
  /// New encryption key.
  new_encryption_key: Option<String>,
  
}



impl Object for SetDatabaseEncryptionKey {}
impl RObject for SetDatabaseEncryptionKey {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setDatabaseEncryptionKey" }
  fn td_type(&self) -> RTDType { RTDType::SetDatabaseEncryptionKey }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetDatabaseEncryptionKey {}


impl SetDatabaseEncryptionKey {
  
  pub fn new_encryption_key(&self) -> Option<String> { self.new_encryption_key.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs TDLib on a file generation prograss.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetFileGenerationProgress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setFileGenerationProgress
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// Expected size of the generated file, in bytes; 0 if unknown.
  expected_size: Option<i32>,
  /// The number of bytes already generated.
  local_prefix_size: Option<i32>,
  
}



impl Object for SetFileGenerationProgress {}
impl RObject for SetFileGenerationProgress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setFileGenerationProgress" }
  fn td_type(&self) -> RTDType { RTDType::SetFileGenerationProgress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetFileGenerationProgress {}


impl SetFileGenerationProgress {
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn expected_size(&self) -> Option<i32> { self.expected_size.clone() }
  
  pub fn local_prefix_size(&self) -> Option<i32> { self.local_prefix_size.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Updates the game score of the specified user in the game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setGameScore
  /// The chat to which the message with the game belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,
  
}



impl Object for SetGameScore {}
impl RObject for SetGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setGameScore" }
  fn td_type(&self) -> RTDType { RTDType::SetGameScore }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetGameScore {}


impl SetGameScore {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn edit_message(&self) -> Option<bool> { self.edit_message.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Updates the game score of the specified user in a game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetInlineGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setInlineGameScore
  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,
  
}



impl Object for SetInlineGameScore {}
impl RObject for SetInlineGameScore {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setInlineGameScore" }
  fn td_type(&self) -> RTDType { RTDType::SetInlineGameScore }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetInlineGameScore {}


impl SetInlineGameScore {
  
  pub fn inline_message_id(&self) -> Option<String> { self.inline_message_id.clone() }
  
  pub fn edit_message(&self) -> Option<bool> { self.edit_message.clone() }
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn score(&self) -> Option<i32> { self.score.clone() }
  
  pub fn force(&self) -> Option<bool> { self.force.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets new log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogStream
  /// New log stream.
  log_stream: Option<Box<LogStream>>,
  
}


impl Clone for SetLogStream {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetLogStream {}
impl RObject for SetLogStream {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogStream" }
  fn td_type(&self) -> RTDType { RTDType::SetLogStream }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetLogStream {}


impl SetLogStream {
  
  pub fn log_stream(&self) -> Option<Box<LogStream>> { self.log_stream.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogTagVerbosityLevel
  /// Logging tag to change verbosity level.
  tag: Option<String>,
  /// New verbosity level; 1-1024.
  new_verbosity_level: Option<i32>,
  
}



impl Object for SetLogTagVerbosityLevel {}
impl RObject for SetLogTagVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogTagVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::SetLogTagVerbosityLevel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetLogTagVerbosityLevel {}


impl SetLogTagVerbosityLevel {
  
  pub fn tag(&self) -> Option<String> { self.tag.clone() }
  
  pub fn new_verbosity_level(&self) -> Option<i32> { self.new_verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setLogVerbosityLevel
  /// New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging.
  new_verbosity_level: Option<i32>,
  
}



impl Object for SetLogVerbosityLevel {}
impl RObject for SetLogVerbosityLevel {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setLogVerbosityLevel" }
  fn td_type(&self) -> RTDType { RTDType::SetLogVerbosityLevel }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetLogVerbosityLevel {}


impl SetLogVerbosityLevel {
  
  pub fn new_verbosity_level(&self) -> Option<i32> { self.new_verbosity_level.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the first and last name of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setName
  /// The new value of the first name for the user; 1-64 characters.
  first_name: Option<String>,
  /// The new value of the optional last name for the user; 0-64 characters.
  last_name: Option<String>,
  
}



impl Object for SetName {}
impl RObject for SetName {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setName" }
  fn td_type(&self) -> RTDType { RTDType::SetName }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetName {}


impl SetName {
  
  pub fn first_name(&self) -> Option<String> { self.first_name.clone() }
  
  pub fn last_name(&self) -> Option<String> { self.last_name.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetNetworkType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setNetworkType
  /// The new network type. By default, networkTypeOther.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NetworkType>>,
  
}


impl Clone for SetNetworkType {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetNetworkType {}
impl RObject for SetNetworkType {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setNetworkType" }
  fn td_type(&self) -> RTDType { RTDType::SetNetworkType }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetNetworkType {}


impl SetNetworkType {
  
  pub fn type_(&self) -> Option<Box<NetworkType>> { self.type_.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the value of an option. (Check the list of available options on 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setOption
  /// The name of the option.
  name: Option<String>,
  /// The new value of the option.
  value: Option<Box<OptionValue>>,
  
}


impl Clone for SetOption {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetOption {}
impl RObject for SetOption {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setOption" }
  fn td_type(&self) -> RTDType { RTDType::SetOption }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetOption {}


impl SetOption {
  
  pub fn name(&self) -> Option<String> { self.name.clone() }
  
  pub fn value(&self) -> Option<Box<OptionValue>> { self.value.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassportElement
  /// Input Telegram Passport element.
  element: Option<Box<InputPassportElement>>,
  /// Password of the current user.
  password: Option<String>,
  
}


impl Clone for SetPassportElement {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetPassportElement {}
impl RObject for SetPassportElement {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassportElement" }
  fn td_type(&self) -> RTDType { RTDType::SetPassportElement }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetPassportElement {}


impl SetPassportElement {
  
  pub fn element(&self) -> Option<Box<InputPassportElement>> { self.element.clone() }
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassportElementErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassportElementErrors
  /// User identifier.
  user_id: Option<i32>,
  /// The errors.
  errors: Option<Vec<InputPassportElementError>>,
  
}



impl Object for SetPassportElementErrors {}
impl RObject for SetPassportElementErrors {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassportElementErrors" }
  fn td_type(&self) -> RTDType { RTDType::SetPassportElementErrors }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetPassportElementErrors {}


impl SetPassportElementErrors {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn errors(&self) -> Option<Vec<InputPassportElementError>> { self.errors.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the password for the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPassword
  /// Previous password of the user.
  old_password: Option<String>,
  /// New password of the user; may be empty to remove the password.
  new_password: Option<String>,
  /// New password hint; may be empty.
  new_hint: Option<String>,
  /// Pass true if the recovery email address should be changed.
  set_recovery_email_address: Option<bool>,
  /// New recovery email address; may be empty.
  new_recovery_email_address: Option<String>,
  
}



impl Object for SetPassword {}
impl RObject for SetPassword {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPassword" }
  fn td_type(&self) -> RTDType { RTDType::SetPassword }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetPassword {}


impl SetPassword {
  
  pub fn old_password(&self) -> Option<String> { self.old_password.clone() }
  
  pub fn new_password(&self) -> Option<String> { self.new_password.clone() }
  
  pub fn new_hint(&self) -> Option<String> { self.new_hint.clone() }
  
  pub fn set_recovery_email_address(&self) -> Option<bool> { self.set_recovery_email_address.clone() }
  
  pub fn new_recovery_email_address(&self) -> Option<String> { self.new_recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the order of pinned chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPinnedChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPinnedChats
  /// The new list of pinned chats.
  chat_ids: Option<Vec<i64>>,
  
}



impl Object for SetPinnedChats {}
impl RObject for SetPinnedChats {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPinnedChats" }
  fn td_type(&self) -> RTDType { RTDType::SetPinnedChats }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetPinnedChats {}


impl SetPinnedChats {
  
  pub fn chat_ids(&self) -> Option<Vec<i64>> { self.chat_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes user answer to a poll.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPollAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setPollAnswer
  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// 0-based identifiers of options, chosen by the user. Currently user can't choose more than 1 option.
  option_ids: Option<Vec<i32>>,
  
}



impl Object for SetPollAnswer {}
impl RObject for SetPollAnswer {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setPollAnswer" }
  fn td_type(&self) -> RTDType { RTDType::SetPollAnswer }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetPollAnswer {}


impl SetPollAnswer {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn option_ids(&self) -> Option<Vec<i32>> { self.option_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Uploads a new profile photo for the current user. If something changes, 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setProfilePhoto
  /// Profile photo to set. inputFileId and inputFileRemote may still be unsupported.
  photo: Option<Box<InputFile>>,
  
}


impl Clone for SetProfilePhoto {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetProfilePhoto {}
impl RObject for SetProfilePhoto {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setProfilePhoto" }
  fn td_type(&self) -> RTDType { RTDType::SetProfilePhoto }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetProfilePhoto {}


impl SetProfilePhoto {
  
  pub fn photo(&self) -> Option<Box<InputFile>> { self.photo.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setRecoveryEmailAddress
  /// Password of the current user.
  password: Option<String>,
  /// New recovery email address.
  new_recovery_email_address: Option<String>,
  
}



impl Object for SetRecoveryEmailAddress {}
impl RObject for SetRecoveryEmailAddress {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setRecoveryEmailAddress" }
  fn td_type(&self) -> RTDType { RTDType::SetRecoveryEmailAddress }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetRecoveryEmailAddress {}


impl SetRecoveryEmailAddress {
  
  pub fn password(&self) -> Option<String> { self.password.clone() }
  
  pub fn new_recovery_email_address(&self) -> Option<String> { self.new_recovery_email_address.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setScopeNotificationSettings
  /// Types of chats for which to change the notification settings.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings for the given scope.
  notification_settings: Option<ScopeNotificationSettings>,
  
}


impl Clone for SetScopeNotificationSettings {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetScopeNotificationSettings {}
impl RObject for SetScopeNotificationSettings {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setScopeNotificationSettings" }
  fn td_type(&self) -> RTDType { RTDType::SetScopeNotificationSettings }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetScopeNotificationSettings {}


impl SetScopeNotificationSettings {
  
  pub fn scope(&self) -> Option<Box<NotificationSettingsScope>> { self.scope.clone() }
  
  pub fn notification_settings(&self) -> Option<ScopeNotificationSettings> { self.notification_settings.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetStickerPositionInSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setStickerPositionInSet
  /// Sticker.
  sticker: Option<Box<InputFile>>,
  /// New position of the sticker in the set, zero-based.
  position: Option<i32>,
  
}


impl Clone for SetStickerPositionInSet {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetStickerPositionInSet {}
impl RObject for SetStickerPositionInSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setStickerPositionInSet" }
  fn td_type(&self) -> RTDType { RTDType::SetStickerPositionInSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetStickerPositionInSet {}


impl SetStickerPositionInSet {
  
  pub fn sticker(&self) -> Option<Box<InputFile>> { self.sticker.clone() }
  
  pub fn position(&self) -> Option<i32> { self.position.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes information about a supergroup or channel; requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupDescription {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupDescription
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New supergroup or channel description; 0-255 characters.
  description: Option<String>,
  
}



impl Object for SetSupergroupDescription {}
impl RObject for SetSupergroupDescription {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupDescription" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupDescription }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetSupergroupDescription {}


impl SetSupergroupDescription {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn description(&self) -> Option<String> { self.description.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the sticker set of a supergroup; requires appropriate rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupStickerSet
  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set.
  sticker_set_id: Option<i64>,
  
}



impl Object for SetSupergroupStickerSet {}
impl RObject for SetSupergroupStickerSet {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupStickerSet" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupStickerSet }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetSupergroupStickerSet {}


impl SetSupergroupStickerSet {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn sticker_set_id(&self) -> Option<i64> { self.sticker_set_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the username of a supergroup or channel, requires creator privileges in the supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setSupergroupUsername
  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New value of the username. Use an empty string to remove the username.
  username: Option<String>,
  
}



impl Object for SetSupergroupUsername {}
impl RObject for SetSupergroupUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setSupergroupUsername" }
  fn td_type(&self) -> RTDType { RTDType::SetSupergroupUsername }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetSupergroupUsername {}


impl SetSupergroupUsername {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sets the parameters for TDLib initialization. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setTdlibParameters
  /// Parameters.
  parameters: Option<TdlibParameters>,
  
}



impl Object for SetTdlibParameters {}
impl RObject for SetTdlibParameters {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setTdlibParameters" }
  fn td_type(&self) -> RTDType { RTDType::SetTdlibParameters }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetTdlibParameters {}


impl SetTdlibParameters {
  
  pub fn parameters(&self) -> Option<TdlibParameters> { self.parameters.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes user privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setUserPrivacySettingRules
  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// The new privacy rules.
  rules: Option<UserPrivacySettingRules>,
  
}


impl Clone for SetUserPrivacySettingRules {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for SetUserPrivacySettingRules {}
impl RObject for SetUserPrivacySettingRules {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setUserPrivacySettingRules" }
  fn td_type(&self) -> RTDType { RTDType::SetUserPrivacySettingRules }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetUserPrivacySettingRules {}


impl SetUserPrivacySettingRules {
  
  pub fn setting(&self) -> Option<Box<UserPrivacySetting>> { self.setting.clone() }
  
  pub fn rules(&self) -> Option<UserPrivacySettingRules> { self.rules.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the username of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // setUsername
  /// The new value of the username. Use an empty string to remove the username.
  username: Option<String>,
  
}



impl Object for SetUsername {}
impl RObject for SetUsername {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "setUsername" }
  fn td_type(&self) -> RTDType { RTDType::SetUsername }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SetUsername {}


impl SetUsername {
  
  pub fn username(&self) -> Option<String> { self.username.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set.
#[derive(Debug, Serialize, Deserialize)]
pub struct StopPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // stopPoll
  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  
}


impl Clone for StopPoll {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for StopPoll {}
impl RObject for StopPoll {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "stopPoll" }
  fn td_type(&self) -> RTDType { RTDType::StopPoll }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for StopPoll {}


impl StopPoll {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn reply_markup(&self) -> Option<Box<ReplyMarkup>> { self.reply_markup.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynchronizeLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // synchronizeLanguagePack
  /// Language pack identifier.
  language_pack_id: Option<String>,
  
}



impl Object for SynchronizeLanguagePack {}
impl RObject for SynchronizeLanguagePack {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "synchronizeLanguagePack" }
  fn td_type(&self) -> RTDType { RTDType::SynchronizeLanguagePack }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for SynchronizeLanguagePack {}


impl SynchronizeLanguagePack {
  
  pub fn language_pack_id(&self) -> Option<String> { self.language_pack_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Terminates all other sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateAllOtherSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // terminateAllOtherSessions
  
}



impl Object for TerminateAllOtherSessions {}
impl RObject for TerminateAllOtherSessions {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "terminateAllOtherSessions" }
  fn td_type(&self) -> RTDType { RTDType::TerminateAllOtherSessions }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TerminateAllOtherSessions {}


impl TerminateAllOtherSessions {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Terminates a session of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateSession {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // terminateSession
  /// Session identifier.
  session_id: Option<i64>,
  
}



impl Object for TerminateSession {}
impl RObject for TerminateSession {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "terminateSession" }
  fn td_type(&self) -> RTDType { RTDType::TerminateSession }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TerminateSession {}


impl TerminateSession {
  
  pub fn session_id(&self) -> Option<i64> { self.session_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallBytes
  /// Bytes to return.
  x: Option<String>,
  
}



impl Object for TestCallBytes {}
impl RObject for TestCallBytes {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallBytes" }
  fn td_type(&self) -> RTDType { RTDType::TestCallBytes }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallBytes {}


impl TestCallBytes {
  
  pub fn x(&self) -> Option<String> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Does nothing; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallEmpty
  
}



impl Object for TestCallEmpty {}
impl RObject for TestCallEmpty {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallEmpty" }
  fn td_type(&self) -> RTDType { RTDType::TestCallEmpty }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallEmpty {}


impl TestCallEmpty {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallString
  /// String to return.
  x: Option<String>,
  
}



impl Object for TestCallString {}
impl RObject for TestCallString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallString" }
  fn td_type(&self) -> RTDType { RTDType::TestCallString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallString {}


impl TestCallString {
  
  pub fn x(&self) -> Option<String> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorInt
  /// Vector of numbers to return.
  x: Option<Vec<i32>>,
  
}



impl Object for TestCallVectorInt {}
impl RObject for TestCallVectorInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorInt" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorInt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallVectorInt {}


impl TestCallVectorInt {
  
  pub fn x(&self) -> Option<Vec<i32>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorIntObject
  /// Vector of objects to return.
  x: Option<Vec<TestInt>>,
  
}



impl Object for TestCallVectorIntObject {}
impl RObject for TestCallVectorIntObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorIntObject" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorIntObject }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallVectorIntObject {}


impl TestCallVectorIntObject {
  
  pub fn x(&self) -> Option<Vec<TestInt>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorString
  /// Vector of strings to return.
  x: Option<Vec<String>>,
  
}



impl Object for TestCallVectorString {}
impl RObject for TestCallVectorString {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorString" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorString }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallVectorString {}


impl TestCallVectorString {
  
  pub fn x(&self) -> Option<Vec<String>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testCallVectorStringObject
  /// Vector of objects to return.
  x: Option<Vec<TestString>>,
  
}



impl Object for TestCallVectorStringObject {}
impl RObject for TestCallVectorStringObject {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testCallVectorStringObject" }
  fn td_type(&self) -> RTDType { RTDType::TestCallVectorStringObject }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestCallVectorStringObject {}


impl TestCallVectorStringObject {
  
  pub fn x(&self) -> Option<Vec<TestString>> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Forces an updates.getDifference call to the Telegram servers; for testing only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestGetDifference {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testGetDifference
  
}



impl Object for TestGetDifference {}
impl RObject for TestGetDifference {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testGetDifference" }
  fn td_type(&self) -> RTDType { RTDType::TestGetDifference }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestGetDifference {}


impl TestGetDifference {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testNetwork
  
}



impl Object for TestNetwork {}
impl RObject for TestNetwork {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testNetwork" }
  fn td_type(&self) -> RTDType { RTDType::TestNetwork }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestNetwork {}


impl TestNetwork {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestSquareInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testSquareInt
  /// Number to square.
  x: Option<i32>,
  
}



impl Object for TestSquareInt {}
impl RObject for TestSquareInt {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testSquareInt" }
  fn td_type(&self) -> RTDType { RTDType::TestSquareInt }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestSquareInt {}


impl TestSquareInt {
  
  pub fn x(&self) -> Option<i32> { self.x.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Does nothing and ensures that the Error object is used; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testUseError
  
}



impl Object for TestUseError {}
impl RObject for TestUseError {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testUseError" }
  fn td_type(&self) -> RTDType { RTDType::TestUseError }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestUseError {}


impl TestUseError {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Does nothing and ensures that the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseUpdate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // testUseUpdate
  
}



impl Object for TestUseUpdate {}
impl RObject for TestUseUpdate {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "testUseUpdate" }
  fn td_type(&self) -> RTDType { RTDType::TestUseUpdate }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for TestUseUpdate {}


impl TestUseUpdate {
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Toggles the "All members are admins" setting in basic groups; requires creator privileges in the group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleBasicGroupAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleBasicGroupAdministrators
  /// Identifier of the basic group.
  basic_group_id: Option<i32>,
  /// New value of everyone_is_administrator.
  everyone_is_administrator: Option<bool>,
  
}



impl Object for ToggleBasicGroupAdministrators {}
impl RObject for ToggleBasicGroupAdministrators {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleBasicGroupAdministrators" }
  fn td_type(&self) -> RTDType { RTDType::ToggleBasicGroupAdministrators }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleBasicGroupAdministrators {}


impl ToggleBasicGroupAdministrators {
  
  pub fn basic_group_id(&self) -> Option<i32> { self.basic_group_id.clone() }
  
  pub fn everyone_is_administrator(&self) -> Option<bool> { self.everyone_is_administrator.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the value of the default disable_notification parameter, used when a message is sent to a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatDefaultDisableNotification
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of default_disable_notification.
  default_disable_notification: Option<bool>,
  
}



impl Object for ToggleChatDefaultDisableNotification {}
impl RObject for ToggleChatDefaultDisableNotification {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatDefaultDisableNotification" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatDefaultDisableNotification }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleChatDefaultDisableNotification {}


impl ToggleChatDefaultDisableNotification {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn default_disable_notification(&self) -> Option<bool> { self.default_disable_notification.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the marked as unread state of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatIsMarkedAsUnread
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,
  
}



impl Object for ToggleChatIsMarkedAsUnread {}
impl RObject for ToggleChatIsMarkedAsUnread {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatIsMarkedAsUnread" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatIsMarkedAsUnread }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleChatIsMarkedAsUnread {}


impl ToggleChatIsMarkedAsUnread {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_marked_as_unread(&self) -> Option<bool> { self.is_marked_as_unread.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Changes the pinned state of a chat. You can pin up to GetOption("pinned_chat_count_max") non-secret chats and the same number of secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleChatIsPinned
  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,
  
}



impl Object for ToggleChatIsPinned {}
impl RObject for ToggleChatIsPinned {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleChatIsPinned" }
  fn td_type(&self) -> RTDType { RTDType::ToggleChatIsPinned }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleChatIsPinned {}


impl ToggleChatIsPinned {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn is_pinned(&self) -> Option<bool> { self.is_pinned.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Toggles whether all members of a supergroup can add new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupInvites
  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,
  
}



impl Object for ToggleSupergroupInvites {}
impl RObject for ToggleSupergroupInvites {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupInvites" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupInvites }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleSupergroupInvites {}


impl ToggleSupergroupInvites {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn anyone_can_invite(&self) -> Option<bool> { self.anyone_can_invite.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Toggles whether the message history of a supergroup is available to new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupIsAllHistoryAvailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupIsAllHistoryAvailable
  /// The identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// The new value of is_all_history_available.
  is_all_history_available: Option<bool>,
  
}



impl Object for ToggleSupergroupIsAllHistoryAvailable {}
impl RObject for ToggleSupergroupIsAllHistoryAvailable {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupIsAllHistoryAvailable" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupIsAllHistoryAvailable }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleSupergroupIsAllHistoryAvailable {}


impl ToggleSupergroupIsAllHistoryAvailable {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn is_all_history_available(&self) -> Option<bool> { self.is_all_history_available.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Toggles sender signatures messages sent in a channel; requires appropriate administrator rights in the channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupSignMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // toggleSupergroupSignMessages
  /// Identifier of the channel.
  supergroup_id: Option<i32>,
  /// New value of sign_messages.
  sign_messages: Option<bool>,
  
}



impl Object for ToggleSupergroupSignMessages {}
impl RObject for ToggleSupergroupSignMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "toggleSupergroupSignMessages" }
  fn td_type(&self) -> RTDType { RTDType::ToggleSupergroupSignMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ToggleSupergroupSignMessages {}


impl ToggleSupergroupSignMessages {
  
  pub fn supergroup_id(&self) -> Option<i32> { self.supergroup_id.clone() }
  
  pub fn sign_messages(&self) -> Option<bool> { self.sign_messages.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes a user from the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnblockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // unblockUser
  /// User identifier.
  user_id: Option<i32>,
  
}



impl Object for UnblockUser {}
impl RObject for UnblockUser {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "unblockUser" }
  fn td_type(&self) -> RTDType { RTDType::UnblockUser }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for UnblockUser {}


impl UnblockUser {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Removes the pinned message from a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnpinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // unpinChatMessage
  /// Identifier of the chat.
  chat_id: Option<i64>,
  
}



impl Object for UnpinChatMessage {}
impl RObject for UnpinChatMessage {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "unpinChatMessage" }
  fn td_type(&self) -> RTDType { RTDType::UnpinChatMessage }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for UnpinChatMessage {}


impl UnpinChatMessage {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Creates a new supergroup from an existing basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpgradeBasicGroupChatToSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // upgradeBasicGroupChatToSupergroupChat
  /// Identifier of the chat to upgrade.
  chat_id: Option<i64>,
  
}



impl Object for UpgradeBasicGroupChatToSupergroupChat {}
impl RObject for UpgradeBasicGroupChatToSupergroupChat {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "upgradeBasicGroupChatToSupergroupChat" }
  fn td_type(&self) -> RTDType { RTDType::UpgradeBasicGroupChatToSupergroupChat }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for UpgradeBasicGroupChatToSupergroupChat {}


impl UpgradeBasicGroupChatToSupergroupChat {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Asynchronously uploads a file to the cloud without sending it in a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // uploadFile
  /// File to upload.
  file: Option<Box<InputFile>>,
  /// File type.
  file_type: Option<Box<FileType>>,
  /// Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first.
  priority: Option<i32>,
  
}


impl Clone for UploadFile {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UploadFile {}
impl RObject for UploadFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "uploadFile" }
  fn td_type(&self) -> RTDType { RTDType::UploadFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for UploadFile {}


impl UploadFile {
  
  pub fn file(&self) -> Option<Box<InputFile>> { self.file.clone() }
  
  pub fn file_type(&self) -> Option<Box<FileType>> { self.file_type.clone() }
  
  pub fn priority(&self) -> Option<i32> { self.priority.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Uploads a PNG image with a sticker; for bots only; returns the uploaded file.
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadStickerFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // uploadStickerFile
  /// Sticker file owner.
  user_id: Option<i32>,
  /// PNG image with the sticker; must be up to 512 kB in size and fit in 512x512 square.
  png_sticker: Option<Box<InputFile>>,
  
}


impl Clone for UploadStickerFile {
  fn clone(&self) -> Self { rtd_clone!()(self) }
}


impl Object for UploadStickerFile {}
impl RObject for UploadStickerFile {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "uploadStickerFile" }
  fn td_type(&self) -> RTDType { RTDType::UploadStickerFile }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for UploadStickerFile {}


impl UploadStickerFile {
  
  pub fn user_id(&self) -> Option<i32> { self.user_id.clone() }
  
  pub fn png_sticker(&self) -> Option<Box<InputFile>> { self.png_sticker.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Validates the order information provided by a user and returns the available shipping options for a flexible invoice.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidateOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // validateOrderInfo
  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The order information, provided by the user.
  order_info: Option<OrderInfo>,
  /// True, if the order information can be saved.
  allow_save: Option<bool>,
  
}



impl Object for ValidateOrderInfo {}
impl RObject for ValidateOrderInfo {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "validateOrderInfo" }
  fn td_type(&self) -> RTDType { RTDType::ValidateOrderInfo }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ValidateOrderInfo {}


impl ValidateOrderInfo {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_id(&self) -> Option<i64> { self.message_id.clone() }
  
  pub fn order_info(&self) -> Option<OrderInfo> { self.order_info.clone() }
  
  pub fn allow_save(&self) -> Option<bool> { self.allow_save.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // viewMessages
  /// Chat identifier.
  chat_id: Option<i64>,
  /// The identifiers of the messages being viewed.
  message_ids: Option<Vec<i64>>,
  /// True, if messages in closed chats should be marked as read.
  force_read: Option<bool>,
  
}



impl Object for ViewMessages {}
impl RObject for ViewMessages {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "viewMessages" }
  fn td_type(&self) -> RTDType { RTDType::ViewMessages }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ViewMessages {}


impl ViewMessages {
  
  pub fn chat_id(&self) -> Option<i64> { self.chat_id.clone() }
  
  pub fn message_ids(&self) -> Option<Vec<i64>> { self.message_ids.clone() }
  
  pub fn force_read(&self) -> Option<bool> { self.force_read.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Informs the server that some trending sticker sets have been viewed by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // viewTrendingStickerSets
  /// Identifiers of viewed trending sticker sets.
  sticker_set_ids: Option<Vec<i64>>,
  
}



impl Object for ViewTrendingStickerSets {}
impl RObject for ViewTrendingStickerSets {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "viewTrendingStickerSets" }
  fn td_type(&self) -> RTDType { RTDType::ViewTrendingStickerSets }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for ViewTrendingStickerSets {}


impl ViewTrendingStickerSets {
  
  pub fn sticker_set_ids(&self) -> Option<Vec<i64>> { self.sticker_set_ids.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



/// Writes a part of a generated file. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WriteGeneratedFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  td_name: String, // writeGeneratedFilePart
  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// The offset from which to write the data to the file.
  offset: Option<i32>,
  /// The data to write.
  data: Option<String>,
  
}



impl Object for WriteGeneratedFilePart {}
impl RObject for WriteGeneratedFilePart {
  #[doc(hidden)] fn td_name(&self) -> &'static str { "writeGeneratedFilePart" }
  fn td_type(&self) -> RTDType { RTDType::WriteGeneratedFilePart }
  fn to_json(&self) -> String { rtd_to_json!()(self) }
}


impl Function for WriteGeneratedFilePart {}


impl WriteGeneratedFilePart {
  
  pub fn generation_id(&self) -> Option<i64> { self.generation_id.clone() }
  
  pub fn offset(&self) -> Option<i32> { self.offset.clone() }
  
  pub fn data(&self) -> Option<String> { self.data.clone() }
  
  pub fn from_json<S: AsRef<str>>(json: S) -> Option<Self> { from_json!()(json.as_ref()) }
}



