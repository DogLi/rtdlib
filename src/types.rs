
use std::fmt::Debug;

/// This class is a base class for all TDLib TL-objects.
trait TlObject: Debug {}

/// This class is a base class for all TDLib API classes. 

pub trait Object: Debug {}



impl TlObject for Object {}





/// This class is a base class for all TDLib API functions. 

pub trait Function: Debug {}



impl TlObject for Function {}





/// Contains information about the period of inactivity after which the current user's account will automatically be deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // accountTtl

  /// Number of days of inactivity before the account will be flagged for deletion; should range from 30-366 days.
  days: Option<i32>,


}




impl Object for AccountTtl {}


impl AccountTtl {
  
  pub fn builder() -> AccountTtlBuilder {
    let instance = Self {
      tdfname: "accountTtl".to_string(),
      days: None,
      
    };
    AccountTtlBuilder::new(instance)
  }
  
  
  pub fn days(&self) -> &Option<i32> { &self.days }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AccountTtlBuilder {
  instance: AccountTtl
}

impl AccountTtlBuilder {
  fn new(instance: AccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> AccountTtl {
    self.instance.clone()
  }
  
  pub fn days(&mut self, days: i32) -> &mut Self {
    self.instance.days = Some(days);
    self
  }
  
}


/// Describes an address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Address {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // address

  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,
  /// State, if applicable.
  state: Option<String>,
  /// City.
  city: Option<String>,
  /// First line of the address.
  street_line1: Option<String>,
  /// Second line of the address.
  street_line2: Option<String>,
  /// Address postal code.
  postal_code: Option<String>,


}




impl Object for Address {}


impl Address {
  
  pub fn builder() -> AddressBuilder {
    let instance = Self {
      tdfname: "address".to_string(),
      country_code: None,
      state: None,
      city: None,
      street_line1: None,
      street_line2: None,
      postal_code: None,
      
    };
    AddressBuilder::new(instance)
  }
  
  
  pub fn country_code(&self) -> &Option<String> { &self.country_code }
  
  pub fn state(&self) -> &Option<String> { &self.state }
  
  pub fn city(&self) -> &Option<String> { &self.city }
  
  pub fn street_line1(&self) -> &Option<String> { &self.street_line1 }
  
  pub fn street_line2(&self) -> &Option<String> { &self.street_line2 }
  
  pub fn postal_code(&self) -> &Option<String> { &self.postal_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddressBuilder {
  instance: Address
}

impl AddressBuilder {
  fn new(instance: Address) -> Self { Self { instance } }

  pub fn build(&self) -> Address {
    self.instance.clone()
  }
  
  pub fn country_code(&mut self, country_code: String) -> &mut Self {
    self.instance.country_code = Some(country_code);
    self
  }
  
  pub fn state(&mut self, state: String) -> &mut Self {
    self.instance.state = Some(state);
    self
  }
  
  pub fn city(&mut self, city: String) -> &mut Self {
    self.instance.city = Some(city);
    self
  }
  
  pub fn street_line1(&mut self, street_line1: String) -> &mut Self {
    self.instance.street_line1 = Some(street_line1);
    self
  }
  
  pub fn street_line2(&mut self, street_line2: String) -> &mut Self {
    self.instance.street_line2 = Some(street_line2);
    self
  }
  
  pub fn postal_code(&mut self, postal_code: String) -> &mut Self {
    self.instance.postal_code = Some(postal_code);
    self
  }
  
}


/// Describes an animation file. The animation must be encoded in GIF or MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // animation

  /// Duration of the animation, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Width of the animation.
  width: Option<i32>,
  /// Height of the animation.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file, usually "image/gif" or "video/mp4".
  mime_type: Option<String>,
  /// Animation thumbnail; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the animation.
  animation: Option<File>,


}




impl Object for Animation {}


impl Animation {
  
  pub fn builder() -> AnimationBuilder {
    let instance = Self {
      tdfname: "animation".to_string(),
      duration: None,
      width: None,
      height: None,
      file_name: None,
      mime_type: None,
      thumbnail: None,
      animation: None,
      
    };
    AnimationBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  pub fn animation(&self) -> &Option<File> { &self.animation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnimationBuilder {
  instance: Animation
}

impl AnimationBuilder {
  fn new(instance: Animation) -> Self { Self { instance } }

  pub fn build(&self) -> Animation {
    self.instance.clone()
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn animation(&mut self, animation: File) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}


/// Represents a list of animations. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Animations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // animations

  /// List of animations.
  animations: Option<Vec<Animation>>,


}




impl Object for Animations {}


impl Animations {
  
  pub fn builder() -> AnimationsBuilder {
    let instance = Self {
      tdfname: "animations".to_string(),
      animations: None,
      
    };
    AnimationsBuilder::new(instance)
  }
  
  
  pub fn animations(&self) -> &Option<Vec<Animation>> { &self.animations }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnimationsBuilder {
  instance: Animations
}

impl AnimationsBuilder {
  fn new(instance: Animations) -> Self { Self { instance } }

  pub fn build(&self) -> Animations {
    self.instance.clone()
  }
  
  pub fn animations(&mut self, animations: Vec<Animation>) -> &mut Self {
    self.instance.animations = Some(animations);
    self
  }
  
}


/// Describes an audio file. Audio is usually in MP3 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Audio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // audio

  /// Duration of the audio, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Title of the audio; as defined by the sender.
  title: Option<String>,
  /// Performer of the audio; as defined by the sender.
  performer: Option<String>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// The MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// The thumbnail of the album cover; as defined by the sender. The full size thumbnail should be extracted from the downloaded file; may be null.
  album_cover_thumbnail: Option<PhotoSize>,
  /// File containing the audio.
  audio: Option<File>,


}




impl Object for Audio {}


impl Audio {
  
  pub fn builder() -> AudioBuilder {
    let instance = Self {
      tdfname: "audio".to_string(),
      duration: None,
      title: None,
      performer: None,
      file_name: None,
      mime_type: None,
      album_cover_thumbnail: None,
      audio: None,
      
    };
    AudioBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn performer(&self) -> &Option<String> { &self.performer }
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn album_cover_thumbnail(&self) -> &Option<PhotoSize> { &self.album_cover_thumbnail }
  
  pub fn audio(&self) -> &Option<File> { &self.audio }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AudioBuilder {
  instance: Audio
}

impl AudioBuilder {
  fn new(instance: Audio) -> Self { Self { instance } }

  pub fn build(&self) -> Audio {
    self.instance.clone()
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn performer(&mut self, performer: String) -> &mut Self {
    self.instance.performer = Some(performer);
    self
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn album_cover_thumbnail(&mut self, album_cover_thumbnail: PhotoSize) -> &mut Self {
    self.instance.album_cover_thumbnail = Some(album_cover_thumbnail);
    self
  }
  
  pub fn audio(&mut self, audio: File) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
}


/// Information about the authentication code that was sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authenticationCodeInfo

  /// A phone number that is being authenticated.
  phone_number: Option<String>,
  /// Describes the way the code was sent to the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<AuthenticationCodeType>>,
  /// Describes the way the next code will be sent to the user; may be null.
  next_type: Option<Box<AuthenticationCodeType>>,
  /// Timeout before the code should be re-sent, in seconds.
  timeout: Option<i32>,


}


impl Clone for AuthenticationCodeInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for AuthenticationCodeInfo {}


impl AuthenticationCodeInfo {
  
  pub fn builder() -> AuthenticationCodeInfoBuilder {
    let instance = Self {
      tdfname: "authenticationCodeInfo".to_string(),
      phone_number: None,
      type_: None,
      next_type: None,
      timeout: None,
      
    };
    AuthenticationCodeInfoBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn type_(&self) -> &Option<Box<AuthenticationCodeType>> { &self.type_ }
  
  pub fn next_type(&self) -> &Option<Box<AuthenticationCodeType>> { &self.next_type }
  
  pub fn timeout(&self) -> &Option<i32> { &self.timeout }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AuthenticationCodeInfoBuilder {
  instance: AuthenticationCodeInfo
}

impl AuthenticationCodeInfoBuilder {
  fn new(instance: AuthenticationCodeInfo) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeInfo {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn type_(&mut self, type_: Box<AuthenticationCodeType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn next_type(&mut self, next_type: Box<AuthenticationCodeType>) -> &mut Self {
    self.instance.next_type = Some(next_type);
    self
  }
  
  pub fn timeout(&mut self, timeout: i32) -> &mut Self {
    self.instance.timeout = Some(timeout);
    self
  }
  
}


/// This class is an abstract base class. Provides information about the method by which an authentication code is delivered to the user. 
#[typetag::serde(tag = "@struct")]
pub trait AuthenticationCodeType: Debug {}



impl Object for AuthenticationCodeType {}





/// An authentication code is delivered via a private Telegram message, which can be viewed in another client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeTelegramMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authenticationCodeTypeTelegramMessage

  /// Length of the code.
  length: Option<i32>,


}



#[typetag::serde]
impl AuthenticationCodeType for AuthenticationCodeTypeTelegramMessage {}


impl AuthenticationCodeTypeTelegramMessage {
  
  pub fn builder() -> AuthenticationCodeTypeTelegramMessageBuilder {
    let instance = Self {
      tdfname: "authenticationCodeTypeTelegramMessage".to_string(),
      length: None,
      
    };
    AuthenticationCodeTypeTelegramMessageBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AuthenticationCodeTypeTelegramMessageBuilder {
  instance: AuthenticationCodeTypeTelegramMessage
}

impl AuthenticationCodeTypeTelegramMessageBuilder {
  fn new(instance: AuthenticationCodeTypeTelegramMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeTelegramMessage {
    self.instance.clone()
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}


/// An authentication code is delivered via an SMS message to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeSms {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authenticationCodeTypeSms

  /// Length of the code.
  length: Option<i32>,


}



#[typetag::serde]
impl AuthenticationCodeType for AuthenticationCodeTypeSms {}


impl AuthenticationCodeTypeSms {
  
  pub fn builder() -> AuthenticationCodeTypeSmsBuilder {
    let instance = Self {
      tdfname: "authenticationCodeTypeSms".to_string(),
      length: None,
      
    };
    AuthenticationCodeTypeSmsBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AuthenticationCodeTypeSmsBuilder {
  instance: AuthenticationCodeTypeSms
}

impl AuthenticationCodeTypeSmsBuilder {
  fn new(instance: AuthenticationCodeTypeSms) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeSms {
    self.instance.clone()
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}


/// An authentication code is delivered via a phone call to the specified phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authenticationCodeTypeCall

  /// Length of the code.
  length: Option<i32>,


}



#[typetag::serde]
impl AuthenticationCodeType for AuthenticationCodeTypeCall {}


impl AuthenticationCodeTypeCall {
  
  pub fn builder() -> AuthenticationCodeTypeCallBuilder {
    let instance = Self {
      tdfname: "authenticationCodeTypeCall".to_string(),
      length: None,
      
    };
    AuthenticationCodeTypeCallBuilder::new(instance)
  }
  
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AuthenticationCodeTypeCallBuilder {
  instance: AuthenticationCodeTypeCall
}

impl AuthenticationCodeTypeCallBuilder {
  fn new(instance: AuthenticationCodeTypeCall) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeCall {
    self.instance.clone()
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}


/// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthenticationCodeTypeFlashCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authenticationCodeTypeFlashCall

  /// Pattern of the phone number from which the call will be made.
  pattern: Option<String>,


}



#[typetag::serde]
impl AuthenticationCodeType for AuthenticationCodeTypeFlashCall {}


impl AuthenticationCodeTypeFlashCall {
  
  pub fn builder() -> AuthenticationCodeTypeFlashCallBuilder {
    let instance = Self {
      tdfname: "authenticationCodeTypeFlashCall".to_string(),
      pattern: None,
      
    };
    AuthenticationCodeTypeFlashCallBuilder::new(instance)
  }
  
  
  pub fn pattern(&self) -> &Option<String> { &self.pattern }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AuthenticationCodeTypeFlashCallBuilder {
  instance: AuthenticationCodeTypeFlashCall
}

impl AuthenticationCodeTypeFlashCallBuilder {
  fn new(instance: AuthenticationCodeTypeFlashCall) -> Self { Self { instance } }

  pub fn build(&self) -> AuthenticationCodeTypeFlashCall {
    self.instance.clone()
  }
  
  pub fn pattern(&mut self, pattern: String) -> &mut Self {
    self.instance.pattern = Some(pattern);
    self
  }
  
}


/// This class is an abstract base class. Represents the current authorization state of the client. 
#[typetag::serde(tag = "@struct")]
pub trait AuthorizationState: Debug {}



impl Object for AuthorizationState {}





/// TDLib needs TdlibParameters for initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateWaitTdlibParameters

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateWaitTdlibParameters {}


impl AuthorizationStateWaitTdlibParameters {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// TDLib needs an encryption key to decrypt the local database. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateWaitEncryptionKey

  /// True, if the database is currently encrypted.
  is_encrypted: Option<bool>,


}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateWaitEncryptionKey {}


impl AuthorizationStateWaitEncryptionKey {
  
  
  pub fn is_encrypted(&self) -> &Option<bool> { &self.is_encrypted }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// TDLib needs the user's phone number to authorize. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateWaitPhoneNumber

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateWaitPhoneNumber {}


impl AuthorizationStateWaitPhoneNumber {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// TDLib needs the user's authentication code to finalize authorization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateWaitCode

  /// True, if the user is already registered.
  is_registered: Option<bool>,
  /// Telegram terms of service, which should be accepted before user can continue registration; may be null.
  terms_of_service: Option<TermsOfService>,
  /// Information about the authorization code that was sent.
  code_info: Option<AuthenticationCodeInfo>,


}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateWaitCode {}


impl AuthorizationStateWaitCode {
  
  
  pub fn is_registered(&self) -> &Option<bool> { &self.is_registered }
  
  pub fn terms_of_service(&self) -> &Option<TermsOfService> { &self.terms_of_service }
  
  pub fn code_info(&self) -> &Option<AuthenticationCodeInfo> { &self.code_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The user has been authorized, but needs to enter a password to start using the application. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateWaitPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateWaitPassword

  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True if a recovery email address has been set up.
  has_recovery_email_address: Option<bool>,
  /// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent.
  recovery_email_address_pattern: Option<String>,


}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateWaitPassword {}


impl AuthorizationStateWaitPassword {
  
  
  pub fn password_hint(&self) -> &Option<String> { &self.password_hint }
  
  pub fn has_recovery_email_address(&self) -> &Option<bool> { &self.has_recovery_email_address }
  
  pub fn recovery_email_address_pattern(&self) -> &Option<String> { &self.recovery_email_address_pattern }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The user has been successfully authorized. TDLib is now ready to answer queries. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateReady

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateReady {}


impl AuthorizationStateReady {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The user is currently logging out. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateLoggingOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateLoggingOut

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateLoggingOut {}


impl AuthorizationStateLoggingOut {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosing {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateClosing

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateClosing {}


impl AuthorizationStateClosing {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to with error code 500. To continue working, one should create a new instance of the TDLib client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthorizationStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // authorizationStateClosed

}



#[typetag::serde]
impl AuthorizationState for AuthorizationStateClosed {}


impl AuthorizationStateClosed {
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users). 
#[derive(Debug, Serialize, Deserialize)]
pub struct BasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // basicGroup

  /// Group identifier.
  id: Option<i32>,
  /// Number of members in the group.
  member_count: Option<i32>,
  /// Status of the current user in the group.
  status: Option<Box<ChatMemberStatus>>,
  /// True, if all members have been granted administrator rights in the group.
  everyone_is_administrator: Option<bool>,
  /// True, if the group is active.
  is_active: Option<bool>,
  /// Identifier of the supergroup to which this group was upgraded; 0 if none.
  upgraded_to_supergroup_id: Option<i32>,


}


impl Clone for BasicGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for BasicGroup {}


impl BasicGroup {
  
  pub fn builder() -> BasicGroupBuilder {
    let instance = Self {
      tdfname: "basicGroup".to_string(),
      id: None,
      member_count: None,
      status: None,
      everyone_is_administrator: None,
      is_active: None,
      upgraded_to_supergroup_id: None,
      
    };
    BasicGroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn member_count(&self) -> &Option<i32> { &self.member_count }
  
  pub fn status(&self) -> &Option<Box<ChatMemberStatus>> { &self.status }
  
  pub fn everyone_is_administrator(&self) -> &Option<bool> { &self.everyone_is_administrator }
  
  pub fn is_active(&self) -> &Option<bool> { &self.is_active }
  
  pub fn upgraded_to_supergroup_id(&self) -> &Option<i32> { &self.upgraded_to_supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct BasicGroupBuilder {
  instance: BasicGroup
}

impl BasicGroupBuilder {
  fn new(instance: BasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> BasicGroup {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn everyone_is_administrator(&mut self, everyone_is_administrator: bool) -> &mut Self {
    self.instance.everyone_is_administrator = Some(everyone_is_administrator);
    self
  }
  
  pub fn is_active(&mut self, is_active: bool) -> &mut Self {
    self.instance.is_active = Some(is_active);
    self
  }
  
  pub fn upgraded_to_supergroup_id(&mut self, upgraded_to_supergroup_id: i32) -> &mut Self {
    self.instance.upgraded_to_supergroup_id = Some(upgraded_to_supergroup_id);
    self
  }
  
}


/// Contains full information about a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // basicGroupFullInfo

  /// User identifier of the creator of the group; 0 if unknown.
  creator_user_id: Option<i32>,
  /// Group members.
  members: Option<Vec<ChatMember>>,
  /// Invite link for this group; available only for the group creator and only after it has been generated at least once.
  invite_link: Option<String>,


}




impl Object for BasicGroupFullInfo {}


impl BasicGroupFullInfo {
  
  pub fn builder() -> BasicGroupFullInfoBuilder {
    let instance = Self {
      tdfname: "basicGroupFullInfo".to_string(),
      creator_user_id: None,
      members: None,
      invite_link: None,
      
    };
    BasicGroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn creator_user_id(&self) -> &Option<i32> { &self.creator_user_id }
  
  pub fn members(&self) -> &Option<Vec<ChatMember>> { &self.members }
  
  pub fn invite_link(&self) -> &Option<String> { &self.invite_link }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct BasicGroupFullInfoBuilder {
  instance: BasicGroupFullInfo
}

impl BasicGroupFullInfoBuilder {
  fn new(instance: BasicGroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> BasicGroupFullInfo {
    self.instance.clone()
  }
  
  pub fn creator_user_id(&mut self, creator_user_id: i32) -> &mut Self {
    self.instance.creator_user_id = Some(creator_user_id);
    self
  }
  
  pub fn members(&mut self, members: Vec<ChatMember>) -> &mut Self {
    self.instance.members = Some(members);
    self
  }
  
  pub fn invite_link(&mut self, invite_link: String) -> &mut Self {
    self.instance.invite_link = Some(invite_link);
    self
  }
  
}


/// Represents commands supported by a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // botCommand

  /// Text of the bot command.
  command: Option<String>,
  /// Description of the bot command.
  description: Option<String>,


}




impl Object for BotCommand {}


impl BotCommand {
  
  pub fn builder() -> BotCommandBuilder {
    let instance = Self {
      tdfname: "botCommand".to_string(),
      command: None,
      description: None,
      
    };
    BotCommandBuilder::new(instance)
  }
  
  
  pub fn command(&self) -> &Option<String> { &self.command }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct BotCommandBuilder {
  instance: BotCommand
}

impl BotCommandBuilder {
  fn new(instance: BotCommand) -> Self { Self { instance } }

  pub fn build(&self) -> BotCommand {
    self.instance.clone()
  }
  
  pub fn command(&mut self, command: String) -> &mut Self {
    self.instance.command = Some(command);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Provides information about a bot and its supported commands. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BotInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // botInfo

  /// Long description shown on the user info page.
  description: Option<String>,
  /// A list of commands supported by the bot.
  commands: Option<Vec<BotCommand>>,


}




impl Object for BotInfo {}


impl BotInfo {
  
  pub fn builder() -> BotInfoBuilder {
    let instance = Self {
      tdfname: "botInfo".to_string(),
      description: None,
      commands: None,
      
    };
    BotInfoBuilder::new(instance)
  }
  
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn commands(&self) -> &Option<Vec<BotCommand>> { &self.commands }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct BotInfoBuilder {
  instance: BotInfo
}

impl BotInfoBuilder {
  fn new(instance: BotInfo) -> Self { Self { instance } }

  pub fn build(&self) -> BotInfo {
    self.instance.clone()
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn commands(&mut self, commands: Vec<BotCommand>) -> &mut Self {
    self.instance.commands = Some(commands);
    self
  }
  
}


/// Describes a call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Call {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // call

  /// Call identifier, not persistent.
  id: Option<i32>,
  /// Peer user identifier.
  user_id: Option<i32>,
  /// True, if the call is outgoing.
  is_outgoing: Option<bool>,
  /// Call state.
  state: Option<Box<CallState>>,


}


impl Clone for Call {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Call {}


impl Call {
  
  pub fn builder() -> CallBuilder {
    let instance = Self {
      tdfname: "call".to_string(),
      id: None,
      user_id: None,
      is_outgoing: None,
      state: None,
      
    };
    CallBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn is_outgoing(&self) -> &Option<bool> { &self.is_outgoing }
  
  pub fn state(&self) -> &Option<Box<CallState>> { &self.state }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallBuilder {
  instance: Call
}

impl CallBuilder {
  fn new(instance: Call) -> Self { Self { instance } }

  pub fn build(&self) -> Call {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn is_outgoing(&mut self, is_outgoing: bool) -> &mut Self {
    self.instance.is_outgoing = Some(is_outgoing);
    self
  }
  
  pub fn state(&mut self, state: Box<CallState>) -> &mut Self {
    self.instance.state = Some(state);
    self
  }
  
}


/// Describes the address of UDP reflectors. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallConnection {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callConnection

  /// Reflector identifier.
  id: Option<i64>,
  /// IPv4 reflector address.
  ip: Option<String>,
  /// IPv6 reflector address.
  ipv6: Option<String>,
  /// Reflector port number.
  port: Option<i32>,
  /// Connection peer tag.
  peer_tag: Option<String>,


}




impl Object for CallConnection {}


impl CallConnection {
  
  pub fn builder() -> CallConnectionBuilder {
    let instance = Self {
      tdfname: "callConnection".to_string(),
      id: None,
      ip: None,
      ipv6: None,
      port: None,
      peer_tag: None,
      
    };
    CallConnectionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn ip(&self) -> &Option<String> { &self.ip }
  
  pub fn ipv6(&self) -> &Option<String> { &self.ipv6 }
  
  pub fn port(&self) -> &Option<i32> { &self.port }
  
  pub fn peer_tag(&self) -> &Option<String> { &self.peer_tag }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallConnectionBuilder {
  instance: CallConnection
}

impl CallConnectionBuilder {
  fn new(instance: CallConnection) -> Self { Self { instance } }

  pub fn build(&self) -> CallConnection {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn ip(&mut self, ip: String) -> &mut Self {
    self.instance.ip = Some(ip);
    self
  }
  
  pub fn ipv6(&mut self, ipv6: String) -> &mut Self {
    self.instance.ipv6 = Some(ipv6);
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn peer_tag(&mut self, peer_tag: String) -> &mut Self {
    self.instance.peer_tag = Some(peer_tag);
    self
  }
  
}


/// This class is an abstract base class. Describes the reason why a call was discarded. 
#[typetag::serde(tag = "@struct")]
pub trait CallDiscardReason: Debug {}



impl Object for CallDiscardReason {}





/// The call wasn't discarded, or the reason is unknown. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callDiscardReasonEmpty

}



#[typetag::serde]
impl CallDiscardReason for CallDiscardReasonEmpty {}


impl CallDiscardReasonEmpty {
  
  pub fn builder() -> CallDiscardReasonEmptyBuilder {
    let instance = Self {
      tdfname: "callDiscardReasonEmpty".to_string(),
      
    };
    CallDiscardReasonEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallDiscardReasonEmptyBuilder {
  instance: CallDiscardReasonEmpty
}

impl CallDiscardReasonEmptyBuilder {
  fn new(instance: CallDiscardReasonEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonEmpty {
    self.instance.clone()
  }
  
}


/// The call was ended before the conversation started. It was cancelled by the caller or missed by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonMissed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callDiscardReasonMissed

}



#[typetag::serde]
impl CallDiscardReason for CallDiscardReasonMissed {}


impl CallDiscardReasonMissed {
  
  pub fn builder() -> CallDiscardReasonMissedBuilder {
    let instance = Self {
      tdfname: "callDiscardReasonMissed".to_string(),
      
    };
    CallDiscardReasonMissedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallDiscardReasonMissedBuilder {
  instance: CallDiscardReasonMissed
}

impl CallDiscardReasonMissedBuilder {
  fn new(instance: CallDiscardReasonMissed) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonMissed {
    self.instance.clone()
  }
  
}


/// The call was ended before the conversation started. It was declined by the other party. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDeclined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callDiscardReasonDeclined

}



#[typetag::serde]
impl CallDiscardReason for CallDiscardReasonDeclined {}


impl CallDiscardReasonDeclined {
  
  pub fn builder() -> CallDiscardReasonDeclinedBuilder {
    let instance = Self {
      tdfname: "callDiscardReasonDeclined".to_string(),
      
    };
    CallDiscardReasonDeclinedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallDiscardReasonDeclinedBuilder {
  instance: CallDiscardReasonDeclined
}

impl CallDiscardReasonDeclinedBuilder {
  fn new(instance: CallDiscardReasonDeclined) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonDeclined {
    self.instance.clone()
  }
  
}


/// The call was ended during the conversation because the users were disconnected. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonDisconnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callDiscardReasonDisconnected

}



#[typetag::serde]
impl CallDiscardReason for CallDiscardReasonDisconnected {}


impl CallDiscardReasonDisconnected {
  
  pub fn builder() -> CallDiscardReasonDisconnectedBuilder {
    let instance = Self {
      tdfname: "callDiscardReasonDisconnected".to_string(),
      
    };
    CallDiscardReasonDisconnectedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallDiscardReasonDisconnectedBuilder {
  instance: CallDiscardReasonDisconnected
}

impl CallDiscardReasonDisconnectedBuilder {
  fn new(instance: CallDiscardReasonDisconnected) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonDisconnected {
    self.instance.clone()
  }
  
}


/// The call was ended because one of the parties hung up. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallDiscardReasonHungUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callDiscardReasonHungUp

}



#[typetag::serde]
impl CallDiscardReason for CallDiscardReasonHungUp {}


impl CallDiscardReasonHungUp {
  
  pub fn builder() -> CallDiscardReasonHungUpBuilder {
    let instance = Self {
      tdfname: "callDiscardReasonHungUp".to_string(),
      
    };
    CallDiscardReasonHungUpBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallDiscardReasonHungUpBuilder {
  instance: CallDiscardReasonHungUp
}

impl CallDiscardReasonHungUpBuilder {
  fn new(instance: CallDiscardReasonHungUp) -> Self { Self { instance } }

  pub fn build(&self) -> CallDiscardReasonHungUp {
    self.instance.clone()
  }
  
}


/// Contains the call identifier. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callId

  /// Call identifier.
  id: Option<i32>,


}




impl Object for CallId {}


impl CallId {
  
  pub fn builder() -> CallIdBuilder {
    let instance = Self {
      tdfname: "callId".to_string(),
      id: None,
      
    };
    CallIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallIdBuilder {
  instance: CallId
}

impl CallIdBuilder {
  fn new(instance: CallId) -> Self { Self { instance } }

  pub fn build(&self) -> CallId {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}


/// Specifies the supported call protocols. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallProtocol {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callProtocol

  /// True, if UDP peer-to-peer connections are supported.
  udp_p2p: Option<bool>,
  /// True, if connection through UDP reflectors is supported.
  udp_reflector: Option<bool>,
  /// Minimum supported API layer; use 65.
  min_layer: Option<i32>,
  /// Maximum supported API layer; use 65.
  max_layer: Option<i32>,


}




impl Object for CallProtocol {}


impl CallProtocol {
  
  pub fn builder() -> CallProtocolBuilder {
    let instance = Self {
      tdfname: "callProtocol".to_string(),
      udp_p2p: None,
      udp_reflector: None,
      min_layer: None,
      max_layer: None,
      
    };
    CallProtocolBuilder::new(instance)
  }
  
  
  pub fn udp_p2p(&self) -> &Option<bool> { &self.udp_p2p }
  
  pub fn udp_reflector(&self) -> &Option<bool> { &self.udp_reflector }
  
  pub fn min_layer(&self) -> &Option<i32> { &self.min_layer }
  
  pub fn max_layer(&self) -> &Option<i32> { &self.max_layer }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallProtocolBuilder {
  instance: CallProtocol
}

impl CallProtocolBuilder {
  fn new(instance: CallProtocol) -> Self { Self { instance } }

  pub fn build(&self) -> CallProtocol {
    self.instance.clone()
  }
  
  pub fn udp_p2p(&mut self, udp_p2p: bool) -> &mut Self {
    self.instance.udp_p2p = Some(udp_p2p);
    self
  }
  
  pub fn udp_reflector(&mut self, udp_reflector: bool) -> &mut Self {
    self.instance.udp_reflector = Some(udp_reflector);
    self
  }
  
  pub fn min_layer(&mut self, min_layer: i32) -> &mut Self {
    self.instance.min_layer = Some(min_layer);
    self
  }
  
  pub fn max_layer(&mut self, max_layer: i32) -> &mut Self {
    self.instance.max_layer = Some(max_layer);
    self
  }
  
}


/// This class is an abstract base class. Describes the current call state. 
#[typetag::serde(tag = "@struct")]
pub trait CallState: Debug {}



impl Object for CallState {}





/// The call is pending, waiting to be accepted by a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStatePending

  /// True, if the call has already been created by the server.
  is_created: Option<bool>,
  /// True, if the call has already been received by the other party.
  is_received: Option<bool>,


}



#[typetag::serde]
impl CallState for CallStatePending {}


impl CallStatePending {
  
  pub fn builder() -> CallStatePendingBuilder {
    let instance = Self {
      tdfname: "callStatePending".to_string(),
      is_created: None,
      is_received: None,
      
    };
    CallStatePendingBuilder::new(instance)
  }
  
  
  pub fn is_created(&self) -> &Option<bool> { &self.is_created }
  
  pub fn is_received(&self) -> &Option<bool> { &self.is_received }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStatePendingBuilder {
  instance: CallStatePending
}

impl CallStatePendingBuilder {
  fn new(instance: CallStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> CallStatePending {
    self.instance.clone()
  }
  
  pub fn is_created(&mut self, is_created: bool) -> &mut Self {
    self.instance.is_created = Some(is_created);
    self
  }
  
  pub fn is_received(&mut self, is_received: bool) -> &mut Self {
    self.instance.is_received = Some(is_received);
    self
  }
  
}


/// The call has been answered and encryption keys are being exchanged. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateExchangingKeys {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStateExchangingKeys

}



#[typetag::serde]
impl CallState for CallStateExchangingKeys {}


impl CallStateExchangingKeys {
  
  pub fn builder() -> CallStateExchangingKeysBuilder {
    let instance = Self {
      tdfname: "callStateExchangingKeys".to_string(),
      
    };
    CallStateExchangingKeysBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStateExchangingKeysBuilder {
  instance: CallStateExchangingKeys
}

impl CallStateExchangingKeysBuilder {
  fn new(instance: CallStateExchangingKeys) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateExchangingKeys {
    self.instance.clone()
  }
  
}


/// The call is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStateReady

  /// Call protocols supported by the peer.
  protocol: Option<CallProtocol>,
  /// Available UDP reflectors.
  connections: Option<Vec<CallConnection>>,
  /// A JSON-encoded call config.
  config: Option<String>,
  /// Call encryption key.
  encryption_key: Option<String>,
  /// Encryption key emojis fingerprint.
  emojis: Option<Vec<String>>,
  /// True, if peer-to-peer connection is allowed by users privacy settings.
  allow_p2p: Option<bool>,


}



#[typetag::serde]
impl CallState for CallStateReady {}


impl CallStateReady {
  
  pub fn builder() -> CallStateReadyBuilder {
    let instance = Self {
      tdfname: "callStateReady".to_string(),
      protocol: None,
      connections: None,
      config: None,
      encryption_key: None,
      emojis: None,
      allow_p2p: None,
      
    };
    CallStateReadyBuilder::new(instance)
  }
  
  
  pub fn protocol(&self) -> &Option<CallProtocol> { &self.protocol }
  
  pub fn connections(&self) -> &Option<Vec<CallConnection>> { &self.connections }
  
  pub fn config(&self) -> &Option<String> { &self.config }
  
  pub fn encryption_key(&self) -> &Option<String> { &self.encryption_key }
  
  pub fn emojis(&self) -> &Option<Vec<String>> { &self.emojis }
  
  pub fn allow_p2p(&self) -> &Option<bool> { &self.allow_p2p }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStateReadyBuilder {
  instance: CallStateReady
}

impl CallStateReadyBuilder {
  fn new(instance: CallStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateReady {
    self.instance.clone()
  }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
  pub fn connections(&mut self, connections: Vec<CallConnection>) -> &mut Self {
    self.instance.connections = Some(connections);
    self
  }
  
  pub fn config(&mut self, config: String) -> &mut Self {
    self.instance.config = Some(config);
    self
  }
  
  pub fn encryption_key(&mut self, encryption_key: String) -> &mut Self {
    self.instance.encryption_key = Some(encryption_key);
    self
  }
  
  pub fn emojis(&mut self, emojis: Vec<String>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
  pub fn allow_p2p(&mut self, allow_p2p: bool) -> &mut Self {
    self.instance.allow_p2p = Some(allow_p2p);
    self
  }
  
}


/// The call is hanging up after 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateHangingUp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStateHangingUp

}



#[typetag::serde]
impl CallState for CallStateHangingUp {}


impl CallStateHangingUp {
  
  pub fn builder() -> CallStateHangingUpBuilder {
    let instance = Self {
      tdfname: "callStateHangingUp".to_string(),
      
    };
    CallStateHangingUpBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStateHangingUpBuilder {
  instance: CallStateHangingUp
}

impl CallStateHangingUpBuilder {
  fn new(instance: CallStateHangingUp) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateHangingUp {
    self.instance.clone()
  }
  
}


/// The call has ended successfully. 
#[derive(Debug, Serialize, Deserialize)]
pub struct CallStateDiscarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStateDiscarded

  /// The reason, why the call has ended.
  reason: Option<Box<CallDiscardReason>>,
  /// True, if the call rating should be sent to the server.
  need_rating: Option<bool>,
  /// True, if the call debug information should be sent to the server.
  need_debug_information: Option<bool>,


}


impl Clone for CallStateDiscarded {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl CallState for CallStateDiscarded {}


impl CallStateDiscarded {
  
  pub fn builder() -> CallStateDiscardedBuilder {
    let instance = Self {
      tdfname: "callStateDiscarded".to_string(),
      reason: None,
      need_rating: None,
      need_debug_information: None,
      
    };
    CallStateDiscardedBuilder::new(instance)
  }
  
  
  pub fn reason(&self) -> &Option<Box<CallDiscardReason>> { &self.reason }
  
  pub fn need_rating(&self) -> &Option<bool> { &self.need_rating }
  
  pub fn need_debug_information(&self) -> &Option<bool> { &self.need_debug_information }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStateDiscardedBuilder {
  instance: CallStateDiscarded
}

impl CallStateDiscardedBuilder {
  fn new(instance: CallStateDiscarded) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateDiscarded {
    self.instance.clone()
  }
  
  pub fn reason(&mut self, reason: Box<CallDiscardReason>) -> &mut Self {
    self.instance.reason = Some(reason);
    self
  }
  
  pub fn need_rating(&mut self, need_rating: bool) -> &mut Self {
    self.instance.need_rating = Some(need_rating);
    self
  }
  
  pub fn need_debug_information(&mut self, need_debug_information: bool) -> &mut Self {
    self.instance.need_debug_information = Some(need_debug_information);
    self
  }
  
}


/// The call has ended with an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallStateError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callStateError

  /// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout.
  error: Option<Error>,


}



#[typetag::serde]
impl CallState for CallStateError {}


impl CallStateError {
  
  pub fn builder() -> CallStateErrorBuilder {
    let instance = Self {
      tdfname: "callStateError".to_string(),
      error: None,
      
    };
    CallStateErrorBuilder::new(instance)
  }
  
  
  pub fn error(&self) -> &Option<Error> { &self.error }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallStateErrorBuilder {
  instance: CallStateError
}

impl CallStateErrorBuilder {
  fn new(instance: CallStateError) -> Self { Self { instance } }

  pub fn build(&self) -> CallStateError {
    self.instance.clone()
  }
  
  pub fn error(&mut self, error: Error) -> &mut Self {
    self.instance.error = Some(error);
    self
  }
  
}


/// Contains a bot's answer to a callback query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callbackQueryAnswer

  /// Text of the answer.
  text: Option<String>,
  /// True, if an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,


}




impl Object for CallbackQueryAnswer {}


impl CallbackQueryAnswer {
  
  pub fn builder() -> CallbackQueryAnswerBuilder {
    let instance = Self {
      tdfname: "callbackQueryAnswer".to_string(),
      text: None,
      show_alert: None,
      url: None,
      
    };
    CallbackQueryAnswerBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn show_alert(&self) -> &Option<bool> { &self.show_alert }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallbackQueryAnswerBuilder {
  instance: CallbackQueryAnswer
}

impl CallbackQueryAnswerBuilder {
  fn new(instance: CallbackQueryAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryAnswer {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn show_alert(&mut self, show_alert: bool) -> &mut Self {
    self.instance.show_alert = Some(show_alert);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// This class is an abstract base class. Represents a payload of a callback query. 
#[typetag::serde(tag = "@struct")]
pub trait CallbackQueryPayload: Debug {}



impl Object for CallbackQueryPayload {}





/// The payload from a general callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callbackQueryPayloadData

  /// Data that was attached to the callback button.
  data: Option<String>,


}



#[typetag::serde]
impl CallbackQueryPayload for CallbackQueryPayloadData {}


impl CallbackQueryPayloadData {
  
  pub fn builder() -> CallbackQueryPayloadDataBuilder {
    let instance = Self {
      tdfname: "callbackQueryPayloadData".to_string(),
      data: None,
      
    };
    CallbackQueryPayloadDataBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallbackQueryPayloadDataBuilder {
  instance: CallbackQueryPayloadData
}

impl CallbackQueryPayloadDataBuilder {
  fn new(instance: CallbackQueryPayloadData) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryPayloadData {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// The payload from a game callback button. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CallbackQueryPayloadGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // callbackQueryPayloadGame

  /// A short name of the game that was attached to the callback button.
  game_short_name: Option<String>,


}



#[typetag::serde]
impl CallbackQueryPayload for CallbackQueryPayloadGame {}


impl CallbackQueryPayloadGame {
  
  pub fn builder() -> CallbackQueryPayloadGameBuilder {
    let instance = Self {
      tdfname: "callbackQueryPayloadGame".to_string(),
      game_short_name: None,
      
    };
    CallbackQueryPayloadGameBuilder::new(instance)
  }
  
  
  pub fn game_short_name(&self) -> &Option<String> { &self.game_short_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CallbackQueryPayloadGameBuilder {
  instance: CallbackQueryPayloadGame
}

impl CallbackQueryPayloadGameBuilder {
  fn new(instance: CallbackQueryPayloadGame) -> Self { Self { instance } }

  pub fn build(&self) -> CallbackQueryPayloadGame {
    self.instance.clone()
  }
  
  pub fn game_short_name(&mut self, game_short_name: String) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name);
    self
  }
  
}


/// A chat. (Can be a private chat, basic group, supergroup, or secret chat.) 
#[derive(Debug, Serialize, Deserialize)]
pub struct Chat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chat

  /// Chat unique identifier.
  id: Option<i64>,
  /// Type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Last message in the chat; may be null.
  last_message: Option<Message>,
  /// Descending parameter by which chats are sorted in the main chat list. If the order number of two chats is the same, they must be sorted in descending order by ID. If 0, the position of the chat in the list is undetermined.
  order: Option<i64>,
  /// True, if the chat is pinned.
  is_pinned: Option<bool>,
  /// True, if the chat is marked as unread.
  is_marked_as_unread: Option<bool>,
  /// True, if the chat is sponsored by the user's MTProxy server.
  is_sponsored: Option<bool>,
  /// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the chat messages can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the chat can be reported to Telegram moderators through reportChat.
  can_be_reported: Option<bool>,
  /// Default value of the disable_notification parameter, used when a message is sent to the chat.
  default_disable_notification: Option<bool>,
  /// Number of unread messages in the chat.
  unread_count: Option<i32>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// Identifier of the last read outgoing message.
  last_read_outbox_message_id: Option<i64>,
  /// Number of unread messages with a mention/reply in the chat.
  unread_mention_count: Option<i32>,
  /// Notification settings for this chat.
  notification_settings: Option<ChatNotificationSettings>,
  /// Identifier of the pinned message in the chat; 0 if none.
  pinned_message_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,
  /// A draft of a message in the chat; may be null.
  draft_message: Option<DraftMessage>,
  /// Contains client-specific data associated with the chat. (For example, the chat position or local chat notification settings can be stored here.) Persistent if a message database is used.
  client_data: Option<String>,


}


impl Clone for Chat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Chat {}


impl Chat {
  
  pub fn builder() -> ChatBuilder {
    let instance = Self {
      tdfname: "chat".to_string(),
      id: None,
      type_: None,
      title: None,
      photo: None,
      last_message: None,
      order: None,
      is_pinned: None,
      is_marked_as_unread: None,
      is_sponsored: None,
      can_be_deleted_only_for_self: None,
      can_be_deleted_for_all_users: None,
      can_be_reported: None,
      default_disable_notification: None,
      unread_count: None,
      last_read_inbox_message_id: None,
      last_read_outbox_message_id: None,
      unread_mention_count: None,
      notification_settings: None,
      pinned_message_id: None,
      reply_markup_message_id: None,
      draft_message: None,
      client_data: None,
      
    };
    ChatBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn type_(&self) -> &Option<Box<ChatType>> { &self.type_ }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn photo(&self) -> &Option<ChatPhoto> { &self.photo }
  
  pub fn last_message(&self) -> &Option<Message> { &self.last_message }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  pub fn is_marked_as_unread(&self) -> &Option<bool> { &self.is_marked_as_unread }
  
  pub fn is_sponsored(&self) -> &Option<bool> { &self.is_sponsored }
  
  pub fn can_be_deleted_only_for_self(&self) -> &Option<bool> { &self.can_be_deleted_only_for_self }
  
  pub fn can_be_deleted_for_all_users(&self) -> &Option<bool> { &self.can_be_deleted_for_all_users }
  
  pub fn can_be_reported(&self) -> &Option<bool> { &self.can_be_reported }
  
  pub fn default_disable_notification(&self) -> &Option<bool> { &self.default_disable_notification }
  
  pub fn unread_count(&self) -> &Option<i32> { &self.unread_count }
  
  pub fn last_read_inbox_message_id(&self) -> &Option<i64> { &self.last_read_inbox_message_id }
  
  pub fn last_read_outbox_message_id(&self) -> &Option<i64> { &self.last_read_outbox_message_id }
  
  pub fn unread_mention_count(&self) -> &Option<i32> { &self.unread_mention_count }
  
  pub fn notification_settings(&self) -> &Option<ChatNotificationSettings> { &self.notification_settings }
  
  pub fn pinned_message_id(&self) -> &Option<i64> { &self.pinned_message_id }
  
  pub fn reply_markup_message_id(&self) -> &Option<i64> { &self.reply_markup_message_id }
  
  pub fn draft_message(&self) -> &Option<DraftMessage> { &self.draft_message }
  
  pub fn client_data(&self) -> &Option<String> { &self.client_data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatBuilder {
  instance: Chat
}

impl ChatBuilder {
  fn new(instance: Chat) -> Self { Self { instance } }

  pub fn build(&self) -> Chat {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ChatType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn last_message(&mut self, last_message: Message) -> &mut Self {
    self.instance.last_message = Some(last_message);
    self
  }
  
  pub fn order(&mut self, order: i64) -> &mut Self {
    self.instance.order = Some(order);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
  pub fn is_marked_as_unread(&mut self, is_marked_as_unread: bool) -> &mut Self {
    self.instance.is_marked_as_unread = Some(is_marked_as_unread);
    self
  }
  
  pub fn is_sponsored(&mut self, is_sponsored: bool) -> &mut Self {
    self.instance.is_sponsored = Some(is_sponsored);
    self
  }
  
  pub fn can_be_deleted_only_for_self(&mut self, can_be_deleted_only_for_self: bool) -> &mut Self {
    self.instance.can_be_deleted_only_for_self = Some(can_be_deleted_only_for_self);
    self
  }
  
  pub fn can_be_deleted_for_all_users(&mut self, can_be_deleted_for_all_users: bool) -> &mut Self {
    self.instance.can_be_deleted_for_all_users = Some(can_be_deleted_for_all_users);
    self
  }
  
  pub fn can_be_reported(&mut self, can_be_reported: bool) -> &mut Self {
    self.instance.can_be_reported = Some(can_be_reported);
    self
  }
  
  pub fn default_disable_notification(&mut self, default_disable_notification: bool) -> &mut Self {
    self.instance.default_disable_notification = Some(default_disable_notification);
    self
  }
  
  pub fn unread_count(&mut self, unread_count: i32) -> &mut Self {
    self.instance.unread_count = Some(unread_count);
    self
  }
  
  pub fn last_read_inbox_message_id(&mut self, last_read_inbox_message_id: i64) -> &mut Self {
    self.instance.last_read_inbox_message_id = Some(last_read_inbox_message_id);
    self
  }
  
  pub fn last_read_outbox_message_id(&mut self, last_read_outbox_message_id: i64) -> &mut Self {
    self.instance.last_read_outbox_message_id = Some(last_read_outbox_message_id);
    self
  }
  
  pub fn unread_mention_count(&mut self, unread_mention_count: i32) -> &mut Self {
    self.instance.unread_mention_count = Some(unread_mention_count);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ChatNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
  pub fn pinned_message_id(&mut self, pinned_message_id: i64) -> &mut Self {
    self.instance.pinned_message_id = Some(pinned_message_id);
    self
  }
  
  pub fn reply_markup_message_id(&mut self, reply_markup_message_id: i64) -> &mut Self {
    self.instance.reply_markup_message_id = Some(reply_markup_message_id);
    self
  }
  
  pub fn draft_message(&mut self, draft_message: DraftMessage) -> &mut Self {
    self.instance.draft_message = Some(draft_message);
    self
  }
  
  pub fn client_data(&mut self, client_data: String) -> &mut Self {
    self.instance.client_data = Some(client_data);
    self
  }
  
}


/// This class is an abstract base class. Describes the different types of activity in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatAction: Debug {}



impl Object for ChatAction {}





/// The user is typing a message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionTyping {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionTyping

}



#[typetag::serde]
impl ChatAction for ChatActionTyping {}


impl ChatActionTyping {
  
  pub fn builder() -> ChatActionTypingBuilder {
    let instance = Self {
      tdfname: "chatActionTyping".to_string(),
      
    };
    ChatActionTypingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionTypingBuilder {
  instance: ChatActionTyping
}

impl ChatActionTypingBuilder {
  fn new(instance: ChatActionTyping) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionTyping {
    self.instance.clone()
  }
  
}


/// The user is recording a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionRecordingVideo

}



#[typetag::serde]
impl ChatAction for ChatActionRecordingVideo {}


impl ChatActionRecordingVideo {
  
  pub fn builder() -> ChatActionRecordingVideoBuilder {
    let instance = Self {
      tdfname: "chatActionRecordingVideo".to_string(),
      
    };
    ChatActionRecordingVideoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionRecordingVideoBuilder {
  instance: ChatActionRecordingVideo
}

impl ChatActionRecordingVideoBuilder {
  fn new(instance: ChatActionRecordingVideo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVideo {
    self.instance.clone()
  }
  
}


/// The user is uploading a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionUploadingVideo

  /// Upload progress, as a percentage.
  progress: Option<i32>,


}



#[typetag::serde]
impl ChatAction for ChatActionUploadingVideo {}


impl ChatActionUploadingVideo {
  
  pub fn builder() -> ChatActionUploadingVideoBuilder {
    let instance = Self {
      tdfname: "chatActionUploadingVideo".to_string(),
      progress: None,
      
    };
    ChatActionUploadingVideoBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> &Option<i32> { &self.progress }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionUploadingVideoBuilder {
  instance: ChatActionUploadingVideo
}

impl ChatActionUploadingVideoBuilder {
  fn new(instance: ChatActionUploadingVideo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVideo {
    self.instance.clone()
  }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}


/// The user is recording a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionRecordingVoiceNote

}



#[typetag::serde]
impl ChatAction for ChatActionRecordingVoiceNote {}


impl ChatActionRecordingVoiceNote {
  
  pub fn builder() -> ChatActionRecordingVoiceNoteBuilder {
    let instance = Self {
      tdfname: "chatActionRecordingVoiceNote".to_string(),
      
    };
    ChatActionRecordingVoiceNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionRecordingVoiceNoteBuilder {
  instance: ChatActionRecordingVoiceNote
}

impl ChatActionRecordingVoiceNoteBuilder {
  fn new(instance: ChatActionRecordingVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVoiceNote {
    self.instance.clone()
  }
  
}


/// The user is uploading a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionUploadingVoiceNote

  /// Upload progress, as a percentage.
  progress: Option<i32>,


}



#[typetag::serde]
impl ChatAction for ChatActionUploadingVoiceNote {}


impl ChatActionUploadingVoiceNote {
  
  pub fn builder() -> ChatActionUploadingVoiceNoteBuilder {
    let instance = Self {
      tdfname: "chatActionUploadingVoiceNote".to_string(),
      progress: None,
      
    };
    ChatActionUploadingVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> &Option<i32> { &self.progress }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionUploadingVoiceNoteBuilder {
  instance: ChatActionUploadingVoiceNote
}

impl ChatActionUploadingVoiceNoteBuilder {
  fn new(instance: ChatActionUploadingVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVoiceNote {
    self.instance.clone()
  }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}


/// The user is uploading a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionUploadingPhoto

  /// Upload progress, as a percentage.
  progress: Option<i32>,


}



#[typetag::serde]
impl ChatAction for ChatActionUploadingPhoto {}


impl ChatActionUploadingPhoto {
  
  pub fn builder() -> ChatActionUploadingPhotoBuilder {
    let instance = Self {
      tdfname: "chatActionUploadingPhoto".to_string(),
      progress: None,
      
    };
    ChatActionUploadingPhotoBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> &Option<i32> { &self.progress }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionUploadingPhotoBuilder {
  instance: ChatActionUploadingPhoto
}

impl ChatActionUploadingPhotoBuilder {
  fn new(instance: ChatActionUploadingPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingPhoto {
    self.instance.clone()
  }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}


/// The user is uploading a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionUploadingDocument

  /// Upload progress, as a percentage.
  progress: Option<i32>,


}



#[typetag::serde]
impl ChatAction for ChatActionUploadingDocument {}


impl ChatActionUploadingDocument {
  
  pub fn builder() -> ChatActionUploadingDocumentBuilder {
    let instance = Self {
      tdfname: "chatActionUploadingDocument".to_string(),
      progress: None,
      
    };
    ChatActionUploadingDocumentBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> &Option<i32> { &self.progress }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionUploadingDocumentBuilder {
  instance: ChatActionUploadingDocument
}

impl ChatActionUploadingDocumentBuilder {
  fn new(instance: ChatActionUploadingDocument) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingDocument {
    self.instance.clone()
  }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}


/// The user is picking a location or venue to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionChoosingLocation

}



#[typetag::serde]
impl ChatAction for ChatActionChoosingLocation {}


impl ChatActionChoosingLocation {
  
  pub fn builder() -> ChatActionChoosingLocationBuilder {
    let instance = Self {
      tdfname: "chatActionChoosingLocation".to_string(),
      
    };
    ChatActionChoosingLocationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionChoosingLocationBuilder {
  instance: ChatActionChoosingLocation
}

impl ChatActionChoosingLocationBuilder {
  fn new(instance: ChatActionChoosingLocation) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionChoosingLocation {
    self.instance.clone()
  }
  
}


/// The user is picking a contact to send. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionChoosingContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionChoosingContact

}



#[typetag::serde]
impl ChatAction for ChatActionChoosingContact {}


impl ChatActionChoosingContact {
  
  pub fn builder() -> ChatActionChoosingContactBuilder {
    let instance = Self {
      tdfname: "chatActionChoosingContact".to_string(),
      
    };
    ChatActionChoosingContactBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionChoosingContactBuilder {
  instance: ChatActionChoosingContact
}

impl ChatActionChoosingContactBuilder {
  fn new(instance: ChatActionChoosingContact) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionChoosingContact {
    self.instance.clone()
  }
  
}


/// The user has started to play a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionStartPlayingGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionStartPlayingGame

}



#[typetag::serde]
impl ChatAction for ChatActionStartPlayingGame {}


impl ChatActionStartPlayingGame {
  
  pub fn builder() -> ChatActionStartPlayingGameBuilder {
    let instance = Self {
      tdfname: "chatActionStartPlayingGame".to_string(),
      
    };
    ChatActionStartPlayingGameBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionStartPlayingGameBuilder {
  instance: ChatActionStartPlayingGame
}

impl ChatActionStartPlayingGameBuilder {
  fn new(instance: ChatActionStartPlayingGame) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionStartPlayingGame {
    self.instance.clone()
  }
  
}


/// The user is recording a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionRecordingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionRecordingVideoNote

}



#[typetag::serde]
impl ChatAction for ChatActionRecordingVideoNote {}


impl ChatActionRecordingVideoNote {
  
  pub fn builder() -> ChatActionRecordingVideoNoteBuilder {
    let instance = Self {
      tdfname: "chatActionRecordingVideoNote".to_string(),
      
    };
    ChatActionRecordingVideoNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionRecordingVideoNoteBuilder {
  instance: ChatActionRecordingVideoNote
}

impl ChatActionRecordingVideoNoteBuilder {
  fn new(instance: ChatActionRecordingVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionRecordingVideoNote {
    self.instance.clone()
  }
  
}


/// The user is uploading a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionUploadingVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionUploadingVideoNote

  /// Upload progress, as a percentage.
  progress: Option<i32>,


}



#[typetag::serde]
impl ChatAction for ChatActionUploadingVideoNote {}


impl ChatActionUploadingVideoNote {
  
  pub fn builder() -> ChatActionUploadingVideoNoteBuilder {
    let instance = Self {
      tdfname: "chatActionUploadingVideoNote".to_string(),
      progress: None,
      
    };
    ChatActionUploadingVideoNoteBuilder::new(instance)
  }
  
  
  pub fn progress(&self) -> &Option<i32> { &self.progress }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionUploadingVideoNoteBuilder {
  instance: ChatActionUploadingVideoNote
}

impl ChatActionUploadingVideoNoteBuilder {
  fn new(instance: ChatActionUploadingVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionUploadingVideoNote {
    self.instance.clone()
  }
  
  pub fn progress(&mut self, progress: i32) -> &mut Self {
    self.instance.progress = Some(progress);
    self
  }
  
}


/// The user has cancelled the previous action. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatActionCancel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatActionCancel

}



#[typetag::serde]
impl ChatAction for ChatActionCancel {}


impl ChatActionCancel {
  
  pub fn builder() -> ChatActionCancelBuilder {
    let instance = Self {
      tdfname: "chatActionCancel".to_string(),
      
    };
    ChatActionCancelBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatActionCancelBuilder {
  instance: ChatActionCancel
}

impl ChatActionCancelBuilder {
  fn new(instance: ChatActionCancel) -> Self { Self { instance } }

  pub fn build(&self) -> ChatActionCancel {
    self.instance.clone()
  }
  
}


/// Represents a chat event. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEvent

  /// Chat event identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the event happened.
  date: Option<i32>,
  /// Identifier of the user who performed the action that triggered the event.
  user_id: Option<i32>,
  /// Action performed by the user.
  action: Option<Box<ChatEventAction>>,


}


impl Clone for ChatEvent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for ChatEvent {}


impl ChatEvent {
  
  pub fn builder() -> ChatEventBuilder {
    let instance = Self {
      tdfname: "chatEvent".to_string(),
      id: None,
      date: None,
      user_id: None,
      action: None,
      
    };
    ChatEventBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn action(&self) -> &Option<Box<ChatEventAction>> { &self.action }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventBuilder {
  instance: ChatEvent
}

impl ChatEventBuilder {
  fn new(instance: ChatEvent) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEvent {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn action(&mut self, action: Box<ChatEventAction>) -> &mut Self {
    self.instance.action = Some(action);
    self
  }
  
}


/// This class is an abstract base class. Represents a chat event. 
#[typetag::serde(tag = "@struct")]
pub trait ChatEventAction: Debug {}



impl Object for ChatEventAction {}





/// A message was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMessageEdited

  /// The original message before the edit.
  old_message: Option<Message>,
  /// The message after it was edited.
  new_message: Option<Message>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventMessageEdited {}


impl ChatEventMessageEdited {
  
  pub fn builder() -> ChatEventMessageEditedBuilder {
    let instance = Self {
      tdfname: "chatEventMessageEdited".to_string(),
      old_message: None,
      new_message: None,
      
    };
    ChatEventMessageEditedBuilder::new(instance)
  }
  
  
  pub fn old_message(&self) -> &Option<Message> { &self.old_message }
  
  pub fn new_message(&self) -> &Option<Message> { &self.new_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMessageEditedBuilder {
  instance: ChatEventMessageEdited
}

impl ChatEventMessageEditedBuilder {
  fn new(instance: ChatEventMessageEdited) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageEdited {
    self.instance.clone()
  }
  
  pub fn old_message(&mut self, old_message: Message) -> &mut Self {
    self.instance.old_message = Some(old_message);
    self
  }
  
  pub fn new_message(&mut self, new_message: Message) -> &mut Self {
    self.instance.new_message = Some(new_message);
    self
  }
  
}


/// A message was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMessageDeleted

  /// Deleted message.
  message: Option<Message>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventMessageDeleted {}


impl ChatEventMessageDeleted {
  
  pub fn builder() -> ChatEventMessageDeletedBuilder {
    let instance = Self {
      tdfname: "chatEventMessageDeleted".to_string(),
      message: None,
      
    };
    ChatEventMessageDeletedBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMessageDeletedBuilder {
  instance: ChatEventMessageDeleted
}

impl ChatEventMessageDeletedBuilder {
  fn new(instance: ChatEventMessageDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageDeleted {
    self.instance.clone()
  }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}


/// A message was pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessagePinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMessagePinned

  /// Pinned message.
  message: Option<Message>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventMessagePinned {}


impl ChatEventMessagePinned {
  
  pub fn builder() -> ChatEventMessagePinnedBuilder {
    let instance = Self {
      tdfname: "chatEventMessagePinned".to_string(),
      message: None,
      
    };
    ChatEventMessagePinnedBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMessagePinnedBuilder {
  instance: ChatEventMessagePinned
}

impl ChatEventMessagePinnedBuilder {
  fn new(instance: ChatEventMessagePinned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessagePinned {
    self.instance.clone()
  }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}


/// A message was unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMessageUnpinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMessageUnpinned

}



#[typetag::serde]
impl ChatEventAction for ChatEventMessageUnpinned {}


impl ChatEventMessageUnpinned {
  
  pub fn builder() -> ChatEventMessageUnpinnedBuilder {
    let instance = Self {
      tdfname: "chatEventMessageUnpinned".to_string(),
      
    };
    ChatEventMessageUnpinnedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMessageUnpinnedBuilder {
  instance: ChatEventMessageUnpinned
}

impl ChatEventMessageUnpinnedBuilder {
  fn new(instance: ChatEventMessageUnpinned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMessageUnpinned {
    self.instance.clone()
  }
  
}


/// A new member joined the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberJoined {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMemberJoined

}



#[typetag::serde]
impl ChatEventAction for ChatEventMemberJoined {}


impl ChatEventMemberJoined {
  
  pub fn builder() -> ChatEventMemberJoinedBuilder {
    let instance = Self {
      tdfname: "chatEventMemberJoined".to_string(),
      
    };
    ChatEventMemberJoinedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMemberJoinedBuilder {
  instance: ChatEventMemberJoined
}

impl ChatEventMemberJoinedBuilder {
  fn new(instance: ChatEventMemberJoined) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberJoined {
    self.instance.clone()
  }
  
}


/// A member left the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventMemberLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMemberLeft

}



#[typetag::serde]
impl ChatEventAction for ChatEventMemberLeft {}


impl ChatEventMemberLeft {
  
  pub fn builder() -> ChatEventMemberLeftBuilder {
    let instance = Self {
      tdfname: "chatEventMemberLeft".to_string(),
      
    };
    ChatEventMemberLeftBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMemberLeftBuilder {
  instance: ChatEventMemberLeft
}

impl ChatEventMemberLeftBuilder {
  fn new(instance: ChatEventMemberLeft) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberLeft {
    self.instance.clone()
  }
  
}


/// A new chat member was invited. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberInvited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMemberInvited

  /// New member user identifier.
  user_id: Option<i32>,
  /// New member status.
  status: Option<Box<ChatMemberStatus>>,


}


impl Clone for ChatEventMemberInvited {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl ChatEventAction for ChatEventMemberInvited {}


impl ChatEventMemberInvited {
  
  pub fn builder() -> ChatEventMemberInvitedBuilder {
    let instance = Self {
      tdfname: "chatEventMemberInvited".to_string(),
      user_id: None,
      status: None,
      
    };
    ChatEventMemberInvitedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn status(&self) -> &Option<Box<ChatMemberStatus>> { &self.status }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMemberInvitedBuilder {
  instance: ChatEventMemberInvited
}

impl ChatEventMemberInvitedBuilder {
  fn new(instance: ChatEventMemberInvited) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberInvited {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
}


/// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberPromoted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMemberPromoted

  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,


}


impl Clone for ChatEventMemberPromoted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl ChatEventAction for ChatEventMemberPromoted {}


impl ChatEventMemberPromoted {
  
  pub fn builder() -> ChatEventMemberPromotedBuilder {
    let instance = Self {
      tdfname: "chatEventMemberPromoted".to_string(),
      user_id: None,
      old_status: None,
      new_status: None,
      
    };
    ChatEventMemberPromotedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn old_status(&self) -> &Option<Box<ChatMemberStatus>> { &self.old_status }
  
  pub fn new_status(&self) -> &Option<Box<ChatMemberStatus>> { &self.new_status }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMemberPromotedBuilder {
  instance: ChatEventMemberPromoted
}

impl ChatEventMemberPromotedBuilder {
  fn new(instance: ChatEventMemberPromoted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberPromoted {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn old_status(&mut self, old_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.old_status = Some(old_status);
    self
  }
  
  pub fn new_status(&mut self, new_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.new_status = Some(new_status);
    self
  }
  
}


/// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatEventMemberRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventMemberRestricted

  /// Chat member user identifier.
  user_id: Option<i32>,
  /// Previous status of the chat member.
  old_status: Option<Box<ChatMemberStatus>>,
  /// New status of the chat member.
  new_status: Option<Box<ChatMemberStatus>>,


}


impl Clone for ChatEventMemberRestricted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl ChatEventAction for ChatEventMemberRestricted {}


impl ChatEventMemberRestricted {
  
  pub fn builder() -> ChatEventMemberRestrictedBuilder {
    let instance = Self {
      tdfname: "chatEventMemberRestricted".to_string(),
      user_id: None,
      old_status: None,
      new_status: None,
      
    };
    ChatEventMemberRestrictedBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn old_status(&self) -> &Option<Box<ChatMemberStatus>> { &self.old_status }
  
  pub fn new_status(&self) -> &Option<Box<ChatMemberStatus>> { &self.new_status }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventMemberRestrictedBuilder {
  instance: ChatEventMemberRestricted
}

impl ChatEventMemberRestrictedBuilder {
  fn new(instance: ChatEventMemberRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventMemberRestricted {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn old_status(&mut self, old_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.old_status = Some(old_status);
    self
  }
  
  pub fn new_status(&mut self, new_status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.new_status = Some(new_status);
    self
  }
  
}


/// The chat title was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventTitleChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventTitleChanged

  /// Previous chat title.
  old_title: Option<String>,
  /// New chat title.
  new_title: Option<String>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventTitleChanged {}


impl ChatEventTitleChanged {
  
  pub fn builder() -> ChatEventTitleChangedBuilder {
    let instance = Self {
      tdfname: "chatEventTitleChanged".to_string(),
      old_title: None,
      new_title: None,
      
    };
    ChatEventTitleChangedBuilder::new(instance)
  }
  
  
  pub fn old_title(&self) -> &Option<String> { &self.old_title }
  
  pub fn new_title(&self) -> &Option<String> { &self.new_title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventTitleChangedBuilder {
  instance: ChatEventTitleChanged
}

impl ChatEventTitleChangedBuilder {
  fn new(instance: ChatEventTitleChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventTitleChanged {
    self.instance.clone()
  }
  
  pub fn old_title(&mut self, old_title: String) -> &mut Self {
    self.instance.old_title = Some(old_title);
    self
  }
  
  pub fn new_title(&mut self, new_title: String) -> &mut Self {
    self.instance.new_title = Some(new_title);
    self
  }
  
}


/// The chat description was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventDescriptionChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventDescriptionChanged

  /// Previous chat description.
  old_description: Option<String>,
  /// New chat description.
  new_description: Option<String>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventDescriptionChanged {}


impl ChatEventDescriptionChanged {
  
  pub fn builder() -> ChatEventDescriptionChangedBuilder {
    let instance = Self {
      tdfname: "chatEventDescriptionChanged".to_string(),
      old_description: None,
      new_description: None,
      
    };
    ChatEventDescriptionChangedBuilder::new(instance)
  }
  
  
  pub fn old_description(&self) -> &Option<String> { &self.old_description }
  
  pub fn new_description(&self) -> &Option<String> { &self.new_description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventDescriptionChangedBuilder {
  instance: ChatEventDescriptionChanged
}

impl ChatEventDescriptionChangedBuilder {
  fn new(instance: ChatEventDescriptionChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventDescriptionChanged {
    self.instance.clone()
  }
  
  pub fn old_description(&mut self, old_description: String) -> &mut Self {
    self.instance.old_description = Some(old_description);
    self
  }
  
  pub fn new_description(&mut self, new_description: String) -> &mut Self {
    self.instance.new_description = Some(new_description);
    self
  }
  
}


/// The chat username was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventUsernameChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventUsernameChanged

  /// Previous chat username.
  old_username: Option<String>,
  /// New chat username.
  new_username: Option<String>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventUsernameChanged {}


impl ChatEventUsernameChanged {
  
  pub fn builder() -> ChatEventUsernameChangedBuilder {
    let instance = Self {
      tdfname: "chatEventUsernameChanged".to_string(),
      old_username: None,
      new_username: None,
      
    };
    ChatEventUsernameChangedBuilder::new(instance)
  }
  
  
  pub fn old_username(&self) -> &Option<String> { &self.old_username }
  
  pub fn new_username(&self) -> &Option<String> { &self.new_username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventUsernameChangedBuilder {
  instance: ChatEventUsernameChanged
}

impl ChatEventUsernameChangedBuilder {
  fn new(instance: ChatEventUsernameChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventUsernameChanged {
    self.instance.clone()
  }
  
  pub fn old_username(&mut self, old_username: String) -> &mut Self {
    self.instance.old_username = Some(old_username);
    self
  }
  
  pub fn new_username(&mut self, new_username: String) -> &mut Self {
    self.instance.new_username = Some(new_username);
    self
  }
  
}


/// The chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventPhotoChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventPhotoChanged

  /// Previous chat photo value; may be null.
  old_photo: Option<ChatPhoto>,
  /// New chat photo value; may be null.
  new_photo: Option<ChatPhoto>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventPhotoChanged {}


impl ChatEventPhotoChanged {
  
  pub fn builder() -> ChatEventPhotoChangedBuilder {
    let instance = Self {
      tdfname: "chatEventPhotoChanged".to_string(),
      old_photo: None,
      new_photo: None,
      
    };
    ChatEventPhotoChangedBuilder::new(instance)
  }
  
  
  pub fn old_photo(&self) -> &Option<ChatPhoto> { &self.old_photo }
  
  pub fn new_photo(&self) -> &Option<ChatPhoto> { &self.new_photo }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventPhotoChangedBuilder {
  instance: ChatEventPhotoChanged
}

impl ChatEventPhotoChangedBuilder {
  fn new(instance: ChatEventPhotoChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventPhotoChanged {
    self.instance.clone()
  }
  
  pub fn old_photo(&mut self, old_photo: ChatPhoto) -> &mut Self {
    self.instance.old_photo = Some(old_photo);
    self
  }
  
  pub fn new_photo(&mut self, new_photo: ChatPhoto) -> &mut Self {
    self.instance.new_photo = Some(new_photo);
    self
  }
  
}


/// The anyone_can_invite setting of a supergroup chat was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventInvitesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventInvitesToggled

  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventInvitesToggled {}


impl ChatEventInvitesToggled {
  
  pub fn builder() -> ChatEventInvitesToggledBuilder {
    let instance = Self {
      tdfname: "chatEventInvitesToggled".to_string(),
      anyone_can_invite: None,
      
    };
    ChatEventInvitesToggledBuilder::new(instance)
  }
  
  
  pub fn anyone_can_invite(&self) -> &Option<bool> { &self.anyone_can_invite }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventInvitesToggledBuilder {
  instance: ChatEventInvitesToggled
}

impl ChatEventInvitesToggledBuilder {
  fn new(instance: ChatEventInvitesToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventInvitesToggled {
    self.instance.clone()
  }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
}


/// The sign_messages setting of a channel was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventSignMessagesToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventSignMessagesToggled

  /// New value of sign_messages.
  sign_messages: Option<bool>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventSignMessagesToggled {}


impl ChatEventSignMessagesToggled {
  
  pub fn builder() -> ChatEventSignMessagesToggledBuilder {
    let instance = Self {
      tdfname: "chatEventSignMessagesToggled".to_string(),
      sign_messages: None,
      
    };
    ChatEventSignMessagesToggledBuilder::new(instance)
  }
  
  
  pub fn sign_messages(&self) -> &Option<bool> { &self.sign_messages }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventSignMessagesToggledBuilder {
  instance: ChatEventSignMessagesToggled
}

impl ChatEventSignMessagesToggledBuilder {
  fn new(instance: ChatEventSignMessagesToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventSignMessagesToggled {
    self.instance.clone()
  }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
}


/// The supergroup sticker set was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventStickerSetChanged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventStickerSetChanged

  /// Previous identifier of the chat sticker set; 0 if none.
  old_sticker_set_id: Option<i64>,
  /// New identifier of the chat sticker set; 0 if none.
  new_sticker_set_id: Option<i64>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventStickerSetChanged {}


impl ChatEventStickerSetChanged {
  
  pub fn builder() -> ChatEventStickerSetChangedBuilder {
    let instance = Self {
      tdfname: "chatEventStickerSetChanged".to_string(),
      old_sticker_set_id: None,
      new_sticker_set_id: None,
      
    };
    ChatEventStickerSetChangedBuilder::new(instance)
  }
  
  
  pub fn old_sticker_set_id(&self) -> &Option<i64> { &self.old_sticker_set_id }
  
  pub fn new_sticker_set_id(&self) -> &Option<i64> { &self.new_sticker_set_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventStickerSetChangedBuilder {
  instance: ChatEventStickerSetChanged
}

impl ChatEventStickerSetChangedBuilder {
  fn new(instance: ChatEventStickerSetChanged) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventStickerSetChanged {
    self.instance.clone()
  }
  
  pub fn old_sticker_set_id(&mut self, old_sticker_set_id: i64) -> &mut Self {
    self.instance.old_sticker_set_id = Some(old_sticker_set_id);
    self
  }
  
  pub fn new_sticker_set_id(&mut self, new_sticker_set_id: i64) -> &mut Self {
    self.instance.new_sticker_set_id = Some(new_sticker_set_id);
    self
  }
  
}


/// The is_all_history_available setting of a supergroup was toggled. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventIsAllHistoryAvailableToggled {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventIsAllHistoryAvailableToggled

  /// New value of is_all_history_available.
  is_all_history_available: Option<bool>,


}



#[typetag::serde]
impl ChatEventAction for ChatEventIsAllHistoryAvailableToggled {}


impl ChatEventIsAllHistoryAvailableToggled {
  
  pub fn builder() -> ChatEventIsAllHistoryAvailableToggledBuilder {
    let instance = Self {
      tdfname: "chatEventIsAllHistoryAvailableToggled".to_string(),
      is_all_history_available: None,
      
    };
    ChatEventIsAllHistoryAvailableToggledBuilder::new(instance)
  }
  
  
  pub fn is_all_history_available(&self) -> &Option<bool> { &self.is_all_history_available }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventIsAllHistoryAvailableToggledBuilder {
  instance: ChatEventIsAllHistoryAvailableToggled
}

impl ChatEventIsAllHistoryAvailableToggledBuilder {
  fn new(instance: ChatEventIsAllHistoryAvailableToggled) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventIsAllHistoryAvailableToggled {
    self.instance.clone()
  }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
}


/// Represents a set of filters used to obtain a chat event log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEventLogFilters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEventLogFilters

  /// True, if message edits should be returned.
  message_edits: Option<bool>,
  /// True, if message deletions should be returned.
  message_deletions: Option<bool>,
  /// True, if pin/unpin events should be returned.
  message_pins: Option<bool>,
  /// True, if members joining events should be returned.
  member_joins: Option<bool>,
  /// True, if members leaving events should be returned.
  member_leaves: Option<bool>,
  /// True, if invited member events should be returned.
  member_invites: Option<bool>,
  /// True, if member promotion/demotion events should be returned.
  member_promotions: Option<bool>,
  /// True, if member restricted/unrestricted/banned/unbanned events should be returned.
  member_restrictions: Option<bool>,
  /// True, if changes in chat information should be returned.
  info_changes: Option<bool>,
  /// True, if changes in chat settings should be returned.
  setting_changes: Option<bool>,


}




impl Object for ChatEventLogFilters {}


impl ChatEventLogFilters {
  
  pub fn builder() -> ChatEventLogFiltersBuilder {
    let instance = Self {
      tdfname: "chatEventLogFilters".to_string(),
      message_edits: None,
      message_deletions: None,
      message_pins: None,
      member_joins: None,
      member_leaves: None,
      member_invites: None,
      member_promotions: None,
      member_restrictions: None,
      info_changes: None,
      setting_changes: None,
      
    };
    ChatEventLogFiltersBuilder::new(instance)
  }
  
  
  pub fn message_edits(&self) -> &Option<bool> { &self.message_edits }
  
  pub fn message_deletions(&self) -> &Option<bool> { &self.message_deletions }
  
  pub fn message_pins(&self) -> &Option<bool> { &self.message_pins }
  
  pub fn member_joins(&self) -> &Option<bool> { &self.member_joins }
  
  pub fn member_leaves(&self) -> &Option<bool> { &self.member_leaves }
  
  pub fn member_invites(&self) -> &Option<bool> { &self.member_invites }
  
  pub fn member_promotions(&self) -> &Option<bool> { &self.member_promotions }
  
  pub fn member_restrictions(&self) -> &Option<bool> { &self.member_restrictions }
  
  pub fn info_changes(&self) -> &Option<bool> { &self.info_changes }
  
  pub fn setting_changes(&self) -> &Option<bool> { &self.setting_changes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventLogFiltersBuilder {
  instance: ChatEventLogFilters
}

impl ChatEventLogFiltersBuilder {
  fn new(instance: ChatEventLogFilters) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEventLogFilters {
    self.instance.clone()
  }
  
  pub fn message_edits(&mut self, message_edits: bool) -> &mut Self {
    self.instance.message_edits = Some(message_edits);
    self
  }
  
  pub fn message_deletions(&mut self, message_deletions: bool) -> &mut Self {
    self.instance.message_deletions = Some(message_deletions);
    self
  }
  
  pub fn message_pins(&mut self, message_pins: bool) -> &mut Self {
    self.instance.message_pins = Some(message_pins);
    self
  }
  
  pub fn member_joins(&mut self, member_joins: bool) -> &mut Self {
    self.instance.member_joins = Some(member_joins);
    self
  }
  
  pub fn member_leaves(&mut self, member_leaves: bool) -> &mut Self {
    self.instance.member_leaves = Some(member_leaves);
    self
  }
  
  pub fn member_invites(&mut self, member_invites: bool) -> &mut Self {
    self.instance.member_invites = Some(member_invites);
    self
  }
  
  pub fn member_promotions(&mut self, member_promotions: bool) -> &mut Self {
    self.instance.member_promotions = Some(member_promotions);
    self
  }
  
  pub fn member_restrictions(&mut self, member_restrictions: bool) -> &mut Self {
    self.instance.member_restrictions = Some(member_restrictions);
    self
  }
  
  pub fn info_changes(&mut self, info_changes: bool) -> &mut Self {
    self.instance.info_changes = Some(info_changes);
    self
  }
  
  pub fn setting_changes(&mut self, setting_changes: bool) -> &mut Self {
    self.instance.setting_changes = Some(setting_changes);
    self
  }
  
}


/// Contains a list of chat events. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatEvents {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatEvents

  /// List of events.
  events: Option<Vec<ChatEvent>>,


}




impl Object for ChatEvents {}


impl ChatEvents {
  
  pub fn builder() -> ChatEventsBuilder {
    let instance = Self {
      tdfname: "chatEvents".to_string(),
      events: None,
      
    };
    ChatEventsBuilder::new(instance)
  }
  
  
  pub fn events(&self) -> &Option<Vec<ChatEvent>> { &self.events }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatEventsBuilder {
  instance: ChatEvents
}

impl ChatEventsBuilder {
  fn new(instance: ChatEvents) -> Self { Self { instance } }

  pub fn build(&self) -> ChatEvents {
    self.instance.clone()
  }
  
  pub fn events(&mut self, events: Vec<ChatEvent>) -> &mut Self {
    self.instance.events = Some(events);
    self
  }
  
}


/// Contains a chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatInviteLink

  /// Chat invite link.
  invite_link: Option<String>,


}




impl Object for ChatInviteLink {}


impl ChatInviteLink {
  
  pub fn builder() -> ChatInviteLinkBuilder {
    let instance = Self {
      tdfname: "chatInviteLink".to_string(),
      invite_link: None,
      
    };
    ChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> &Option<String> { &self.invite_link }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatInviteLinkBuilder {
  instance: ChatInviteLink
}

impl ChatInviteLinkBuilder {
  fn new(instance: ChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> ChatInviteLink {
    self.instance.clone()
  }
  
  pub fn invite_link(&mut self, invite_link: String) -> &mut Self {
    self.instance.invite_link = Some(invite_link);
    self
  }
  
}


/// Contains information about a chat invite link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatInviteLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatInviteLinkInfo

  /// Chat identifier of the invite link; 0 if the user is not a member of this chat.
  chat_id: Option<i64>,
  /// Contains information about the type of the chat.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ChatType>>,
  /// Title of the chat.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Number of members.
  member_count: Option<i32>,
  /// User identifiers of some chat members that may be known to the current user.
  member_user_ids: Option<Vec<i32>>,
  /// True, if the chat is a public supergroup or channel with a username.
  is_public: Option<bool>,


}


impl Clone for ChatInviteLinkInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for ChatInviteLinkInfo {}


impl ChatInviteLinkInfo {
  
  pub fn builder() -> ChatInviteLinkInfoBuilder {
    let instance = Self {
      tdfname: "chatInviteLinkInfo".to_string(),
      chat_id: None,
      type_: None,
      title: None,
      photo: None,
      member_count: None,
      member_user_ids: None,
      is_public: None,
      
    };
    ChatInviteLinkInfoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn type_(&self) -> &Option<Box<ChatType>> { &self.type_ }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn photo(&self) -> &Option<ChatPhoto> { &self.photo }
  
  pub fn member_count(&self) -> &Option<i32> { &self.member_count }
  
  pub fn member_user_ids(&self) -> &Option<Vec<i32>> { &self.member_user_ids }
  
  pub fn is_public(&self) -> &Option<bool> { &self.is_public }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatInviteLinkInfoBuilder {
  instance: ChatInviteLinkInfo
}

impl ChatInviteLinkInfoBuilder {
  fn new(instance: ChatInviteLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ChatInviteLinkInfo {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ChatType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
  pub fn is_public(&mut self, is_public: bool) -> &mut Self {
    self.instance.is_public = Some(is_public);
    self
  }
  
}


/// A user with information about joining/leaving a chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct ChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMember

  /// User identifier of the chat member.
  user_id: Option<i32>,
  /// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown.
  inviter_user_id: Option<i32>,
  /// Point in time (Unix timestamp) when the user joined a chat.
  joined_chat_date: Option<i32>,
  /// Status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,
  /// If the user is a bot, information about the bot; may be null. Can be null even for a bot if the bot is not a chat member.
  bot_info: Option<BotInfo>,


}


impl Clone for ChatMember {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for ChatMember {}


impl ChatMember {
  
  pub fn builder() -> ChatMemberBuilder {
    let instance = Self {
      tdfname: "chatMember".to_string(),
      user_id: None,
      inviter_user_id: None,
      joined_chat_date: None,
      status: None,
      bot_info: None,
      
    };
    ChatMemberBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn inviter_user_id(&self) -> &Option<i32> { &self.inviter_user_id }
  
  pub fn joined_chat_date(&self) -> &Option<i32> { &self.joined_chat_date }
  
  pub fn status(&self) -> &Option<Box<ChatMemberStatus>> { &self.status }
  
  pub fn bot_info(&self) -> &Option<BotInfo> { &self.bot_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberBuilder {
  instance: ChatMember
}

impl ChatMemberBuilder {
  fn new(instance: ChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMember {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn inviter_user_id(&mut self, inviter_user_id: i32) -> &mut Self {
    self.instance.inviter_user_id = Some(inviter_user_id);
    self
  }
  
  pub fn joined_chat_date(&mut self, joined_chat_date: i32) -> &mut Self {
    self.instance.joined_chat_date = Some(joined_chat_date);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn bot_info(&mut self, bot_info: BotInfo) -> &mut Self {
    self.instance.bot_info = Some(bot_info);
    self
  }
  
}


/// This class is an abstract base class. Provides information about the status of a member in a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatMemberStatus: Debug {}



impl Object for ChatMemberStatus {}





/// The user is the creator of a chat and has all the administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusCreator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusCreator

  /// True, if the user is a member of the chat.
  is_member: Option<bool>,


}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusCreator {}


impl ChatMemberStatusCreator {
  
  pub fn builder() -> ChatMemberStatusCreatorBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusCreator".to_string(),
      is_member: None,
      
    };
    ChatMemberStatusCreatorBuilder::new(instance)
  }
  
  
  pub fn is_member(&self) -> &Option<bool> { &self.is_member }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusCreatorBuilder {
  instance: ChatMemberStatusCreator
}

impl ChatMemberStatusCreatorBuilder {
  fn new(instance: ChatMemberStatusCreator) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusCreator {
    self.instance.clone()
  }
  
  pub fn is_member(&mut self, is_member: bool) -> &mut Self {
    self.instance.is_member = Some(is_member);
    self
  }
  
}


/// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusAdministrator {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusAdministrator

  /// True, if the current user can edit the administrator privileges for the called user.
  can_be_edited: Option<bool>,
  /// True, if the administrator can change the chat title, photo, and other settings.
  can_change_info: Option<bool>,
  /// True, if the administrator can create channel posts; applicable to channels only.
  can_post_messages: Option<bool>,
  /// True, if the administrator can edit messages of other users and pin messages; applicable to channels only.
  can_edit_messages: Option<bool>,
  /// True, if the administrator can delete messages of other users.
  can_delete_messages: Option<bool>,
  /// True, if the administrator can invite new users to the chat.
  can_invite_users: Option<bool>,
  /// True, if the administrator can restrict, ban, or unban chat members.
  can_restrict_members: Option<bool>,
  /// True, if the administrator can pin messages; applicable to groups only.
  can_pin_messages: Option<bool>,
  /// True, if the administrator can add new administrators with a subset of his own privileges or demote administrators that were directly or indirectly promoted by him.
  can_promote_members: Option<bool>,


}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusAdministrator {}


impl ChatMemberStatusAdministrator {
  
  pub fn builder() -> ChatMemberStatusAdministratorBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusAdministrator".to_string(),
      can_be_edited: None,
      can_change_info: None,
      can_post_messages: None,
      can_edit_messages: None,
      can_delete_messages: None,
      can_invite_users: None,
      can_restrict_members: None,
      can_pin_messages: None,
      can_promote_members: None,
      
    };
    ChatMemberStatusAdministratorBuilder::new(instance)
  }
  
  
  pub fn can_be_edited(&self) -> &Option<bool> { &self.can_be_edited }
  
  pub fn can_change_info(&self) -> &Option<bool> { &self.can_change_info }
  
  pub fn can_post_messages(&self) -> &Option<bool> { &self.can_post_messages }
  
  pub fn can_edit_messages(&self) -> &Option<bool> { &self.can_edit_messages }
  
  pub fn can_delete_messages(&self) -> &Option<bool> { &self.can_delete_messages }
  
  pub fn can_invite_users(&self) -> &Option<bool> { &self.can_invite_users }
  
  pub fn can_restrict_members(&self) -> &Option<bool> { &self.can_restrict_members }
  
  pub fn can_pin_messages(&self) -> &Option<bool> { &self.can_pin_messages }
  
  pub fn can_promote_members(&self) -> &Option<bool> { &self.can_promote_members }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusAdministratorBuilder {
  instance: ChatMemberStatusAdministrator
}

impl ChatMemberStatusAdministratorBuilder {
  fn new(instance: ChatMemberStatusAdministrator) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusAdministrator {
    self.instance.clone()
  }
  
  pub fn can_be_edited(&mut self, can_be_edited: bool) -> &mut Self {
    self.instance.can_be_edited = Some(can_be_edited);
    self
  }
  
  pub fn can_change_info(&mut self, can_change_info: bool) -> &mut Self {
    self.instance.can_change_info = Some(can_change_info);
    self
  }
  
  pub fn can_post_messages(&mut self, can_post_messages: bool) -> &mut Self {
    self.instance.can_post_messages = Some(can_post_messages);
    self
  }
  
  pub fn can_edit_messages(&mut self, can_edit_messages: bool) -> &mut Self {
    self.instance.can_edit_messages = Some(can_edit_messages);
    self
  }
  
  pub fn can_delete_messages(&mut self, can_delete_messages: bool) -> &mut Self {
    self.instance.can_delete_messages = Some(can_delete_messages);
    self
  }
  
  pub fn can_invite_users(&mut self, can_invite_users: bool) -> &mut Self {
    self.instance.can_invite_users = Some(can_invite_users);
    self
  }
  
  pub fn can_restrict_members(&mut self, can_restrict_members: bool) -> &mut Self {
    self.instance.can_restrict_members = Some(can_restrict_members);
    self
  }
  
  pub fn can_pin_messages(&mut self, can_pin_messages: bool) -> &mut Self {
    self.instance.can_pin_messages = Some(can_pin_messages);
    self
  }
  
  pub fn can_promote_members(&mut self, can_promote_members: bool) -> &mut Self {
    self.instance.can_promote_members = Some(can_promote_members);
    self
  }
  
}


/// The user is a member of a chat, without any additional privileges or restrictions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusMember

}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusMember {}


impl ChatMemberStatusMember {
  
  pub fn builder() -> ChatMemberStatusMemberBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusMember".to_string(),
      
    };
    ChatMemberStatusMemberBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusMemberBuilder {
  instance: ChatMemberStatusMember
}

impl ChatMemberStatusMemberBuilder {
  fn new(instance: ChatMemberStatusMember) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusMember {
    self.instance.clone()
  }
  
}


/// The user is under certain restrictions in the chat. Not supported in basic groups and channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusRestricted

  /// True, if the user is a member of the chat.
  is_member: Option<bool>,
  /// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever.
  restricted_until_date: Option<i32>,
  /// True, if the user can send text messages, contacts, locations, and venues.
  can_send_messages: Option<bool>,
  /// True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions.
  can_send_media_messages: Option<bool>,
  /// True, if the user can send animations, games, and stickers and use inline bots. Implies can_send_media_messages permissions.
  can_send_other_messages: Option<bool>,
  /// True, if the user may add a web page preview to his messages. Implies can_send_messages permissions.
  can_add_web_page_previews: Option<bool>,


}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusRestricted {}


impl ChatMemberStatusRestricted {
  
  pub fn builder() -> ChatMemberStatusRestrictedBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusRestricted".to_string(),
      is_member: None,
      restricted_until_date: None,
      can_send_messages: None,
      can_send_media_messages: None,
      can_send_other_messages: None,
      can_add_web_page_previews: None,
      
    };
    ChatMemberStatusRestrictedBuilder::new(instance)
  }
  
  
  pub fn is_member(&self) -> &Option<bool> { &self.is_member }
  
  pub fn restricted_until_date(&self) -> &Option<i32> { &self.restricted_until_date }
  
  pub fn can_send_messages(&self) -> &Option<bool> { &self.can_send_messages }
  
  pub fn can_send_media_messages(&self) -> &Option<bool> { &self.can_send_media_messages }
  
  pub fn can_send_other_messages(&self) -> &Option<bool> { &self.can_send_other_messages }
  
  pub fn can_add_web_page_previews(&self) -> &Option<bool> { &self.can_add_web_page_previews }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusRestrictedBuilder {
  instance: ChatMemberStatusRestricted
}

impl ChatMemberStatusRestrictedBuilder {
  fn new(instance: ChatMemberStatusRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusRestricted {
    self.instance.clone()
  }
  
  pub fn is_member(&mut self, is_member: bool) -> &mut Self {
    self.instance.is_member = Some(is_member);
    self
  }
  
  pub fn restricted_until_date(&mut self, restricted_until_date: i32) -> &mut Self {
    self.instance.restricted_until_date = Some(restricted_until_date);
    self
  }
  
  pub fn can_send_messages(&mut self, can_send_messages: bool) -> &mut Self {
    self.instance.can_send_messages = Some(can_send_messages);
    self
  }
  
  pub fn can_send_media_messages(&mut self, can_send_media_messages: bool) -> &mut Self {
    self.instance.can_send_media_messages = Some(can_send_media_messages);
    self
  }
  
  pub fn can_send_other_messages(&mut self, can_send_other_messages: bool) -> &mut Self {
    self.instance.can_send_other_messages = Some(can_send_other_messages);
    self
  }
  
  pub fn can_add_web_page_previews(&mut self, can_add_web_page_previews: bool) -> &mut Self {
    self.instance.can_add_web_page_previews = Some(can_add_web_page_previews);
    self
  }
  
}


/// The user is not a chat member. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusLeft

}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusLeft {}


impl ChatMemberStatusLeft {
  
  pub fn builder() -> ChatMemberStatusLeftBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusLeft".to_string(),
      
    };
    ChatMemberStatusLeftBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusLeftBuilder {
  instance: ChatMemberStatusLeft
}

impl ChatMemberStatusLeftBuilder {
  fn new(instance: ChatMemberStatusLeft) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusLeft {
    self.instance.clone()
  }
  
}


/// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMemberStatusBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMemberStatusBanned

  /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever.
  banned_until_date: Option<i32>,


}



#[typetag::serde]
impl ChatMemberStatus for ChatMemberStatusBanned {}


impl ChatMemberStatusBanned {
  
  pub fn builder() -> ChatMemberStatusBannedBuilder {
    let instance = Self {
      tdfname: "chatMemberStatusBanned".to_string(),
      banned_until_date: None,
      
    };
    ChatMemberStatusBannedBuilder::new(instance)
  }
  
  
  pub fn banned_until_date(&self) -> &Option<i32> { &self.banned_until_date }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMemberStatusBannedBuilder {
  instance: ChatMemberStatusBanned
}

impl ChatMemberStatusBannedBuilder {
  fn new(instance: ChatMemberStatusBanned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMemberStatusBanned {
    self.instance.clone()
  }
  
  pub fn banned_until_date(&mut self, banned_until_date: i32) -> &mut Self {
    self.instance.banned_until_date = Some(banned_until_date);
    self
  }
  
}


/// Contains a list of chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembers

  /// Approximate total count of chat members found.
  total_count: Option<i32>,
  /// A list of chat members.
  members: Option<Vec<ChatMember>>,


}




impl Object for ChatMembers {}


impl ChatMembers {
  
  pub fn builder() -> ChatMembersBuilder {
    let instance = Self {
      tdfname: "chatMembers".to_string(),
      total_count: None,
      members: None,
      
    };
    ChatMembersBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn members(&self) -> &Option<Vec<ChatMember>> { &self.members }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersBuilder {
  instance: ChatMembers
}

impl ChatMembersBuilder {
  fn new(instance: ChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembers {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn members(&mut self, members: Vec<ChatMember>) -> &mut Self {
    self.instance.members = Some(members);
    self
  }
  
}


/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait ChatMembersFilter: Debug {}



impl Object for ChatMembersFilter {}





/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembersFilterAdministrators

}



#[typetag::serde]
impl ChatMembersFilter for ChatMembersFilterAdministrators {}


impl ChatMembersFilterAdministrators {
  
  pub fn builder() -> ChatMembersFilterAdministratorsBuilder {
    let instance = Self {
      tdfname: "chatMembersFilterAdministrators".to_string(),
      
    };
    ChatMembersFilterAdministratorsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersFilterAdministratorsBuilder {
  instance: ChatMembersFilterAdministrators
}

impl ChatMembersFilterAdministratorsBuilder {
  fn new(instance: ChatMembersFilterAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterAdministrators {
    self.instance.clone()
  }
  
}


/// Returns all chat members, including restricted chat members. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembersFilterMembers

}



#[typetag::serde]
impl ChatMembersFilter for ChatMembersFilterMembers {}


impl ChatMembersFilterMembers {
  
  pub fn builder() -> ChatMembersFilterMembersBuilder {
    let instance = Self {
      tdfname: "chatMembersFilterMembers".to_string(),
      
    };
    ChatMembersFilterMembersBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersFilterMembersBuilder {
  instance: ChatMembersFilterMembers
}

impl ChatMembersFilterMembersBuilder {
  fn new(instance: ChatMembersFilterMembers) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterMembers {
    self.instance.clone()
  }
  
}


/// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembersFilterRestricted

}



#[typetag::serde]
impl ChatMembersFilter for ChatMembersFilterRestricted {}


impl ChatMembersFilterRestricted {
  
  pub fn builder() -> ChatMembersFilterRestrictedBuilder {
    let instance = Self {
      tdfname: "chatMembersFilterRestricted".to_string(),
      
    };
    ChatMembersFilterRestrictedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersFilterRestrictedBuilder {
  instance: ChatMembersFilterRestricted
}

impl ChatMembersFilterRestrictedBuilder {
  fn new(instance: ChatMembersFilterRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterRestricted {
    self.instance.clone()
  }
  
}


/// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembersFilterBanned

}



#[typetag::serde]
impl ChatMembersFilter for ChatMembersFilterBanned {}


impl ChatMembersFilterBanned {
  
  pub fn builder() -> ChatMembersFilterBannedBuilder {
    let instance = Self {
      tdfname: "chatMembersFilterBanned".to_string(),
      
    };
    ChatMembersFilterBannedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersFilterBannedBuilder {
  instance: ChatMembersFilterBanned
}

impl ChatMembersFilterBannedBuilder {
  fn new(instance: ChatMembersFilterBanned) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterBanned {
    self.instance.clone()
  }
  
}


/// Returns bot members of the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatMembersFilterBots

}



#[typetag::serde]
impl ChatMembersFilter for ChatMembersFilterBots {}


impl ChatMembersFilterBots {
  
  pub fn builder() -> ChatMembersFilterBotsBuilder {
    let instance = Self {
      tdfname: "chatMembersFilterBots".to_string(),
      
    };
    ChatMembersFilterBotsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatMembersFilterBotsBuilder {
  instance: ChatMembersFilterBots
}

impl ChatMembersFilterBotsBuilder {
  fn new(instance: ChatMembersFilterBots) -> Self { Self { instance } }

  pub fn build(&self) -> ChatMembersFilterBots {
    self.instance.clone()
  }
  
}


/// Contains information about notification settings for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatNotificationSettings

  /// If true, mute_for is ignored and the value for the relevant type of chat is used instead.
  use_default_mute_for: Option<bool>,
  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// If true, sound is ignored and the value for the relevant type of chat is used instead.
  use_default_sound: Option<bool>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// If true, show_preview is ignored and the value for the relevant type of chat is used instead.
  use_default_show_preview: Option<bool>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_pinned_message_notifications: Option<bool>,
  /// If true, notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead.
  use_default_disable_mention_notifications: Option<bool>,
  /// If true, notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,


}




impl Object for ChatNotificationSettings {}


impl ChatNotificationSettings {
  
  pub fn builder() -> ChatNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "chatNotificationSettings".to_string(),
      use_default_mute_for: None,
      mute_for: None,
      use_default_sound: None,
      sound: None,
      use_default_show_preview: None,
      show_preview: None,
      use_default_disable_pinned_message_notifications: None,
      disable_pinned_message_notifications: None,
      use_default_disable_mention_notifications: None,
      disable_mention_notifications: None,
      
    };
    ChatNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn use_default_mute_for(&self) -> &Option<bool> { &self.use_default_mute_for }
  
  pub fn mute_for(&self) -> &Option<i32> { &self.mute_for }
  
  pub fn use_default_sound(&self) -> &Option<bool> { &self.use_default_sound }
  
  pub fn sound(&self) -> &Option<String> { &self.sound }
  
  pub fn use_default_show_preview(&self) -> &Option<bool> { &self.use_default_show_preview }
  
  pub fn show_preview(&self) -> &Option<bool> { &self.show_preview }
  
  pub fn use_default_disable_pinned_message_notifications(&self) -> &Option<bool> { &self.use_default_disable_pinned_message_notifications }
  
  pub fn disable_pinned_message_notifications(&self) -> &Option<bool> { &self.disable_pinned_message_notifications }
  
  pub fn use_default_disable_mention_notifications(&self) -> &Option<bool> { &self.use_default_disable_mention_notifications }
  
  pub fn disable_mention_notifications(&self) -> &Option<bool> { &self.disable_mention_notifications }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatNotificationSettingsBuilder {
  instance: ChatNotificationSettings
}

impl ChatNotificationSettingsBuilder {
  fn new(instance: ChatNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ChatNotificationSettings {
    self.instance.clone()
  }
  
  pub fn use_default_mute_for(&mut self, use_default_mute_for: bool) -> &mut Self {
    self.instance.use_default_mute_for = Some(use_default_mute_for);
    self
  }
  
  pub fn mute_for(&mut self, mute_for: i32) -> &mut Self {
    self.instance.mute_for = Some(mute_for);
    self
  }
  
  pub fn use_default_sound(&mut self, use_default_sound: bool) -> &mut Self {
    self.instance.use_default_sound = Some(use_default_sound);
    self
  }
  
  pub fn sound(&mut self, sound: String) -> &mut Self {
    self.instance.sound = Some(sound);
    self
  }
  
  pub fn use_default_show_preview(&mut self, use_default_show_preview: bool) -> &mut Self {
    self.instance.use_default_show_preview = Some(use_default_show_preview);
    self
  }
  
  pub fn show_preview(&mut self, show_preview: bool) -> &mut Self {
    self.instance.show_preview = Some(show_preview);
    self
  }
  
  pub fn use_default_disable_pinned_message_notifications(&mut self, use_default_disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.use_default_disable_pinned_message_notifications = Some(use_default_disable_pinned_message_notifications);
    self
  }
  
  pub fn disable_pinned_message_notifications(&mut self, disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.disable_pinned_message_notifications = Some(disable_pinned_message_notifications);
    self
  }
  
  pub fn use_default_disable_mention_notifications(&mut self, use_default_disable_mention_notifications: bool) -> &mut Self {
    self.instance.use_default_disable_mention_notifications = Some(use_default_disable_mention_notifications);
    self
  }
  
  pub fn disable_mention_notifications(&mut self, disable_mention_notifications: bool) -> &mut Self {
    self.instance.disable_mention_notifications = Some(disable_mention_notifications);
    self
  }
  
}


/// Describes the photo of a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatPhoto

  /// A small (160x160) chat photo.
  small: Option<File>,
  /// A big (640x640) chat photo.
  big: Option<File>,


}




impl Object for ChatPhoto {}


impl ChatPhoto {
  
  pub fn builder() -> ChatPhotoBuilder {
    let instance = Self {
      tdfname: "chatPhoto".to_string(),
      small: None,
      big: None,
      
    };
    ChatPhotoBuilder::new(instance)
  }
  
  
  pub fn small(&self) -> &Option<File> { &self.small }
  
  pub fn big(&self) -> &Option<File> { &self.big }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatPhotoBuilder {
  instance: ChatPhoto
}

impl ChatPhotoBuilder {
  fn new(instance: ChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ChatPhoto {
    self.instance.clone()
  }
  
  pub fn small(&mut self, small: File) -> &mut Self {
    self.instance.small = Some(small);
    self
  }
  
  pub fn big(&mut self, big: File) -> &mut Self {
    self.instance.big = Some(big);
    self
  }
  
}


/// This class is an abstract base class. Describes the reason why a chat is reported. 
#[typetag::serde(tag = "@struct")]
pub trait ChatReportReason: Debug {}



impl Object for ChatReportReason {}





/// The chat contains spam messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonSpam

}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonSpam {}


impl ChatReportReasonSpam {
  
  pub fn builder() -> ChatReportReasonSpamBuilder {
    let instance = Self {
      tdfname: "chatReportReasonSpam".to_string(),
      
    };
    ChatReportReasonSpamBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonSpamBuilder {
  instance: ChatReportReasonSpam
}

impl ChatReportReasonSpamBuilder {
  fn new(instance: ChatReportReasonSpam) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonSpam {
    self.instance.clone()
  }
  
}


/// The chat promotes violence. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonViolence {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonViolence

}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonViolence {}


impl ChatReportReasonViolence {
  
  pub fn builder() -> ChatReportReasonViolenceBuilder {
    let instance = Self {
      tdfname: "chatReportReasonViolence".to_string(),
      
    };
    ChatReportReasonViolenceBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonViolenceBuilder {
  instance: ChatReportReasonViolence
}

impl ChatReportReasonViolenceBuilder {
  fn new(instance: ChatReportReasonViolence) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonViolence {
    self.instance.clone()
  }
  
}


/// The chat contains pornographic messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonPornography {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonPornography

}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonPornography {}


impl ChatReportReasonPornography {
  
  pub fn builder() -> ChatReportReasonPornographyBuilder {
    let instance = Self {
      tdfname: "chatReportReasonPornography".to_string(),
      
    };
    ChatReportReasonPornographyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonPornographyBuilder {
  instance: ChatReportReasonPornography
}

impl ChatReportReasonPornographyBuilder {
  fn new(instance: ChatReportReasonPornography) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonPornography {
    self.instance.clone()
  }
  
}


/// The chat has child abuse related content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonChildAbuse {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonChildAbuse

}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonChildAbuse {}


impl ChatReportReasonChildAbuse {
  
  pub fn builder() -> ChatReportReasonChildAbuseBuilder {
    let instance = Self {
      tdfname: "chatReportReasonChildAbuse".to_string(),
      
    };
    ChatReportReasonChildAbuseBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonChildAbuseBuilder {
  instance: ChatReportReasonChildAbuse
}

impl ChatReportReasonChildAbuseBuilder {
  fn new(instance: ChatReportReasonChildAbuse) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonChildAbuse {
    self.instance.clone()
  }
  
}


/// The chat contains copyrighted content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCopyright {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonCopyright

}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonCopyright {}


impl ChatReportReasonCopyright {
  
  pub fn builder() -> ChatReportReasonCopyrightBuilder {
    let instance = Self {
      tdfname: "chatReportReasonCopyright".to_string(),
      
    };
    ChatReportReasonCopyrightBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonCopyrightBuilder {
  instance: ChatReportReasonCopyright
}

impl ChatReportReasonCopyrightBuilder {
  fn new(instance: ChatReportReasonCopyright) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonCopyright {
    self.instance.clone()
  }
  
}


/// A custom reason provided by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportReasonCustom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportReasonCustom

  /// Report text.
  text: Option<String>,


}



#[typetag::serde]
impl ChatReportReason for ChatReportReasonCustom {}


impl ChatReportReasonCustom {
  
  pub fn builder() -> ChatReportReasonCustomBuilder {
    let instance = Self {
      tdfname: "chatReportReasonCustom".to_string(),
      text: None,
      
    };
    ChatReportReasonCustomBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportReasonCustomBuilder {
  instance: ChatReportReasonCustom
}

impl ChatReportReasonCustomBuilder {
  fn new(instance: ChatReportReasonCustom) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportReasonCustom {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// Contains information about the availability of the "Report spam" action for a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatReportSpamState

  /// True, if a prompt with the "Report spam" action should be shown to the user.
  can_report_spam: Option<bool>,


}




impl Object for ChatReportSpamState {}


impl ChatReportSpamState {
  
  pub fn builder() -> ChatReportSpamStateBuilder {
    let instance = Self {
      tdfname: "chatReportSpamState".to_string(),
      can_report_spam: None,
      
    };
    ChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn can_report_spam(&self) -> &Option<bool> { &self.can_report_spam }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatReportSpamStateBuilder {
  instance: ChatReportSpamState
}

impl ChatReportSpamStateBuilder {
  fn new(instance: ChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> ChatReportSpamState {
    self.instance.clone()
  }
  
  pub fn can_report_spam(&mut self, can_report_spam: bool) -> &mut Self {
    self.instance.can_report_spam = Some(can_report_spam);
    self
  }
  
}


/// This class is an abstract base class. Describes the type of a chat. 
#[typetag::serde(tag = "@struct")]
pub trait ChatType: Debug {}



impl Object for ChatType {}





/// An ordinary chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypePrivate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatTypePrivate

  /// User identifier.
  user_id: Option<i32>,


}



#[typetag::serde]
impl ChatType for ChatTypePrivate {}


impl ChatTypePrivate {
  
  pub fn builder() -> ChatTypePrivateBuilder {
    let instance = Self {
      tdfname: "chatTypePrivate".to_string(),
      user_id: None,
      
    };
    ChatTypePrivateBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatTypePrivateBuilder {
  instance: ChatTypePrivate
}

impl ChatTypePrivateBuilder {
  fn new(instance: ChatTypePrivate) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypePrivate {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// A basic group (i.e., a chat with 0-200 other users). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatTypeBasicGroup

  /// Basic group identifier.
  basic_group_id: Option<i32>,


}



#[typetag::serde]
impl ChatType for ChatTypeBasicGroup {}


impl ChatTypeBasicGroup {
  
  pub fn builder() -> ChatTypeBasicGroupBuilder {
    let instance = Self {
      tdfname: "chatTypeBasicGroup".to_string(),
      basic_group_id: None,
      
    };
    ChatTypeBasicGroupBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatTypeBasicGroupBuilder {
  instance: ChatTypeBasicGroup
}

impl ChatTypeBasicGroupBuilder {
  fn new(instance: ChatTypeBasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeBasicGroup {
    self.instance.clone()
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}


/// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatTypeSupergroup

  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,


}



#[typetag::serde]
impl ChatType for ChatTypeSupergroup {}


impl ChatTypeSupergroup {
  
  pub fn builder() -> ChatTypeSupergroupBuilder {
    let instance = Self {
      tdfname: "chatTypeSupergroup".to_string(),
      supergroup_id: None,
      is_channel: None,
      
    };
    ChatTypeSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn is_channel(&self) -> &Option<bool> { &self.is_channel }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatTypeSupergroupBuilder {
  instance: ChatTypeSupergroup
}

impl ChatTypeSupergroupBuilder {
  fn new(instance: ChatTypeSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeSupergroup {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
}


/// A secret chat with a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChatTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chatTypeSecret

  /// Secret chat identifier.
  secret_chat_id: Option<i32>,
  /// User identifier of the secret chat peer.
  user_id: Option<i32>,


}



#[typetag::serde]
impl ChatType for ChatTypeSecret {}


impl ChatTypeSecret {
  
  pub fn builder() -> ChatTypeSecretBuilder {
    let instance = Self {
      tdfname: "chatTypeSecret".to_string(),
      secret_chat_id: None,
      user_id: None,
      
    };
    ChatTypeSecretBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> &Option<i32> { &self.secret_chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatTypeSecretBuilder {
  instance: ChatTypeSecret
}

impl ChatTypeSecretBuilder {
  fn new(instance: ChatTypeSecret) -> Self { Self { instance } }

  pub fn build(&self) -> ChatTypeSecret {
    self.instance.clone()
  }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Represents a list of chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Chats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // chats

  /// List of chat identifiers.
  chat_ids: Option<Vec<i64>>,


}




impl Object for Chats {}


impl Chats {
  
  pub fn builder() -> ChatsBuilder {
    let instance = Self {
      tdfname: "chats".to_string(),
      chat_ids: None,
      
    };
    ChatsBuilder::new(instance)
  }
  
  
  pub fn chat_ids(&self) -> &Option<Vec<i64>> { &self.chat_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChatsBuilder {
  instance: Chats
}

impl ChatsBuilder {
  fn new(instance: Chats) -> Self { Self { instance } }

  pub fn build(&self) -> Chats {
    self.instance.clone()
  }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
}


/// This class is an abstract base class. Represents result of checking whether a username can be set for a chat. 
#[typetag::serde(tag = "@struct")]
pub trait CheckChatUsernameResult: Debug {}



impl Object for CheckChatUsernameResult {}





/// The username can be set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultOk {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsernameResultOk

}



#[typetag::serde]
impl CheckChatUsernameResult for CheckChatUsernameResultOk {}


impl CheckChatUsernameResultOk {
  
  pub fn builder() -> CheckChatUsernameResultOkBuilder {
    let instance = Self {
      tdfname: "checkChatUsernameResultOk".to_string(),
      
    };
    CheckChatUsernameResultOkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameResultOkBuilder {
  instance: CheckChatUsernameResultOk
}

impl CheckChatUsernameResultOkBuilder {
  fn new(instance: CheckChatUsernameResultOk) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultOk {
    self.instance.clone()
  }
  
}


/// The username is invalid. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameInvalid {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsernameResultUsernameInvalid

}



#[typetag::serde]
impl CheckChatUsernameResult for CheckChatUsernameResultUsernameInvalid {}


impl CheckChatUsernameResultUsernameInvalid {
  
  pub fn builder() -> CheckChatUsernameResultUsernameInvalidBuilder {
    let instance = Self {
      tdfname: "checkChatUsernameResultUsernameInvalid".to_string(),
      
    };
    CheckChatUsernameResultUsernameInvalidBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameResultUsernameInvalidBuilder {
  instance: CheckChatUsernameResultUsernameInvalid
}

impl CheckChatUsernameResultUsernameInvalidBuilder {
  fn new(instance: CheckChatUsernameResultUsernameInvalid) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultUsernameInvalid {
    self.instance.clone()
  }
  
}


/// The username is occupied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultUsernameOccupied {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsernameResultUsernameOccupied

}



#[typetag::serde]
impl CheckChatUsernameResult for CheckChatUsernameResultUsernameOccupied {}


impl CheckChatUsernameResultUsernameOccupied {
  
  pub fn builder() -> CheckChatUsernameResultUsernameOccupiedBuilder {
    let instance = Self {
      tdfname: "checkChatUsernameResultUsernameOccupied".to_string(),
      
    };
    CheckChatUsernameResultUsernameOccupiedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameResultUsernameOccupiedBuilder {
  instance: CheckChatUsernameResultUsernameOccupied
}

impl CheckChatUsernameResultUsernameOccupiedBuilder {
  fn new(instance: CheckChatUsernameResultUsernameOccupied) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultUsernameOccupied {
    self.instance.clone()
  }
  
}


/// The user has too much public chats, one of them should be made private first. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicChatsTooMuch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsernameResultPublicChatsTooMuch

}



#[typetag::serde]
impl CheckChatUsernameResult for CheckChatUsernameResultPublicChatsTooMuch {}


impl CheckChatUsernameResultPublicChatsTooMuch {
  
  pub fn builder() -> CheckChatUsernameResultPublicChatsTooMuchBuilder {
    let instance = Self {
      tdfname: "checkChatUsernameResultPublicChatsTooMuch".to_string(),
      
    };
    CheckChatUsernameResultPublicChatsTooMuchBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameResultPublicChatsTooMuchBuilder {
  instance: CheckChatUsernameResultPublicChatsTooMuch
}

impl CheckChatUsernameResultPublicChatsTooMuchBuilder {
  fn new(instance: CheckChatUsernameResultPublicChatsTooMuch) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultPublicChatsTooMuch {
    self.instance.clone()
  }
  
}


/// The user can't be a member of a public supergroup. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsernameResultPublicGroupsUnavailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsernameResultPublicGroupsUnavailable

}



#[typetag::serde]
impl CheckChatUsernameResult for CheckChatUsernameResultPublicGroupsUnavailable {}


impl CheckChatUsernameResultPublicGroupsUnavailable {
  
  pub fn builder() -> CheckChatUsernameResultPublicGroupsUnavailableBuilder {
    let instance = Self {
      tdfname: "checkChatUsernameResultPublicGroupsUnavailable".to_string(),
      
    };
    CheckChatUsernameResultPublicGroupsUnavailableBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameResultPublicGroupsUnavailableBuilder {
  instance: CheckChatUsernameResultPublicGroupsUnavailable
}

impl CheckChatUsernameResultPublicGroupsUnavailableBuilder {
  fn new(instance: CheckChatUsernameResultPublicGroupsUnavailable) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsernameResultPublicGroupsUnavailable {
    self.instance.clone()
  }
  
}


/// Contains information about one website the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectedWebsite

  /// Website identifier.
  id: Option<i64>,
  /// The domain name of the website.
  domain_name: Option<String>,
  /// User identifier of a bot linked with the website.
  bot_user_id: Option<i32>,
  /// The version of a browser used to log in.
  browser: Option<String>,
  /// Operating system the browser is running on.
  platform: Option<String>,
  /// Point in time (Unix timestamp) when the user was logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when obtained authorization was last used.
  last_active_date: Option<i32>,
  /// IP address from which the user was logged in, in human-readable format.
  ip: Option<String>,
  /// Human-readable description of a country and a region, from which the user was logged in, based on the IP address.
  location: Option<String>,


}




impl Object for ConnectedWebsite {}


impl ConnectedWebsite {
  
  pub fn builder() -> ConnectedWebsiteBuilder {
    let instance = Self {
      tdfname: "connectedWebsite".to_string(),
      id: None,
      domain_name: None,
      bot_user_id: None,
      browser: None,
      platform: None,
      log_in_date: None,
      last_active_date: None,
      ip: None,
      location: None,
      
    };
    ConnectedWebsiteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn domain_name(&self) -> &Option<String> { &self.domain_name }
  
  pub fn bot_user_id(&self) -> &Option<i32> { &self.bot_user_id }
  
  pub fn browser(&self) -> &Option<String> { &self.browser }
  
  pub fn platform(&self) -> &Option<String> { &self.platform }
  
  pub fn log_in_date(&self) -> &Option<i32> { &self.log_in_date }
  
  pub fn last_active_date(&self) -> &Option<i32> { &self.last_active_date }
  
  pub fn ip(&self) -> &Option<String> { &self.ip }
  
  pub fn location(&self) -> &Option<String> { &self.location }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectedWebsiteBuilder {
  instance: ConnectedWebsite
}

impl ConnectedWebsiteBuilder {
  fn new(instance: ConnectedWebsite) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectedWebsite {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn domain_name(&mut self, domain_name: String) -> &mut Self {
    self.instance.domain_name = Some(domain_name);
    self
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn browser(&mut self, browser: String) -> &mut Self {
    self.instance.browser = Some(browser);
    self
  }
  
  pub fn platform(&mut self, platform: String) -> &mut Self {
    self.instance.platform = Some(platform);
    self
  }
  
  pub fn log_in_date(&mut self, log_in_date: i32) -> &mut Self {
    self.instance.log_in_date = Some(log_in_date);
    self
  }
  
  pub fn last_active_date(&mut self, last_active_date: i32) -> &mut Self {
    self.instance.last_active_date = Some(last_active_date);
    self
  }
  
  pub fn ip(&mut self, ip: String) -> &mut Self {
    self.instance.ip = Some(ip);
    self
  }
  
  pub fn location(&mut self, location: String) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
}


/// Contains a list of websites the current user is logged in with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectedWebsites

  /// List of connected websites.
  websites: Option<Vec<ConnectedWebsite>>,


}




impl Object for ConnectedWebsites {}


impl ConnectedWebsites {
  
  pub fn builder() -> ConnectedWebsitesBuilder {
    let instance = Self {
      tdfname: "connectedWebsites".to_string(),
      websites: None,
      
    };
    ConnectedWebsitesBuilder::new(instance)
  }
  
  
  pub fn websites(&self) -> &Option<Vec<ConnectedWebsite>> { &self.websites }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectedWebsitesBuilder {
  instance: ConnectedWebsites
}

impl ConnectedWebsitesBuilder {
  fn new(instance: ConnectedWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectedWebsites {
    self.instance.clone()
  }
  
  pub fn websites(&mut self, websites: Vec<ConnectedWebsite>) -> &mut Self {
    self.instance.websites = Some(websites);
    self
  }
  
}


/// This class is an abstract base class. Describes the current state of the connection to Telegram servers. 
#[typetag::serde(tag = "@struct")]
pub trait ConnectionState: Debug {}



impl Object for ConnectionState {}





/// Currently waiting for the network to become available. Use SetNetworkType to change the available network type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateWaitingForNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectionStateWaitingForNetwork

}



#[typetag::serde]
impl ConnectionState for ConnectionStateWaitingForNetwork {}


impl ConnectionStateWaitingForNetwork {
  
  pub fn builder() -> ConnectionStateWaitingForNetworkBuilder {
    let instance = Self {
      tdfname: "connectionStateWaitingForNetwork".to_string(),
      
    };
    ConnectionStateWaitingForNetworkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectionStateWaitingForNetworkBuilder {
  instance: ConnectionStateWaitingForNetwork
}

impl ConnectionStateWaitingForNetworkBuilder {
  fn new(instance: ConnectionStateWaitingForNetwork) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateWaitingForNetwork {
    self.instance.clone()
  }
  
}


/// Currently establishing a connection with a proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnectingToProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectionStateConnectingToProxy

}



#[typetag::serde]
impl ConnectionState for ConnectionStateConnectingToProxy {}


impl ConnectionStateConnectingToProxy {
  
  pub fn builder() -> ConnectionStateConnectingToProxyBuilder {
    let instance = Self {
      tdfname: "connectionStateConnectingToProxy".to_string(),
      
    };
    ConnectionStateConnectingToProxyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectionStateConnectingToProxyBuilder {
  instance: ConnectionStateConnectingToProxy
}

impl ConnectionStateConnectingToProxyBuilder {
  fn new(instance: ConnectionStateConnectingToProxy) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateConnectingToProxy {
    self.instance.clone()
  }
  
}


/// Currently establishing a connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateConnecting {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectionStateConnecting

}



#[typetag::serde]
impl ConnectionState for ConnectionStateConnecting {}


impl ConnectionStateConnecting {
  
  pub fn builder() -> ConnectionStateConnectingBuilder {
    let instance = Self {
      tdfname: "connectionStateConnecting".to_string(),
      
    };
    ConnectionStateConnectingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectionStateConnectingBuilder {
  instance: ConnectionStateConnecting
}

impl ConnectionStateConnectingBuilder {
  fn new(instance: ConnectionStateConnecting) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateConnecting {
    self.instance.clone()
  }
  
}


/// Downloading data received while the client was offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateUpdating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectionStateUpdating

}



#[typetag::serde]
impl ConnectionState for ConnectionStateUpdating {}


impl ConnectionStateUpdating {
  
  pub fn builder() -> ConnectionStateUpdatingBuilder {
    let instance = Self {
      tdfname: "connectionStateUpdating".to_string(),
      
    };
    ConnectionStateUpdatingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectionStateUpdatingBuilder {
  instance: ConnectionStateUpdating
}

impl ConnectionStateUpdatingBuilder {
  fn new(instance: ConnectionStateUpdating) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateUpdating {
    self.instance.clone()
  }
  
}


/// There is a working connection to the Telegram servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // connectionStateReady

}



#[typetag::serde]
impl ConnectionState for ConnectionStateReady {}


impl ConnectionStateReady {
  
  pub fn builder() -> ConnectionStateReadyBuilder {
    let instance = Self {
      tdfname: "connectionStateReady".to_string(),
      
    };
    ConnectionStateReadyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ConnectionStateReadyBuilder {
  instance: ConnectionStateReady
}

impl ConnectionStateReadyBuilder {
  fn new(instance: ConnectionStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> ConnectionStateReady {
    self.instance.clone()
  }
  
}


/// Describes a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Contact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // contact

  /// Phone number of the user.
  phone_number: Option<String>,
  /// First name of the user; 1-255 characters in length.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Additional data about the user in a form of vCard; 0-2048 bytes in length.
  vcard: Option<String>,
  /// Identifier of the user, if known; otherwise 0.
  user_id: Option<i32>,


}




impl Object for Contact {}


impl Contact {
  
  pub fn builder() -> ContactBuilder {
    let instance = Self {
      tdfname: "contact".to_string(),
      phone_number: None,
      first_name: None,
      last_name: None,
      vcard: None,
      user_id: None,
      
    };
    ContactBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn first_name(&self) -> &Option<String> { &self.first_name }
  
  pub fn last_name(&self) -> &Option<String> { &self.last_name }
  
  pub fn vcard(&self) -> &Option<String> { &self.vcard }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ContactBuilder {
  instance: Contact
}

impl ContactBuilder {
  fn new(instance: Contact) -> Self { Self { instance } }

  pub fn build(&self) -> Contact {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn first_name(&mut self, first_name: String) -> &mut Self {
    self.instance.first_name = Some(first_name);
    self
  }
  
  pub fn last_name(&mut self, last_name: String) -> &mut Self {
    self.instance.last_name = Some(last_name);
    self
  }
  
  pub fn vcard(&mut self, vcard: String) -> &mut Self {
    self.instance.vcard = Some(vcard);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Contains a counter. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Count {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // count

  /// Count.
  count: Option<i32>,


}




impl Object for Count {}


impl Count {
  
  pub fn builder() -> CountBuilder {
    let instance = Self {
      tdfname: "count".to_string(),
      count: None,
      
    };
    CountBuilder::new(instance)
  }
  
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CountBuilder {
  instance: Count
}

impl CountBuilder {
  fn new(instance: Count) -> Self { Self { instance } }

  pub fn build(&self) -> Count {
    self.instance.clone()
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}


/// Contains the result of a custom request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CustomRequestResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // customRequestResult

  /// A JSON-serialized result.
  result: Option<String>,


}




impl Object for CustomRequestResult {}


impl CustomRequestResult {
  
  pub fn builder() -> CustomRequestResultBuilder {
    let instance = Self {
      tdfname: "customRequestResult".to_string(),
      result: None,
      
    };
    CustomRequestResultBuilder::new(instance)
  }
  
  
  pub fn result(&self) -> &Option<String> { &self.result }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CustomRequestResultBuilder {
  instance: CustomRequestResult
}

impl CustomRequestResultBuilder {
  fn new(instance: CustomRequestResult) -> Self { Self { instance } }

  pub fn build(&self) -> CustomRequestResult {
    self.instance.clone()
  }
  
  pub fn result(&mut self, result: String) -> &mut Self {
    self.instance.result = Some(result);
    self
  }
  
}


/// Contains database statistics. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // databaseStatistics

  /// Database statistics in an unspecified human-readable format.
  statistics: Option<String>,


}




impl Object for DatabaseStatistics {}


impl DatabaseStatistics {
  
  pub fn builder() -> DatabaseStatisticsBuilder {
    let instance = Self {
      tdfname: "databaseStatistics".to_string(),
      statistics: None,
      
    };
    DatabaseStatisticsBuilder::new(instance)
  }
  
  
  pub fn statistics(&self) -> &Option<String> { &self.statistics }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DatabaseStatisticsBuilder {
  instance: DatabaseStatistics
}

impl DatabaseStatisticsBuilder {
  fn new(instance: DatabaseStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> DatabaseStatistics {
    self.instance.clone()
  }
  
  pub fn statistics(&mut self, statistics: String) -> &mut Self {
    self.instance.statistics = Some(statistics);
    self
  }
  
}


/// Represents a date according to the Gregorian calendar. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Date {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // date

  /// Day of the month, 1-31.
  day: Option<i32>,
  /// Month, 1-12.
  month: Option<i32>,
  /// Year, 1-9999.
  year: Option<i32>,


}




impl Object for Date {}


impl Date {
  
  pub fn builder() -> DateBuilder {
    let instance = Self {
      tdfname: "date".to_string(),
      day: None,
      month: None,
      year: None,
      
    };
    DateBuilder::new(instance)
  }
  
  
  pub fn day(&self) -> &Option<i32> { &self.day }
  
  pub fn month(&self) -> &Option<i32> { &self.month }
  
  pub fn year(&self) -> &Option<i32> { &self.year }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DateBuilder {
  instance: Date
}

impl DateBuilder {
  fn new(instance: Date) -> Self { Self { instance } }

  pub fn build(&self) -> Date {
    self.instance.clone()
  }
  
  pub fn day(&mut self, day: i32) -> &mut Self {
    self.instance.day = Some(day);
    self
  }
  
  pub fn month(&mut self, month: i32) -> &mut Self {
    self.instance.month = Some(month);
    self
  }
  
  pub fn year(&mut self, year: i32) -> &mut Self {
    self.instance.year = Some(year);
    self
  }
  
}


/// File with the date it was uploaded. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatedFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // datedFile

  /// The file.
  file: Option<File>,
  /// Point in time (Unix timestamp) when the file was uploaded.
  date: Option<i32>,


}




impl Object for DatedFile {}


impl DatedFile {
  
  pub fn builder() -> DatedFileBuilder {
    let instance = Self {
      tdfname: "datedFile".to_string(),
      file: None,
      date: None,
      
    };
    DatedFileBuilder::new(instance)
  }
  
  
  pub fn file(&self) -> &Option<File> { &self.file }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DatedFileBuilder {
  instance: DatedFile
}

impl DatedFileBuilder {
  fn new(instance: DatedFile) -> Self { Self { instance } }

  pub fn build(&self) -> DatedFile {
    self.instance.clone()
  }
  
  pub fn file(&mut self, file: File) -> &mut Self {
    self.instance.file = Some(file);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
}


/// Contains information about a tg:// deep link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deepLinkInfo

  /// Text to be shown to the user.
  text: Option<FormattedText>,
  /// True, if user should be asked to update the application.
  need_update_application: Option<bool>,


}




impl Object for DeepLinkInfo {}


impl DeepLinkInfo {
  
  pub fn builder() -> DeepLinkInfoBuilder {
    let instance = Self {
      tdfname: "deepLinkInfo".to_string(),
      text: None,
      need_update_application: None,
      
    };
    DeepLinkInfoBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  pub fn need_update_application(&self) -> &Option<bool> { &self.need_update_application }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeepLinkInfoBuilder {
  instance: DeepLinkInfo
}

impl DeepLinkInfoBuilder {
  fn new(instance: DeepLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> DeepLinkInfo {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn need_update_application(&mut self, need_update_application: bool) -> &mut Self {
    self.instance.need_update_application = Some(need_update_application);
    self
  }
  
}


/// This class is an abstract base class. Represents a data needed to subscribe for push notifications through 
#[typetag::serde(tag = "@struct")]
pub trait DeviceToken: Debug {}



impl Object for DeviceToken {}





/// A token for Firebase Cloud Messaging. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenFirebaseCloudMessaging {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenFirebaseCloudMessaging

  /// Device registration token; may be empty to de-register a device.
  token: Option<String>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenFirebaseCloudMessaging {}


impl DeviceTokenFirebaseCloudMessaging {
  
  pub fn builder() -> DeviceTokenFirebaseCloudMessagingBuilder {
    let instance = Self {
      tdfname: "deviceTokenFirebaseCloudMessaging".to_string(),
      token: None,
      encrypt: None,
      
    };
    DeviceTokenFirebaseCloudMessagingBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> &Option<String> { &self.token }
  
  pub fn encrypt(&self) -> &Option<bool> { &self.encrypt }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenFirebaseCloudMessagingBuilder {
  instance: DeviceTokenFirebaseCloudMessaging
}

impl DeviceTokenFirebaseCloudMessagingBuilder {
  fn new(instance: DeviceTokenFirebaseCloudMessaging) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenFirebaseCloudMessaging {
    self.instance.clone()
  }
  
  pub fn token(&mut self, token: String) -> &mut Self {
    self.instance.token = Some(token);
    self
  }
  
  pub fn encrypt(&mut self, encrypt: bool) -> &mut Self {
    self.instance.encrypt = Some(encrypt);
    self
  }
  
}


/// A token for Apple Push Notification service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenApplePush

  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenApplePush {}


impl DeviceTokenApplePush {
  
  pub fn builder() -> DeviceTokenApplePushBuilder {
    let instance = Self {
      tdfname: "deviceTokenApplePush".to_string(),
      device_token: None,
      is_app_sandbox: None,
      
    };
    DeviceTokenApplePushBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> &Option<String> { &self.device_token }
  
  pub fn is_app_sandbox(&self) -> &Option<bool> { &self.is_app_sandbox }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenApplePushBuilder {
  instance: DeviceTokenApplePush
}

impl DeviceTokenApplePushBuilder {
  fn new(instance: DeviceTokenApplePush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenApplePush {
    self.instance.clone()
  }
  
  pub fn device_token(&mut self, device_token: String) -> &mut Self {
    self.instance.device_token = Some(device_token);
    self
  }
  
  pub fn is_app_sandbox(&mut self, is_app_sandbox: bool) -> &mut Self {
    self.instance.is_app_sandbox = Some(is_app_sandbox);
    self
  }
  
}


/// A token for Apple Push Notification service VoIP notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenApplePushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenApplePushVoIP

  /// Device token; may be empty to de-register a device.
  device_token: Option<String>,
  /// True, if App Sandbox is enabled.
  is_app_sandbox: Option<bool>,
  /// True, if push notifications should be additionally encrypted.
  encrypt: Option<bool>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenApplePushVoIP {}


impl DeviceTokenApplePushVoIP {
  
  pub fn builder() -> DeviceTokenApplePushVoIPBuilder {
    let instance = Self {
      tdfname: "deviceTokenApplePushVoIP".to_string(),
      device_token: None,
      is_app_sandbox: None,
      encrypt: None,
      
    };
    DeviceTokenApplePushVoIPBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> &Option<String> { &self.device_token }
  
  pub fn is_app_sandbox(&self) -> &Option<bool> { &self.is_app_sandbox }
  
  pub fn encrypt(&self) -> &Option<bool> { &self.encrypt }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenApplePushVoIPBuilder {
  instance: DeviceTokenApplePushVoIP
}

impl DeviceTokenApplePushVoIPBuilder {
  fn new(instance: DeviceTokenApplePushVoIP) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenApplePushVoIP {
    self.instance.clone()
  }
  
  pub fn device_token(&mut self, device_token: String) -> &mut Self {
    self.instance.device_token = Some(device_token);
    self
  }
  
  pub fn is_app_sandbox(&mut self, is_app_sandbox: bool) -> &mut Self {
    self.instance.is_app_sandbox = Some(is_app_sandbox);
    self
  }
  
  pub fn encrypt(&mut self, encrypt: bool) -> &mut Self {
    self.instance.encrypt = Some(encrypt);
    self
  }
  
}


/// A token for Windows Push Notification Services. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWindowsPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenWindowsPush

  /// The access token that will be used to send notifications; may be empty to de-register a device.
  access_token: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenWindowsPush {}


impl DeviceTokenWindowsPush {
  
  pub fn builder() -> DeviceTokenWindowsPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenWindowsPush".to_string(),
      access_token: None,
      
    };
    DeviceTokenWindowsPushBuilder::new(instance)
  }
  
  
  pub fn access_token(&self) -> &Option<String> { &self.access_token }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenWindowsPushBuilder {
  instance: DeviceTokenWindowsPush
}

impl DeviceTokenWindowsPushBuilder {
  fn new(instance: DeviceTokenWindowsPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenWindowsPush {
    self.instance.clone()
  }
  
  pub fn access_token(&mut self, access_token: String) -> &mut Self {
    self.instance.access_token = Some(access_token);
    self
  }
  
}


/// A token for Microsoft Push Notification Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenMicrosoftPush

  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenMicrosoftPush {}


impl DeviceTokenMicrosoftPush {
  
  pub fn builder() -> DeviceTokenMicrosoftPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenMicrosoftPush".to_string(),
      channel_uri: None,
      
    };
    DeviceTokenMicrosoftPushBuilder::new(instance)
  }
  
  
  pub fn channel_uri(&self) -> &Option<String> { &self.channel_uri }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenMicrosoftPushBuilder {
  instance: DeviceTokenMicrosoftPush
}

impl DeviceTokenMicrosoftPushBuilder {
  fn new(instance: DeviceTokenMicrosoftPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenMicrosoftPush {
    self.instance.clone()
  }
  
  pub fn channel_uri(&mut self, channel_uri: String) -> &mut Self {
    self.instance.channel_uri = Some(channel_uri);
    self
  }
  
}


/// A token for Microsoft Push Notification Service VoIP channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenMicrosoftPushVoIP {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenMicrosoftPushVoIP

  /// Push notification channel URI; may be empty to de-register a device.
  channel_uri: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenMicrosoftPushVoIP {}


impl DeviceTokenMicrosoftPushVoIP {
  
  pub fn builder() -> DeviceTokenMicrosoftPushVoIPBuilder {
    let instance = Self {
      tdfname: "deviceTokenMicrosoftPushVoIP".to_string(),
      channel_uri: None,
      
    };
    DeviceTokenMicrosoftPushVoIPBuilder::new(instance)
  }
  
  
  pub fn channel_uri(&self) -> &Option<String> { &self.channel_uri }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenMicrosoftPushVoIPBuilder {
  instance: DeviceTokenMicrosoftPushVoIP
}

impl DeviceTokenMicrosoftPushVoIPBuilder {
  fn new(instance: DeviceTokenMicrosoftPushVoIP) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenMicrosoftPushVoIP {
    self.instance.clone()
  }
  
  pub fn channel_uri(&mut self, channel_uri: String) -> &mut Self {
    self.instance.channel_uri = Some(channel_uri);
    self
  }
  
}


/// A token for web Push API. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenWebPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenWebPush

  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,
  /// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key.
  p256dh_base64url: Option<String>,
  /// Base64url-encoded authentication secret.
  auth_base64url: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenWebPush {}


impl DeviceTokenWebPush {
  
  pub fn builder() -> DeviceTokenWebPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenWebPush".to_string(),
      endpoint: None,
      p256dh_base64url: None,
      auth_base64url: None,
      
    };
    DeviceTokenWebPushBuilder::new(instance)
  }
  
  
  pub fn endpoint(&self) -> &Option<String> { &self.endpoint }
  
  pub fn p256dh_base64url(&self) -> &Option<String> { &self.p256dh_base64url }
  
  pub fn auth_base64url(&self) -> &Option<String> { &self.auth_base64url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenWebPushBuilder {
  instance: DeviceTokenWebPush
}

impl DeviceTokenWebPushBuilder {
  fn new(instance: DeviceTokenWebPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenWebPush {
    self.instance.clone()
  }
  
  pub fn endpoint(&mut self, endpoint: String) -> &mut Self {
    self.instance.endpoint = Some(endpoint);
    self
  }
  
  pub fn p256dh_base64url(&mut self, p256dh_base64url: String) -> &mut Self {
    self.instance.p256dh_base64url = Some(p256dh_base64url);
    self
  }
  
  pub fn auth_base64url(&mut self, auth_base64url: String) -> &mut Self {
    self.instance.auth_base64url = Some(auth_base64url);
    self
  }
  
}


/// A token for Simple Push API for Firefox OS. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenSimplePush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenSimplePush

  /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device.
  endpoint: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenSimplePush {}


impl DeviceTokenSimplePush {
  
  pub fn builder() -> DeviceTokenSimplePushBuilder {
    let instance = Self {
      tdfname: "deviceTokenSimplePush".to_string(),
      endpoint: None,
      
    };
    DeviceTokenSimplePushBuilder::new(instance)
  }
  
  
  pub fn endpoint(&self) -> &Option<String> { &self.endpoint }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenSimplePushBuilder {
  instance: DeviceTokenSimplePush
}

impl DeviceTokenSimplePushBuilder {
  fn new(instance: DeviceTokenSimplePush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenSimplePush {
    self.instance.clone()
  }
  
  pub fn endpoint(&mut self, endpoint: String) -> &mut Self {
    self.instance.endpoint = Some(endpoint);
    self
  }
  
}


/// A token for Ubuntu Push 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenUbuntuPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenUbuntuPush

  /// Token; may be empty to de-register a device.
  token: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenUbuntuPush {}


impl DeviceTokenUbuntuPush {
  
  pub fn builder() -> DeviceTokenUbuntuPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenUbuntuPush".to_string(),
      token: None,
      
    };
    DeviceTokenUbuntuPushBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> &Option<String> { &self.token }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenUbuntuPushBuilder {
  instance: DeviceTokenUbuntuPush
}

impl DeviceTokenUbuntuPushBuilder {
  fn new(instance: DeviceTokenUbuntuPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenUbuntuPush {
    self.instance.clone()
  }
  
  pub fn token(&mut self, token: String) -> &mut Self {
    self.instance.token = Some(token);
    self
  }
  
}


/// A token for BlackBerry Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenBlackBerryPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenBlackBerryPush

  /// Token; may be empty to de-register a device.
  token: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenBlackBerryPush {}


impl DeviceTokenBlackBerryPush {
  
  pub fn builder() -> DeviceTokenBlackBerryPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenBlackBerryPush".to_string(),
      token: None,
      
    };
    DeviceTokenBlackBerryPushBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> &Option<String> { &self.token }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenBlackBerryPushBuilder {
  instance: DeviceTokenBlackBerryPush
}

impl DeviceTokenBlackBerryPushBuilder {
  fn new(instance: DeviceTokenBlackBerryPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenBlackBerryPush {
    self.instance.clone()
  }
  
  pub fn token(&mut self, token: String) -> &mut Self {
    self.instance.token = Some(token);
    self
  }
  
}


/// A token for Tizen Push Service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTokenTizenPush {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deviceTokenTizenPush

  /// Push service registration identifier; may be empty to de-register a device.
  reg_id: Option<String>,


}



#[typetag::serde]
impl DeviceToken for DeviceTokenTizenPush {}


impl DeviceTokenTizenPush {
  
  pub fn builder() -> DeviceTokenTizenPushBuilder {
    let instance = Self {
      tdfname: "deviceTokenTizenPush".to_string(),
      reg_id: None,
      
    };
    DeviceTokenTizenPushBuilder::new(instance)
  }
  
  
  pub fn reg_id(&self) -> &Option<String> { &self.reg_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeviceTokenTizenPushBuilder {
  instance: DeviceTokenTizenPush
}

impl DeviceTokenTizenPushBuilder {
  fn new(instance: DeviceTokenTizenPush) -> Self { Self { instance } }

  pub fn build(&self) -> DeviceTokenTizenPush {
    self.instance.clone()
  }
  
  pub fn reg_id(&mut self, reg_id: String) -> &mut Self {
    self.instance.reg_id = Some(reg_id);
    self
  }
  
}


/// Describes a document of any type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Document {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // document

  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// Document thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the document.
  document: Option<File>,


}




impl Object for Document {}


impl Document {
  
  pub fn builder() -> DocumentBuilder {
    let instance = Self {
      tdfname: "document".to_string(),
      file_name: None,
      mime_type: None,
      thumbnail: None,
      document: None,
      
    };
    DocumentBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  pub fn document(&self) -> &Option<File> { &self.document }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DocumentBuilder {
  instance: Document
}

impl DocumentBuilder {
  fn new(instance: Document) -> Self { Self { instance } }

  pub fn build(&self) -> Document {
    self.instance.clone()
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn document(&mut self, document: File) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
}


/// Contains information about a message draft. 
#[derive(Debug, Serialize, Deserialize)]
pub struct DraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // draftMessage

  /// Identifier of the message to reply to; 0 if none.
  reply_to_message_id: Option<i64>,
  /// Content of the message draft; this should always be of type inputMessageText.
  input_message_text: Option<Box<InputMessageContent>>,


}


impl Clone for DraftMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for DraftMessage {}


impl DraftMessage {
  
  pub fn builder() -> DraftMessageBuilder {
    let instance = Self {
      tdfname: "draftMessage".to_string(),
      reply_to_message_id: None,
      input_message_text: None,
      
    };
    DraftMessageBuilder::new(instance)
  }
  
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn input_message_text(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DraftMessageBuilder {
  instance: DraftMessage
}

impl DraftMessageBuilder {
  fn new(instance: DraftMessage) -> Self { Self { instance } }

  pub fn build(&self) -> DraftMessage {
    self.instance.clone()
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn input_message_text(&mut self, input_message_text: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_text = Some(input_message_text);
    self
  }
  
}


/// Information about the email address authentication code that was sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmailAddressAuthenticationCodeInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // emailAddressAuthenticationCodeInfo

  /// Pattern of the email address to which an authentication code was sent.
  email_address_pattern: Option<String>,
  /// Length of the code; 0 if unknown.
  length: Option<i32>,


}




impl Object for EmailAddressAuthenticationCodeInfo {}


impl EmailAddressAuthenticationCodeInfo {
  
  pub fn builder() -> EmailAddressAuthenticationCodeInfoBuilder {
    let instance = Self {
      tdfname: "emailAddressAuthenticationCodeInfo".to_string(),
      email_address_pattern: None,
      length: None,
      
    };
    EmailAddressAuthenticationCodeInfoBuilder::new(instance)
  }
  
  
  pub fn email_address_pattern(&self) -> &Option<String> { &self.email_address_pattern }
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EmailAddressAuthenticationCodeInfoBuilder {
  instance: EmailAddressAuthenticationCodeInfo
}

impl EmailAddressAuthenticationCodeInfoBuilder {
  fn new(instance: EmailAddressAuthenticationCodeInfo) -> Self { Self { instance } }

  pub fn build(&self) -> EmailAddressAuthenticationCodeInfo {
    self.instance.clone()
  }
  
  pub fn email_address_pattern(&mut self, email_address_pattern: String) -> &mut Self {
    self.instance.email_address_pattern = Some(email_address_pattern);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}


/// Contains encrypted Telegram Passport data credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncryptedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // encryptedCredentials

  /// The encrypted credentials.
  data: Option<String>,
  /// The decrypted data hash.
  hash: Option<String>,
  /// Secret for data decryption, encrypted with the service's public key.
  secret: Option<String>,


}




impl Object for EncryptedCredentials {}


impl EncryptedCredentials {
  
  pub fn builder() -> EncryptedCredentialsBuilder {
    let instance = Self {
      tdfname: "encryptedCredentials".to_string(),
      data: None,
      hash: None,
      secret: None,
      
    };
    EncryptedCredentialsBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  pub fn hash(&self) -> &Option<String> { &self.hash }
  
  pub fn secret(&self) -> &Option<String> { &self.secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EncryptedCredentialsBuilder {
  instance: EncryptedCredentials
}

impl EncryptedCredentialsBuilder {
  fn new(instance: EncryptedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> EncryptedCredentials {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
  pub fn hash(&mut self, hash: String) -> &mut Self {
    self.instance.hash = Some(hash);
    self
  }
  
  pub fn secret(&mut self, secret: String) -> &mut Self {
    self.instance.secret = Some(secret);
    self
  }
  
}


/// Contains information about an encrypted Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct EncryptedPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // encryptedPassportElement

  /// Type of Telegram Passport element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Encrypted JSON-encoded data about the user.
  data: Option<String>,
  /// The front side of an identity document.
  front_side: Option<DatedFile>,
  /// The reverse side of an identity document; may be null.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,
  /// List of attached files.
  files: Option<Vec<DatedFile>>,
  /// Unencrypted data, phone number or email address.
  value: Option<String>,
  /// Hash of the entire element.
  hash: Option<String>,


}


impl Clone for EncryptedPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for EncryptedPassportElement {}


impl EncryptedPassportElement {
  
  pub fn builder() -> EncryptedPassportElementBuilder {
    let instance = Self {
      tdfname: "encryptedPassportElement".to_string(),
      type_: None,
      data: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      files: None,
      value: None,
      hash: None,
      
    };
    EncryptedPassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  pub fn front_side(&self) -> &Option<DatedFile> { &self.front_side }
  
  pub fn reverse_side(&self) -> &Option<DatedFile> { &self.reverse_side }
  
  pub fn selfie(&self) -> &Option<DatedFile> { &self.selfie }
  
  pub fn translation(&self) -> &Option<Vec<DatedFile>> { &self.translation }
  
  pub fn files(&self) -> &Option<Vec<DatedFile>> { &self.files }
  
  pub fn value(&self) -> &Option<String> { &self.value }
  
  pub fn hash(&self) -> &Option<String> { &self.hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EncryptedPassportElementBuilder {
  instance: EncryptedPassportElement
}

impl EncryptedPassportElementBuilder {
  fn new(instance: EncryptedPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> EncryptedPassportElement {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
  pub fn front_side(&mut self, front_side: DatedFile) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: DatedFile) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: DatedFile) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
  pub fn files(&mut self, files: Vec<DatedFile>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn value(&mut self, value: String) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
  pub fn hash(&mut self, hash: String) -> &mut Self {
    self.instance.hash = Some(hash);
    self
  }
  
}


/// An object of this type can be returned on every function call, in case of an error. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Error {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // error

  /// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user.
  code: Option<i32>,
  /// Error message; subject to future changes.
  message: Option<String>,


}




impl Object for Error {}


impl Error {
  
  pub fn builder() -> ErrorBuilder {
    let instance = Self {
      tdfname: "error".to_string(),
      code: None,
      message: None,
      
    };
    ErrorBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<i32> { &self.code }
  
  pub fn message(&self) -> &Option<String> { &self.message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ErrorBuilder {
  instance: Error
}

impl ErrorBuilder {
  fn new(instance: Error) -> Self { Self { instance } }

  pub fn build(&self) -> Error {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: i32) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
  pub fn message(&mut self, message: String) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}


/// Represents a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct File {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // file

  /// Unique file identifier.
  id: Option<i32>,
  /// File size; 0 if unknown.
  size: Option<i32>,
  /// Expected file size in case the exact file size is unknown, but an approximate size is known. Can be used to show download/upload progress.
  expected_size: Option<i32>,
  /// Information about the local copy of the file.
  local: Option<LocalFile>,
  /// Information about the remote copy of the file.
  remote: Option<RemoteFile>,


}




impl Object for File {}


impl File {
  
  pub fn builder() -> FileBuilder {
    let instance = Self {
      tdfname: "file".to_string(),
      id: None,
      size: None,
      expected_size: None,
      local: None,
      remote: None,
      
    };
    FileBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn size(&self) -> &Option<i32> { &self.size }
  
  pub fn expected_size(&self) -> &Option<i32> { &self.expected_size }
  
  pub fn local(&self) -> &Option<LocalFile> { &self.local }
  
  pub fn remote(&self) -> &Option<RemoteFile> { &self.remote }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileBuilder {
  instance: File
}

impl FileBuilder {
  fn new(instance: File) -> Self { Self { instance } }

  pub fn build(&self) -> File {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn size(&mut self, size: i32) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
  pub fn local(&mut self, local: LocalFile) -> &mut Self {
    self.instance.local = Some(local);
    self
  }
  
  pub fn remote(&mut self, remote: RemoteFile) -> &mut Self {
    self.instance.remote = Some(remote);
    self
  }
  
}


/// Contains a part of a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // filePart

  /// File bytes.
  data: Option<String>,


}




impl Object for FilePart {}


impl FilePart {
  
  pub fn builder() -> FilePartBuilder {
    let instance = Self {
      tdfname: "filePart".to_string(),
      data: None,
      
    };
    FilePartBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FilePartBuilder {
  instance: FilePart
}

impl FilePartBuilder {
  fn new(instance: FilePart) -> Self { Self { instance } }

  pub fn build(&self) -> FilePart {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// This class is an abstract base class. Represents the type of a file. 
#[typetag::serde(tag = "@struct")]
pub trait FileType: Debug {}



impl Object for FileType {}





/// The data is not a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeNone

}



#[typetag::serde]
impl FileType for FileTypeNone {}


impl FileTypeNone {
  
  pub fn builder() -> FileTypeNoneBuilder {
    let instance = Self {
      tdfname: "fileTypeNone".to_string(),
      
    };
    FileTypeNoneBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeNoneBuilder {
  instance: FileTypeNone
}

impl FileTypeNoneBuilder {
  fn new(instance: FileTypeNone) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeNone {
    self.instance.clone()
  }
  
}


/// The file is an animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeAnimation

}



#[typetag::serde]
impl FileType for FileTypeAnimation {}


impl FileTypeAnimation {
  
  pub fn builder() -> FileTypeAnimationBuilder {
    let instance = Self {
      tdfname: "fileTypeAnimation".to_string(),
      
    };
    FileTypeAnimationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeAnimationBuilder {
  instance: FileTypeAnimation
}

impl FileTypeAnimationBuilder {
  fn new(instance: FileTypeAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeAnimation {
    self.instance.clone()
  }
  
}


/// The file is an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeAudio

}



#[typetag::serde]
impl FileType for FileTypeAudio {}


impl FileTypeAudio {
  
  pub fn builder() -> FileTypeAudioBuilder {
    let instance = Self {
      tdfname: "fileTypeAudio".to_string(),
      
    };
    FileTypeAudioBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeAudioBuilder {
  instance: FileTypeAudio
}

impl FileTypeAudioBuilder {
  fn new(instance: FileTypeAudio) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeAudio {
    self.instance.clone()
  }
  
}


/// The file is a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeDocument

}



#[typetag::serde]
impl FileType for FileTypeDocument {}


impl FileTypeDocument {
  
  pub fn builder() -> FileTypeDocumentBuilder {
    let instance = Self {
      tdfname: "fileTypeDocument".to_string(),
      
    };
    FileTypeDocumentBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeDocumentBuilder {
  instance: FileTypeDocument
}

impl FileTypeDocumentBuilder {
  fn new(instance: FileTypeDocument) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeDocument {
    self.instance.clone()
  }
  
}


/// The file is a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypePhoto

}



#[typetag::serde]
impl FileType for FileTypePhoto {}


impl FileTypePhoto {
  
  pub fn builder() -> FileTypePhotoBuilder {
    let instance = Self {
      tdfname: "fileTypePhoto".to_string(),
      
    };
    FileTypePhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypePhotoBuilder {
  instance: FileTypePhoto
}

impl FileTypePhotoBuilder {
  fn new(instance: FileTypePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypePhoto {
    self.instance.clone()
  }
  
}


/// The file is a profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeProfilePhoto

}



#[typetag::serde]
impl FileType for FileTypeProfilePhoto {}


impl FileTypeProfilePhoto {
  
  pub fn builder() -> FileTypeProfilePhotoBuilder {
    let instance = Self {
      tdfname: "fileTypeProfilePhoto".to_string(),
      
    };
    FileTypeProfilePhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeProfilePhotoBuilder {
  instance: FileTypeProfilePhoto
}

impl FileTypeProfilePhotoBuilder {
  fn new(instance: FileTypeProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeProfilePhoto {
    self.instance.clone()
  }
  
}


/// The file was sent to a secret chat (the file type is not known to the server). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecret {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeSecret

}



#[typetag::serde]
impl FileType for FileTypeSecret {}


impl FileTypeSecret {
  
  pub fn builder() -> FileTypeSecretBuilder {
    let instance = Self {
      tdfname: "fileTypeSecret".to_string(),
      
    };
    FileTypeSecretBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeSecretBuilder {
  instance: FileTypeSecret
}

impl FileTypeSecretBuilder {
  fn new(instance: FileTypeSecret) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecret {
    self.instance.clone()
  }
  
}


/// The file is a thumbnail of a file from a secret chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecretThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeSecretThumbnail

}



#[typetag::serde]
impl FileType for FileTypeSecretThumbnail {}


impl FileTypeSecretThumbnail {
  
  pub fn builder() -> FileTypeSecretThumbnailBuilder {
    let instance = Self {
      tdfname: "fileTypeSecretThumbnail".to_string(),
      
    };
    FileTypeSecretThumbnailBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeSecretThumbnailBuilder {
  instance: FileTypeSecretThumbnail
}

impl FileTypeSecretThumbnailBuilder {
  fn new(instance: FileTypeSecretThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecretThumbnail {
    self.instance.clone()
  }
  
}


/// The file is a file from Secure storage used for storing Telegram Passport files. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSecure {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeSecure

}



#[typetag::serde]
impl FileType for FileTypeSecure {}


impl FileTypeSecure {
  
  pub fn builder() -> FileTypeSecureBuilder {
    let instance = Self {
      tdfname: "fileTypeSecure".to_string(),
      
    };
    FileTypeSecureBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeSecureBuilder {
  instance: FileTypeSecure
}

impl FileTypeSecureBuilder {
  fn new(instance: FileTypeSecure) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSecure {
    self.instance.clone()
  }
  
}


/// The file is a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeSticker

}



#[typetag::serde]
impl FileType for FileTypeSticker {}


impl FileTypeSticker {
  
  pub fn builder() -> FileTypeStickerBuilder {
    let instance = Self {
      tdfname: "fileTypeSticker".to_string(),
      
    };
    FileTypeStickerBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeStickerBuilder {
  instance: FileTypeSticker
}

impl FileTypeStickerBuilder {
  fn new(instance: FileTypeSticker) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeSticker {
    self.instance.clone()
  }
  
}


/// The file is a thumbnail of another file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeThumbnail

}



#[typetag::serde]
impl FileType for FileTypeThumbnail {}


impl FileTypeThumbnail {
  
  pub fn builder() -> FileTypeThumbnailBuilder {
    let instance = Self {
      tdfname: "fileTypeThumbnail".to_string(),
      
    };
    FileTypeThumbnailBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeThumbnailBuilder {
  instance: FileTypeThumbnail
}

impl FileTypeThumbnailBuilder {
  fn new(instance: FileTypeThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeThumbnail {
    self.instance.clone()
  }
  
}


/// The file type is not yet known. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeUnknown

}



#[typetag::serde]
impl FileType for FileTypeUnknown {}


impl FileTypeUnknown {
  
  pub fn builder() -> FileTypeUnknownBuilder {
    let instance = Self {
      tdfname: "fileTypeUnknown".to_string(),
      
    };
    FileTypeUnknownBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeUnknownBuilder {
  instance: FileTypeUnknown
}

impl FileTypeUnknownBuilder {
  fn new(instance: FileTypeUnknown) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeUnknown {
    self.instance.clone()
  }
  
}


/// The file is a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeVideo

}



#[typetag::serde]
impl FileType for FileTypeVideo {}


impl FileTypeVideo {
  
  pub fn builder() -> FileTypeVideoBuilder {
    let instance = Self {
      tdfname: "fileTypeVideo".to_string(),
      
    };
    FileTypeVideoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeVideoBuilder {
  instance: FileTypeVideo
}

impl FileTypeVideoBuilder {
  fn new(instance: FileTypeVideo) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVideo {
    self.instance.clone()
  }
  
}


/// The file is a video note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeVideoNote

}



#[typetag::serde]
impl FileType for FileTypeVideoNote {}


impl FileTypeVideoNote {
  
  pub fn builder() -> FileTypeVideoNoteBuilder {
    let instance = Self {
      tdfname: "fileTypeVideoNote".to_string(),
      
    };
    FileTypeVideoNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeVideoNoteBuilder {
  instance: FileTypeVideoNote
}

impl FileTypeVideoNoteBuilder {
  fn new(instance: FileTypeVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVideoNote {
    self.instance.clone()
  }
  
}


/// The file is a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeVoiceNote

}



#[typetag::serde]
impl FileType for FileTypeVoiceNote {}


impl FileTypeVoiceNote {
  
  pub fn builder() -> FileTypeVoiceNoteBuilder {
    let instance = Self {
      tdfname: "fileTypeVoiceNote".to_string(),
      
    };
    FileTypeVoiceNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeVoiceNoteBuilder {
  instance: FileTypeVoiceNote
}

impl FileTypeVoiceNoteBuilder {
  fn new(instance: FileTypeVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeVoiceNote {
    self.instance.clone()
  }
  
}


/// The file is a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileTypeWallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // fileTypeWallpaper

}



#[typetag::serde]
impl FileType for FileTypeWallpaper {}


impl FileTypeWallpaper {
  
  pub fn builder() -> FileTypeWallpaperBuilder {
    let instance = Self {
      tdfname: "fileTypeWallpaper".to_string(),
      
    };
    FileTypeWallpaperBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FileTypeWallpaperBuilder {
  instance: FileTypeWallpaper
}

impl FileTypeWallpaperBuilder {
  fn new(instance: FileTypeWallpaper) -> Self { Self { instance } }

  pub fn build(&self) -> FileTypeWallpaper {
    self.instance.clone()
  }
  
}


/// A text with some entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormattedText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // formattedText

  /// The text.
  text: Option<String>,
  /// Entities contained in the text.
  entities: Option<Vec<TextEntity>>,


}




impl Object for FormattedText {}


impl FormattedText {
  
  pub fn builder() -> FormattedTextBuilder {
    let instance = Self {
      tdfname: "formattedText".to_string(),
      text: None,
      entities: None,
      
    };
    FormattedTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn entities(&self) -> &Option<Vec<TextEntity>> { &self.entities }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FormattedTextBuilder {
  instance: FormattedText
}

impl FormattedTextBuilder {
  fn new(instance: FormattedText) -> Self { Self { instance } }

  pub fn build(&self) -> FormattedText {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn entities(&mut self, entities: Vec<TextEntity>) -> &mut Self {
    self.instance.entities = Some(entities);
    self
  }
  
}


/// Contains a list of messages found by a search. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FoundMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // foundMessages

  /// List of messages.
  messages: Option<Vec<Message>>,
  /// Value to pass as from_search_id to get more results.
  next_from_search_id: Option<i64>,


}




impl Object for FoundMessages {}


impl FoundMessages {
  
  pub fn builder() -> FoundMessagesBuilder {
    let instance = Self {
      tdfname: "foundMessages".to_string(),
      messages: None,
      next_from_search_id: None,
      
    };
    FoundMessagesBuilder::new(instance)
  }
  
  
  pub fn messages(&self) -> &Option<Vec<Message>> { &self.messages }
  
  pub fn next_from_search_id(&self) -> &Option<i64> { &self.next_from_search_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FoundMessagesBuilder {
  instance: FoundMessages
}

impl FoundMessagesBuilder {
  fn new(instance: FoundMessages) -> Self { Self { instance } }

  pub fn build(&self) -> FoundMessages {
    self.instance.clone()
  }
  
  pub fn messages(&mut self, messages: Vec<Message>) -> &mut Self {
    self.instance.messages = Some(messages);
    self
  }
  
  pub fn next_from_search_id(&mut self, next_from_search_id: i64) -> &mut Self {
    self.instance.next_from_search_id = Some(next_from_search_id);
    self
  }
  
}


/// Describes a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Game {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // game

  /// Game ID.
  id: Option<i64>,
  /// Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}.
  short_name: Option<String>,
  /// Game title.
  title: Option<String>,
  /// Game text, usually containing scoreboards for a game.
  text: Option<FormattedText>,
  /// Game description.
  description: Option<String>,
  /// Game photo.
  photo: Option<Photo>,
  /// Game animation; may be null.
  animation: Option<Animation>,


}




impl Object for Game {}


impl Game {
  
  pub fn builder() -> GameBuilder {
    let instance = Self {
      tdfname: "game".to_string(),
      id: None,
      short_name: None,
      title: None,
      text: None,
      description: None,
      photo: None,
      animation: None,
      
    };
    GameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn short_name(&self) -> &Option<String> { &self.short_name }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GameBuilder {
  instance: Game
}

impl GameBuilder {
  fn new(instance: Game) -> Self { Self { instance } }

  pub fn build(&self) -> Game {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn short_name(&mut self, short_name: String) -> &mut Self {
    self.instance.short_name = Some(short_name);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}


/// Contains one row of the game high score table. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // gameHighScore

  /// Position in the high score table.
  position: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// User score.
  score: Option<i32>,


}




impl Object for GameHighScore {}


impl GameHighScore {
  
  pub fn builder() -> GameHighScoreBuilder {
    let instance = Self {
      tdfname: "gameHighScore".to_string(),
      position: None,
      user_id: None,
      score: None,
      
    };
    GameHighScoreBuilder::new(instance)
  }
  
  
  pub fn position(&self) -> &Option<i32> { &self.position }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn score(&self) -> &Option<i32> { &self.score }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GameHighScoreBuilder {
  instance: GameHighScore
}

impl GameHighScoreBuilder {
  fn new(instance: GameHighScore) -> Self { Self { instance } }

  pub fn build(&self) -> GameHighScore {
    self.instance.clone()
  }
  
  pub fn position(&mut self, position: i32) -> &mut Self {
    self.instance.position = Some(position);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
}


/// Contains a list of game high scores. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // gameHighScores

  /// A list of game high scores.
  scores: Option<Vec<GameHighScore>>,


}




impl Object for GameHighScores {}


impl GameHighScores {
  
  pub fn builder() -> GameHighScoresBuilder {
    let instance = Self {
      tdfname: "gameHighScores".to_string(),
      scores: None,
      
    };
    GameHighScoresBuilder::new(instance)
  }
  
  
  pub fn scores(&self) -> &Option<Vec<GameHighScore>> { &self.scores }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GameHighScoresBuilder {
  instance: GameHighScores
}

impl GameHighScoresBuilder {
  fn new(instance: GameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GameHighScores {
    self.instance.clone()
  }
  
  pub fn scores(&mut self, scores: Vec<GameHighScore>) -> &mut Self {
    self.instance.scores = Some(scores);
    self
  }
  
}


/// Contains a list of hashtags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Hashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // hashtags

  /// A list of hashtags.
  hashtags: Option<Vec<String>>,


}




impl Object for Hashtags {}


impl Hashtags {
  
  pub fn builder() -> HashtagsBuilder {
    let instance = Self {
      tdfname: "hashtags".to_string(),
      hashtags: None,
      
    };
    HashtagsBuilder::new(instance)
  }
  
  
  pub fn hashtags(&self) -> &Option<Vec<String>> { &self.hashtags }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct HashtagsBuilder {
  instance: Hashtags
}

impl HashtagsBuilder {
  fn new(instance: Hashtags) -> Self { Self { instance } }

  pub fn build(&self) -> Hashtags {
    self.instance.clone()
  }
  
  pub fn hashtags(&mut self, hashtags: Vec<String>) -> &mut Self {
    self.instance.hashtags = Some(hashtags);
    self
  }
  
}


/// Contains an HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // httpUrl

  /// The URL.
  url: Option<String>,


}




impl Object for HttpUrl {}


impl HttpUrl {
  
  pub fn builder() -> HttpUrlBuilder {
    let instance = Self {
      tdfname: "httpUrl".to_string(),
      url: None,
      
    };
    HttpUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct HttpUrlBuilder {
  instance: HttpUrl
}

impl HttpUrlBuilder {
  fn new(instance: HttpUrl) -> Self { Self { instance } }

  pub fn build(&self) -> HttpUrl {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// An identity document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // identityDocument

  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date; may be null.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<DatedFile>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<DatedFile>,
  /// Selfie with the document; may be null.
  selfie: Option<DatedFile>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,


}




impl Object for IdentityDocument {}


impl IdentityDocument {
  
  pub fn builder() -> IdentityDocumentBuilder {
    let instance = Self {
      tdfname: "identityDocument".to_string(),
      number: None,
      expiry_date: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      
    };
    IdentityDocumentBuilder::new(instance)
  }
  
  
  pub fn number(&self) -> &Option<String> { &self.number }
  
  pub fn expiry_date(&self) -> &Option<Date> { &self.expiry_date }
  
  pub fn front_side(&self) -> &Option<DatedFile> { &self.front_side }
  
  pub fn reverse_side(&self) -> &Option<DatedFile> { &self.reverse_side }
  
  pub fn selfie(&self) -> &Option<DatedFile> { &self.selfie }
  
  pub fn translation(&self) -> &Option<Vec<DatedFile>> { &self.translation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct IdentityDocumentBuilder {
  instance: IdentityDocument
}

impl IdentityDocumentBuilder {
  fn new(instance: IdentityDocument) -> Self { Self { instance } }

  pub fn build(&self) -> IdentityDocument {
    self.instance.clone()
  }
  
  pub fn number(&mut self, number: String) -> &mut Self {
    self.instance.number = Some(number);
    self
  }
  
  pub fn expiry_date(&mut self, expiry_date: Date) -> &mut Self {
    self.instance.expiry_date = Some(expiry_date);
    self
  }
  
  pub fn front_side(&mut self, front_side: DatedFile) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: DatedFile) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: DatedFile) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}


/// Represents the result of an ImportContacts request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // importedContacts

  /// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user.
  user_ids: Option<Vec<i32>>,
  /// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable.
  importer_count: Option<Vec<i32>>,


}




impl Object for ImportedContacts {}


impl ImportedContacts {
  
  pub fn builder() -> ImportedContactsBuilder {
    let instance = Self {
      tdfname: "importedContacts".to_string(),
      user_ids: None,
      importer_count: None,
      
    };
    ImportedContactsBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  pub fn importer_count(&self) -> &Option<Vec<i32>> { &self.importer_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ImportedContactsBuilder {
  instance: ImportedContacts
}

impl ImportedContactsBuilder {
  fn new(instance: ImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ImportedContacts {
    self.instance.clone()
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
  pub fn importer_count(&mut self, importer_count: Vec<i32>) -> &mut Self {
    self.instance.importer_count = Some(importer_count);
    self
  }
  
}


/// Represents a single button in an inline keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineKeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButton

  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<InlineKeyboardButtonType>>,


}


impl Clone for InlineKeyboardButton {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InlineKeyboardButton {}


impl InlineKeyboardButton {
  
  pub fn builder() -> InlineKeyboardButtonBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButton".to_string(),
      text: None,
      type_: None,
      
    };
    InlineKeyboardButtonBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn type_(&self) -> &Option<Box<InlineKeyboardButtonType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonBuilder {
  instance: InlineKeyboardButton
}

impl InlineKeyboardButtonBuilder {
  fn new(instance: InlineKeyboardButton) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButton {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn type_(&mut self, type_: Box<InlineKeyboardButtonType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// This class is an abstract base class. Describes the type of an inline keyboard button. 
#[typetag::serde(tag = "@struct")]
pub trait InlineKeyboardButtonType: Debug {}



impl Object for InlineKeyboardButtonType {}





/// A button that opens a specified URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButtonTypeUrl

  /// HTTP or tg:// URL to open.
  url: Option<String>,


}



#[typetag::serde]
impl InlineKeyboardButtonType for InlineKeyboardButtonTypeUrl {}


impl InlineKeyboardButtonTypeUrl {
  
  pub fn builder() -> InlineKeyboardButtonTypeUrlBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButtonTypeUrl".to_string(),
      url: None,
      
    };
    InlineKeyboardButtonTypeUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonTypeUrlBuilder {
  instance: InlineKeyboardButtonTypeUrl
}

impl InlineKeyboardButtonTypeUrlBuilder {
  fn new(instance: InlineKeyboardButtonTypeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeUrl {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// A button that sends a special callback query to a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallback {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButtonTypeCallback

  /// Data to be sent to the bot via a callback query.
  data: Option<String>,


}



#[typetag::serde]
impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallback {}


impl InlineKeyboardButtonTypeCallback {
  
  pub fn builder() -> InlineKeyboardButtonTypeCallbackBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButtonTypeCallback".to_string(),
      data: None,
      
    };
    InlineKeyboardButtonTypeCallbackBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonTypeCallbackBuilder {
  instance: InlineKeyboardButtonTypeCallback
}

impl InlineKeyboardButtonTypeCallbackBuilder {
  fn new(instance: InlineKeyboardButtonTypeCallback) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeCallback {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// A button with a game that sends a special callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeCallbackGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButtonTypeCallbackGame

}



#[typetag::serde]
impl InlineKeyboardButtonType for InlineKeyboardButtonTypeCallbackGame {}


impl InlineKeyboardButtonTypeCallbackGame {
  
  pub fn builder() -> InlineKeyboardButtonTypeCallbackGameBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButtonTypeCallbackGame".to_string(),
      
    };
    InlineKeyboardButtonTypeCallbackGameBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonTypeCallbackGameBuilder {
  instance: InlineKeyboardButtonTypeCallbackGame
}

impl InlineKeyboardButtonTypeCallbackGameBuilder {
  fn new(instance: InlineKeyboardButtonTypeCallbackGame) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeCallbackGame {
    self.instance.clone()
  }
  
}


/// A button that forces an inline query to the bot to be inserted in the input field. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeSwitchInline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButtonTypeSwitchInline

  /// Inline query to be sent to the bot.
  query: Option<String>,
  /// True, if the inline query should be sent from the current chat.
  in_current_chat: Option<bool>,


}



#[typetag::serde]
impl InlineKeyboardButtonType for InlineKeyboardButtonTypeSwitchInline {}


impl InlineKeyboardButtonTypeSwitchInline {
  
  pub fn builder() -> InlineKeyboardButtonTypeSwitchInlineBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButtonTypeSwitchInline".to_string(),
      query: None,
      in_current_chat: None,
      
    };
    InlineKeyboardButtonTypeSwitchInlineBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn in_current_chat(&self) -> &Option<bool> { &self.in_current_chat }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonTypeSwitchInlineBuilder {
  instance: InlineKeyboardButtonTypeSwitchInline
}

impl InlineKeyboardButtonTypeSwitchInlineBuilder {
  fn new(instance: InlineKeyboardButtonTypeSwitchInline) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeSwitchInline {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn in_current_chat(&mut self, in_current_chat: bool) -> &mut Self {
    self.instance.in_current_chat = Some(in_current_chat);
    self
  }
  
}


/// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineKeyboardButtonTypeBuy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineKeyboardButtonTypeBuy

}



#[typetag::serde]
impl InlineKeyboardButtonType for InlineKeyboardButtonTypeBuy {}


impl InlineKeyboardButtonTypeBuy {
  
  pub fn builder() -> InlineKeyboardButtonTypeBuyBuilder {
    let instance = Self {
      tdfname: "inlineKeyboardButtonTypeBuy".to_string(),
      
    };
    InlineKeyboardButtonTypeBuyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineKeyboardButtonTypeBuyBuilder {
  instance: InlineKeyboardButtonTypeBuy
}

impl InlineKeyboardButtonTypeBuyBuilder {
  fn new(instance: InlineKeyboardButtonTypeBuy) -> Self { Self { instance } }

  pub fn build(&self) -> InlineKeyboardButtonTypeBuy {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Represents a single result of an inline query. 
#[typetag::serde(tag = "@struct")]
pub trait InlineQueryResult: Debug {}



impl Object for InlineQueryResult {}





/// Represents a link to an article or web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultArticle

  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultArticle {}


impl InlineQueryResultArticle {
  
  pub fn builder() -> InlineQueryResultArticleBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultArticle".to_string(),
      id: None,
      url: None,
      hide_url: None,
      title: None,
      description: None,
      thumbnail: None,
      
    };
    InlineQueryResultArticleBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn hide_url(&self) -> &Option<bool> { &self.hide_url }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultArticleBuilder {
  instance: InlineQueryResultArticle
}

impl InlineQueryResultArticleBuilder {
  fn new(instance: InlineQueryResultArticle) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultArticle {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn hide_url(&mut self, hide_url: bool) -> &mut Self {
    self.instance.hide_url = Some(hide_url);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}


/// Represents a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultContact

  /// Unique identifier of the query result.
  id: Option<String>,
  /// A user contact.
  contact: Option<Contact>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultContact {}


impl InlineQueryResultContact {
  
  pub fn builder() -> InlineQueryResultContactBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultContact".to_string(),
      id: None,
      contact: None,
      thumbnail: None,
      
    };
    InlineQueryResultContactBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn contact(&self) -> &Option<Contact> { &self.contact }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultContactBuilder {
  instance: InlineQueryResultContact
}

impl InlineQueryResultContactBuilder {
  fn new(instance: InlineQueryResultContact) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultContact {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}


/// Represents a point on the map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultLocation

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Title of the result.
  title: Option<String>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultLocation {}


impl InlineQueryResultLocation {
  
  pub fn builder() -> InlineQueryResultLocationBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultLocation".to_string(),
      id: None,
      location: None,
      title: None,
      thumbnail: None,
      
    };
    InlineQueryResultLocationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultLocationBuilder {
  instance: InlineQueryResultLocation
}

impl InlineQueryResultLocationBuilder {
  fn new(instance: InlineQueryResultLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultLocation {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}


/// Represents information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultVenue

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// Result thumbnail; may be null.
  thumbnail: Option<PhotoSize>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultVenue {}


impl InlineQueryResultVenue {
  
  pub fn builder() -> InlineQueryResultVenueBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultVenue".to_string(),
      id: None,
      venue: None,
      thumbnail: None,
      
    };
    InlineQueryResultVenueBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn venue(&self) -> &Option<Venue> { &self.venue }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultVenueBuilder {
  instance: InlineQueryResultVenue
}

impl InlineQueryResultVenueBuilder {
  fn new(instance: InlineQueryResultVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVenue {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
}


/// Represents information about a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultGame

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Game result.
  game: Option<Game>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultGame {}


impl InlineQueryResultGame {
  
  pub fn builder() -> InlineQueryResultGameBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultGame".to_string(),
      id: None,
      game: None,
      
    };
    InlineQueryResultGameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn game(&self) -> &Option<Game> { &self.game }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultGameBuilder {
  instance: InlineQueryResultGame
}

impl InlineQueryResultGameBuilder {
  fn new(instance: InlineQueryResultGame) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultGame {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn game(&mut self, game: Game) -> &mut Self {
    self.instance.game = Some(game);
    self
  }
  
}


/// Represents an animation file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultAnimation

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Animation file.
  animation: Option<Animation>,
  /// Animation title.
  title: Option<String>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultAnimation {}


impl InlineQueryResultAnimation {
  
  pub fn builder() -> InlineQueryResultAnimationBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultAnimation".to_string(),
      id: None,
      animation: None,
      title: None,
      
    };
    InlineQueryResultAnimationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultAnimationBuilder {
  instance: InlineQueryResultAnimation
}

impl InlineQueryResultAnimationBuilder {
  fn new(instance: InlineQueryResultAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultAnimation {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// Represents an audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultAudio

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Audio file.
  audio: Option<Audio>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultAudio {}


impl InlineQueryResultAudio {
  
  pub fn builder() -> InlineQueryResultAudioBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultAudio".to_string(),
      id: None,
      audio: None,
      
    };
    InlineQueryResultAudioBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn audio(&self) -> &Option<Audio> { &self.audio }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultAudioBuilder {
  instance: InlineQueryResultAudio
}

impl InlineQueryResultAudioBuilder {
  fn new(instance: InlineQueryResultAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultAudio {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
}


/// Represents a document. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultDocument

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Document.
  document: Option<Document>,
  /// Document title.
  title: Option<String>,
  /// Document description.
  description: Option<String>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultDocument {}


impl InlineQueryResultDocument {
  
  pub fn builder() -> InlineQueryResultDocumentBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultDocument".to_string(),
      id: None,
      document: None,
      title: None,
      description: None,
      
    };
    InlineQueryResultDocumentBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn document(&self) -> &Option<Document> { &self.document }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultDocumentBuilder {
  instance: InlineQueryResultDocument
}

impl InlineQueryResultDocumentBuilder {
  fn new(instance: InlineQueryResultDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultDocument {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Represents a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultPhoto

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Photo.
  photo: Option<Photo>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultPhoto {}


impl InlineQueryResultPhoto {
  
  pub fn builder() -> InlineQueryResultPhotoBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultPhoto".to_string(),
      id: None,
      photo: None,
      title: None,
      description: None,
      
    };
    InlineQueryResultPhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultPhotoBuilder {
  instance: InlineQueryResultPhoto
}

impl InlineQueryResultPhotoBuilder {
  fn new(instance: InlineQueryResultPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultPhoto {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Represents a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultSticker

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Sticker.
  sticker: Option<Sticker>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultSticker {}


impl InlineQueryResultSticker {
  
  pub fn builder() -> InlineQueryResultStickerBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultSticker".to_string(),
      id: None,
      sticker: None,
      
    };
    InlineQueryResultStickerBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn sticker(&self) -> &Option<Sticker> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultStickerBuilder {
  instance: InlineQueryResultSticker
}

impl InlineQueryResultStickerBuilder {
  fn new(instance: InlineQueryResultSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultSticker {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Represents a video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultVideo

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Video.
  video: Option<Video>,
  /// Title of the video.
  title: Option<String>,
  /// Description of the video.
  description: Option<String>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultVideo {}


impl InlineQueryResultVideo {
  
  pub fn builder() -> InlineQueryResultVideoBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultVideo".to_string(),
      id: None,
      video: None,
      title: None,
      description: None,
      
    };
    InlineQueryResultVideoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn video(&self) -> &Option<Video> { &self.video }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultVideoBuilder {
  instance: InlineQueryResultVideo
}

impl InlineQueryResultVideoBuilder {
  fn new(instance: InlineQueryResultVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVideo {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Represents a voice note. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResultVoiceNote

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Voice note.
  voice_note: Option<VoiceNote>,
  /// Title of the voice note.
  title: Option<String>,


}



#[typetag::serde]
impl InlineQueryResult for InlineQueryResultVoiceNote {}


impl InlineQueryResultVoiceNote {
  
  pub fn builder() -> InlineQueryResultVoiceNoteBuilder {
    let instance = Self {
      tdfname: "inlineQueryResultVoiceNote".to_string(),
      id: None,
      voice_note: None,
      title: None,
      
    };
    InlineQueryResultVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn voice_note(&self) -> &Option<VoiceNote> { &self.voice_note }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultVoiceNoteBuilder {
  instance: InlineQueryResultVoiceNote
}

impl InlineQueryResultVoiceNoteBuilder {
  fn new(instance: InlineQueryResultVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResultVoiceNote {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// Represents the results of the inline query. Use 
#[derive(Debug, Serialize, Deserialize)]
pub struct InlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inlineQueryResults

  /// Unique identifier of the inline query.
  inline_query_id: Option<i64>,
  /// The offset for the next request. If empty, there are no more results.
  next_offset: Option<String>,
  /// Results of the query.
  results: Option<Vec<Box<InlineQueryResult>>>,
  /// If non-empty, this text should be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// Parameter for the bot start message.
  switch_pm_parameter: Option<String>,


}


impl Clone for InlineQueryResults {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InlineQueryResults {}


impl InlineQueryResults {
  
  pub fn builder() -> InlineQueryResultsBuilder {
    let instance = Self {
      tdfname: "inlineQueryResults".to_string(),
      inline_query_id: None,
      next_offset: None,
      results: None,
      switch_pm_text: None,
      switch_pm_parameter: None,
      
    };
    InlineQueryResultsBuilder::new(instance)
  }
  
  
  pub fn inline_query_id(&self) -> &Option<i64> { &self.inline_query_id }
  
  pub fn next_offset(&self) -> &Option<String> { &self.next_offset }
  
  pub fn results(&self) -> &Option<Vec<Box<InlineQueryResult>>> { &self.results }
  
  pub fn switch_pm_text(&self) -> &Option<String> { &self.switch_pm_text }
  
  pub fn switch_pm_parameter(&self) -> &Option<String> { &self.switch_pm_parameter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InlineQueryResultsBuilder {
  instance: InlineQueryResults
}

impl InlineQueryResultsBuilder {
  fn new(instance: InlineQueryResults) -> Self { Self { instance } }

  pub fn build(&self) -> InlineQueryResults {
    self.instance.clone()
  }
  
  pub fn inline_query_id(&mut self, inline_query_id: i64) -> &mut Self {
    self.instance.inline_query_id = Some(inline_query_id);
    self
  }
  
  pub fn next_offset(&mut self, next_offset: String) -> &mut Self {
    self.instance.next_offset = Some(next_offset);
    self
  }
  
  pub fn results(&mut self, results: Vec<Box<InlineQueryResult>>) -> &mut Self {
    self.instance.results = Some(results);
    self
  }
  
  pub fn switch_pm_text(&mut self, switch_pm_text: String) -> &mut Self {
    self.instance.switch_pm_text = Some(switch_pm_text);
    self
  }
  
  pub fn switch_pm_parameter(&mut self, switch_pm_parameter: String) -> &mut Self {
    self.instance.switch_pm_parameter = Some(switch_pm_parameter);
    self
  }
  
}


/// This class is an abstract base class. Contains information about the payment method chosen by the user. 
#[typetag::serde(tag = "@struct")]
pub trait InputCredentials: Debug {}



impl Object for InputCredentials {}





/// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsSaved {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputCredentialsSaved

  /// Identifier of the saved credentials.
  saved_credentials_id: Option<String>,


}



#[typetag::serde]
impl InputCredentials for InputCredentialsSaved {}


impl InputCredentialsSaved {
  
  pub fn builder() -> InputCredentialsSavedBuilder {
    let instance = Self {
      tdfname: "inputCredentialsSaved".to_string(),
      saved_credentials_id: None,
      
    };
    InputCredentialsSavedBuilder::new(instance)
  }
  
  
  pub fn saved_credentials_id(&self) -> &Option<String> { &self.saved_credentials_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputCredentialsSavedBuilder {
  instance: InputCredentialsSaved
}

impl InputCredentialsSavedBuilder {
  fn new(instance: InputCredentialsSaved) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsSaved {
    self.instance.clone()
  }
  
  pub fn saved_credentials_id(&mut self, saved_credentials_id: String) -> &mut Self {
    self.instance.saved_credentials_id = Some(saved_credentials_id);
    self
  }
  
}


/// Applies if a user enters new credentials on a payment provider website. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsNew {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputCredentialsNew

  /// Contains JSON-encoded data with a credential identifier from the payment provider.
  data: Option<String>,
  /// True, if the credential identifier can be saved on the server side.
  allow_save: Option<bool>,


}



#[typetag::serde]
impl InputCredentials for InputCredentialsNew {}


impl InputCredentialsNew {
  
  pub fn builder() -> InputCredentialsNewBuilder {
    let instance = Self {
      tdfname: "inputCredentialsNew".to_string(),
      data: None,
      allow_save: None,
      
    };
    InputCredentialsNewBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  pub fn allow_save(&self) -> &Option<bool> { &self.allow_save }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputCredentialsNewBuilder {
  instance: InputCredentialsNew
}

impl InputCredentialsNewBuilder {
  fn new(instance: InputCredentialsNew) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsNew {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
  pub fn allow_save(&mut self, allow_save: bool) -> &mut Self {
    self.instance.allow_save = Some(allow_save);
    self
  }
  
}


/// Applies if a user enters new credentials using Android Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsAndroidPay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputCredentialsAndroidPay

  /// JSON-encoded data with the credential identifier.
  data: Option<String>,


}



#[typetag::serde]
impl InputCredentials for InputCredentialsAndroidPay {}


impl InputCredentialsAndroidPay {
  
  pub fn builder() -> InputCredentialsAndroidPayBuilder {
    let instance = Self {
      tdfname: "inputCredentialsAndroidPay".to_string(),
      data: None,
      
    };
    InputCredentialsAndroidPayBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputCredentialsAndroidPayBuilder {
  instance: InputCredentialsAndroidPay
}

impl InputCredentialsAndroidPayBuilder {
  fn new(instance: InputCredentialsAndroidPay) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsAndroidPay {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// Applies if a user enters new credentials using Apple Pay. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputCredentialsApplePay {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputCredentialsApplePay

  /// JSON-encoded data with the credential identifier.
  data: Option<String>,


}



#[typetag::serde]
impl InputCredentials for InputCredentialsApplePay {}


impl InputCredentialsApplePay {
  
  pub fn builder() -> InputCredentialsApplePayBuilder {
    let instance = Self {
      tdfname: "inputCredentialsApplePay".to_string(),
      data: None,
      
    };
    InputCredentialsApplePayBuilder::new(instance)
  }
  
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputCredentialsApplePayBuilder {
  instance: InputCredentialsApplePay
}

impl InputCredentialsApplePayBuilder {
  fn new(instance: InputCredentialsApplePay) -> Self { Self { instance } }

  pub fn build(&self) -> InputCredentialsApplePay {
    self.instance.clone()
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// This class is an abstract base class. Points to a file. 
#[typetag::serde(tag = "@struct")]
pub trait InputFile: Debug {}



impl Object for InputFile {}





/// A file defined by its unique ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputFileId

  /// Unique file identifier.
  id: Option<i32>,


}



#[typetag::serde]
impl InputFile for InputFileId {}


impl InputFileId {
  
  pub fn builder() -> InputFileIdBuilder {
    let instance = Self {
      tdfname: "inputFileId".to_string(),
      id: None,
      
    };
    InputFileIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputFileIdBuilder {
  instance: InputFileId
}

impl InputFileIdBuilder {
  fn new(instance: InputFileId) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileId {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}


/// A file defined by its remote ID. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileRemote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputFileRemote

  /// Remote file identifier.
  id: Option<String>,


}



#[typetag::serde]
impl InputFile for InputFileRemote {}


impl InputFileRemote {
  
  pub fn builder() -> InputFileRemoteBuilder {
    let instance = Self {
      tdfname: "inputFileRemote".to_string(),
      id: None,
      
    };
    InputFileRemoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputFileRemoteBuilder {
  instance: InputFileRemote
}

impl InputFileRemoteBuilder {
  fn new(instance: InputFileRemote) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileRemote {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}


/// A file defined by a local path. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileLocal {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputFileLocal

  /// Local path to the file.
  path: Option<String>,


}



#[typetag::serde]
impl InputFile for InputFileLocal {}


impl InputFileLocal {
  
  pub fn builder() -> InputFileLocalBuilder {
    let instance = Self {
      tdfname: "inputFileLocal".to_string(),
      path: None,
      
    };
    InputFileLocalBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> &Option<String> { &self.path }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputFileLocalBuilder {
  instance: InputFileLocal
}

impl InputFileLocalBuilder {
  fn new(instance: InputFileLocal) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileLocal {
    self.instance.clone()
  }
  
  pub fn path(&mut self, path: String) -> &mut Self {
    self.instance.path = Some(path);
    self
  }
  
}


/// A file generated by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputFileGenerated {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputFileGenerated

  /// Local path to a file from which the file is generated; may be empty if there is no such file.
  original_path: Option<String>,
  /// String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage.
  conversion: Option<String>,
  /// Expected size of the generated file; 0 if unknown.
  expected_size: Option<i32>,


}



#[typetag::serde]
impl InputFile for InputFileGenerated {}


impl InputFileGenerated {
  
  pub fn builder() -> InputFileGeneratedBuilder {
    let instance = Self {
      tdfname: "inputFileGenerated".to_string(),
      original_path: None,
      conversion: None,
      expected_size: None,
      
    };
    InputFileGeneratedBuilder::new(instance)
  }
  
  
  pub fn original_path(&self) -> &Option<String> { &self.original_path }
  
  pub fn conversion(&self) -> &Option<String> { &self.conversion }
  
  pub fn expected_size(&self) -> &Option<i32> { &self.expected_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputFileGeneratedBuilder {
  instance: InputFileGenerated
}

impl InputFileGeneratedBuilder {
  fn new(instance: InputFileGenerated) -> Self { Self { instance } }

  pub fn build(&self) -> InputFileGenerated {
    self.instance.clone()
  }
  
  pub fn original_path(&mut self, original_path: String) -> &mut Self {
    self.instance.original_path = Some(original_path);
    self
  }
  
  pub fn conversion(&mut self, conversion: String) -> &mut Self {
    self.instance.conversion = Some(conversion);
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
}


/// An identity document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputIdentityDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputIdentityDocument

  /// Document number; 1-24 characters.
  number: Option<String>,
  /// Document expiry date, if available.
  expiry_date: Option<Date>,
  /// Front side of the document.
  front_side: Option<Box<InputFile>>,
  /// Reverse side of the document; only for driver license and identity card.
  reverse_side: Option<Box<InputFile>>,
  /// Selfie with the document, if available.
  selfie: Option<Box<InputFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,


}


impl Clone for InputIdentityDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InputIdentityDocument {}


impl InputIdentityDocument {
  
  pub fn builder() -> InputIdentityDocumentBuilder {
    let instance = Self {
      tdfname: "inputIdentityDocument".to_string(),
      number: None,
      expiry_date: None,
      front_side: None,
      reverse_side: None,
      selfie: None,
      translation: None,
      
    };
    InputIdentityDocumentBuilder::new(instance)
  }
  
  
  pub fn number(&self) -> &Option<String> { &self.number }
  
  pub fn expiry_date(&self) -> &Option<Date> { &self.expiry_date }
  
  pub fn front_side(&self) -> &Option<Box<InputFile>> { &self.front_side }
  
  pub fn reverse_side(&self) -> &Option<Box<InputFile>> { &self.reverse_side }
  
  pub fn selfie(&self) -> &Option<Box<InputFile>> { &self.selfie }
  
  pub fn translation(&self) -> &Option<Vec<Box<InputFile>>> { &self.translation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputIdentityDocumentBuilder {
  instance: InputIdentityDocument
}

impl InputIdentityDocumentBuilder {
  fn new(instance: InputIdentityDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputIdentityDocument {
    self.instance.clone()
  }
  
  pub fn number(&mut self, number: String) -> &mut Self {
    self.instance.number = Some(number);
    self
  }
  
  pub fn expiry_date(&mut self, expiry_date: Date) -> &mut Self {
    self.instance.expiry_date = Some(expiry_date);
    self
  }
  
  pub fn front_side(&mut self, front_side: Box<InputFile>) -> &mut Self {
    self.instance.front_side = Some(front_side);
    self
  }
  
  pub fn reverse_side(&mut self, reverse_side: Box<InputFile>) -> &mut Self {
    self.instance.reverse_side = Some(reverse_side);
    self
  }
  
  pub fn selfie(&mut self, selfie: Box<InputFile>) -> &mut Self {
    self.instance.selfie = Some(selfie);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}


/// This class is an abstract base class. Represents a single result of an inline query; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputInlineQueryResult: Debug {}



impl Object for InputInlineQueryResult {}





/// Represents a link to an animated GIF. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedGif {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultAnimatedGif

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the query result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the GIF-file (file size must not exceed 1MB).
  gif_url: Option<String>,
  /// Duration of the GIF, in seconds.
  gif_duration: Option<i32>,
  /// Width of the GIF.
  gif_width: Option<i32>,
  /// Height of the GIF.
  gif_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultAnimatedGif {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultAnimatedGif {}


impl InputInlineQueryResultAnimatedGif {
  
  pub fn builder() -> InputInlineQueryResultAnimatedGifBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultAnimatedGif".to_string(),
      id: None,
      title: None,
      thumbnail_url: None,
      gif_url: None,
      gif_duration: None,
      gif_width: None,
      gif_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultAnimatedGifBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn gif_url(&self) -> &Option<String> { &self.gif_url }
  
  pub fn gif_duration(&self) -> &Option<i32> { &self.gif_duration }
  
  pub fn gif_width(&self) -> &Option<i32> { &self.gif_width }
  
  pub fn gif_height(&self) -> &Option<i32> { &self.gif_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultAnimatedGifBuilder {
  instance: InputInlineQueryResultAnimatedGif
}

impl InputInlineQueryResultAnimatedGifBuilder {
  fn new(instance: InputInlineQueryResultAnimatedGif) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAnimatedGif {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn gif_url(&mut self, gif_url: String) -> &mut Self {
    self.instance.gif_url = Some(gif_url);
    self
  }
  
  pub fn gif_duration(&mut self, gif_duration: i32) -> &mut Self {
    self.instance.gif_duration = Some(gif_duration);
    self
  }
  
  pub fn gif_width(&mut self, gif_width: i32) -> &mut Self {
    self.instance.gif_width = Some(gif_width);
    self
  }
  
  pub fn gif_height(&mut self, gif_height: i32) -> &mut Self {
    self.instance.gif_height = Some(gif_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to an animated (i.e. without sound) H.264/MPEG-4 AVC video. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAnimatedMpeg4 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultAnimatedMpeg4

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the static result thumbnail (JPEG or GIF), if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the MPEG4-file (file size must not exceed 1MB).
  mpeg4_url: Option<String>,
  /// Duration of the video, in seconds.
  mpeg4_duration: Option<i32>,
  /// Width of the video.
  mpeg4_width: Option<i32>,
  /// Height of the video.
  mpeg4_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultAnimatedMpeg4 {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultAnimatedMpeg4 {}


impl InputInlineQueryResultAnimatedMpeg4 {
  
  pub fn builder() -> InputInlineQueryResultAnimatedMpeg4Builder {
    let instance = Self {
      tdfname: "inputInlineQueryResultAnimatedMpeg4".to_string(),
      id: None,
      title: None,
      thumbnail_url: None,
      mpeg4_url: None,
      mpeg4_duration: None,
      mpeg4_width: None,
      mpeg4_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultAnimatedMpeg4Builder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn mpeg4_url(&self) -> &Option<String> { &self.mpeg4_url }
  
  pub fn mpeg4_duration(&self) -> &Option<i32> { &self.mpeg4_duration }
  
  pub fn mpeg4_width(&self) -> &Option<i32> { &self.mpeg4_width }
  
  pub fn mpeg4_height(&self) -> &Option<i32> { &self.mpeg4_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultAnimatedMpeg4Builder {
  instance: InputInlineQueryResultAnimatedMpeg4
}

impl InputInlineQueryResultAnimatedMpeg4Builder {
  fn new(instance: InputInlineQueryResultAnimatedMpeg4) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAnimatedMpeg4 {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn mpeg4_url(&mut self, mpeg4_url: String) -> &mut Self {
    self.instance.mpeg4_url = Some(mpeg4_url);
    self
  }
  
  pub fn mpeg4_duration(&mut self, mpeg4_duration: i32) -> &mut Self {
    self.instance.mpeg4_duration = Some(mpeg4_duration);
    self
  }
  
  pub fn mpeg4_width(&mut self, mpeg4_width: i32) -> &mut Self {
    self.instance.mpeg4_width = Some(mpeg4_width);
    self
  }
  
  pub fn mpeg4_height(&mut self, mpeg4_height: i32) -> &mut Self {
    self.instance.mpeg4_height = Some(mpeg4_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to an article or web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultArticle

  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the result, if it exists.
  url: Option<String>,
  /// True, if the URL must be not shown.
  hide_url: Option<bool>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result.
  description: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultArticle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultArticle {}


impl InputInlineQueryResultArticle {
  
  pub fn builder() -> InputInlineQueryResultArticleBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultArticle".to_string(),
      id: None,
      url: None,
      hide_url: None,
      title: None,
      description: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultArticleBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn hide_url(&self) -> &Option<bool> { &self.hide_url }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn thumbnail_width(&self) -> &Option<i32> { &self.thumbnail_width }
  
  pub fn thumbnail_height(&self) -> &Option<i32> { &self.thumbnail_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultArticleBuilder {
  instance: InputInlineQueryResultArticle
}

impl InputInlineQueryResultArticleBuilder {
  fn new(instance: InputInlineQueryResultArticle) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultArticle {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn hide_url(&mut self, hide_url: bool) -> &mut Self {
    self.instance.hide_url = Some(hide_url);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to an MP3 audio file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultAudio

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the audio file.
  title: Option<String>,
  /// Performer of the audio file.
  performer: Option<String>,
  /// The URL of the audio file.
  audio_url: Option<String>,
  /// Audio file duration, in seconds.
  audio_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAudio, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultAudio {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultAudio {}


impl InputInlineQueryResultAudio {
  
  pub fn builder() -> InputInlineQueryResultAudioBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultAudio".to_string(),
      id: None,
      title: None,
      performer: None,
      audio_url: None,
      audio_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultAudioBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn performer(&self) -> &Option<String> { &self.performer }
  
  pub fn audio_url(&self) -> &Option<String> { &self.audio_url }
  
  pub fn audio_duration(&self) -> &Option<i32> { &self.audio_duration }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultAudioBuilder {
  instance: InputInlineQueryResultAudio
}

impl InputInlineQueryResultAudioBuilder {
  fn new(instance: InputInlineQueryResultAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultAudio {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn performer(&mut self, performer: String) -> &mut Self {
    self.instance.performer = Some(performer);
    self
  }
  
  pub fn audio_url(&mut self, audio_url: String) -> &mut Self {
    self.instance.audio_url = Some(audio_url);
    self
  }
  
  pub fn audio_duration(&mut self, audio_duration: i32) -> &mut Self {
    self.instance.audio_duration = Some(audio_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a user contact. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultContact

  /// Unique identifier of the query result.
  id: Option<String>,
  /// User contact.
  contact: Option<Contact>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultContact {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultContact {}


impl InputInlineQueryResultContact {
  
  pub fn builder() -> InputInlineQueryResultContactBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultContact".to_string(),
      id: None,
      contact: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultContactBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn contact(&self) -> &Option<Contact> { &self.contact }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn thumbnail_width(&self) -> &Option<i32> { &self.thumbnail_width }
  
  pub fn thumbnail_height(&self) -> &Option<i32> { &self.thumbnail_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultContactBuilder {
  instance: InputInlineQueryResultContact
}

impl InputInlineQueryResultContactBuilder {
  fn new(instance: InputInlineQueryResultContact) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultContact {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to a file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultDocument

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the resulting file.
  title: Option<String>,
  /// Short description of the result, if known.
  description: Option<String>,
  /// URL of the file.
  document_url: Option<String>,
  /// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed.
  mime_type: Option<String>,
  /// The URL of the file thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Width of the thumbnail.
  thumbnail_width: Option<i32>,
  /// Height of the thumbnail.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageDocument, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultDocument {}


impl InputInlineQueryResultDocument {
  
  pub fn builder() -> InputInlineQueryResultDocumentBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultDocument".to_string(),
      id: None,
      title: None,
      description: None,
      document_url: None,
      mime_type: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultDocumentBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn document_url(&self) -> &Option<String> { &self.document_url }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn thumbnail_width(&self) -> &Option<i32> { &self.thumbnail_width }
  
  pub fn thumbnail_height(&self) -> &Option<i32> { &self.thumbnail_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultDocumentBuilder {
  instance: InputInlineQueryResultDocument
}

impl InputInlineQueryResultDocumentBuilder {
  fn new(instance: InputInlineQueryResultDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultDocument {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn document_url(&mut self, document_url: String) -> &mut Self {
    self.instance.document_url = Some(document_url);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a game. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultGame

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Short name of the game.
  game_short_name: Option<String>,
  /// Message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for InputInlineQueryResultGame {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultGame {}


impl InputInlineQueryResultGame {
  
  pub fn builder() -> InputInlineQueryResultGameBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultGame".to_string(),
      id: None,
      game_short_name: None,
      reply_markup: None,
      
    };
    InputInlineQueryResultGameBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn game_short_name(&self) -> &Option<String> { &self.game_short_name }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultGameBuilder {
  instance: InputInlineQueryResultGame
}

impl InputInlineQueryResultGameBuilder {
  fn new(instance: InputInlineQueryResultGame) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultGame {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn game_short_name(&mut self, game_short_name: String) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}


/// Represents a point on the map. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultLocation

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Location result.
  location: Option<Location>,
  /// Amount of time relative to the message sent time until the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Title of the result.
  title: Option<String>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultLocation {}


impl InputInlineQueryResultLocation {
  
  pub fn builder() -> InputInlineQueryResultLocationBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultLocation".to_string(),
      id: None,
      location: None,
      live_period: None,
      title: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultLocationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn live_period(&self) -> &Option<i32> { &self.live_period }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn thumbnail_width(&self) -> &Option<i32> { &self.thumbnail_width }
  
  pub fn thumbnail_height(&self) -> &Option<i32> { &self.thumbnail_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultLocationBuilder {
  instance: InputInlineQueryResultLocation
}

impl InputInlineQueryResultLocationBuilder {
  fn new(instance: InputInlineQueryResultLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultLocation {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents link to a JPEG image. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultPhoto

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result, if known.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// URL of the photo thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the JPEG photo (photo size must not exceed 5MB).
  photo_url: Option<String>,
  /// Width of the photo.
  photo_width: Option<i32>,
  /// Height of the photo.
  photo_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessagePhoto, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultPhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultPhoto {}


impl InputInlineQueryResultPhoto {
  
  pub fn builder() -> InputInlineQueryResultPhotoBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultPhoto".to_string(),
      id: None,
      title: None,
      description: None,
      thumbnail_url: None,
      photo_url: None,
      photo_width: None,
      photo_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultPhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn photo_url(&self) -> &Option<String> { &self.photo_url }
  
  pub fn photo_width(&self) -> &Option<i32> { &self.photo_width }
  
  pub fn photo_height(&self) -> &Option<i32> { &self.photo_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultPhotoBuilder {
  instance: InputInlineQueryResultPhoto
}

impl InputInlineQueryResultPhotoBuilder {
  fn new(instance: InputInlineQueryResultPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultPhoto {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn photo_url(&mut self, photo_url: String) -> &mut Self {
    self.instance.photo_url = Some(photo_url);
    self
  }
  
  pub fn photo_width(&mut self, photo_width: i32) -> &mut Self {
    self.instance.photo_width = Some(photo_width);
    self
  }
  
  pub fn photo_height(&mut self, photo_height: i32) -> &mut Self {
    self.instance.photo_height = Some(photo_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to a WEBP sticker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultSticker

  /// Unique identifier of the query result.
  id: Option<String>,
  /// URL of the sticker thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// The URL of the WEBP sticker (sticker file size must not exceed 5MB).
  sticker_url: Option<String>,
  /// Width of the sticker.
  sticker_width: Option<i32>,
  /// Height of the sticker.
  sticker_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, inputMessageSticker, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultSticker {}


impl InputInlineQueryResultSticker {
  
  pub fn builder() -> InputInlineQueryResultStickerBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultSticker".to_string(),
      id: None,
      thumbnail_url: None,
      sticker_url: None,
      sticker_width: None,
      sticker_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultStickerBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn sticker_url(&self) -> &Option<String> { &self.sticker_url }
  
  pub fn sticker_width(&self) -> &Option<i32> { &self.sticker_width }
  
  pub fn sticker_height(&self) -> &Option<i32> { &self.sticker_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultStickerBuilder {
  instance: InputInlineQueryResultSticker
}

impl InputInlineQueryResultStickerBuilder {
  fn new(instance: InputInlineQueryResultSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultSticker {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn sticker_url(&mut self, sticker_url: String) -> &mut Self {
    self.instance.sticker_url = Some(sticker_url);
    self
  }
  
  pub fn sticker_width(&mut self, sticker_width: i32) -> &mut Self {
    self.instance.sticker_width = Some(sticker_width);
    self
  }
  
  pub fn sticker_height(&mut self, sticker_height: i32) -> &mut Self {
    self.instance.sticker_height = Some(sticker_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents information about a venue. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultVenue

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Venue result.
  venue: Option<Venue>,
  /// URL of the result thumbnail, if it exists.
  thumbnail_url: Option<String>,
  /// Thumbnail width, if known.
  thumbnail_width: Option<i32>,
  /// Thumbnail height, if known.
  thumbnail_height: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultVenue {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultVenue {}


impl InputInlineQueryResultVenue {
  
  pub fn builder() -> InputInlineQueryResultVenueBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultVenue".to_string(),
      id: None,
      venue: None,
      thumbnail_url: None,
      thumbnail_width: None,
      thumbnail_height: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultVenueBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn venue(&self) -> &Option<Venue> { &self.venue }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn thumbnail_width(&self) -> &Option<i32> { &self.thumbnail_width }
  
  pub fn thumbnail_height(&self) -> &Option<i32> { &self.thumbnail_height }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultVenueBuilder {
  instance: InputInlineQueryResultVenue
}

impl InputInlineQueryResultVenueBuilder {
  fn new(instance: InputInlineQueryResultVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVenue {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn thumbnail_width(&mut self, thumbnail_width: i32) -> &mut Self {
    self.instance.thumbnail_width = Some(thumbnail_width);
    self
  }
  
  pub fn thumbnail_height(&mut self, thumbnail_height: i32) -> &mut Self {
    self.instance.thumbnail_height = Some(thumbnail_height);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to a page containing an embedded video player or a video file. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultVideo

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the result.
  title: Option<String>,
  /// A short description of the result, if known.
  description: Option<String>,
  /// The URL of the video thumbnail (JPEG), if it exists.
  thumbnail_url: Option<String>,
  /// URL of the embedded video player or video file.
  video_url: Option<String>,
  /// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported.
  mime_type: Option<String>,
  /// Width of the video.
  video_width: Option<i32>,
  /// Height of the video.
  video_height: Option<i32>,
  /// Video duration, in seconds.
  video_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVideo, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultVideo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultVideo {}


impl InputInlineQueryResultVideo {
  
  pub fn builder() -> InputInlineQueryResultVideoBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultVideo".to_string(),
      id: None,
      title: None,
      description: None,
      thumbnail_url: None,
      video_url: None,
      mime_type: None,
      video_width: None,
      video_height: None,
      video_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultVideoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn thumbnail_url(&self) -> &Option<String> { &self.thumbnail_url }
  
  pub fn video_url(&self) -> &Option<String> { &self.video_url }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn video_width(&self) -> &Option<i32> { &self.video_width }
  
  pub fn video_height(&self) -> &Option<i32> { &self.video_height }
  
  pub fn video_duration(&self) -> &Option<i32> { &self.video_duration }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultVideoBuilder {
  instance: InputInlineQueryResultVideo
}

impl InputInlineQueryResultVideoBuilder {
  fn new(instance: InputInlineQueryResultVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVideo {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn thumbnail_url(&mut self, thumbnail_url: String) -> &mut Self {
    self.instance.thumbnail_url = Some(thumbnail_url);
    self
  }
  
  pub fn video_url(&mut self, video_url: String) -> &mut Self {
    self.instance.video_url = Some(video_url);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn video_width(&mut self, video_width: i32) -> &mut Self {
    self.instance.video_width = Some(video_width);
    self
  }
  
  pub fn video_height(&mut self, video_height: i32) -> &mut Self {
    self.instance.video_height = Some(video_height);
    self
  }
  
  pub fn video_duration(&mut self, video_duration: i32) -> &mut Self {
    self.instance.video_duration = Some(video_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Represents a link to an opus-encoded audio file within an OGG container, single channel audio. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputInlineQueryResultVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputInlineQueryResultVoiceNote

  /// Unique identifier of the query result.
  id: Option<String>,
  /// Title of the voice note.
  title: Option<String>,
  /// The URL of the voice note file.
  voice_note_url: Option<String>,
  /// Duration of the voice note, in seconds.
  voice_note_duration: Option<i32>,
  /// The message reply markup. Must be of type replyMarkupInlineKeyboard or null.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVoiceNote, InputMessageLocation, InputMessageVenue or InputMessageContact.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for InputInlineQueryResultVoiceNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputInlineQueryResult for InputInlineQueryResultVoiceNote {}


impl InputInlineQueryResultVoiceNote {
  
  pub fn builder() -> InputInlineQueryResultVoiceNoteBuilder {
    let instance = Self {
      tdfname: "inputInlineQueryResultVoiceNote".to_string(),
      id: None,
      title: None,
      voice_note_url: None,
      voice_note_duration: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    InputInlineQueryResultVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn voice_note_url(&self) -> &Option<String> { &self.voice_note_url }
  
  pub fn voice_note_duration(&self) -> &Option<i32> { &self.voice_note_duration }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputInlineQueryResultVoiceNoteBuilder {
  instance: InputInlineQueryResultVoiceNote
}

impl InputInlineQueryResultVoiceNoteBuilder {
  fn new(instance: InputInlineQueryResultVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputInlineQueryResultVoiceNote {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn voice_note_url(&mut self, voice_note_url: String) -> &mut Self {
    self.instance.voice_note_url = Some(voice_note_url);
    self
  }
  
  pub fn voice_note_duration(&mut self, voice_note_duration: i32) -> &mut Self {
    self.instance.voice_note_duration = Some(voice_note_duration);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// This class is an abstract base class. The content of a message to send. 
#[typetag::serde(tag = "@struct")]
pub trait InputMessageContent: Debug {}



impl Object for InputMessageContent {}





/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageText

  /// Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Code, Pre, PreCode and TextUrl entities are allowed to be specified manually.
  text: Option<FormattedText>,
  /// True, if rich web page previews for URLs in the message text should be disabled.
  disable_web_page_preview: Option<bool>,
  /// True, if a chat message draft should be deleted.
  clear_draft: Option<bool>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageText {}


impl InputMessageText {
  
  pub fn builder() -> InputMessageTextBuilder {
    let instance = Self {
      tdfname: "inputMessageText".to_string(),
      text: None,
      disable_web_page_preview: None,
      clear_draft: None,
      
    };
    InputMessageTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  pub fn disable_web_page_preview(&self) -> &Option<bool> { &self.disable_web_page_preview }
  
  pub fn clear_draft(&self) -> &Option<bool> { &self.clear_draft }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageTextBuilder {
  instance: InputMessageText
}

impl InputMessageTextBuilder {
  fn new(instance: InputMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageText {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn disable_web_page_preview(&mut self, disable_web_page_preview: bool) -> &mut Self {
    self.instance.disable_web_page_preview = Some(disable_web_page_preview);
    self
  }
  
  pub fn clear_draft(&mut self, clear_draft: bool) -> &mut Self {
    self.instance.clear_draft = Some(clear_draft);
    self
  }
  
}


/// An animation message (GIF-style). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageAnimation

  /// Animation file to be sent.
  animation: Option<Box<InputFile>>,
  /// Animation thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the animation, in seconds.
  duration: Option<i32>,
  /// Width of the animation; may be replaced by the server.
  width: Option<i32>,
  /// Height of the animation; may be replaced by the server.
  height: Option<i32>,
  /// Animation caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for InputMessageAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageAnimation {}


impl InputMessageAnimation {
  
  pub fn builder() -> InputMessageAnimationBuilder {
    let instance = Self {
      tdfname: "inputMessageAnimation".to_string(),
      animation: None,
      thumbnail: None,
      duration: None,
      width: None,
      height: None,
      caption: None,
      
    };
    InputMessageAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Box<InputFile>> { &self.animation }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageAnimationBuilder {
  instance: InputMessageAnimation
}

impl InputMessageAnimationBuilder {
  fn new(instance: InputMessageAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// An audio message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageAudio

  /// Audio file to be sent.
  audio: Option<Box<InputFile>>,
  /// Thumbnail of the cover for the album, if available.
  album_cover_thumbnail: Option<InputThumbnail>,
  /// Duration of the audio, in seconds; may be replaced by the server.
  duration: Option<i32>,
  /// Title of the audio; 0-64 characters; may be replaced by the server.
  title: Option<String>,
  /// Performer of the audio; 0-64 characters, may be replaced by the server.
  performer: Option<String>,
  /// Audio caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for InputMessageAudio {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageAudio {}


impl InputMessageAudio {
  
  pub fn builder() -> InputMessageAudioBuilder {
    let instance = Self {
      tdfname: "inputMessageAudio".to_string(),
      audio: None,
      album_cover_thumbnail: None,
      duration: None,
      title: None,
      performer: None,
      caption: None,
      
    };
    InputMessageAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> &Option<Box<InputFile>> { &self.audio }
  
  pub fn album_cover_thumbnail(&self) -> &Option<InputThumbnail> { &self.album_cover_thumbnail }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn performer(&self) -> &Option<String> { &self.performer }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageAudioBuilder {
  instance: InputMessageAudio
}

impl InputMessageAudioBuilder {
  fn new(instance: InputMessageAudio) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageAudio {
    self.instance.clone()
  }
  
  pub fn audio(&mut self, audio: Box<InputFile>) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn album_cover_thumbnail(&mut self, album_cover_thumbnail: InputThumbnail) -> &mut Self {
    self.instance.album_cover_thumbnail = Some(album_cover_thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn performer(&mut self, performer: String) -> &mut Self {
    self.instance.performer = Some(performer);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A document message (general file). 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageDocument

  /// Document to be sent.
  document: Option<Box<InputFile>>,
  /// Document thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Document caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for InputMessageDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageDocument {}


impl InputMessageDocument {
  
  pub fn builder() -> InputMessageDocumentBuilder {
    let instance = Self {
      tdfname: "inputMessageDocument".to_string(),
      document: None,
      thumbnail: None,
      caption: None,
      
    };
    InputMessageDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> &Option<Box<InputFile>> { &self.document }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageDocumentBuilder {
  instance: InputMessageDocument
}

impl InputMessageDocumentBuilder {
  fn new(instance: InputMessageDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageDocument {
    self.instance.clone()
  }
  
  pub fn document(&mut self, document: Box<InputFile>) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A photo message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessagePhoto

  /// Photo to send.
  photo: Option<Box<InputFile>>,
  /// Photo thumbnail to be sent, this is sent to the other party in secret chats only.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the photo, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,
  /// Photo caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,


}


impl Clone for InputMessagePhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessagePhoto {}


impl InputMessagePhoto {
  
  pub fn builder() -> InputMessagePhotoBuilder {
    let instance = Self {
      tdfname: "inputMessagePhoto".to_string(),
      photo: None,
      thumbnail: None,
      added_sticker_file_ids: None,
      width: None,
      height: None,
      caption: None,
      ttl: None,
      
    };
    InputMessagePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Box<InputFile>> { &self.photo }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn added_sticker_file_ids(&self) -> &Option<Vec<i32>> { &self.added_sticker_file_ids }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessagePhotoBuilder {
  instance: InputMessagePhoto
}

impl InputMessagePhotoBuilder {
  fn new(instance: InputMessagePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessagePhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn added_sticker_file_ids(&mut self, added_sticker_file_ids: Vec<i32>) -> &mut Self {
    self.instance.added_sticker_file_ids = Some(added_sticker_file_ids);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}


/// A sticker message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageSticker

  /// Sticker to be sent.
  sticker: Option<Box<InputFile>>,
  /// Sticker thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Sticker width.
  width: Option<i32>,
  /// Sticker height.
  height: Option<i32>,


}


impl Clone for InputMessageSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageSticker {}


impl InputMessageSticker {
  
  pub fn builder() -> InputMessageStickerBuilder {
    let instance = Self {
      tdfname: "inputMessageSticker".to_string(),
      sticker: None,
      thumbnail: None,
      width: None,
      height: None,
      
    };
    InputMessageStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageStickerBuilder {
  instance: InputMessageSticker
}

impl InputMessageStickerBuilder {
  fn new(instance: InputMessageSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageSticker {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}


/// A video message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageVideo

  /// Video to be sent.
  video: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// File identifiers of the stickers added to the video, if applicable.
  added_sticker_file_ids: Option<Vec<i32>>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width.
  width: Option<i32>,
  /// Video height.
  height: Option<i32>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,
  /// Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats.
  ttl: Option<i32>,


}


impl Clone for InputMessageVideo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageVideo {}


impl InputMessageVideo {
  
  pub fn builder() -> InputMessageVideoBuilder {
    let instance = Self {
      tdfname: "inputMessageVideo".to_string(),
      video: None,
      thumbnail: None,
      added_sticker_file_ids: None,
      duration: None,
      width: None,
      height: None,
      supports_streaming: None,
      caption: None,
      ttl: None,
      
    };
    InputMessageVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> &Option<Box<InputFile>> { &self.video }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn added_sticker_file_ids(&self) -> &Option<Vec<i32>> { &self.added_sticker_file_ids }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn supports_streaming(&self) -> &Option<bool> { &self.supports_streaming }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageVideoBuilder {
  instance: InputMessageVideo
}

impl InputMessageVideoBuilder {
  fn new(instance: InputMessageVideo) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVideo {
    self.instance.clone()
  }
  
  pub fn video(&mut self, video: Box<InputFile>) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn added_sticker_file_ids(&mut self, added_sticker_file_ids: Vec<i32>) -> &mut Self {
    self.instance.added_sticker_file_ids = Some(added_sticker_file_ids);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn supports_streaming(&mut self, supports_streaming: bool) -> &mut Self {
    self.instance.supports_streaming = Some(supports_streaming);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}


/// A video note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageVideoNote

  /// Video note to be sent.
  video_note: Option<Box<InputFile>>,
  /// Video thumbnail, if available.
  thumbnail: Option<InputThumbnail>,
  /// Duration of the video, in seconds.
  duration: Option<i32>,
  /// Video width and height; must be positive and not greater than 640.
  length: Option<i32>,


}


impl Clone for InputMessageVideoNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageVideoNote {}


impl InputMessageVideoNote {
  
  pub fn builder() -> InputMessageVideoNoteBuilder {
    let instance = Self {
      tdfname: "inputMessageVideoNote".to_string(),
      video_note: None,
      thumbnail: None,
      duration: None,
      length: None,
      
    };
    InputMessageVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> &Option<Box<InputFile>> { &self.video_note }
  
  pub fn thumbnail(&self) -> &Option<InputThumbnail> { &self.thumbnail }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageVideoNoteBuilder {
  instance: InputMessageVideoNote
}

impl InputMessageVideoNoteBuilder {
  fn new(instance: InputMessageVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVideoNote {
    self.instance.clone()
  }
  
  pub fn video_note(&mut self, video_note: Box<InputFile>) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: InputThumbnail) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
}


/// A voice note message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputMessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageVoiceNote

  /// Voice note to be sent.
  voice_note: Option<Box<InputFile>>,
  /// Duration of the voice note, in seconds.
  duration: Option<i32>,
  /// Waveform representation of the voice note, in 5-bit format.
  waveform: Option<String>,
  /// Voice note caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for InputMessageVoiceNote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl InputMessageContent for InputMessageVoiceNote {}


impl InputMessageVoiceNote {
  
  pub fn builder() -> InputMessageVoiceNoteBuilder {
    let instance = Self {
      tdfname: "inputMessageVoiceNote".to_string(),
      voice_note: None,
      duration: None,
      waveform: None,
      caption: None,
      
    };
    InputMessageVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> &Option<Box<InputFile>> { &self.voice_note }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn waveform(&self) -> &Option<String> { &self.waveform }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageVoiceNoteBuilder {
  instance: InputMessageVoiceNote
}

impl InputMessageVoiceNoteBuilder {
  fn new(instance: InputMessageVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVoiceNote {
    self.instance.clone()
  }
  
  pub fn voice_note(&mut self, voice_note: Box<InputFile>) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn waveform(&mut self, waveform: String) -> &mut Self {
    self.instance.waveform = Some(waveform);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageLocation

  /// Location to be sent.
  location: Option<Location>,
  /// Period for which the location can be updated, in seconds; should bebetween 60 and 86400 for a live location and 0 otherwise.
  live_period: Option<i32>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageLocation {}


impl InputMessageLocation {
  
  pub fn builder() -> InputMessageLocationBuilder {
    let instance = Self {
      tdfname: "inputMessageLocation".to_string(),
      location: None,
      live_period: None,
      
    };
    InputMessageLocationBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn live_period(&self) -> &Option<i32> { &self.live_period }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageLocationBuilder {
  instance: InputMessageLocation
}

impl InputMessageLocationBuilder {
  fn new(instance: InputMessageLocation) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageLocation {
    self.instance.clone()
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
}


/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageVenue

  /// Venue to send.
  venue: Option<Venue>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageVenue {}


impl InputMessageVenue {
  
  pub fn builder() -> InputMessageVenueBuilder {
    let instance = Self {
      tdfname: "inputMessageVenue".to_string(),
      venue: None,
      
    };
    InputMessageVenueBuilder::new(instance)
  }
  
  
  pub fn venue(&self) -> &Option<Venue> { &self.venue }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageVenueBuilder {
  instance: InputMessageVenue
}

impl InputMessageVenueBuilder {
  fn new(instance: InputMessageVenue) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageVenue {
    self.instance.clone()
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
}


/// A message containing a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageContact

  /// Contact to send.
  contact: Option<Contact>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageContact {}


impl InputMessageContact {
  
  pub fn builder() -> InputMessageContactBuilder {
    let instance = Self {
      tdfname: "inputMessageContact".to_string(),
      contact: None,
      
    };
    InputMessageContactBuilder::new(instance)
  }
  
  
  pub fn contact(&self) -> &Option<Contact> { &self.contact }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageContactBuilder {
  instance: InputMessageContact
}

impl InputMessageContactBuilder {
  fn new(instance: InputMessageContact) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageContact {
    self.instance.clone()
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
}


/// A message with a game; not supported for channels or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageGame

  /// User identifier of the bot that owns the game.
  bot_user_id: Option<i32>,
  /// Short name of the game.
  game_short_name: Option<String>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageGame {}


impl InputMessageGame {
  
  pub fn builder() -> InputMessageGameBuilder {
    let instance = Self {
      tdfname: "inputMessageGame".to_string(),
      bot_user_id: None,
      game_short_name: None,
      
    };
    InputMessageGameBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> &Option<i32> { &self.bot_user_id }
  
  pub fn game_short_name(&self) -> &Option<String> { &self.game_short_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageGameBuilder {
  instance: InputMessageGame
}

impl InputMessageGameBuilder {
  fn new(instance: InputMessageGame) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageGame {
    self.instance.clone()
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn game_short_name(&mut self, game_short_name: String) -> &mut Self {
    self.instance.game_short_name = Some(game_short_name);
    self
  }
  
}


/// A message with an invoice; can be used only by bots and only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageInvoice

  /// Invoice.
  invoice: Option<Invoice>,
  /// Product title; 1-32 characters.
  title: Option<String>,
  /// Product description; 0-255 characters.
  description: Option<String>,
  /// Product photo URL; optional.
  photo_url: Option<String>,
  /// Product photo size.
  photo_size: Option<i32>,
  /// Product photo width.
  photo_width: Option<i32>,
  /// Product photo height.
  photo_height: Option<i32>,
  /// The invoice payload.
  payload: Option<String>,
  /// Payment provider token.
  provider_token: Option<String>,
  /// JSON-encoded data about the invoice, which will be shared with the payment provider.
  provider_data: Option<String>,
  /// Unique invoice bot start_parameter for the generation of this invoice.
  start_parameter: Option<String>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageInvoice {}


impl InputMessageInvoice {
  
  pub fn builder() -> InputMessageInvoiceBuilder {
    let instance = Self {
      tdfname: "inputMessageInvoice".to_string(),
      invoice: None,
      title: None,
      description: None,
      photo_url: None,
      photo_size: None,
      photo_width: None,
      photo_height: None,
      payload: None,
      provider_token: None,
      provider_data: None,
      start_parameter: None,
      
    };
    InputMessageInvoiceBuilder::new(instance)
  }
  
  
  pub fn invoice(&self) -> &Option<Invoice> { &self.invoice }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn photo_url(&self) -> &Option<String> { &self.photo_url }
  
  pub fn photo_size(&self) -> &Option<i32> { &self.photo_size }
  
  pub fn photo_width(&self) -> &Option<i32> { &self.photo_width }
  
  pub fn photo_height(&self) -> &Option<i32> { &self.photo_height }
  
  pub fn payload(&self) -> &Option<String> { &self.payload }
  
  pub fn provider_token(&self) -> &Option<String> { &self.provider_token }
  
  pub fn provider_data(&self) -> &Option<String> { &self.provider_data }
  
  pub fn start_parameter(&self) -> &Option<String> { &self.start_parameter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageInvoiceBuilder {
  instance: InputMessageInvoice
}

impl InputMessageInvoiceBuilder {
  fn new(instance: InputMessageInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageInvoice {
    self.instance.clone()
  }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn photo_url(&mut self, photo_url: String) -> &mut Self {
    self.instance.photo_url = Some(photo_url);
    self
  }
  
  pub fn photo_size(&mut self, photo_size: i32) -> &mut Self {
    self.instance.photo_size = Some(photo_size);
    self
  }
  
  pub fn photo_width(&mut self, photo_width: i32) -> &mut Self {
    self.instance.photo_width = Some(photo_width);
    self
  }
  
  pub fn photo_height(&mut self, photo_height: i32) -> &mut Self {
    self.instance.photo_height = Some(photo_height);
    self
  }
  
  pub fn payload(&mut self, payload: String) -> &mut Self {
    self.instance.payload = Some(payload);
    self
  }
  
  pub fn provider_token(&mut self, provider_token: String) -> &mut Self {
    self.instance.provider_token = Some(provider_token);
    self
  }
  
  pub fn provider_data(&mut self, provider_data: String) -> &mut Self {
    self.instance.provider_data = Some(provider_data);
    self
  }
  
  pub fn start_parameter(&mut self, start_parameter: String) -> &mut Self {
    self.instance.start_parameter = Some(start_parameter);
    self
  }
  
}


/// A message with a poll. Polls can't be sent to private or secret chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessagePoll

  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options, 2-10 strings 1-100 characters each.
  options: Option<Vec<String>>,


}



#[typetag::serde]
impl InputMessageContent for InputMessagePoll {}


impl InputMessagePoll {
  
  pub fn builder() -> InputMessagePollBuilder {
    let instance = Self {
      tdfname: "inputMessagePoll".to_string(),
      question: None,
      options: None,
      
    };
    InputMessagePollBuilder::new(instance)
  }
  
  
  pub fn question(&self) -> &Option<String> { &self.question }
  
  pub fn options(&self) -> &Option<Vec<String>> { &self.options }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessagePollBuilder {
  instance: InputMessagePoll
}

impl InputMessagePollBuilder {
  fn new(instance: InputMessagePoll) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessagePoll {
    self.instance.clone()
  }
  
  pub fn question(&mut self, question: String) -> &mut Self {
    self.instance.question = Some(question);
    self
  }
  
  pub fn options(&mut self, options: Vec<String>) -> &mut Self {
    self.instance.options = Some(options);
    self
  }
  
}


/// A forwarded message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputMessageForwarded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputMessageForwarded

  /// Identifier for the chat this forwarded message came from.
  from_chat_id: Option<i64>,
  /// Identifier of the message to forward.
  message_id: Option<i64>,
  /// True, if a game message should be shared within a launched game; applies only to game messages.
  in_game_share: Option<bool>,


}



#[typetag::serde]
impl InputMessageContent for InputMessageForwarded {}


impl InputMessageForwarded {
  
  pub fn builder() -> InputMessageForwardedBuilder {
    let instance = Self {
      tdfname: "inputMessageForwarded".to_string(),
      from_chat_id: None,
      message_id: None,
      in_game_share: None,
      
    };
    InputMessageForwardedBuilder::new(instance)
  }
  
  
  pub fn from_chat_id(&self) -> &Option<i64> { &self.from_chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn in_game_share(&self) -> &Option<bool> { &self.in_game_share }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputMessageForwardedBuilder {
  instance: InputMessageForwarded
}

impl InputMessageForwardedBuilder {
  fn new(instance: InputMessageForwarded) -> Self { Self { instance } }

  pub fn build(&self) -> InputMessageForwarded {
    self.instance.clone()
  }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn in_game_share(&mut self, in_game_share: bool) -> &mut Self {
    self.instance.in_game_share = Some(in_game_share);
    self
  }
  
}


/// This class is an abstract base class. Contains information about a Telegram Passport element to be saved. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElement: Debug {}



impl Object for InputPassportElement {}





/// A Telegram Passport element to be saved containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementPersonalDetails

  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementPersonalDetails {}


impl InputPassportElementPersonalDetails {
  
  pub fn builder() -> InputPassportElementPersonalDetailsBuilder {
    let instance = Self {
      tdfname: "inputPassportElementPersonalDetails".to_string(),
      personal_details: None,
      
    };
    InputPassportElementPersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn personal_details(&self) -> &Option<PersonalDetails> { &self.personal_details }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementPersonalDetailsBuilder {
  instance: InputPassportElementPersonalDetails
}

impl InputPassportElementPersonalDetailsBuilder {
  fn new(instance: InputPassportElementPersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPersonalDetails {
    self.instance.clone()
  }
  
  pub fn personal_details(&mut self, personal_details: PersonalDetails) -> &mut Self {
    self.instance.personal_details = Some(personal_details);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementPassport

  /// The passport to be saved.
  passport: Option<InputIdentityDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementPassport {}


impl InputPassportElementPassport {
  
  pub fn builder() -> InputPassportElementPassportBuilder {
    let instance = Self {
      tdfname: "inputPassportElementPassport".to_string(),
      passport: None,
      
    };
    InputPassportElementPassportBuilder::new(instance)
  }
  
  
  pub fn passport(&self) -> &Option<InputIdentityDocument> { &self.passport }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementPassportBuilder {
  instance: InputPassportElementPassport
}

impl InputPassportElementPassportBuilder {
  fn new(instance: InputPassportElementPassport) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPassport {
    self.instance.clone()
  }
  
  pub fn passport(&mut self, passport: InputIdentityDocument) -> &mut Self {
    self.instance.passport = Some(passport);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementDriverLicense

  /// The driver license to be saved.
  driver_license: Option<InputIdentityDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementDriverLicense {}


impl InputPassportElementDriverLicense {
  
  pub fn builder() -> InputPassportElementDriverLicenseBuilder {
    let instance = Self {
      tdfname: "inputPassportElementDriverLicense".to_string(),
      driver_license: None,
      
    };
    InputPassportElementDriverLicenseBuilder::new(instance)
  }
  
  
  pub fn driver_license(&self) -> &Option<InputIdentityDocument> { &self.driver_license }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementDriverLicenseBuilder {
  instance: InputPassportElementDriverLicense
}

impl InputPassportElementDriverLicenseBuilder {
  fn new(instance: InputPassportElementDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementDriverLicense {
    self.instance.clone()
  }
  
  pub fn driver_license(&mut self, driver_license: InputIdentityDocument) -> &mut Self {
    self.instance.driver_license = Some(driver_license);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementIdentityCard

  /// The identity card to be saved.
  identity_card: Option<InputIdentityDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementIdentityCard {}


impl InputPassportElementIdentityCard {
  
  pub fn builder() -> InputPassportElementIdentityCardBuilder {
    let instance = Self {
      tdfname: "inputPassportElementIdentityCard".to_string(),
      identity_card: None,
      
    };
    InputPassportElementIdentityCardBuilder::new(instance)
  }
  
  
  pub fn identity_card(&self) -> &Option<InputIdentityDocument> { &self.identity_card }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementIdentityCardBuilder {
  instance: InputPassportElementIdentityCard
}

impl InputPassportElementIdentityCardBuilder {
  fn new(instance: InputPassportElementIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementIdentityCard {
    self.instance.clone()
  }
  
  pub fn identity_card(&mut self, identity_card: InputIdentityDocument) -> &mut Self {
    self.instance.identity_card = Some(identity_card);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementInternalPassport

  /// The internal passport to be saved.
  internal_passport: Option<InputIdentityDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementInternalPassport {}


impl InputPassportElementInternalPassport {
  
  pub fn builder() -> InputPassportElementInternalPassportBuilder {
    let instance = Self {
      tdfname: "inputPassportElementInternalPassport".to_string(),
      internal_passport: None,
      
    };
    InputPassportElementInternalPassportBuilder::new(instance)
  }
  
  
  pub fn internal_passport(&self) -> &Option<InputIdentityDocument> { &self.internal_passport }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementInternalPassportBuilder {
  instance: InputPassportElementInternalPassport
}

impl InputPassportElementInternalPassportBuilder {
  fn new(instance: InputPassportElementInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementInternalPassport {
    self.instance.clone()
  }
  
  pub fn internal_passport(&mut self, internal_passport: InputIdentityDocument) -> &mut Self {
    self.instance.internal_passport = Some(internal_passport);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementAddress

  /// The address to be saved.
  address: Option<Address>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementAddress {}


impl InputPassportElementAddress {
  
  pub fn builder() -> InputPassportElementAddressBuilder {
    let instance = Self {
      tdfname: "inputPassportElementAddress".to_string(),
      address: None,
      
    };
    InputPassportElementAddressBuilder::new(instance)
  }
  
  
  pub fn address(&self) -> &Option<Address> { &self.address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementAddressBuilder {
  instance: InputPassportElementAddress
}

impl InputPassportElementAddressBuilder {
  fn new(instance: InputPassportElementAddress) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementAddress {
    self.instance.clone()
  }
  
  pub fn address(&mut self, address: Address) -> &mut Self {
    self.instance.address = Some(address);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementUtilityBill

  /// The utility bill to be saved.
  utility_bill: Option<InputPersonalDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementUtilityBill {}


impl InputPassportElementUtilityBill {
  
  pub fn builder() -> InputPassportElementUtilityBillBuilder {
    let instance = Self {
      tdfname: "inputPassportElementUtilityBill".to_string(),
      utility_bill: None,
      
    };
    InputPassportElementUtilityBillBuilder::new(instance)
  }
  
  
  pub fn utility_bill(&self) -> &Option<InputPersonalDocument> { &self.utility_bill }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementUtilityBillBuilder {
  instance: InputPassportElementUtilityBill
}

impl InputPassportElementUtilityBillBuilder {
  fn new(instance: InputPassportElementUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementUtilityBill {
    self.instance.clone()
  }
  
  pub fn utility_bill(&mut self, utility_bill: InputPersonalDocument) -> &mut Self {
    self.instance.utility_bill = Some(utility_bill);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementBankStatement

  /// The bank statement to be saved.
  bank_statement: Option<InputPersonalDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementBankStatement {}


impl InputPassportElementBankStatement {
  
  pub fn builder() -> InputPassportElementBankStatementBuilder {
    let instance = Self {
      tdfname: "inputPassportElementBankStatement".to_string(),
      bank_statement: None,
      
    };
    InputPassportElementBankStatementBuilder::new(instance)
  }
  
  
  pub fn bank_statement(&self) -> &Option<InputPersonalDocument> { &self.bank_statement }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementBankStatementBuilder {
  instance: InputPassportElementBankStatement
}

impl InputPassportElementBankStatementBuilder {
  fn new(instance: InputPassportElementBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementBankStatement {
    self.instance.clone()
  }
  
  pub fn bank_statement(&mut self, bank_statement: InputPersonalDocument) -> &mut Self {
    self.instance.bank_statement = Some(bank_statement);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementRentalAgreement

  /// The rental agreement to be saved.
  rental_agreement: Option<InputPersonalDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementRentalAgreement {}


impl InputPassportElementRentalAgreement {
  
  pub fn builder() -> InputPassportElementRentalAgreementBuilder {
    let instance = Self {
      tdfname: "inputPassportElementRentalAgreement".to_string(),
      rental_agreement: None,
      
    };
    InputPassportElementRentalAgreementBuilder::new(instance)
  }
  
  
  pub fn rental_agreement(&self) -> &Option<InputPersonalDocument> { &self.rental_agreement }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementRentalAgreementBuilder {
  instance: InputPassportElementRentalAgreement
}

impl InputPassportElementRentalAgreementBuilder {
  fn new(instance: InputPassportElementRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementRentalAgreement {
    self.instance.clone()
  }
  
  pub fn rental_agreement(&mut self, rental_agreement: InputPersonalDocument) -> &mut Self {
    self.instance.rental_agreement = Some(rental_agreement);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's passport registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementPassportRegistration

  /// The passport registration page to be saved.
  passport_registration: Option<InputPersonalDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementPassportRegistration {}


impl InputPassportElementPassportRegistration {
  
  pub fn builder() -> InputPassportElementPassportRegistrationBuilder {
    let instance = Self {
      tdfname: "inputPassportElementPassportRegistration".to_string(),
      passport_registration: None,
      
    };
    InputPassportElementPassportRegistrationBuilder::new(instance)
  }
  
  
  pub fn passport_registration(&self) -> &Option<InputPersonalDocument> { &self.passport_registration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementPassportRegistrationBuilder {
  instance: InputPassportElementPassportRegistration
}

impl InputPassportElementPassportRegistrationBuilder {
  fn new(instance: InputPassportElementPassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPassportRegistration {
    self.instance.clone()
  }
  
  pub fn passport_registration(&mut self, passport_registration: InputPersonalDocument) -> &mut Self {
    self.instance.passport_registration = Some(passport_registration);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementTemporaryRegistration

  /// The temporary registration document to be saved.
  temporary_registration: Option<InputPersonalDocument>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementTemporaryRegistration {}


impl InputPassportElementTemporaryRegistration {
  
  pub fn builder() -> InputPassportElementTemporaryRegistrationBuilder {
    let instance = Self {
      tdfname: "inputPassportElementTemporaryRegistration".to_string(),
      temporary_registration: None,
      
    };
    InputPassportElementTemporaryRegistrationBuilder::new(instance)
  }
  
  
  pub fn temporary_registration(&self) -> &Option<InputPersonalDocument> { &self.temporary_registration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementTemporaryRegistrationBuilder {
  instance: InputPassportElementTemporaryRegistration
}

impl InputPassportElementTemporaryRegistrationBuilder {
  fn new(instance: InputPassportElementTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementTemporaryRegistration {
    self.instance.clone()
  }
  
  pub fn temporary_registration(&mut self, temporary_registration: InputPersonalDocument) -> &mut Self {
    self.instance.temporary_registration = Some(temporary_registration);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementPhoneNumber

  /// The phone number to be saved.
  phone_number: Option<String>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementPhoneNumber {}


impl InputPassportElementPhoneNumber {
  
  pub fn builder() -> InputPassportElementPhoneNumberBuilder {
    let instance = Self {
      tdfname: "inputPassportElementPhoneNumber".to_string(),
      phone_number: None,
      
    };
    InputPassportElementPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementPhoneNumberBuilder {
  instance: InputPassportElementPhoneNumber
}

impl InputPassportElementPhoneNumberBuilder {
  fn new(instance: InputPassportElementPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementPhoneNumber {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
}


/// A Telegram Passport element to be saved containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementEmailAddress

  /// The email address to be saved.
  email_address: Option<String>,


}



#[typetag::serde]
impl InputPassportElement for InputPassportElementEmailAddress {}


impl InputPassportElementEmailAddress {
  
  pub fn builder() -> InputPassportElementEmailAddressBuilder {
    let instance = Self {
      tdfname: "inputPassportElementEmailAddress".to_string(),
      email_address: None,
      
    };
    InputPassportElementEmailAddressBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> &Option<String> { &self.email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementEmailAddressBuilder {
  instance: InputPassportElementEmailAddress
}

impl InputPassportElementEmailAddressBuilder {
  fn new(instance: InputPassportElementEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementEmailAddress {
    self.instance.clone()
  }
  
  pub fn email_address(&mut self, email_address: String) -> &mut Self {
    self.instance.email_address = Some(email_address);
    self
  }
  
}


/// Contains the description of an error in a Telegram Passport element; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementError

  /// Type of Telegram Passport element that has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<InputPassportElementErrorSource>>,


}


impl Clone for InputPassportElementError {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InputPassportElementError {}


impl InputPassportElementError {
  
  pub fn builder() -> InputPassportElementErrorBuilder {
    let instance = Self {
      tdfname: "inputPassportElementError".to_string(),
      type_: None,
      message: None,
      source: None,
      
    };
    InputPassportElementErrorBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  pub fn message(&self) -> &Option<String> { &self.message }
  
  pub fn source(&self) -> &Option<Box<InputPassportElementErrorSource>> { &self.source }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorBuilder {
  instance: InputPassportElementError
}

impl InputPassportElementErrorBuilder {
  fn new(instance: InputPassportElementError) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementError {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn message(&mut self, message: String) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
  pub fn source(&mut self, source: Box<InputPassportElementErrorSource>) -> &mut Self {
    self.instance.source = Some(source);
    self
  }
  
}


/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element; for bots only. 
#[typetag::serde(tag = "@struct")]
pub trait InputPassportElementErrorSource: Debug {}



impl Object for InputPassportElementErrorSource {}





/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceUnspecified

  /// Current hash of the entire element.
  element_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceUnspecified {}


impl InputPassportElementErrorSourceUnspecified {
  
  pub fn builder() -> InputPassportElementErrorSourceUnspecifiedBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceUnspecified".to_string(),
      element_hash: None,
      
    };
    InputPassportElementErrorSourceUnspecifiedBuilder::new(instance)
  }
  
  
  pub fn element_hash(&self) -> &Option<String> { &self.element_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceUnspecifiedBuilder {
  instance: InputPassportElementErrorSourceUnspecified
}

impl InputPassportElementErrorSourceUnspecifiedBuilder {
  fn new(instance: InputPassportElementErrorSourceUnspecified) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceUnspecified {
    self.instance.clone()
  }
  
  pub fn element_hash(&mut self, element_hash: String) -> &mut Self {
    self.instance.element_hash = Some(element_hash);
    self
  }
  
}


/// A data field contains an error. The error is considered resolved when the field's value changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceDataField

  /// Field name.
  field_name: Option<String>,
  /// Current data hash.
  data_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceDataField {}


impl InputPassportElementErrorSourceDataField {
  
  pub fn builder() -> InputPassportElementErrorSourceDataFieldBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceDataField".to_string(),
      field_name: None,
      data_hash: None,
      
    };
    InputPassportElementErrorSourceDataFieldBuilder::new(instance)
  }
  
  
  pub fn field_name(&self) -> &Option<String> { &self.field_name }
  
  pub fn data_hash(&self) -> &Option<String> { &self.data_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceDataFieldBuilder {
  instance: InputPassportElementErrorSourceDataField
}

impl InputPassportElementErrorSourceDataFieldBuilder {
  fn new(instance: InputPassportElementErrorSourceDataField) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceDataField {
    self.instance.clone()
  }
  
  pub fn field_name(&mut self, field_name: String) -> &mut Self {
    self.instance.field_name = Some(field_name);
    self
  }
  
  pub fn data_hash(&mut self, data_hash: String) -> &mut Self {
    self.instance.data_hash = Some(data_hash);
    self
  }
  
}


/// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceFrontSide

  /// Current hash of the file containing the front side.
  file_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceFrontSide {}


impl InputPassportElementErrorSourceFrontSide {
  
  pub fn builder() -> InputPassportElementErrorSourceFrontSideBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceFrontSide".to_string(),
      file_hash: None,
      
    };
    InputPassportElementErrorSourceFrontSideBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> &Option<String> { &self.file_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceFrontSideBuilder {
  instance: InputPassportElementErrorSourceFrontSide
}

impl InputPassportElementErrorSourceFrontSideBuilder {
  fn new(instance: InputPassportElementErrorSourceFrontSide) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFrontSide {
    self.instance.clone()
  }
  
  pub fn file_hash(&mut self, file_hash: String) -> &mut Self {
    self.instance.file_hash = Some(file_hash);
    self
  }
  
}


/// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceReverseSide

  /// Current hash of the file containing the reverse side.
  file_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceReverseSide {}


impl InputPassportElementErrorSourceReverseSide {
  
  pub fn builder() -> InputPassportElementErrorSourceReverseSideBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceReverseSide".to_string(),
      file_hash: None,
      
    };
    InputPassportElementErrorSourceReverseSideBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> &Option<String> { &self.file_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceReverseSideBuilder {
  instance: InputPassportElementErrorSourceReverseSide
}

impl InputPassportElementErrorSourceReverseSideBuilder {
  fn new(instance: InputPassportElementErrorSourceReverseSide) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceReverseSide {
    self.instance.clone()
  }
  
  pub fn file_hash(&mut self, file_hash: String) -> &mut Self {
    self.instance.file_hash = Some(file_hash);
    self
  }
  
}


/// The selfie contains an error. The error is considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceSelfie

  /// Current hash of the file containing the selfie.
  file_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceSelfie {}


impl InputPassportElementErrorSourceSelfie {
  
  pub fn builder() -> InputPassportElementErrorSourceSelfieBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceSelfie".to_string(),
      file_hash: None,
      
    };
    InputPassportElementErrorSourceSelfieBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> &Option<String> { &self.file_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceSelfieBuilder {
  instance: InputPassportElementErrorSourceSelfie
}

impl InputPassportElementErrorSourceSelfieBuilder {
  fn new(instance: InputPassportElementErrorSourceSelfie) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceSelfie {
    self.instance.clone()
  }
  
  pub fn file_hash(&mut self, file_hash: String) -> &mut Self {
    self.instance.file_hash = Some(file_hash);
    self
  }
  
}


/// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceTranslationFile

  /// Current hash of the file containing the translation.
  file_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFile {}


impl InputPassportElementErrorSourceTranslationFile {
  
  pub fn builder() -> InputPassportElementErrorSourceTranslationFileBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceTranslationFile".to_string(),
      file_hash: None,
      
    };
    InputPassportElementErrorSourceTranslationFileBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> &Option<String> { &self.file_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceTranslationFileBuilder {
  instance: InputPassportElementErrorSourceTranslationFile
}

impl InputPassportElementErrorSourceTranslationFileBuilder {
  fn new(instance: InputPassportElementErrorSourceTranslationFile) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceTranslationFile {
    self.instance.clone()
  }
  
  pub fn file_hash(&mut self, file_hash: String) -> &mut Self {
    self.instance.file_hash = Some(file_hash);
    self
  }
  
}


/// The translation of the document contains an error. The error is considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceTranslationFiles

  /// Current hashes of all files with the translation.
  file_hashes: Option<Vec<String>>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceTranslationFiles {}


impl InputPassportElementErrorSourceTranslationFiles {
  
  pub fn builder() -> InputPassportElementErrorSourceTranslationFilesBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceTranslationFiles".to_string(),
      file_hashes: None,
      
    };
    InputPassportElementErrorSourceTranslationFilesBuilder::new(instance)
  }
  
  
  pub fn file_hashes(&self) -> &Option<Vec<String>> { &self.file_hashes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceTranslationFilesBuilder {
  instance: InputPassportElementErrorSourceTranslationFiles
}

impl InputPassportElementErrorSourceTranslationFilesBuilder {
  fn new(instance: InputPassportElementErrorSourceTranslationFiles) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceTranslationFiles {
    self.instance.clone()
  }
  
  pub fn file_hashes(&mut self, file_hashes: Vec<String>) -> &mut Self {
    self.instance.file_hashes = Some(file_hashes);
    self
  }
  
}


/// The file contains an error. The error is considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceFile

  /// Current hash of the file which has the error.
  file_hash: Option<String>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceFile {}


impl InputPassportElementErrorSourceFile {
  
  pub fn builder() -> InputPassportElementErrorSourceFileBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceFile".to_string(),
      file_hash: None,
      
    };
    InputPassportElementErrorSourceFileBuilder::new(instance)
  }
  
  
  pub fn file_hash(&self) -> &Option<String> { &self.file_hash }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceFileBuilder {
  instance: InputPassportElementErrorSourceFile
}

impl InputPassportElementErrorSourceFileBuilder {
  fn new(instance: InputPassportElementErrorSourceFile) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFile {
    self.instance.clone()
  }
  
  pub fn file_hash(&mut self, file_hash: String) -> &mut Self {
    self.instance.file_hash = Some(file_hash);
    self
  }
  
}


/// The list of attached files contains an error. The error is considered resolved when the file list changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InputPassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPassportElementErrorSourceFiles

  /// Current hashes of all attached files.
  file_hashes: Option<Vec<String>>,


}



#[typetag::serde]
impl InputPassportElementErrorSource for InputPassportElementErrorSourceFiles {}


impl InputPassportElementErrorSourceFiles {
  
  pub fn builder() -> InputPassportElementErrorSourceFilesBuilder {
    let instance = Self {
      tdfname: "inputPassportElementErrorSourceFiles".to_string(),
      file_hashes: None,
      
    };
    InputPassportElementErrorSourceFilesBuilder::new(instance)
  }
  
  
  pub fn file_hashes(&self) -> &Option<Vec<String>> { &self.file_hashes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPassportElementErrorSourceFilesBuilder {
  instance: InputPassportElementErrorSourceFiles
}

impl InputPassportElementErrorSourceFilesBuilder {
  fn new(instance: InputPassportElementErrorSourceFiles) -> Self { Self { instance } }

  pub fn build(&self) -> InputPassportElementErrorSourceFiles {
    self.instance.clone()
  }
  
  pub fn file_hashes(&mut self, file_hashes: Vec<String>) -> &mut Self {
    self.instance.file_hashes = Some(file_hashes);
    self
  }
  
}


/// A personal document to be saved to Telegram Passport. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputPersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputPersonalDocument

  /// List of files containing the pages of the document.
  files: Option<Vec<Box<InputFile>>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<Box<InputFile>>>,


}


impl Clone for InputPersonalDocument {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InputPersonalDocument {}


impl InputPersonalDocument {
  
  pub fn builder() -> InputPersonalDocumentBuilder {
    let instance = Self {
      tdfname: "inputPersonalDocument".to_string(),
      files: None,
      translation: None,
      
    };
    InputPersonalDocumentBuilder::new(instance)
  }
  
  
  pub fn files(&self) -> &Option<Vec<Box<InputFile>>> { &self.files }
  
  pub fn translation(&self) -> &Option<Vec<Box<InputFile>>> { &self.translation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputPersonalDocumentBuilder {
  instance: InputPersonalDocument
}

impl InputPersonalDocumentBuilder {
  fn new(instance: InputPersonalDocument) -> Self { Self { instance } }

  pub fn build(&self) -> InputPersonalDocument {
    self.instance.clone()
  }
  
  pub fn files(&mut self, files: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<Box<InputFile>>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}


/// Describes a sticker that should be added to a sticker set. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputSticker

  /// PNG image with the sticker; must be up to 512 kB in size and fit in a 512x512 square.
  png_sticker: Option<Box<InputFile>>,
  /// Emoji corresponding to the sticker.
  emojis: Option<String>,
  /// For masks, position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,


}


impl Clone for InputSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InputSticker {}


impl InputSticker {
  
  pub fn builder() -> InputStickerBuilder {
    let instance = Self {
      tdfname: "inputSticker".to_string(),
      png_sticker: None,
      emojis: None,
      mask_position: None,
      
    };
    InputStickerBuilder::new(instance)
  }
  
  
  pub fn png_sticker(&self) -> &Option<Box<InputFile>> { &self.png_sticker }
  
  pub fn emojis(&self) -> &Option<String> { &self.emojis }
  
  pub fn mask_position(&self) -> &Option<MaskPosition> { &self.mask_position }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputStickerBuilder {
  instance: InputSticker
}

impl InputStickerBuilder {
  fn new(instance: InputSticker) -> Self { Self { instance } }

  pub fn build(&self) -> InputSticker {
    self.instance.clone()
  }
  
  pub fn png_sticker(&mut self, png_sticker: Box<InputFile>) -> &mut Self {
    self.instance.png_sticker = Some(png_sticker);
    self
  }
  
  pub fn emojis(&mut self, emojis: String) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
  pub fn mask_position(&mut self, mask_position: MaskPosition) -> &mut Self {
    self.instance.mask_position = Some(mask_position);
    self
  }
  
}


/// A thumbnail to be sent along with a file; should be in JPEG or WEBP format for stickers, and less than 200 kB in size. 
#[derive(Debug, Serialize, Deserialize)]
pub struct InputThumbnail {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // inputThumbnail

  /// Thumbnail file to send. Sending thumbnails by file_id is currently not supported.
  thumbnail: Option<Box<InputFile>>,
  /// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown.
  width: Option<i32>,
  /// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown.
  height: Option<i32>,


}


impl Clone for InputThumbnail {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for InputThumbnail {}


impl InputThumbnail {
  
  pub fn builder() -> InputThumbnailBuilder {
    let instance = Self {
      tdfname: "inputThumbnail".to_string(),
      thumbnail: None,
      width: None,
      height: None,
      
    };
    InputThumbnailBuilder::new(instance)
  }
  
  
  pub fn thumbnail(&self) -> &Option<Box<InputFile>> { &self.thumbnail }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InputThumbnailBuilder {
  instance: InputThumbnail
}

impl InputThumbnailBuilder {
  fn new(instance: InputThumbnail) -> Self { Self { instance } }

  pub fn build(&self) -> InputThumbnail {
    self.instance.clone()
  }
  
  pub fn thumbnail(&mut self, thumbnail: Box<InputFile>) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}


/// Product invoice. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Invoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // invoice

  /// ISO 4217 currency code.
  currency: Option<String>,
  /// A list of objects used to calculate the total price of the product.
  price_parts: Option<Vec<LabeledPricePart>>,
  /// True, if the payment is a test payment.
  is_test: Option<bool>,
  /// True, if the user's name is needed for payment.
  need_name: Option<bool>,
  /// True, if the user's phone number is needed for payment.
  need_phone_number: Option<bool>,
  /// True, if the user's email address is needed for payment.
  need_email_address: Option<bool>,
  /// True, if the user's shipping address is needed for payment.
  need_shipping_address: Option<bool>,
  /// True, if the user's phone number will be sent to the provider.
  send_phone_number_to_provider: Option<bool>,
  /// True, if the user's email address will be sent to the provider.
  send_email_address_to_provider: Option<bool>,
  /// True, if the total price depends on the shipping method.
  is_flexible: Option<bool>,


}




impl Object for Invoice {}


impl Invoice {
  
  pub fn builder() -> InvoiceBuilder {
    let instance = Self {
      tdfname: "invoice".to_string(),
      currency: None,
      price_parts: None,
      is_test: None,
      need_name: None,
      need_phone_number: None,
      need_email_address: None,
      need_shipping_address: None,
      send_phone_number_to_provider: None,
      send_email_address_to_provider: None,
      is_flexible: None,
      
    };
    InvoiceBuilder::new(instance)
  }
  
  
  pub fn currency(&self) -> &Option<String> { &self.currency }
  
  pub fn price_parts(&self) -> &Option<Vec<LabeledPricePart>> { &self.price_parts }
  
  pub fn is_test(&self) -> &Option<bool> { &self.is_test }
  
  pub fn need_name(&self) -> &Option<bool> { &self.need_name }
  
  pub fn need_phone_number(&self) -> &Option<bool> { &self.need_phone_number }
  
  pub fn need_email_address(&self) -> &Option<bool> { &self.need_email_address }
  
  pub fn need_shipping_address(&self) -> &Option<bool> { &self.need_shipping_address }
  
  pub fn send_phone_number_to_provider(&self) -> &Option<bool> { &self.send_phone_number_to_provider }
  
  pub fn send_email_address_to_provider(&self) -> &Option<bool> { &self.send_email_address_to_provider }
  
  pub fn is_flexible(&self) -> &Option<bool> { &self.is_flexible }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct InvoiceBuilder {
  instance: Invoice
}

impl InvoiceBuilder {
  fn new(instance: Invoice) -> Self { Self { instance } }

  pub fn build(&self) -> Invoice {
    self.instance.clone()
  }
  
  pub fn currency(&mut self, currency: String) -> &mut Self {
    self.instance.currency = Some(currency);
    self
  }
  
  pub fn price_parts(&mut self, price_parts: Vec<LabeledPricePart>) -> &mut Self {
    self.instance.price_parts = Some(price_parts);
    self
  }
  
  pub fn is_test(&mut self, is_test: bool) -> &mut Self {
    self.instance.is_test = Some(is_test);
    self
  }
  
  pub fn need_name(&mut self, need_name: bool) -> &mut Self {
    self.instance.need_name = Some(need_name);
    self
  }
  
  pub fn need_phone_number(&mut self, need_phone_number: bool) -> &mut Self {
    self.instance.need_phone_number = Some(need_phone_number);
    self
  }
  
  pub fn need_email_address(&mut self, need_email_address: bool) -> &mut Self {
    self.instance.need_email_address = Some(need_email_address);
    self
  }
  
  pub fn need_shipping_address(&mut self, need_shipping_address: bool) -> &mut Self {
    self.instance.need_shipping_address = Some(need_shipping_address);
    self
  }
  
  pub fn send_phone_number_to_provider(&mut self, send_phone_number_to_provider: bool) -> &mut Self {
    self.instance.send_phone_number_to_provider = Some(send_phone_number_to_provider);
    self
  }
  
  pub fn send_email_address_to_provider(&mut self, send_email_address_to_provider: bool) -> &mut Self {
    self.instance.send_email_address_to_provider = Some(send_email_address_to_provider);
    self
  }
  
  pub fn is_flexible(&mut self, is_flexible: bool) -> &mut Self {
    self.instance.is_flexible = Some(is_flexible);
    self
  }
  
}


/// Represents a single button in a bot keyboard. 
#[derive(Debug, Serialize, Deserialize)]
pub struct KeyboardButton {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // keyboardButton

  /// Text of the button.
  text: Option<String>,
  /// Type of the button.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<KeyboardButtonType>>,


}


impl Clone for KeyboardButton {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for KeyboardButton {}


impl KeyboardButton {
  
  pub fn builder() -> KeyboardButtonBuilder {
    let instance = Self {
      tdfname: "keyboardButton".to_string(),
      text: None,
      type_: None,
      
    };
    KeyboardButtonBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn type_(&self) -> &Option<Box<KeyboardButtonType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct KeyboardButtonBuilder {
  instance: KeyboardButton
}

impl KeyboardButtonBuilder {
  fn new(instance: KeyboardButton) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButton {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn type_(&mut self, type_: Box<KeyboardButtonType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// This class is an abstract base class. Describes a keyboard button type. 
#[typetag::serde(tag = "@struct")]
pub trait KeyboardButtonType: Debug {}



impl Object for KeyboardButtonType {}





/// A simple button, with text that should be sent when the button is pressed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // keyboardButtonTypeText

}



#[typetag::serde]
impl KeyboardButtonType for KeyboardButtonTypeText {}


impl KeyboardButtonTypeText {
  
  pub fn builder() -> KeyboardButtonTypeTextBuilder {
    let instance = Self {
      tdfname: "keyboardButtonTypeText".to_string(),
      
    };
    KeyboardButtonTypeTextBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct KeyboardButtonTypeTextBuilder {
  instance: KeyboardButtonTypeText
}

impl KeyboardButtonTypeTextBuilder {
  fn new(instance: KeyboardButtonTypeText) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeText {
    self.instance.clone()
  }
  
}


/// A button that sends the user's phone number when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // keyboardButtonTypeRequestPhoneNumber

}



#[typetag::serde]
impl KeyboardButtonType for KeyboardButtonTypeRequestPhoneNumber {}


impl KeyboardButtonTypeRequestPhoneNumber {
  
  pub fn builder() -> KeyboardButtonTypeRequestPhoneNumberBuilder {
    let instance = Self {
      tdfname: "keyboardButtonTypeRequestPhoneNumber".to_string(),
      
    };
    KeyboardButtonTypeRequestPhoneNumberBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct KeyboardButtonTypeRequestPhoneNumberBuilder {
  instance: KeyboardButtonTypeRequestPhoneNumber
}

impl KeyboardButtonTypeRequestPhoneNumberBuilder {
  fn new(instance: KeyboardButtonTypeRequestPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeRequestPhoneNumber {
    self.instance.clone()
  }
  
}


/// A button that sends the user's location when pressed; available only in private chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyboardButtonTypeRequestLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // keyboardButtonTypeRequestLocation

}



#[typetag::serde]
impl KeyboardButtonType for KeyboardButtonTypeRequestLocation {}


impl KeyboardButtonTypeRequestLocation {
  
  pub fn builder() -> KeyboardButtonTypeRequestLocationBuilder {
    let instance = Self {
      tdfname: "keyboardButtonTypeRequestLocation".to_string(),
      
    };
    KeyboardButtonTypeRequestLocationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct KeyboardButtonTypeRequestLocationBuilder {
  instance: KeyboardButtonTypeRequestLocation
}

impl KeyboardButtonTypeRequestLocationBuilder {
  fn new(instance: KeyboardButtonTypeRequestLocation) -> Self { Self { instance } }

  pub fn build(&self) -> KeyboardButtonTypeRequestLocation {
    self.instance.clone()
  }
  
}


/// Portion of the price of a product (e.g., "delivery cost", "tax amount"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LabeledPricePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // labeledPricePart

  /// Label for this portion of the product price.
  label: Option<String>,
  /// Currency amount in minimal quantity of the currency.
  amount: Option<i64>,


}




impl Object for LabeledPricePart {}


impl LabeledPricePart {
  
  pub fn builder() -> LabeledPricePartBuilder {
    let instance = Self {
      tdfname: "labeledPricePart".to_string(),
      label: None,
      amount: None,
      
    };
    LabeledPricePartBuilder::new(instance)
  }
  
  
  pub fn label(&self) -> &Option<String> { &self.label }
  
  pub fn amount(&self) -> &Option<i64> { &self.amount }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LabeledPricePartBuilder {
  instance: LabeledPricePart
}

impl LabeledPricePartBuilder {
  fn new(instance: LabeledPricePart) -> Self { Self { instance } }

  pub fn build(&self) -> LabeledPricePart {
    self.instance.clone()
  }
  
  pub fn label(&mut self, label: String) -> &mut Self {
    self.instance.label = Some(label);
    self
  }
  
  pub fn amount(&mut self, amount: i64) -> &mut Self {
    self.instance.amount = Some(amount);
    self
  }
  
}


/// Contains information about a language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackInfo

  /// Unique language pack identifier.
  id: Option<String>,
  /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs.
  base_language_pack_id: Option<String>,
  /// Language name.
  name: Option<String>,
  /// Name of the language in that language.
  native_name: Option<String>,
  /// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info.
  plural_code: Option<String>,
  /// True, if the language pack is official.
  is_official: Option<bool>,
  /// True, if the language pack strings are RTL.
  is_rtl: Option<bool>,
  /// True, if the language pack is a beta language pack.
  is_beta: Option<bool>,
  /// True, if the language pack is installed by the current user.
  is_installed: Option<bool>,
  /// Total number of non-deleted strings from the language pack.
  total_string_count: Option<i32>,
  /// Total number of translated strings from the language pack.
  translated_string_count: Option<i32>,
  /// Total number of non-deleted strings from the language pack available locally.
  local_string_count: Option<i32>,
  /// Link to language translation interface; empty for custom local language packs.
  translation_url: Option<String>,


}




impl Object for LanguagePackInfo {}


impl LanguagePackInfo {
  
  pub fn builder() -> LanguagePackInfoBuilder {
    let instance = Self {
      tdfname: "languagePackInfo".to_string(),
      id: None,
      base_language_pack_id: None,
      name: None,
      native_name: None,
      plural_code: None,
      is_official: None,
      is_rtl: None,
      is_beta: None,
      is_installed: None,
      total_string_count: None,
      translated_string_count: None,
      local_string_count: None,
      translation_url: None,
      
    };
    LanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn base_language_pack_id(&self) -> &Option<String> { &self.base_language_pack_id }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn native_name(&self) -> &Option<String> { &self.native_name }
  
  pub fn plural_code(&self) -> &Option<String> { &self.plural_code }
  
  pub fn is_official(&self) -> &Option<bool> { &self.is_official }
  
  pub fn is_rtl(&self) -> &Option<bool> { &self.is_rtl }
  
  pub fn is_beta(&self) -> &Option<bool> { &self.is_beta }
  
  pub fn is_installed(&self) -> &Option<bool> { &self.is_installed }
  
  pub fn total_string_count(&self) -> &Option<i32> { &self.total_string_count }
  
  pub fn translated_string_count(&self) -> &Option<i32> { &self.translated_string_count }
  
  pub fn local_string_count(&self) -> &Option<i32> { &self.local_string_count }
  
  pub fn translation_url(&self) -> &Option<String> { &self.translation_url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackInfoBuilder {
  instance: LanguagePackInfo
}

impl LanguagePackInfoBuilder {
  fn new(instance: LanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackInfo {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn base_language_pack_id(&mut self, base_language_pack_id: String) -> &mut Self {
    self.instance.base_language_pack_id = Some(base_language_pack_id);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn native_name(&mut self, native_name: String) -> &mut Self {
    self.instance.native_name = Some(native_name);
    self
  }
  
  pub fn plural_code(&mut self, plural_code: String) -> &mut Self {
    self.instance.plural_code = Some(plural_code);
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_rtl(&mut self, is_rtl: bool) -> &mut Self {
    self.instance.is_rtl = Some(is_rtl);
    self
  }
  
  pub fn is_beta(&mut self, is_beta: bool) -> &mut Self {
    self.instance.is_beta = Some(is_beta);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn total_string_count(&mut self, total_string_count: i32) -> &mut Self {
    self.instance.total_string_count = Some(total_string_count);
    self
  }
  
  pub fn translated_string_count(&mut self, translated_string_count: i32) -> &mut Self {
    self.instance.translated_string_count = Some(translated_string_count);
    self
  }
  
  pub fn local_string_count(&mut self, local_string_count: i32) -> &mut Self {
    self.instance.local_string_count = Some(local_string_count);
    self
  }
  
  pub fn translation_url(&mut self, translation_url: String) -> &mut Self {
    self.instance.translation_url = Some(translation_url);
    self
  }
  
}


/// Represents one language pack string. 
#[derive(Debug, Serialize, Deserialize)]
pub struct LanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackString

  /// String key.
  key: Option<String>,
  /// String value.
  value: Option<Box<LanguagePackStringValue>>,


}


impl Clone for LanguagePackString {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for LanguagePackString {}


impl LanguagePackString {
  
  pub fn builder() -> LanguagePackStringBuilder {
    let instance = Self {
      tdfname: "languagePackString".to_string(),
      key: None,
      value: None,
      
    };
    LanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn key(&self) -> &Option<String> { &self.key }
  
  pub fn value(&self) -> &Option<Box<LanguagePackStringValue>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackStringBuilder {
  instance: LanguagePackString
}

impl LanguagePackStringBuilder {
  fn new(instance: LanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackString {
    self.instance.clone()
  }
  
  pub fn key(&mut self, key: String) -> &mut Self {
    self.instance.key = Some(key);
    self
  }
  
  pub fn value(&mut self, value: Box<LanguagePackStringValue>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// This class is an abstract base class. Represents the value of a string in a language pack. 
#[typetag::serde(tag = "@struct")]
pub trait LanguagePackStringValue: Debug {}



impl Object for LanguagePackStringValue {}





/// An ordinary language pack string. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueOrdinary {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackStringValueOrdinary

  /// String value.
  value: Option<String>,


}



#[typetag::serde]
impl LanguagePackStringValue for LanguagePackStringValueOrdinary {}


impl LanguagePackStringValueOrdinary {
  
  pub fn builder() -> LanguagePackStringValueOrdinaryBuilder {
    let instance = Self {
      tdfname: "languagePackStringValueOrdinary".to_string(),
      value: None,
      
    };
    LanguagePackStringValueOrdinaryBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<String> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackStringValueOrdinaryBuilder {
  instance: LanguagePackStringValueOrdinary
}

impl LanguagePackStringValueOrdinaryBuilder {
  fn new(instance: LanguagePackStringValueOrdinary) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValueOrdinary {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: String) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A language pack string which has different forms based on the number of some object it mentions. See 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValuePluralized {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackStringValuePluralized

  /// Value for zero objects.
  zero_value: Option<String>,
  /// Value for one object.
  one_value: Option<String>,
  /// Value for two objects.
  two_value: Option<String>,
  /// Value for few objects.
  few_value: Option<String>,
  /// Value for many objects.
  many_value: Option<String>,
  /// Default value.
  other_value: Option<String>,


}



#[typetag::serde]
impl LanguagePackStringValue for LanguagePackStringValuePluralized {}


impl LanguagePackStringValuePluralized {
  
  pub fn builder() -> LanguagePackStringValuePluralizedBuilder {
    let instance = Self {
      tdfname: "languagePackStringValuePluralized".to_string(),
      zero_value: None,
      one_value: None,
      two_value: None,
      few_value: None,
      many_value: None,
      other_value: None,
      
    };
    LanguagePackStringValuePluralizedBuilder::new(instance)
  }
  
  
  pub fn zero_value(&self) -> &Option<String> { &self.zero_value }
  
  pub fn one_value(&self) -> &Option<String> { &self.one_value }
  
  pub fn two_value(&self) -> &Option<String> { &self.two_value }
  
  pub fn few_value(&self) -> &Option<String> { &self.few_value }
  
  pub fn many_value(&self) -> &Option<String> { &self.many_value }
  
  pub fn other_value(&self) -> &Option<String> { &self.other_value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackStringValuePluralizedBuilder {
  instance: LanguagePackStringValuePluralized
}

impl LanguagePackStringValuePluralizedBuilder {
  fn new(instance: LanguagePackStringValuePluralized) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValuePluralized {
    self.instance.clone()
  }
  
  pub fn zero_value(&mut self, zero_value: String) -> &mut Self {
    self.instance.zero_value = Some(zero_value);
    self
  }
  
  pub fn one_value(&mut self, one_value: String) -> &mut Self {
    self.instance.one_value = Some(one_value);
    self
  }
  
  pub fn two_value(&mut self, two_value: String) -> &mut Self {
    self.instance.two_value = Some(two_value);
    self
  }
  
  pub fn few_value(&mut self, few_value: String) -> &mut Self {
    self.instance.few_value = Some(few_value);
    self
  }
  
  pub fn many_value(&mut self, many_value: String) -> &mut Self {
    self.instance.many_value = Some(many_value);
    self
  }
  
  pub fn other_value(&mut self, other_value: String) -> &mut Self {
    self.instance.other_value = Some(other_value);
    self
  }
  
}


/// A deleted language pack string, the value should be taken from the built-in english language pack. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStringValueDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackStringValueDeleted

}



#[typetag::serde]
impl LanguagePackStringValue for LanguagePackStringValueDeleted {}


impl LanguagePackStringValueDeleted {
  
  pub fn builder() -> LanguagePackStringValueDeletedBuilder {
    let instance = Self {
      tdfname: "languagePackStringValueDeleted".to_string(),
      
    };
    LanguagePackStringValueDeletedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackStringValueDeletedBuilder {
  instance: LanguagePackStringValueDeleted
}

impl LanguagePackStringValueDeletedBuilder {
  fn new(instance: LanguagePackStringValueDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStringValueDeleted {
    self.instance.clone()
  }
  
}


/// Contains a list of language pack strings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // languagePackStrings

  /// A list of language pack strings.
  strings: Option<Vec<LanguagePackString>>,


}




impl Object for LanguagePackStrings {}


impl LanguagePackStrings {
  
  pub fn builder() -> LanguagePackStringsBuilder {
    let instance = Self {
      tdfname: "languagePackStrings".to_string(),
      strings: None,
      
    };
    LanguagePackStringsBuilder::new(instance)
  }
  
  
  pub fn strings(&self) -> &Option<Vec<LanguagePackString>> { &self.strings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LanguagePackStringsBuilder {
  instance: LanguagePackStrings
}

impl LanguagePackStringsBuilder {
  fn new(instance: LanguagePackStrings) -> Self { Self { instance } }

  pub fn build(&self) -> LanguagePackStrings {
    self.instance.clone()
  }
  
  pub fn strings(&mut self, strings: Vec<LanguagePackString>) -> &mut Self {
    self.instance.strings = Some(strings);
    self
  }
  
}


/// This class is an abstract base class. Represents the relationship between user A and user B. For incoming_link, user A is the current user; for outgoing_link, user B is the current user. 
#[typetag::serde(tag = "@struct")]
pub trait LinkState: Debug {}



impl Object for LinkState {}





/// The phone number of user A is not known to user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // linkStateNone

}



#[typetag::serde]
impl LinkState for LinkStateNone {}


impl LinkStateNone {
  
  pub fn builder() -> LinkStateNoneBuilder {
    let instance = Self {
      tdfname: "linkStateNone".to_string(),
      
    };
    LinkStateNoneBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LinkStateNoneBuilder {
  instance: LinkStateNone
}

impl LinkStateNoneBuilder {
  fn new(instance: LinkStateNone) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateNone {
    self.instance.clone()
  }
  
}


/// The phone number of user A is known but that number has not been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateKnowsPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // linkStateKnowsPhoneNumber

}



#[typetag::serde]
impl LinkState for LinkStateKnowsPhoneNumber {}


impl LinkStateKnowsPhoneNumber {
  
  pub fn builder() -> LinkStateKnowsPhoneNumberBuilder {
    let instance = Self {
      tdfname: "linkStateKnowsPhoneNumber".to_string(),
      
    };
    LinkStateKnowsPhoneNumberBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LinkStateKnowsPhoneNumberBuilder {
  instance: LinkStateKnowsPhoneNumber
}

impl LinkStateKnowsPhoneNumberBuilder {
  fn new(instance: LinkStateKnowsPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateKnowsPhoneNumber {
    self.instance.clone()
  }
  
}


/// The phone number of user A has been saved to the contact list of user B. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LinkStateIsContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // linkStateIsContact

}



#[typetag::serde]
impl LinkState for LinkStateIsContact {}


impl LinkStateIsContact {
  
  pub fn builder() -> LinkStateIsContactBuilder {
    let instance = Self {
      tdfname: "linkStateIsContact".to_string(),
      
    };
    LinkStateIsContactBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LinkStateIsContactBuilder {
  instance: LinkStateIsContact
}

impl LinkStateIsContactBuilder {
  fn new(instance: LinkStateIsContact) -> Self { Self { instance } }

  pub fn build(&self) -> LinkStateIsContact {
    self.instance.clone()
  }
  
}


/// Represents a local file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // localFile

  /// Local path to the locally available file part; may be empty.
  path: Option<String>,
  /// True, if it is possible to try to download or generate the file.
  can_be_downloaded: Option<bool>,
  /// True, if the file can be deleted.
  can_be_deleted: Option<bool>,
  /// True, if the file is currently being downloaded (or a local copy is being generated by some other means).
  is_downloading_active: Option<bool>,
  /// True, if the local copy is fully available.
  is_downloading_completed: Option<bool>,
  /// Download will be started from this offset. downloaded_prefix_size is calculated from this offset.
  download_offset: Option<i32>,
  /// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix.
  downloaded_prefix_size: Option<i32>,
  /// Total downloaded file bytes. Should be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage.
  downloaded_size: Option<i32>,


}




impl Object for LocalFile {}


impl LocalFile {
  
  pub fn builder() -> LocalFileBuilder {
    let instance = Self {
      tdfname: "localFile".to_string(),
      path: None,
      can_be_downloaded: None,
      can_be_deleted: None,
      is_downloading_active: None,
      is_downloading_completed: None,
      download_offset: None,
      downloaded_prefix_size: None,
      downloaded_size: None,
      
    };
    LocalFileBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> &Option<String> { &self.path }
  
  pub fn can_be_downloaded(&self) -> &Option<bool> { &self.can_be_downloaded }
  
  pub fn can_be_deleted(&self) -> &Option<bool> { &self.can_be_deleted }
  
  pub fn is_downloading_active(&self) -> &Option<bool> { &self.is_downloading_active }
  
  pub fn is_downloading_completed(&self) -> &Option<bool> { &self.is_downloading_completed }
  
  pub fn download_offset(&self) -> &Option<i32> { &self.download_offset }
  
  pub fn downloaded_prefix_size(&self) -> &Option<i32> { &self.downloaded_prefix_size }
  
  pub fn downloaded_size(&self) -> &Option<i32> { &self.downloaded_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LocalFileBuilder {
  instance: LocalFile
}

impl LocalFileBuilder {
  fn new(instance: LocalFile) -> Self { Self { instance } }

  pub fn build(&self) -> LocalFile {
    self.instance.clone()
  }
  
  pub fn path(&mut self, path: String) -> &mut Self {
    self.instance.path = Some(path);
    self
  }
  
  pub fn can_be_downloaded(&mut self, can_be_downloaded: bool) -> &mut Self {
    self.instance.can_be_downloaded = Some(can_be_downloaded);
    self
  }
  
  pub fn can_be_deleted(&mut self, can_be_deleted: bool) -> &mut Self {
    self.instance.can_be_deleted = Some(can_be_deleted);
    self
  }
  
  pub fn is_downloading_active(&mut self, is_downloading_active: bool) -> &mut Self {
    self.instance.is_downloading_active = Some(is_downloading_active);
    self
  }
  
  pub fn is_downloading_completed(&mut self, is_downloading_completed: bool) -> &mut Self {
    self.instance.is_downloading_completed = Some(is_downloading_completed);
    self
  }
  
  pub fn download_offset(&mut self, download_offset: i32) -> &mut Self {
    self.instance.download_offset = Some(download_offset);
    self
  }
  
  pub fn downloaded_prefix_size(&mut self, downloaded_prefix_size: i32) -> &mut Self {
    self.instance.downloaded_prefix_size = Some(downloaded_prefix_size);
    self
  }
  
  pub fn downloaded_size(&mut self, downloaded_size: i32) -> &mut Self {
    self.instance.downloaded_size = Some(downloaded_size);
    self
  }
  
}


/// Contains information about the current localization target. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // localizationTargetInfo

  /// List of available language packs for this application.
  language_packs: Option<Vec<LanguagePackInfo>>,


}




impl Object for LocalizationTargetInfo {}


impl LocalizationTargetInfo {
  
  pub fn builder() -> LocalizationTargetInfoBuilder {
    let instance = Self {
      tdfname: "localizationTargetInfo".to_string(),
      language_packs: None,
      
    };
    LocalizationTargetInfoBuilder::new(instance)
  }
  
  
  pub fn language_packs(&self) -> &Option<Vec<LanguagePackInfo>> { &self.language_packs }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LocalizationTargetInfoBuilder {
  instance: LocalizationTargetInfo
}

impl LocalizationTargetInfoBuilder {
  fn new(instance: LocalizationTargetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> LocalizationTargetInfo {
    self.instance.clone()
  }
  
  pub fn language_packs(&mut self, language_packs: Vec<LanguagePackInfo>) -> &mut Self {
    self.instance.language_packs = Some(language_packs);
    self
  }
  
}


/// Describes a location on planet Earth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // location

  /// Latitude of the location in degrees; as defined by the sender.
  latitude: Option<f64>,
  /// Longitude of the location, in degrees; as defined by the sender.
  longitude: Option<f64>,


}




impl Object for Location {}


impl Location {
  
  pub fn builder() -> LocationBuilder {
    let instance = Self {
      tdfname: "location".to_string(),
      latitude: None,
      longitude: None,
      
    };
    LocationBuilder::new(instance)
  }
  
  
  pub fn latitude(&self) -> &Option<f64> { &self.latitude }
  
  pub fn longitude(&self) -> &Option<f64> { &self.longitude }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LocationBuilder {
  instance: Location
}

impl LocationBuilder {
  fn new(instance: Location) -> Self { Self { instance } }

  pub fn build(&self) -> Location {
    self.instance.clone()
  }
  
  pub fn latitude(&mut self, latitude: f64) -> &mut Self {
    self.instance.latitude = Some(latitude);
    self
  }
  
  pub fn longitude(&mut self, longitude: f64) -> &mut Self {
    self.instance.longitude = Some(longitude);
    self
  }
  
}


/// This class is an abstract base class. Describes a stream to which TDLib internal log is written. 
#[typetag::serde(tag = "@struct")]
pub trait LogStream: Debug {}



impl Object for LogStream {}





/// The log is written to stderr or an OS specific log. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamDefault {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logStreamDefault

}



#[typetag::serde]
impl LogStream for LogStreamDefault {}


impl LogStreamDefault {
  
  pub fn builder() -> LogStreamDefaultBuilder {
    let instance = Self {
      tdfname: "logStreamDefault".to_string(),
      
    };
    LogStreamDefaultBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogStreamDefaultBuilder {
  instance: LogStreamDefault
}

impl LogStreamDefaultBuilder {
  fn new(instance: LogStreamDefault) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamDefault {
    self.instance.clone()
  }
  
}


/// The log is written to a file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logStreamFile

  /// Path to the file to where the internal TDLib log will be written.
  path: Option<String>,
  /// Maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated.
  max_file_size: Option<i64>,


}



#[typetag::serde]
impl LogStream for LogStreamFile {}


impl LogStreamFile {
  
  pub fn builder() -> LogStreamFileBuilder {
    let instance = Self {
      tdfname: "logStreamFile".to_string(),
      path: None,
      max_file_size: None,
      
    };
    LogStreamFileBuilder::new(instance)
  }
  
  
  pub fn path(&self) -> &Option<String> { &self.path }
  
  pub fn max_file_size(&self) -> &Option<i64> { &self.max_file_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogStreamFileBuilder {
  instance: LogStreamFile
}

impl LogStreamFileBuilder {
  fn new(instance: LogStreamFile) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamFile {
    self.instance.clone()
  }
  
  pub fn path(&mut self, path: String) -> &mut Self {
    self.instance.path = Some(path);
    self
  }
  
  pub fn max_file_size(&mut self, max_file_size: i64) -> &mut Self {
    self.instance.max_file_size = Some(max_file_size);
    self
  }
  
}


/// The log is written nowhere. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogStreamEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logStreamEmpty

}



#[typetag::serde]
impl LogStream for LogStreamEmpty {}


impl LogStreamEmpty {
  
  pub fn builder() -> LogStreamEmptyBuilder {
    let instance = Self {
      tdfname: "logStreamEmpty".to_string(),
      
    };
    LogStreamEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogStreamEmptyBuilder {
  instance: LogStreamEmpty
}

impl LogStreamEmptyBuilder {
  fn new(instance: LogStreamEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> LogStreamEmpty {
    self.instance.clone()
  }
  
}


/// Contains a list of available TDLib internal log tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logTags

  /// List of log tags.
  tags: Option<Vec<String>>,


}




impl Object for LogTags {}


impl LogTags {
  
  pub fn builder() -> LogTagsBuilder {
    let instance = Self {
      tdfname: "logTags".to_string(),
      tags: None,
      
    };
    LogTagsBuilder::new(instance)
  }
  
  
  pub fn tags(&self) -> &Option<Vec<String>> { &self.tags }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogTagsBuilder {
  instance: LogTags
}

impl LogTagsBuilder {
  fn new(instance: LogTags) -> Self { Self { instance } }

  pub fn build(&self) -> LogTags {
    self.instance.clone()
  }
  
  pub fn tags(&mut self, tags: Vec<String>) -> &mut Self {
    self.instance.tags = Some(tags);
    self
  }
  
}


/// Contains a TDLib internal log verbosity level. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logVerbosityLevel

  /// Log verbosity level.
  verbosity_level: Option<i32>,


}




impl Object for LogVerbosityLevel {}


impl LogVerbosityLevel {
  
  pub fn builder() -> LogVerbosityLevelBuilder {
    let instance = Self {
      tdfname: "logVerbosityLevel".to_string(),
      verbosity_level: None,
      
    };
    LogVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn verbosity_level(&self) -> &Option<i32> { &self.verbosity_level }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogVerbosityLevelBuilder {
  instance: LogVerbosityLevel
}

impl LogVerbosityLevelBuilder {
  fn new(instance: LogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> LogVerbosityLevel {
    self.instance.clone()
  }
  
  pub fn verbosity_level(&mut self, verbosity_level: i32) -> &mut Self {
    self.instance.verbosity_level = Some(verbosity_level);
    self
  }
  
}


/// This class is an abstract base class. Part of the face, relative to which a mask should be placed. 
#[typetag::serde(tag = "@struct")]
pub trait MaskPoint: Debug {}



impl Object for MaskPoint {}





/// A mask should be placed relatively to the forehead. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointForehead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // maskPointForehead

}



#[typetag::serde]
impl MaskPoint for MaskPointForehead {}


impl MaskPointForehead {
  
  pub fn builder() -> MaskPointForeheadBuilder {
    let instance = Self {
      tdfname: "maskPointForehead".to_string(),
      
    };
    MaskPointForeheadBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MaskPointForeheadBuilder {
  instance: MaskPointForehead
}

impl MaskPointForeheadBuilder {
  fn new(instance: MaskPointForehead) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointForehead {
    self.instance.clone()
  }
  
}


/// A mask should be placed relatively to the eyes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointEyes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // maskPointEyes

}



#[typetag::serde]
impl MaskPoint for MaskPointEyes {}


impl MaskPointEyes {
  
  pub fn builder() -> MaskPointEyesBuilder {
    let instance = Self {
      tdfname: "maskPointEyes".to_string(),
      
    };
    MaskPointEyesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MaskPointEyesBuilder {
  instance: MaskPointEyes
}

impl MaskPointEyesBuilder {
  fn new(instance: MaskPointEyes) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointEyes {
    self.instance.clone()
  }
  
}


/// A mask should be placed relatively to the mouth. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointMouth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // maskPointMouth

}



#[typetag::serde]
impl MaskPoint for MaskPointMouth {}


impl MaskPointMouth {
  
  pub fn builder() -> MaskPointMouthBuilder {
    let instance = Self {
      tdfname: "maskPointMouth".to_string(),
      
    };
    MaskPointMouthBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MaskPointMouthBuilder {
  instance: MaskPointMouth
}

impl MaskPointMouthBuilder {
  fn new(instance: MaskPointMouth) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointMouth {
    self.instance.clone()
  }
  
}


/// A mask should be placed relatively to the chin. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MaskPointChin {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // maskPointChin

}



#[typetag::serde]
impl MaskPoint for MaskPointChin {}


impl MaskPointChin {
  
  pub fn builder() -> MaskPointChinBuilder {
    let instance = Self {
      tdfname: "maskPointChin".to_string(),
      
    };
    MaskPointChinBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MaskPointChinBuilder {
  instance: MaskPointChin
}

impl MaskPointChinBuilder {
  fn new(instance: MaskPointChin) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPointChin {
    self.instance.clone()
  }
  
}


/// Position on a photo where a mask should be placed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MaskPosition {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // maskPosition

  /// Part of the face, relative to which the mask should be placed.
  point: Option<Box<MaskPoint>>,
  /// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position.)
  x_shift: Option<f64>,
  /// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position.)
  y_shift: Option<f64>,
  /// Mask scaling coefficient. (For example, 2.0 means a doubled size.)
  scale: Option<f64>,


}


impl Clone for MaskPosition {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for MaskPosition {}


impl MaskPosition {
  
  pub fn builder() -> MaskPositionBuilder {
    let instance = Self {
      tdfname: "maskPosition".to_string(),
      point: None,
      x_shift: None,
      y_shift: None,
      scale: None,
      
    };
    MaskPositionBuilder::new(instance)
  }
  
  
  pub fn point(&self) -> &Option<Box<MaskPoint>> { &self.point }
  
  pub fn x_shift(&self) -> &Option<f64> { &self.x_shift }
  
  pub fn y_shift(&self) -> &Option<f64> { &self.y_shift }
  
  pub fn scale(&self) -> &Option<f64> { &self.scale }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MaskPositionBuilder {
  instance: MaskPosition
}

impl MaskPositionBuilder {
  fn new(instance: MaskPosition) -> Self { Self { instance } }

  pub fn build(&self) -> MaskPosition {
    self.instance.clone()
  }
  
  pub fn point(&mut self, point: Box<MaskPoint>) -> &mut Self {
    self.instance.point = Some(point);
    self
  }
  
  pub fn x_shift(&mut self, x_shift: f64) -> &mut Self {
    self.instance.x_shift = Some(x_shift);
    self
  }
  
  pub fn y_shift(&mut self, y_shift: f64) -> &mut Self {
    self.instance.y_shift = Some(y_shift);
    self
  }
  
  pub fn scale(&mut self, scale: f64) -> &mut Self {
    self.instance.scale = Some(scale);
    self
  }
  
}


/// Describes a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Message {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // message

  /// Message identifier, unique for the chat to which the message belongs.
  id: Option<i64>,
  /// Identifier of the user who sent the message; 0 if unknown. It is unknown for channel posts.
  sender_user_id: Option<i32>,
  /// Chat identifier.
  chat_id: Option<i64>,
  /// Information about the sending state of the message; may be null.
  sending_state: Option<Box<MessageSendingState>>,
  /// True, if the message is outgoing.
  is_outgoing: Option<bool>,
  /// True, if the message can be edited. For live location and poll messages this fields shows, whether editMessageLiveLocation or stopPoll can be used with this message by the client.
  can_be_edited: Option<bool>,
  /// True, if the message can be forwarded.
  can_be_forwarded: Option<bool>,
  /// True, if the message can be deleted only for the current user while other users will continue to see it.
  can_be_deleted_only_for_self: Option<bool>,
  /// True, if the message can be deleted for all users.
  can_be_deleted_for_all_users: Option<bool>,
  /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts.
  is_channel_post: Option<bool>,
  /// True, if the message contains an unread mention for the current user.
  contains_unread_mention: Option<bool>,
  /// Point in time (Unix timestamp) when the message was sent.
  date: Option<i32>,
  /// Point in time (Unix timestamp) when the message was last edited.
  edit_date: Option<i32>,
  /// Information about the initial message sender; may be null.
  forward_info: Option<MessageForwardInfo>,
  /// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message.
  reply_to_message_id: Option<i64>,
  /// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires.
  ttl: Option<i32>,
  /// Time left before the message expires, in seconds.
  ttl_expires_in: Option<f64>,
  /// If non-zero, the user identifier of the bot through which this message was sent.
  via_bot_user_id: Option<i32>,
  /// For channel posts, optional author signature.
  author_signature: Option<String>,
  /// Number of times this message was viewed.
  views: Option<i32>,
  /// Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums.
  media_album_id: Option<i64>,
  /// Content of the message.
  content: Option<Box<MessageContent>>,
  /// Reply markup for the message; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for Message {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Message {}


impl Message {
  
  pub fn builder() -> MessageBuilder {
    let instance = Self {
      tdfname: "message".to_string(),
      id: None,
      sender_user_id: None,
      chat_id: None,
      sending_state: None,
      is_outgoing: None,
      can_be_edited: None,
      can_be_forwarded: None,
      can_be_deleted_only_for_self: None,
      can_be_deleted_for_all_users: None,
      is_channel_post: None,
      contains_unread_mention: None,
      date: None,
      edit_date: None,
      forward_info: None,
      reply_to_message_id: None,
      ttl: None,
      ttl_expires_in: None,
      via_bot_user_id: None,
      author_signature: None,
      views: None,
      media_album_id: None,
      content: None,
      reply_markup: None,
      
    };
    MessageBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn sending_state(&self) -> &Option<Box<MessageSendingState>> { &self.sending_state }
  
  pub fn is_outgoing(&self) -> &Option<bool> { &self.is_outgoing }
  
  pub fn can_be_edited(&self) -> &Option<bool> { &self.can_be_edited }
  
  pub fn can_be_forwarded(&self) -> &Option<bool> { &self.can_be_forwarded }
  
  pub fn can_be_deleted_only_for_self(&self) -> &Option<bool> { &self.can_be_deleted_only_for_self }
  
  pub fn can_be_deleted_for_all_users(&self) -> &Option<bool> { &self.can_be_deleted_for_all_users }
  
  pub fn is_channel_post(&self) -> &Option<bool> { &self.is_channel_post }
  
  pub fn contains_unread_mention(&self) -> &Option<bool> { &self.contains_unread_mention }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn edit_date(&self) -> &Option<i32> { &self.edit_date }
  
  pub fn forward_info(&self) -> &Option<MessageForwardInfo> { &self.forward_info }
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  pub fn ttl_expires_in(&self) -> &Option<f64> { &self.ttl_expires_in }
  
  pub fn via_bot_user_id(&self) -> &Option<i32> { &self.via_bot_user_id }
  
  pub fn author_signature(&self) -> &Option<String> { &self.author_signature }
  
  pub fn views(&self) -> &Option<i32> { &self.views }
  
  pub fn media_album_id(&self) -> &Option<i64> { &self.media_album_id }
  
  pub fn content(&self) -> &Option<Box<MessageContent>> { &self.content }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageBuilder {
  instance: Message
}

impl MessageBuilder {
  fn new(instance: Message) -> Self { Self { instance } }

  pub fn build(&self) -> Message {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn sending_state(&mut self, sending_state: Box<MessageSendingState>) -> &mut Self {
    self.instance.sending_state = Some(sending_state);
    self
  }
  
  pub fn is_outgoing(&mut self, is_outgoing: bool) -> &mut Self {
    self.instance.is_outgoing = Some(is_outgoing);
    self
  }
  
  pub fn can_be_edited(&mut self, can_be_edited: bool) -> &mut Self {
    self.instance.can_be_edited = Some(can_be_edited);
    self
  }
  
  pub fn can_be_forwarded(&mut self, can_be_forwarded: bool) -> &mut Self {
    self.instance.can_be_forwarded = Some(can_be_forwarded);
    self
  }
  
  pub fn can_be_deleted_only_for_self(&mut self, can_be_deleted_only_for_self: bool) -> &mut Self {
    self.instance.can_be_deleted_only_for_self = Some(can_be_deleted_only_for_self);
    self
  }
  
  pub fn can_be_deleted_for_all_users(&mut self, can_be_deleted_for_all_users: bool) -> &mut Self {
    self.instance.can_be_deleted_for_all_users = Some(can_be_deleted_for_all_users);
    self
  }
  
  pub fn is_channel_post(&mut self, is_channel_post: bool) -> &mut Self {
    self.instance.is_channel_post = Some(is_channel_post);
    self
  }
  
  pub fn contains_unread_mention(&mut self, contains_unread_mention: bool) -> &mut Self {
    self.instance.contains_unread_mention = Some(contains_unread_mention);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn edit_date(&mut self, edit_date: i32) -> &mut Self {
    self.instance.edit_date = Some(edit_date);
    self
  }
  
  pub fn forward_info(&mut self, forward_info: MessageForwardInfo) -> &mut Self {
    self.instance.forward_info = Some(forward_info);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn ttl_expires_in(&mut self, ttl_expires_in: f64) -> &mut Self {
    self.instance.ttl_expires_in = Some(ttl_expires_in);
    self
  }
  
  pub fn via_bot_user_id(&mut self, via_bot_user_id: i32) -> &mut Self {
    self.instance.via_bot_user_id = Some(via_bot_user_id);
    self
  }
  
  pub fn author_signature(&mut self, author_signature: String) -> &mut Self {
    self.instance.author_signature = Some(author_signature);
    self
  }
  
  pub fn views(&mut self, views: i32) -> &mut Self {
    self.instance.views = Some(views);
    self
  }
  
  pub fn media_album_id(&mut self, media_album_id: i64) -> &mut Self {
    self.instance.media_album_id = Some(media_album_id);
    self
  }
  
  pub fn content(&mut self, content: Box<MessageContent>) -> &mut Self {
    self.instance.content = Some(content);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}


/// This class is an abstract base class. Contains the content of a message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageContent: Debug {}



impl Object for MessageContent {}





/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageText

  /// Text of the message.
  text: Option<FormattedText>,
  /// A preview of the web page that's mentioned in the text; may be null.
  web_page: Option<WebPage>,


}



#[typetag::serde]
impl MessageContent for MessageText {}


impl MessageText {
  
  pub fn builder() -> MessageTextBuilder {
    let instance = Self {
      tdfname: "messageText".to_string(),
      text: None,
      web_page: None,
      
    };
    MessageTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  pub fn web_page(&self) -> &Option<WebPage> { &self.web_page }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageTextBuilder {
  instance: MessageText
}

impl MessageTextBuilder {
  fn new(instance: MessageText) -> Self { Self { instance } }

  pub fn build(&self) -> MessageText {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn web_page(&mut self, web_page: WebPage) -> &mut Self {
    self.instance.web_page = Some(web_page);
    self
  }
  
}


/// An animation message (GIF-style). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageAnimation

  /// Message content.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<FormattedText>,
  /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped.
  is_secret: Option<bool>,


}



#[typetag::serde]
impl MessageContent for MessageAnimation {}


impl MessageAnimation {
  
  pub fn builder() -> MessageAnimationBuilder {
    let instance = Self {
      tdfname: "messageAnimation".to_string(),
      animation: None,
      caption: None,
      is_secret: None,
      
    };
    MessageAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageAnimationBuilder {
  instance: MessageAnimation
}

impl MessageAnimationBuilder {
  fn new(instance: MessageAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> MessageAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}


/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageAudio

  /// Message content.
  audio: Option<Audio>,
  /// Audio caption.
  caption: Option<FormattedText>,


}



#[typetag::serde]
impl MessageContent for MessageAudio {}


impl MessageAudio {
  
  pub fn builder() -> MessageAudioBuilder {
    let instance = Self {
      tdfname: "messageAudio".to_string(),
      audio: None,
      caption: None,
      
    };
    MessageAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> &Option<Audio> { &self.audio }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageAudioBuilder {
  instance: MessageAudio
}

impl MessageAudioBuilder {
  fn new(instance: MessageAudio) -> Self { Self { instance } }

  pub fn build(&self) -> MessageAudio {
    self.instance.clone()
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A document message (general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageDocument

  /// Message content.
  document: Option<Document>,
  /// Document caption.
  caption: Option<FormattedText>,


}



#[typetag::serde]
impl MessageContent for MessageDocument {}


impl MessageDocument {
  
  pub fn builder() -> MessageDocumentBuilder {
    let instance = Self {
      tdfname: "messageDocument".to_string(),
      document: None,
      caption: None,
      
    };
    MessageDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> &Option<Document> { &self.document }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageDocumentBuilder {
  instance: MessageDocument
}

impl MessageDocumentBuilder {
  fn new(instance: MessageDocument) -> Self { Self { instance } }

  pub fn build(&self) -> MessageDocument {
    self.instance.clone()
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePhoto

  /// Message content.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<FormattedText>,
  /// True, if the photo must be blurred and must be shown only while tapped.
  is_secret: Option<bool>,


}



#[typetag::serde]
impl MessageContent for MessagePhoto {}


impl MessagePhoto {
  
  pub fn builder() -> MessagePhotoBuilder {
    let instance = Self {
      tdfname: "messagePhoto".to_string(),
      photo: None,
      caption: None,
      is_secret: None,
      
    };
    MessagePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePhotoBuilder {
  instance: MessagePhoto
}

impl MessagePhotoBuilder {
  fn new(instance: MessagePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}


/// An expired photo message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageExpiredPhoto

}



#[typetag::serde]
impl MessageContent for MessageExpiredPhoto {}


impl MessageExpiredPhoto {
  
  pub fn builder() -> MessageExpiredPhotoBuilder {
    let instance = Self {
      tdfname: "messageExpiredPhoto".to_string(),
      
    };
    MessageExpiredPhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageExpiredPhotoBuilder {
  instance: MessageExpiredPhoto
}

impl MessageExpiredPhotoBuilder {
  fn new(instance: MessageExpiredPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageExpiredPhoto {
    self.instance.clone()
  }
  
}


/// A sticker message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageSticker

  /// Message content.
  sticker: Option<Sticker>,


}



#[typetag::serde]
impl MessageContent for MessageSticker {}


impl MessageSticker {
  
  pub fn builder() -> MessageStickerBuilder {
    let instance = Self {
      tdfname: "messageSticker".to_string(),
      sticker: None,
      
    };
    MessageStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Sticker> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageStickerBuilder {
  instance: MessageSticker
}

impl MessageStickerBuilder {
  fn new(instance: MessageSticker) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSticker {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageVideo

  /// Message content.
  video: Option<Video>,
  /// Video caption.
  caption: Option<FormattedText>,
  /// True, if the video thumbnail must be blurred and the video must be shown only while tapped.
  is_secret: Option<bool>,


}



#[typetag::serde]
impl MessageContent for MessageVideo {}


impl MessageVideo {
  
  pub fn builder() -> MessageVideoBuilder {
    let instance = Self {
      tdfname: "messageVideo".to_string(),
      video: None,
      caption: None,
      is_secret: None,
      
    };
    MessageVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> &Option<Video> { &self.video }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageVideoBuilder {
  instance: MessageVideo
}

impl MessageVideoBuilder {
  fn new(instance: MessageVideo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVideo {
    self.instance.clone()
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}


/// An expired video message (self-destructed after TTL has elapsed). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageExpiredVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageExpiredVideo

}



#[typetag::serde]
impl MessageContent for MessageExpiredVideo {}


impl MessageExpiredVideo {
  
  pub fn builder() -> MessageExpiredVideoBuilder {
    let instance = Self {
      tdfname: "messageExpiredVideo".to_string(),
      
    };
    MessageExpiredVideoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageExpiredVideoBuilder {
  instance: MessageExpiredVideo
}

impl MessageExpiredVideoBuilder {
  fn new(instance: MessageExpiredVideo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageExpiredVideo {
    self.instance.clone()
  }
  
}


/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageVideoNote

  /// Message content.
  video_note: Option<VideoNote>,
  /// True, if at least one of the recipients has viewed the video note.
  is_viewed: Option<bool>,
  /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped.
  is_secret: Option<bool>,


}



#[typetag::serde]
impl MessageContent for MessageVideoNote {}


impl MessageVideoNote {
  
  pub fn builder() -> MessageVideoNoteBuilder {
    let instance = Self {
      tdfname: "messageVideoNote".to_string(),
      video_note: None,
      is_viewed: None,
      is_secret: None,
      
    };
    MessageVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> &Option<VideoNote> { &self.video_note }
  
  pub fn is_viewed(&self) -> &Option<bool> { &self.is_viewed }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageVideoNoteBuilder {
  instance: MessageVideoNote
}

impl MessageVideoNoteBuilder {
  fn new(instance: MessageVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVideoNote {
    self.instance.clone()
  }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
}


/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageVoiceNote

  /// Message content.
  voice_note: Option<VoiceNote>,
  /// Voice note caption.
  caption: Option<FormattedText>,
  /// True, if at least one of the recipients has listened to the voice note.
  is_listened: Option<bool>,


}



#[typetag::serde]
impl MessageContent for MessageVoiceNote {}


impl MessageVoiceNote {
  
  pub fn builder() -> MessageVoiceNoteBuilder {
    let instance = Self {
      tdfname: "messageVoiceNote".to_string(),
      voice_note: None,
      caption: None,
      is_listened: None,
      
    };
    MessageVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> &Option<VoiceNote> { &self.voice_note }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  pub fn is_listened(&self) -> &Option<bool> { &self.is_listened }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageVoiceNoteBuilder {
  instance: MessageVoiceNote
}

impl MessageVoiceNoteBuilder {
  fn new(instance: MessageVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVoiceNote {
    self.instance.clone()
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_listened(&mut self, is_listened: bool) -> &mut Self {
    self.instance.is_listened = Some(is_listened);
    self
  }
  
}


/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageLocation

  /// Message content.
  location: Option<Location>,
  /// Time relative to the message sent date until which the location can be updated, in seconds.
  live_period: Option<i32>,
  /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes.
  expires_in: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageLocation {}


impl MessageLocation {
  
  pub fn builder() -> MessageLocationBuilder {
    let instance = Self {
      tdfname: "messageLocation".to_string(),
      location: None,
      live_period: None,
      expires_in: None,
      
    };
    MessageLocationBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn live_period(&self) -> &Option<i32> { &self.live_period }
  
  pub fn expires_in(&self) -> &Option<i32> { &self.expires_in }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageLocationBuilder {
  instance: MessageLocation
}

impl MessageLocationBuilder {
  fn new(instance: MessageLocation) -> Self { Self { instance } }

  pub fn build(&self) -> MessageLocation {
    self.instance.clone()
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn live_period(&mut self, live_period: i32) -> &mut Self {
    self.instance.live_period = Some(live_period);
    self
  }
  
  pub fn expires_in(&mut self, expires_in: i32) -> &mut Self {
    self.instance.expires_in = Some(expires_in);
    self
  }
  
}


/// A message with information about a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageVenue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageVenue

  /// Message content.
  venue: Option<Venue>,


}



#[typetag::serde]
impl MessageContent for MessageVenue {}


impl MessageVenue {
  
  pub fn builder() -> MessageVenueBuilder {
    let instance = Self {
      tdfname: "messageVenue".to_string(),
      venue: None,
      
    };
    MessageVenueBuilder::new(instance)
  }
  
  
  pub fn venue(&self) -> &Option<Venue> { &self.venue }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageVenueBuilder {
  instance: MessageVenue
}

impl MessageVenueBuilder {
  fn new(instance: MessageVenue) -> Self { Self { instance } }

  pub fn build(&self) -> MessageVenue {
    self.instance.clone()
  }
  
  pub fn venue(&mut self, venue: Venue) -> &mut Self {
    self.instance.venue = Some(venue);
    self
  }
  
}


/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageContact

  /// Message content.
  contact: Option<Contact>,


}



#[typetag::serde]
impl MessageContent for MessageContact {}


impl MessageContact {
  
  pub fn builder() -> MessageContactBuilder {
    let instance = Self {
      tdfname: "messageContact".to_string(),
      contact: None,
      
    };
    MessageContactBuilder::new(instance)
  }
  
  
  pub fn contact(&self) -> &Option<Contact> { &self.contact }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageContactBuilder {
  instance: MessageContact
}

impl MessageContactBuilder {
  fn new(instance: MessageContact) -> Self { Self { instance } }

  pub fn build(&self) -> MessageContact {
    self.instance.clone()
  }
  
  pub fn contact(&mut self, contact: Contact) -> &mut Self {
    self.instance.contact = Some(contact);
    self
  }
  
}


/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageGame

  /// Game.
  game: Option<Game>,


}



#[typetag::serde]
impl MessageContent for MessageGame {}


impl MessageGame {
  
  pub fn builder() -> MessageGameBuilder {
    let instance = Self {
      tdfname: "messageGame".to_string(),
      game: None,
      
    };
    MessageGameBuilder::new(instance)
  }
  
  
  pub fn game(&self) -> &Option<Game> { &self.game }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageGameBuilder {
  instance: MessageGame
}

impl MessageGameBuilder {
  fn new(instance: MessageGame) -> Self { Self { instance } }

  pub fn build(&self) -> MessageGame {
    self.instance.clone()
  }
  
  pub fn game(&mut self, game: Game) -> &mut Self {
    self.instance.game = Some(game);
    self
  }
  
}


/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePoll

  /// Poll.
  poll: Option<Poll>,


}



#[typetag::serde]
impl MessageContent for MessagePoll {}


impl MessagePoll {
  
  pub fn builder() -> MessagePollBuilder {
    let instance = Self {
      tdfname: "messagePoll".to_string(),
      poll: None,
      
    };
    MessagePollBuilder::new(instance)
  }
  
  
  pub fn poll(&self) -> &Option<Poll> { &self.poll }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePollBuilder {
  instance: MessagePoll
}

impl MessagePollBuilder {
  fn new(instance: MessagePoll) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePoll {
    self.instance.clone()
  }
  
  pub fn poll(&mut self, poll: Poll) -> &mut Self {
    self.instance.poll = Some(poll);
    self
  }
  
}


/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageInvoice

  /// Product title.
  title: Option<String>,
  /// Product description.
  description: Option<String>,
  /// Product photo; may be null.
  photo: Option<Photo>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Product total price in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}.
  start_parameter: Option<String>,
  /// True, if the invoice is a test invoice.
  is_test: Option<bool>,
  /// True, if the shipping address should be specified.
  need_shipping_address: Option<bool>,
  /// The identifier of the message with the receipt, after the product has been purchased.
  receipt_message_id: Option<i64>,


}



#[typetag::serde]
impl MessageContent for MessageInvoice {}


impl MessageInvoice {
  
  pub fn builder() -> MessageInvoiceBuilder {
    let instance = Self {
      tdfname: "messageInvoice".to_string(),
      title: None,
      description: None,
      photo: None,
      currency: None,
      total_amount: None,
      start_parameter: None,
      is_test: None,
      need_shipping_address: None,
      receipt_message_id: None,
      
    };
    MessageInvoiceBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn currency(&self) -> &Option<String> { &self.currency }
  
  pub fn total_amount(&self) -> &Option<i64> { &self.total_amount }
  
  pub fn start_parameter(&self) -> &Option<String> { &self.start_parameter }
  
  pub fn is_test(&self) -> &Option<bool> { &self.is_test }
  
  pub fn need_shipping_address(&self) -> &Option<bool> { &self.need_shipping_address }
  
  pub fn receipt_message_id(&self) -> &Option<i64> { &self.receipt_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageInvoiceBuilder {
  instance: MessageInvoice
}

impl MessageInvoiceBuilder {
  fn new(instance: MessageInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> MessageInvoice {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn currency(&mut self, currency: String) -> &mut Self {
    self.instance.currency = Some(currency);
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
  pub fn start_parameter(&mut self, start_parameter: String) -> &mut Self {
    self.instance.start_parameter = Some(start_parameter);
    self
  }
  
  pub fn is_test(&mut self, is_test: bool) -> &mut Self {
    self.instance.is_test = Some(is_test);
    self
  }
  
  pub fn need_shipping_address(&mut self, need_shipping_address: bool) -> &mut Self {
    self.instance.need_shipping_address = Some(need_shipping_address);
    self
  }
  
  pub fn receipt_message_id(&mut self, receipt_message_id: i64) -> &mut Self {
    self.instance.receipt_message_id = Some(receipt_message_id);
    self
  }
  
}


/// A message with information about an ended call. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageCall

  /// Reason why the call was discarded.
  discard_reason: Option<Box<CallDiscardReason>>,
  /// Call duration, in seconds.
  duration: Option<i32>,


}


impl Clone for MessageCall {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl MessageContent for MessageCall {}


impl MessageCall {
  
  pub fn builder() -> MessageCallBuilder {
    let instance = Self {
      tdfname: "messageCall".to_string(),
      discard_reason: None,
      duration: None,
      
    };
    MessageCallBuilder::new(instance)
  }
  
  
  pub fn discard_reason(&self) -> &Option<Box<CallDiscardReason>> { &self.discard_reason }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageCallBuilder {
  instance: MessageCall
}

impl MessageCallBuilder {
  fn new(instance: MessageCall) -> Self { Self { instance } }

  pub fn build(&self) -> MessageCall {
    self.instance.clone()
  }
  
  pub fn discard_reason(&mut self, discard_reason: Box<CallDiscardReason>) -> &mut Self {
    self.instance.discard_reason = Some(discard_reason);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
}


/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageBasicGroupChatCreate

  /// Title of the basic group.
  title: Option<String>,
  /// User identifiers of members in the basic group.
  member_user_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl MessageContent for MessageBasicGroupChatCreate {}


impl MessageBasicGroupChatCreate {
  
  pub fn builder() -> MessageBasicGroupChatCreateBuilder {
    let instance = Self {
      tdfname: "messageBasicGroupChatCreate".to_string(),
      title: None,
      member_user_ids: None,
      
    };
    MessageBasicGroupChatCreateBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn member_user_ids(&self) -> &Option<Vec<i32>> { &self.member_user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageBasicGroupChatCreateBuilder {
  instance: MessageBasicGroupChatCreate
}

impl MessageBasicGroupChatCreateBuilder {
  fn new(instance: MessageBasicGroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> MessageBasicGroupChatCreate {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
}


/// A newly created supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSupergroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageSupergroupChatCreate

  /// Title of the supergroup or channel.
  title: Option<String>,


}



#[typetag::serde]
impl MessageContent for MessageSupergroupChatCreate {}


impl MessageSupergroupChatCreate {
  
  pub fn builder() -> MessageSupergroupChatCreateBuilder {
    let instance = Self {
      tdfname: "messageSupergroupChatCreate".to_string(),
      title: None,
      
    };
    MessageSupergroupChatCreateBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageSupergroupChatCreateBuilder {
  instance: MessageSupergroupChatCreate
}

impl MessageSupergroupChatCreateBuilder {
  fn new(instance: MessageSupergroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSupergroupChatCreate {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// An updated chat title. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatChangeTitle

  /// New chat title.
  title: Option<String>,


}



#[typetag::serde]
impl MessageContent for MessageChatChangeTitle {}


impl MessageChatChangeTitle {
  
  pub fn builder() -> MessageChatChangeTitleBuilder {
    let instance = Self {
      tdfname: "messageChatChangeTitle".to_string(),
      title: None,
      
    };
    MessageChatChangeTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatChangeTitleBuilder {
  instance: MessageChatChangeTitle
}

impl MessageChatChangeTitleBuilder {
  fn new(instance: MessageChatChangeTitle) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatChangeTitle {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// An updated chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatChangePhoto

  /// New chat photo.
  photo: Option<Photo>,


}



#[typetag::serde]
impl MessageContent for MessageChatChangePhoto {}


impl MessageChatChangePhoto {
  
  pub fn builder() -> MessageChatChangePhotoBuilder {
    let instance = Self {
      tdfname: "messageChatChangePhoto".to_string(),
      photo: None,
      
    };
    MessageChatChangePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatChangePhotoBuilder {
  instance: MessageChatChangePhoto
}

impl MessageChatChangePhotoBuilder {
  fn new(instance: MessageChatChangePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatChangePhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}


/// A deleted chat photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeletePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatDeletePhoto

}



#[typetag::serde]
impl MessageContent for MessageChatDeletePhoto {}


impl MessageChatDeletePhoto {
  
  pub fn builder() -> MessageChatDeletePhotoBuilder {
    let instance = Self {
      tdfname: "messageChatDeletePhoto".to_string(),
      
    };
    MessageChatDeletePhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatDeletePhotoBuilder {
  instance: MessageChatDeletePhoto
}

impl MessageChatDeletePhotoBuilder {
  fn new(instance: MessageChatDeletePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatDeletePhoto {
    self.instance.clone()
  }
  
}


/// New chat members were added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatAddMembers

  /// User identifiers of the new members.
  member_user_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl MessageContent for MessageChatAddMembers {}


impl MessageChatAddMembers {
  
  pub fn builder() -> MessageChatAddMembersBuilder {
    let instance = Self {
      tdfname: "messageChatAddMembers".to_string(),
      member_user_ids: None,
      
    };
    MessageChatAddMembersBuilder::new(instance)
  }
  
  
  pub fn member_user_ids(&self) -> &Option<Vec<i32>> { &self.member_user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatAddMembersBuilder {
  instance: MessageChatAddMembers
}

impl MessageChatAddMembersBuilder {
  fn new(instance: MessageChatAddMembers) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatAddMembers {
    self.instance.clone()
  }
  
  pub fn member_user_ids(&mut self, member_user_ids: Vec<i32>) -> &mut Self {
    self.instance.member_user_ids = Some(member_user_ids);
    self
  }
  
}


/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatJoinByLink

}



#[typetag::serde]
impl MessageContent for MessageChatJoinByLink {}


impl MessageChatJoinByLink {
  
  pub fn builder() -> MessageChatJoinByLinkBuilder {
    let instance = Self {
      tdfname: "messageChatJoinByLink".to_string(),
      
    };
    MessageChatJoinByLinkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatJoinByLinkBuilder {
  instance: MessageChatJoinByLink
}

impl MessageChatJoinByLinkBuilder {
  fn new(instance: MessageChatJoinByLink) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatJoinByLink {
    self.instance.clone()
  }
  
}


/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatDeleteMember

  /// User identifier of the deleted chat member.
  user_id: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageChatDeleteMember {}


impl MessageChatDeleteMember {
  
  pub fn builder() -> MessageChatDeleteMemberBuilder {
    let instance = Self {
      tdfname: "messageChatDeleteMember".to_string(),
      user_id: None,
      
    };
    MessageChatDeleteMemberBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatDeleteMemberBuilder {
  instance: MessageChatDeleteMember
}

impl MessageChatDeleteMemberBuilder {
  fn new(instance: MessageChatDeleteMember) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatDeleteMember {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// A basic group was upgraded to a supergroup and was deactivated as the result. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeTo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatUpgradeTo

  /// Identifier of the supergroup to which the basic group was upgraded.
  supergroup_id: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageChatUpgradeTo {}


impl MessageChatUpgradeTo {
  
  pub fn builder() -> MessageChatUpgradeToBuilder {
    let instance = Self {
      tdfname: "messageChatUpgradeTo".to_string(),
      supergroup_id: None,
      
    };
    MessageChatUpgradeToBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatUpgradeToBuilder {
  instance: MessageChatUpgradeTo
}

impl MessageChatUpgradeToBuilder {
  fn new(instance: MessageChatUpgradeTo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatUpgradeTo {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}


/// A supergroup has been created from a basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatUpgradeFrom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatUpgradeFrom

  /// Title of the newly created supergroup.
  title: Option<String>,
  /// The identifier of the original basic group.
  basic_group_id: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageChatUpgradeFrom {}


impl MessageChatUpgradeFrom {
  
  pub fn builder() -> MessageChatUpgradeFromBuilder {
    let instance = Self {
      tdfname: "messageChatUpgradeFrom".to_string(),
      title: None,
      basic_group_id: None,
      
    };
    MessageChatUpgradeFromBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatUpgradeFromBuilder {
  instance: MessageChatUpgradeFrom
}

impl MessageChatUpgradeFromBuilder {
  fn new(instance: MessageChatUpgradeFrom) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatUpgradeFrom {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}


/// A message has been pinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePinMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePinMessage

  /// Identifier of the pinned message, can be an identifier of a deleted message or 0.
  message_id: Option<i64>,


}



#[typetag::serde]
impl MessageContent for MessagePinMessage {}


impl MessagePinMessage {
  
  pub fn builder() -> MessagePinMessageBuilder {
    let instance = Self {
      tdfname: "messagePinMessage".to_string(),
      message_id: None,
      
    };
    MessagePinMessageBuilder::new(instance)
  }
  
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePinMessageBuilder {
  instance: MessagePinMessage
}

impl MessagePinMessageBuilder {
  fn new(instance: MessagePinMessage) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePinMessage {
    self.instance.clone()
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageScreenshotTaken

}



#[typetag::serde]
impl MessageContent for MessageScreenshotTaken {}


impl MessageScreenshotTaken {
  
  pub fn builder() -> MessageScreenshotTakenBuilder {
    let instance = Self {
      tdfname: "messageScreenshotTaken".to_string(),
      
    };
    MessageScreenshotTakenBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageScreenshotTakenBuilder {
  instance: MessageScreenshotTaken
}

impl MessageScreenshotTakenBuilder {
  fn new(instance: MessageScreenshotTaken) -> Self { Self { instance } }

  pub fn build(&self) -> MessageScreenshotTaken {
    self.instance.clone()
  }
  
}


/// The TTL (Time To Live) setting messages in a secret chat has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageChatSetTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageChatSetTtl

  /// New TTL.
  ttl: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageChatSetTtl {}


impl MessageChatSetTtl {
  
  pub fn builder() -> MessageChatSetTtlBuilder {
    let instance = Self {
      tdfname: "messageChatSetTtl".to_string(),
      ttl: None,
      
    };
    MessageChatSetTtlBuilder::new(instance)
  }
  
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageChatSetTtlBuilder {
  instance: MessageChatSetTtl
}

impl MessageChatSetTtlBuilder {
  fn new(instance: MessageChatSetTtl) -> Self { Self { instance } }

  pub fn build(&self) -> MessageChatSetTtl {
    self.instance.clone()
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}


/// A non-standard action has happened in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageCustomServiceAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageCustomServiceAction

  /// Message text to be shown in the chat.
  text: Option<String>,


}



#[typetag::serde]
impl MessageContent for MessageCustomServiceAction {}


impl MessageCustomServiceAction {
  
  pub fn builder() -> MessageCustomServiceActionBuilder {
    let instance = Self {
      tdfname: "messageCustomServiceAction".to_string(),
      text: None,
      
    };
    MessageCustomServiceActionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageCustomServiceActionBuilder {
  instance: MessageCustomServiceAction
}

impl MessageCustomServiceActionBuilder {
  fn new(instance: MessageCustomServiceAction) -> Self { Self { instance } }

  pub fn build(&self) -> MessageCustomServiceAction {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageGameScore

  /// Identifier of the message with the game, can be an identifier of a deleted message.
  game_message_id: Option<i64>,
  /// Identifier of the game; may be different from the games presented in the message with the game.
  game_id: Option<i64>,
  /// New score.
  score: Option<i32>,


}



#[typetag::serde]
impl MessageContent for MessageGameScore {}


impl MessageGameScore {
  
  pub fn builder() -> MessageGameScoreBuilder {
    let instance = Self {
      tdfname: "messageGameScore".to_string(),
      game_message_id: None,
      game_id: None,
      score: None,
      
    };
    MessageGameScoreBuilder::new(instance)
  }
  
  
  pub fn game_message_id(&self) -> &Option<i64> { &self.game_message_id }
  
  pub fn game_id(&self) -> &Option<i64> { &self.game_id }
  
  pub fn score(&self) -> &Option<i32> { &self.score }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageGameScoreBuilder {
  instance: MessageGameScore
}

impl MessageGameScoreBuilder {
  fn new(instance: MessageGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> MessageGameScore {
    self.instance.clone()
  }
  
  pub fn game_message_id(&mut self, game_message_id: i64) -> &mut Self {
    self.instance.game_message_id = Some(game_message_id);
    self
  }
  
  pub fn game_id(&mut self, game_id: i64) -> &mut Self {
    self.instance.game_id = Some(game_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
}


/// A payment has been completed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessful {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePaymentSuccessful

  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for the price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,


}



#[typetag::serde]
impl MessageContent for MessagePaymentSuccessful {}


impl MessagePaymentSuccessful {
  
  pub fn builder() -> MessagePaymentSuccessfulBuilder {
    let instance = Self {
      tdfname: "messagePaymentSuccessful".to_string(),
      invoice_message_id: None,
      currency: None,
      total_amount: None,
      
    };
    MessagePaymentSuccessfulBuilder::new(instance)
  }
  
  
  pub fn invoice_message_id(&self) -> &Option<i64> { &self.invoice_message_id }
  
  pub fn currency(&self) -> &Option<String> { &self.currency }
  
  pub fn total_amount(&self) -> &Option<i64> { &self.total_amount }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePaymentSuccessfulBuilder {
  instance: MessagePaymentSuccessful
}

impl MessagePaymentSuccessfulBuilder {
  fn new(instance: MessagePaymentSuccessful) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePaymentSuccessful {
    self.instance.clone()
  }
  
  pub fn invoice_message_id(&mut self, invoice_message_id: i64) -> &mut Self {
    self.instance.invoice_message_id = Some(invoice_message_id);
    self
  }
  
  pub fn currency(&mut self, currency: String) -> &mut Self {
    self.instance.currency = Some(currency);
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
}


/// A payment has been completed; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePaymentSuccessfulBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePaymentSuccessfulBot

  /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message.
  invoice_message_id: Option<i64>,
  /// Currency for price of the product.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of the shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,
  /// Telegram payment identifier.
  telegram_payment_charge_id: Option<String>,
  /// Provider payment identifier.
  provider_payment_charge_id: Option<String>,


}



#[typetag::serde]
impl MessageContent for MessagePaymentSuccessfulBot {}


impl MessagePaymentSuccessfulBot {
  
  pub fn builder() -> MessagePaymentSuccessfulBotBuilder {
    let instance = Self {
      tdfname: "messagePaymentSuccessfulBot".to_string(),
      invoice_message_id: None,
      currency: None,
      total_amount: None,
      invoice_payload: None,
      shipping_option_id: None,
      order_info: None,
      telegram_payment_charge_id: None,
      provider_payment_charge_id: None,
      
    };
    MessagePaymentSuccessfulBotBuilder::new(instance)
  }
  
  
  pub fn invoice_message_id(&self) -> &Option<i64> { &self.invoice_message_id }
  
  pub fn currency(&self) -> &Option<String> { &self.currency }
  
  pub fn total_amount(&self) -> &Option<i64> { &self.total_amount }
  
  pub fn invoice_payload(&self) -> &Option<String> { &self.invoice_payload }
  
  pub fn shipping_option_id(&self) -> &Option<String> { &self.shipping_option_id }
  
  pub fn order_info(&self) -> &Option<OrderInfo> { &self.order_info }
  
  pub fn telegram_payment_charge_id(&self) -> &Option<String> { &self.telegram_payment_charge_id }
  
  pub fn provider_payment_charge_id(&self) -> &Option<String> { &self.provider_payment_charge_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePaymentSuccessfulBotBuilder {
  instance: MessagePaymentSuccessfulBot
}

impl MessagePaymentSuccessfulBotBuilder {
  fn new(instance: MessagePaymentSuccessfulBot) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePaymentSuccessfulBot {
    self.instance.clone()
  }
  
  pub fn invoice_message_id(&mut self, invoice_message_id: i64) -> &mut Self {
    self.instance.invoice_message_id = Some(invoice_message_id);
    self
  }
  
  pub fn currency(&mut self, currency: String) -> &mut Self {
    self.instance.currency = Some(currency);
    self
  }
  
  pub fn total_amount(&mut self, total_amount: i64) -> &mut Self {
    self.instance.total_amount = Some(total_amount);
    self
  }
  
  pub fn invoice_payload(&mut self, invoice_payload: String) -> &mut Self {
    self.instance.invoice_payload = Some(invoice_payload);
    self
  }
  
  pub fn shipping_option_id(&mut self, shipping_option_id: String) -> &mut Self {
    self.instance.shipping_option_id = Some(shipping_option_id);
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn telegram_payment_charge_id(&mut self, telegram_payment_charge_id: String) -> &mut Self {
    self.instance.telegram_payment_charge_id = Some(telegram_payment_charge_id);
    self
  }
  
  pub fn provider_payment_charge_id(&mut self, provider_payment_charge_id: String) -> &mut Self {
    self.instance.provider_payment_charge_id = Some(provider_payment_charge_id);
    self
  }
  
}


/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageContactRegistered

}



#[typetag::serde]
impl MessageContent for MessageContactRegistered {}


impl MessageContactRegistered {
  
  pub fn builder() -> MessageContactRegisteredBuilder {
    let instance = Self {
      tdfname: "messageContactRegistered".to_string(),
      
    };
    MessageContactRegisteredBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageContactRegisteredBuilder {
  instance: MessageContactRegistered
}

impl MessageContactRegisteredBuilder {
  fn new(instance: MessageContactRegistered) -> Self { Self { instance } }

  pub fn build(&self) -> MessageContactRegistered {
    self.instance.clone()
  }
  
}


/// The current user has connected a website by logging in using Telegram Login Widget on it. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageWebsiteConnected {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageWebsiteConnected

  /// Domain name of the connected website.
  domain_name: Option<String>,


}



#[typetag::serde]
impl MessageContent for MessageWebsiteConnected {}


impl MessageWebsiteConnected {
  
  pub fn builder() -> MessageWebsiteConnectedBuilder {
    let instance = Self {
      tdfname: "messageWebsiteConnected".to_string(),
      domain_name: None,
      
    };
    MessageWebsiteConnectedBuilder::new(instance)
  }
  
  
  pub fn domain_name(&self) -> &Option<String> { &self.domain_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageWebsiteConnectedBuilder {
  instance: MessageWebsiteConnected
}

impl MessageWebsiteConnectedBuilder {
  fn new(instance: MessageWebsiteConnected) -> Self { Self { instance } }

  pub fn build(&self) -> MessageWebsiteConnected {
    self.instance.clone()
  }
  
  pub fn domain_name(&mut self, domain_name: String) -> &mut Self {
    self.instance.domain_name = Some(domain_name);
    self
  }
  
}


/// Telegram Passport data has been sent. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessagePassportDataSent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePassportDataSent

  /// List of Telegram Passport element types sent.
  types: Option<Vec<Box<PassportElementType>>>,


}


impl Clone for MessagePassportDataSent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl MessageContent for MessagePassportDataSent {}


impl MessagePassportDataSent {
  
  pub fn builder() -> MessagePassportDataSentBuilder {
    let instance = Self {
      tdfname: "messagePassportDataSent".to_string(),
      types: None,
      
    };
    MessagePassportDataSentBuilder::new(instance)
  }
  
  
  pub fn types(&self) -> &Option<Vec<Box<PassportElementType>>> { &self.types }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePassportDataSentBuilder {
  instance: MessagePassportDataSent
}

impl MessagePassportDataSentBuilder {
  fn new(instance: MessagePassportDataSent) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePassportDataSent {
    self.instance.clone()
  }
  
  pub fn types(&mut self, types: Vec<Box<PassportElementType>>) -> &mut Self {
    self.instance.types = Some(types);
    self
  }
  
}


/// Telegram Passport data has been received; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessagePassportDataReceived {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messagePassportDataReceived

  /// List of received Telegram Passport elements.
  elements: Option<Vec<EncryptedPassportElement>>,
  /// Encrypted data credentials.
  credentials: Option<EncryptedCredentials>,


}



#[typetag::serde]
impl MessageContent for MessagePassportDataReceived {}


impl MessagePassportDataReceived {
  
  pub fn builder() -> MessagePassportDataReceivedBuilder {
    let instance = Self {
      tdfname: "messagePassportDataReceived".to_string(),
      elements: None,
      credentials: None,
      
    };
    MessagePassportDataReceivedBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> &Option<Vec<EncryptedPassportElement>> { &self.elements }
  
  pub fn credentials(&self) -> &Option<EncryptedCredentials> { &self.credentials }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagePassportDataReceivedBuilder {
  instance: MessagePassportDataReceived
}

impl MessagePassportDataReceivedBuilder {
  fn new(instance: MessagePassportDataReceived) -> Self { Self { instance } }

  pub fn build(&self) -> MessagePassportDataReceived {
    self.instance.clone()
  }
  
  pub fn elements(&mut self, elements: Vec<EncryptedPassportElement>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
  pub fn credentials(&mut self, credentials: EncryptedCredentials) -> &mut Self {
    self.instance.credentials = Some(credentials);
    self
  }
  
}


/// Message content that is not supported by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageUnsupported {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageUnsupported

}



#[typetag::serde]
impl MessageContent for MessageUnsupported {}


impl MessageUnsupported {
  
  pub fn builder() -> MessageUnsupportedBuilder {
    let instance = Self {
      tdfname: "messageUnsupported".to_string(),
      
    };
    MessageUnsupportedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageUnsupportedBuilder {
  instance: MessageUnsupported
}

impl MessageUnsupportedBuilder {
  fn new(instance: MessageUnsupported) -> Self { Self { instance } }

  pub fn build(&self) -> MessageUnsupported {
    self.instance.clone()
  }
  
}


/// Contains information about a forwarded message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct MessageForwardInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageForwardInfo

  /// Origin of a forwarded message.
  origin: Option<Box<MessageForwardOrigin>>,
  /// Point in time (Unix timestamp) when the message was originally sent.
  date: Option<i32>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the chat from which the message was forwarded last time; 0 if unknown.
  from_chat_id: Option<i64>,
  /// For messages forwarded to the chat with the current user (saved messages), the identifier of the original message from which the new message was forwarded last time; 0 if unknown.
  from_message_id: Option<i64>,


}


impl Clone for MessageForwardInfo {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for MessageForwardInfo {}


impl MessageForwardInfo {
  
  pub fn builder() -> MessageForwardInfoBuilder {
    let instance = Self {
      tdfname: "messageForwardInfo".to_string(),
      origin: None,
      date: None,
      from_chat_id: None,
      from_message_id: None,
      
    };
    MessageForwardInfoBuilder::new(instance)
  }
  
  
  pub fn origin(&self) -> &Option<Box<MessageForwardOrigin>> { &self.origin }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn from_chat_id(&self) -> &Option<i64> { &self.from_chat_id }
  
  pub fn from_message_id(&self) -> &Option<i64> { &self.from_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageForwardInfoBuilder {
  instance: MessageForwardInfo
}

impl MessageForwardInfoBuilder {
  fn new(instance: MessageForwardInfo) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardInfo {
    self.instance.clone()
  }
  
  pub fn origin(&mut self, origin: Box<MessageForwardOrigin>) -> &mut Self {
    self.instance.origin = Some(origin);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
}


/// This class is an abstract base class. Contains information about the origin of a forwarded message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageForwardOrigin: Debug {}



impl Object for MessageForwardOrigin {}





/// The message was originally written by a known user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageForwardOriginUser

  /// Identifier of the user that originally sent the message.
  sender_user_id: Option<i32>,


}



#[typetag::serde]
impl MessageForwardOrigin for MessageForwardOriginUser {}


impl MessageForwardOriginUser {
  
  pub fn builder() -> MessageForwardOriginUserBuilder {
    let instance = Self {
      tdfname: "messageForwardOriginUser".to_string(),
      sender_user_id: None,
      
    };
    MessageForwardOriginUserBuilder::new(instance)
  }
  
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageForwardOriginUserBuilder {
  instance: MessageForwardOriginUser
}

impl MessageForwardOriginUserBuilder {
  fn new(instance: MessageForwardOriginUser) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginUser {
    self.instance.clone()
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
}


/// The message was originally written by a user, which is hidden by his privacy settings. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginHiddenUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageForwardOriginHiddenUser

  /// Name of the sender.
  sender_name: Option<String>,


}



#[typetag::serde]
impl MessageForwardOrigin for MessageForwardOriginHiddenUser {}


impl MessageForwardOriginHiddenUser {
  
  pub fn builder() -> MessageForwardOriginHiddenUserBuilder {
    let instance = Self {
      tdfname: "messageForwardOriginHiddenUser".to_string(),
      sender_name: None,
      
    };
    MessageForwardOriginHiddenUserBuilder::new(instance)
  }
  
  
  pub fn sender_name(&self) -> &Option<String> { &self.sender_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageForwardOriginHiddenUserBuilder {
  instance: MessageForwardOriginHiddenUser
}

impl MessageForwardOriginHiddenUserBuilder {
  fn new(instance: MessageForwardOriginHiddenUser) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginHiddenUser {
    self.instance.clone()
  }
  
  pub fn sender_name(&mut self, sender_name: String) -> &mut Self {
    self.instance.sender_name = Some(sender_name);
    self
  }
  
}


/// The message was originally a post in a channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageForwardOriginChannel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageForwardOriginChannel

  /// Identifier of the chat from which the message was originally forwarded.
  chat_id: Option<i64>,
  /// Message identifier of the original message; 0 if unknown.
  message_id: Option<i64>,
  /// Original post author signature.
  author_signature: Option<String>,


}



#[typetag::serde]
impl MessageForwardOrigin for MessageForwardOriginChannel {}


impl MessageForwardOriginChannel {
  
  pub fn builder() -> MessageForwardOriginChannelBuilder {
    let instance = Self {
      tdfname: "messageForwardOriginChannel".to_string(),
      chat_id: None,
      message_id: None,
      author_signature: None,
      
    };
    MessageForwardOriginChannelBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn author_signature(&self) -> &Option<String> { &self.author_signature }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageForwardOriginChannelBuilder {
  instance: MessageForwardOriginChannel
}

impl MessageForwardOriginChannelBuilder {
  fn new(instance: MessageForwardOriginChannel) -> Self { Self { instance } }

  pub fn build(&self) -> MessageForwardOriginChannel {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn author_signature(&mut self, author_signature: String) -> &mut Self {
    self.instance.author_signature = Some(author_signature);
    self
  }
  
}


/// This class is an abstract base class. Contains information about the sending state of the message. 
#[typetag::serde(tag = "@struct")]
pub trait MessageSendingState: Debug {}



impl Object for MessageSendingState {}





/// The message is being sent now, but has not yet been delivered to the server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageSendingStatePending

}



#[typetag::serde]
impl MessageSendingState for MessageSendingStatePending {}


impl MessageSendingStatePending {
  
  pub fn builder() -> MessageSendingStatePendingBuilder {
    let instance = Self {
      tdfname: "messageSendingStatePending".to_string(),
      
    };
    MessageSendingStatePendingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageSendingStatePendingBuilder {
  instance: MessageSendingStatePending
}

impl MessageSendingStatePendingBuilder {
  fn new(instance: MessageSendingStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSendingStatePending {
    self.instance.clone()
  }
  
}


/// The message failed to be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageSendingStateFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messageSendingStateFailed

}



#[typetag::serde]
impl MessageSendingState for MessageSendingStateFailed {}


impl MessageSendingStateFailed {
  
  pub fn builder() -> MessageSendingStateFailedBuilder {
    let instance = Self {
      tdfname: "messageSendingStateFailed".to_string(),
      
    };
    MessageSendingStateFailedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessageSendingStateFailedBuilder {
  instance: MessageSendingStateFailed
}

impl MessageSendingStateFailedBuilder {
  fn new(instance: MessageSendingStateFailed) -> Self { Self { instance } }

  pub fn build(&self) -> MessageSendingStateFailed {
    self.instance.clone()
  }
  
}


/// Contains a list of messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Messages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // messages

  /// Approximate total count of messages found.
  total_count: Option<i32>,
  /// List of messages; messages may be null.
  messages: Option<Vec<Message>>,


}




impl Object for Messages {}


impl Messages {
  
  pub fn builder() -> MessagesBuilder {
    let instance = Self {
      tdfname: "messages".to_string(),
      total_count: None,
      messages: None,
      
    };
    MessagesBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn messages(&self) -> &Option<Vec<Message>> { &self.messages }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct MessagesBuilder {
  instance: Messages
}

impl MessagesBuilder {
  fn new(instance: Messages) -> Self { Self { instance } }

  pub fn build(&self) -> Messages {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn messages(&mut self, messages: Vec<Message>) -> &mut Self {
    self.instance.messages = Some(messages);
    self
  }
  
}


/// A full list of available network statistic entries. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkStatistics

  /// Point in time (Unix timestamp) when the app began collecting statistics.
  since_date: Option<i32>,
  /// Network statistics entries.
  entries: Option<Vec<Box<NetworkStatisticsEntry>>>,


}


impl Clone for NetworkStatistics {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for NetworkStatistics {}


impl NetworkStatistics {
  
  pub fn builder() -> NetworkStatisticsBuilder {
    let instance = Self {
      tdfname: "networkStatistics".to_string(),
      since_date: None,
      entries: None,
      
    };
    NetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn since_date(&self) -> &Option<i32> { &self.since_date }
  
  pub fn entries(&self) -> &Option<Vec<Box<NetworkStatisticsEntry>>> { &self.entries }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkStatisticsBuilder {
  instance: NetworkStatistics
}

impl NetworkStatisticsBuilder {
  fn new(instance: NetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatistics {
    self.instance.clone()
  }
  
  pub fn since_date(&mut self, since_date: i32) -> &mut Self {
    self.instance.since_date = Some(since_date);
    self
  }
  
  pub fn entries(&mut self, entries: Vec<Box<NetworkStatisticsEntry>>) -> &mut Self {
    self.instance.entries = Some(entries);
    self
  }
  
}


/// This class is an abstract base class. Contains statistics about network usage. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkStatisticsEntry: Debug {}



impl Object for NetworkStatisticsEntry {}





/// Contains information about the total amount of data that was used to send and receive files. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkStatisticsEntryFile

  /// Type of the file the data is part of.
  file_type: Option<Box<FileType>>,
  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,


}


impl Clone for NetworkStatisticsEntryFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl NetworkStatisticsEntry for NetworkStatisticsEntryFile {}


impl NetworkStatisticsEntryFile {
  
  pub fn builder() -> NetworkStatisticsEntryFileBuilder {
    let instance = Self {
      tdfname: "networkStatisticsEntryFile".to_string(),
      file_type: None,
      network_type: None,
      sent_bytes: None,
      received_bytes: None,
      
    };
    NetworkStatisticsEntryFileBuilder::new(instance)
  }
  
  
  pub fn file_type(&self) -> &Option<Box<FileType>> { &self.file_type }
  
  pub fn network_type(&self) -> &Option<Box<NetworkType>> { &self.network_type }
  
  pub fn sent_bytes(&self) -> &Option<i64> { &self.sent_bytes }
  
  pub fn received_bytes(&self) -> &Option<i64> { &self.received_bytes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkStatisticsEntryFileBuilder {
  instance: NetworkStatisticsEntryFile
}

impl NetworkStatisticsEntryFileBuilder {
  fn new(instance: NetworkStatisticsEntryFile) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatisticsEntryFile {
    self.instance.clone()
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn network_type(&mut self, network_type: Box<NetworkType>) -> &mut Self {
    self.instance.network_type = Some(network_type);
    self
  }
  
  pub fn sent_bytes(&mut self, sent_bytes: i64) -> &mut Self {
    self.instance.sent_bytes = Some(sent_bytes);
    self
  }
  
  pub fn received_bytes(&mut self, received_bytes: i64) -> &mut Self {
    self.instance.received_bytes = Some(received_bytes);
    self
  }
  
}


/// Contains information about the total amount of data that was used for calls. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkStatisticsEntryCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkStatisticsEntryCall

  /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type.
  network_type: Option<Box<NetworkType>>,
  /// Total number of bytes sent.
  sent_bytes: Option<i64>,
  /// Total number of bytes received.
  received_bytes: Option<i64>,
  /// Total call duration, in seconds.
  duration: Option<f64>,


}


impl Clone for NetworkStatisticsEntryCall {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl NetworkStatisticsEntry for NetworkStatisticsEntryCall {}


impl NetworkStatisticsEntryCall {
  
  pub fn builder() -> NetworkStatisticsEntryCallBuilder {
    let instance = Self {
      tdfname: "networkStatisticsEntryCall".to_string(),
      network_type: None,
      sent_bytes: None,
      received_bytes: None,
      duration: None,
      
    };
    NetworkStatisticsEntryCallBuilder::new(instance)
  }
  
  
  pub fn network_type(&self) -> &Option<Box<NetworkType>> { &self.network_type }
  
  pub fn sent_bytes(&self) -> &Option<i64> { &self.sent_bytes }
  
  pub fn received_bytes(&self) -> &Option<i64> { &self.received_bytes }
  
  pub fn duration(&self) -> &Option<f64> { &self.duration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkStatisticsEntryCallBuilder {
  instance: NetworkStatisticsEntryCall
}

impl NetworkStatisticsEntryCallBuilder {
  fn new(instance: NetworkStatisticsEntryCall) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkStatisticsEntryCall {
    self.instance.clone()
  }
  
  pub fn network_type(&mut self, network_type: Box<NetworkType>) -> &mut Self {
    self.instance.network_type = Some(network_type);
    self
  }
  
  pub fn sent_bytes(&mut self, sent_bytes: i64) -> &mut Self {
    self.instance.sent_bytes = Some(sent_bytes);
    self
  }
  
  pub fn received_bytes(&mut self, received_bytes: i64) -> &mut Self {
    self.instance.received_bytes = Some(received_bytes);
    self
  }
  
  pub fn duration(&mut self, duration: f64) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
}


/// This class is an abstract base class. Represents the type of a network. 
#[typetag::serde(tag = "@struct")]
pub trait NetworkType: Debug {}



impl Object for NetworkType {}





/// The network is not available. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeNone {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkTypeNone

}



#[typetag::serde]
impl NetworkType for NetworkTypeNone {}


impl NetworkTypeNone {
  
  pub fn builder() -> NetworkTypeNoneBuilder {
    let instance = Self {
      tdfname: "networkTypeNone".to_string(),
      
    };
    NetworkTypeNoneBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkTypeNoneBuilder {
  instance: NetworkTypeNone
}

impl NetworkTypeNoneBuilder {
  fn new(instance: NetworkTypeNone) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeNone {
    self.instance.clone()
  }
  
}


/// A mobile network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkTypeMobile

}



#[typetag::serde]
impl NetworkType for NetworkTypeMobile {}


impl NetworkTypeMobile {
  
  pub fn builder() -> NetworkTypeMobileBuilder {
    let instance = Self {
      tdfname: "networkTypeMobile".to_string(),
      
    };
    NetworkTypeMobileBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkTypeMobileBuilder {
  instance: NetworkTypeMobile
}

impl NetworkTypeMobileBuilder {
  fn new(instance: NetworkTypeMobile) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeMobile {
    self.instance.clone()
  }
  
}


/// A mobile roaming network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeMobileRoaming {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkTypeMobileRoaming

}



#[typetag::serde]
impl NetworkType for NetworkTypeMobileRoaming {}


impl NetworkTypeMobileRoaming {
  
  pub fn builder() -> NetworkTypeMobileRoamingBuilder {
    let instance = Self {
      tdfname: "networkTypeMobileRoaming".to_string(),
      
    };
    NetworkTypeMobileRoamingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkTypeMobileRoamingBuilder {
  instance: NetworkTypeMobileRoaming
}

impl NetworkTypeMobileRoamingBuilder {
  fn new(instance: NetworkTypeMobileRoaming) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeMobileRoaming {
    self.instance.clone()
  }
  
}


/// A Wi-Fi network. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeWiFi {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkTypeWiFi

}



#[typetag::serde]
impl NetworkType for NetworkTypeWiFi {}


impl NetworkTypeWiFi {
  
  pub fn builder() -> NetworkTypeWiFiBuilder {
    let instance = Self {
      tdfname: "networkTypeWiFi".to_string(),
      
    };
    NetworkTypeWiFiBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkTypeWiFiBuilder {
  instance: NetworkTypeWiFi
}

impl NetworkTypeWiFiBuilder {
  fn new(instance: NetworkTypeWiFi) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeWiFi {
    self.instance.clone()
  }
  
}


/// A different network type (e.g., Ethernet network). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTypeOther {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // networkTypeOther

}



#[typetag::serde]
impl NetworkType for NetworkTypeOther {}


impl NetworkTypeOther {
  
  pub fn builder() -> NetworkTypeOtherBuilder {
    let instance = Self {
      tdfname: "networkTypeOther".to_string(),
      
    };
    NetworkTypeOtherBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NetworkTypeOtherBuilder {
  instance: NetworkTypeOther
}

impl NetworkTypeOtherBuilder {
  fn new(instance: NetworkTypeOther) -> Self { Self { instance } }

  pub fn build(&self) -> NetworkTypeOther {
    self.instance.clone()
  }
  
}


/// Contains information about a notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Notification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notification

  /// Unique persistent identifier of this notification.
  id: Option<i32>,
  /// Notification date.
  date: Option<i32>,
  /// Notification type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationType>>,


}


impl Clone for Notification {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Notification {}


impl Notification {
  
  pub fn builder() -> NotificationBuilder {
    let instance = Self {
      tdfname: "notification".to_string(),
      id: None,
      date: None,
      type_: None,
      
    };
    NotificationBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn type_(&self) -> &Option<Box<NotificationType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationBuilder {
  instance: Notification
}

impl NotificationBuilder {
  fn new(instance: Notification) -> Self { Self { instance } }

  pub fn build(&self) -> Notification {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn type_(&mut self, type_: Box<NotificationType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Describes a group of notifications. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationGroup

  /// Unique persistent auto-incremented from 1 identifier of the notification group.
  id: Option<i32>,
  /// Type of the group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Total number of active notifications in the group.
  total_count: Option<i32>,
  /// The list of active notifications.
  notifications: Option<Vec<Notification>>,


}


impl Clone for NotificationGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for NotificationGroup {}


impl NotificationGroup {
  
  pub fn builder() -> NotificationGroupBuilder {
    let instance = Self {
      tdfname: "notificationGroup".to_string(),
      id: None,
      type_: None,
      chat_id: None,
      total_count: None,
      notifications: None,
      
    };
    NotificationGroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn type_(&self) -> &Option<Box<NotificationGroupType>> { &self.type_ }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn notifications(&self) -> &Option<Vec<Notification>> { &self.notifications }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationGroupBuilder {
  instance: NotificationGroup
}

impl NotificationGroupBuilder {
  fn new(instance: NotificationGroup) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroup {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn type_(&mut self, type_: Box<NotificationGroupType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn notifications(&mut self, notifications: Vec<Notification>) -> &mut Self {
    self.instance.notifications = Some(notifications);
    self
  }
  
}


/// This class is an abstract base class. Describes type of notifications in the group. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationGroupType: Debug {}



impl Object for NotificationGroupType {}





/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationGroupTypeMessages

}



#[typetag::serde]
impl NotificationGroupType for NotificationGroupTypeMessages {}


impl NotificationGroupTypeMessages {
  
  pub fn builder() -> NotificationGroupTypeMessagesBuilder {
    let instance = Self {
      tdfname: "notificationGroupTypeMessages".to_string(),
      
    };
    NotificationGroupTypeMessagesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationGroupTypeMessagesBuilder {
  instance: NotificationGroupTypeMessages
}

impl NotificationGroupTypeMessagesBuilder {
  fn new(instance: NotificationGroupTypeMessages) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeMessages {
    self.instance.clone()
  }
  
}


/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationGroupTypeMentions

}



#[typetag::serde]
impl NotificationGroupType for NotificationGroupTypeMentions {}


impl NotificationGroupTypeMentions {
  
  pub fn builder() -> NotificationGroupTypeMentionsBuilder {
    let instance = Self {
      tdfname: "notificationGroupTypeMentions".to_string(),
      
    };
    NotificationGroupTypeMentionsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationGroupTypeMentionsBuilder {
  instance: NotificationGroupTypeMentions
}

impl NotificationGroupTypeMentionsBuilder {
  fn new(instance: NotificationGroupTypeMentions) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeMentions {
    self.instance.clone()
  }
  
}


/// A group containing a notification of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationGroupTypeSecretChat

}



#[typetag::serde]
impl NotificationGroupType for NotificationGroupTypeSecretChat {}


impl NotificationGroupTypeSecretChat {
  
  pub fn builder() -> NotificationGroupTypeSecretChatBuilder {
    let instance = Self {
      tdfname: "notificationGroupTypeSecretChat".to_string(),
      
    };
    NotificationGroupTypeSecretChatBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationGroupTypeSecretChatBuilder {
  instance: NotificationGroupTypeSecretChat
}

impl NotificationGroupTypeSecretChatBuilder {
  fn new(instance: NotificationGroupTypeSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeSecretChat {
    self.instance.clone()
  }
  
}


/// A group containing notifications of type 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationGroupTypeCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationGroupTypeCalls

}



#[typetag::serde]
impl NotificationGroupType for NotificationGroupTypeCalls {}


impl NotificationGroupTypeCalls {
  
  pub fn builder() -> NotificationGroupTypeCallsBuilder {
    let instance = Self {
      tdfname: "notificationGroupTypeCalls".to_string(),
      
    };
    NotificationGroupTypeCallsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationGroupTypeCallsBuilder {
  instance: NotificationGroupTypeCalls
}

impl NotificationGroupTypeCallsBuilder {
  fn new(instance: NotificationGroupTypeCalls) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationGroupTypeCalls {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Describes the types of chats to which notification settings are applied. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationSettingsScope: Debug {}



impl Object for NotificationSettingsScope {}





/// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopePrivateChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationSettingsScopePrivateChats

}



#[typetag::serde]
impl NotificationSettingsScope for NotificationSettingsScopePrivateChats {}


impl NotificationSettingsScopePrivateChats {
  
  pub fn builder() -> NotificationSettingsScopePrivateChatsBuilder {
    let instance = Self {
      tdfname: "notificationSettingsScopePrivateChats".to_string(),
      
    };
    NotificationSettingsScopePrivateChatsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationSettingsScopePrivateChatsBuilder {
  instance: NotificationSettingsScopePrivateChats
}

impl NotificationSettingsScopePrivateChatsBuilder {
  fn new(instance: NotificationSettingsScopePrivateChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopePrivateChats {
    self.instance.clone()
  }
  
}


/// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeGroupChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationSettingsScopeGroupChats

}



#[typetag::serde]
impl NotificationSettingsScope for NotificationSettingsScopeGroupChats {}


impl NotificationSettingsScopeGroupChats {
  
  pub fn builder() -> NotificationSettingsScopeGroupChatsBuilder {
    let instance = Self {
      tdfname: "notificationSettingsScopeGroupChats".to_string(),
      
    };
    NotificationSettingsScopeGroupChatsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationSettingsScopeGroupChatsBuilder {
  instance: NotificationSettingsScopeGroupChats
}

impl NotificationSettingsScopeGroupChatsBuilder {
  fn new(instance: NotificationSettingsScopeGroupChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopeGroupChats {
    self.instance.clone()
  }
  
}


/// Notification settings applied to all channels when the corresponding chat setting has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettingsScopeChannelChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationSettingsScopeChannelChats

}



#[typetag::serde]
impl NotificationSettingsScope for NotificationSettingsScopeChannelChats {}


impl NotificationSettingsScopeChannelChats {
  
  pub fn builder() -> NotificationSettingsScopeChannelChatsBuilder {
    let instance = Self {
      tdfname: "notificationSettingsScopeChannelChats".to_string(),
      
    };
    NotificationSettingsScopeChannelChatsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationSettingsScopeChannelChatsBuilder {
  instance: NotificationSettingsScopeChannelChats
}

impl NotificationSettingsScopeChannelChatsBuilder {
  fn new(instance: NotificationSettingsScopeChannelChats) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationSettingsScopeChannelChats {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Contains detailed information about a notification. 
#[typetag::serde(tag = "@struct")]
pub trait NotificationType: Debug {}



impl Object for NotificationType {}





/// New message was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationTypeNewMessage

  /// The message.
  message: Option<Message>,


}



#[typetag::serde]
impl NotificationType for NotificationTypeNewMessage {}


impl NotificationTypeNewMessage {
  
  pub fn builder() -> NotificationTypeNewMessageBuilder {
    let instance = Self {
      tdfname: "notificationTypeNewMessage".to_string(),
      message: None,
      
    };
    NotificationTypeNewMessageBuilder::new(instance)
  }
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationTypeNewMessageBuilder {
  instance: NotificationTypeNewMessage
}

impl NotificationTypeNewMessageBuilder {
  fn new(instance: NotificationTypeNewMessage) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewMessage {
    self.instance.clone()
  }
  
  pub fn message(&mut self, message: Message) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
}


/// New secret chat was created. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationTypeNewSecretChat

}



#[typetag::serde]
impl NotificationType for NotificationTypeNewSecretChat {}


impl NotificationTypeNewSecretChat {
  
  pub fn builder() -> NotificationTypeNewSecretChatBuilder {
    let instance = Self {
      tdfname: "notificationTypeNewSecretChat".to_string(),
      
    };
    NotificationTypeNewSecretChatBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationTypeNewSecretChatBuilder {
  instance: NotificationTypeNewSecretChat
}

impl NotificationTypeNewSecretChatBuilder {
  fn new(instance: NotificationTypeNewSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewSecretChat {
    self.instance.clone()
  }
  
}


/// New call was received. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTypeNewCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationTypeNewCall

  /// Call identifier.
  call_id: Option<i32>,


}



#[typetag::serde]
impl NotificationType for NotificationTypeNewCall {}


impl NotificationTypeNewCall {
  
  pub fn builder() -> NotificationTypeNewCallBuilder {
    let instance = Self {
      tdfname: "notificationTypeNewCall".to_string(),
      call_id: None,
      
    };
    NotificationTypeNewCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> &Option<i32> { &self.call_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationTypeNewCallBuilder {
  instance: NotificationTypeNewCall
}

impl NotificationTypeNewCallBuilder {
  fn new(instance: NotificationTypeNewCall) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewCall {
    self.instance.clone()
  }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
}


/// New message was received through a push notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct NotificationTypeNewPushMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // notificationTypeNewPushMessage

  /// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages and as reply_to_message_id.
  message_id: Option<i64>,
  /// Sender of the message. Corresponding user may be inaccessible.
  sender_user_id: Option<i32>,
  /// Push message content.
  content: Option<Box<PushMessageContent>>,


}


impl Clone for NotificationTypeNewPushMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl NotificationType for NotificationTypeNewPushMessage {}


impl NotificationTypeNewPushMessage {
  
  pub fn builder() -> NotificationTypeNewPushMessageBuilder {
    let instance = Self {
      tdfname: "notificationTypeNewPushMessage".to_string(),
      message_id: None,
      sender_user_id: None,
      content: None,
      
    };
    NotificationTypeNewPushMessageBuilder::new(instance)
  }
  
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn content(&self) -> &Option<Box<PushMessageContent>> { &self.content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct NotificationTypeNewPushMessageBuilder {
  instance: NotificationTypeNewPushMessage
}

impl NotificationTypeNewPushMessageBuilder {
  fn new(instance: NotificationTypeNewPushMessage) -> Self { Self { instance } }

  pub fn build(&self) -> NotificationTypeNewPushMessage {
    self.instance.clone()
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn content(&mut self, content: Box<PushMessageContent>) -> &mut Self {
    self.instance.content = Some(content);
    self
  }
  
}


/// An object of this type is returned on a successful function call for certain functions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Ok {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // ok

}




impl Object for Ok {}


impl Ok {
  
  pub fn builder() -> OkBuilder {
    let instance = Self {
      tdfname: "ok".to_string(),
      
    };
    OkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OkBuilder {
  instance: Ok
}

impl OkBuilder {
  fn new(instance: Ok) -> Self { Self { instance } }

  pub fn build(&self) -> Ok {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Represents the value of an option. 
#[typetag::serde(tag = "@struct")]
pub trait OptionValue: Debug {}



impl Object for OptionValue {}





/// Represents a boolean option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueBoolean {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // optionValueBoolean

  /// The value of the option.
  value: Option<bool>,


}



#[typetag::serde]
impl OptionValue for OptionValueBoolean {}


impl OptionValueBoolean {
  
  pub fn builder() -> OptionValueBooleanBuilder {
    let instance = Self {
      tdfname: "optionValueBoolean".to_string(),
      value: None,
      
    };
    OptionValueBooleanBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<bool> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OptionValueBooleanBuilder {
  instance: OptionValueBoolean
}

impl OptionValueBooleanBuilder {
  fn new(instance: OptionValueBoolean) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueBoolean {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: bool) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// Represents an unknown option or an option which has a default value. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // optionValueEmpty

}



#[typetag::serde]
impl OptionValue for OptionValueEmpty {}


impl OptionValueEmpty {
  
  pub fn builder() -> OptionValueEmptyBuilder {
    let instance = Self {
      tdfname: "optionValueEmpty".to_string(),
      
    };
    OptionValueEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OptionValueEmptyBuilder {
  instance: OptionValueEmpty
}

impl OptionValueEmptyBuilder {
  fn new(instance: OptionValueEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueEmpty {
    self.instance.clone()
  }
  
}


/// Represents an integer option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueInteger {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // optionValueInteger

  /// The value of the option.
  value: Option<i32>,


}



#[typetag::serde]
impl OptionValue for OptionValueInteger {}


impl OptionValueInteger {
  
  pub fn builder() -> OptionValueIntegerBuilder {
    let instance = Self {
      tdfname: "optionValueInteger".to_string(),
      value: None,
      
    };
    OptionValueIntegerBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<i32> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OptionValueIntegerBuilder {
  instance: OptionValueInteger
}

impl OptionValueIntegerBuilder {
  fn new(instance: OptionValueInteger) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueInteger {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: i32) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// Represents a string option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptionValueString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // optionValueString

  /// The value of the option.
  value: Option<String>,


}



#[typetag::serde]
impl OptionValue for OptionValueString {}


impl OptionValueString {
  
  pub fn builder() -> OptionValueStringBuilder {
    let instance = Self {
      tdfname: "optionValueString".to_string(),
      value: None,
      
    };
    OptionValueStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<String> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OptionValueStringBuilder {
  instance: OptionValueString
}

impl OptionValueStringBuilder {
  fn new(instance: OptionValueString) -> Self { Self { instance } }

  pub fn build(&self) -> OptionValueString {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: String) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// Order information. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // orderInfo

  /// Name of the user.
  name: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Email address of the user.
  email_address: Option<String>,
  /// Shipping address for this order; may be null.
  shipping_address: Option<Address>,


}




impl Object for OrderInfo {}


impl OrderInfo {
  
  pub fn builder() -> OrderInfoBuilder {
    let instance = Self {
      tdfname: "orderInfo".to_string(),
      name: None,
      phone_number: None,
      email_address: None,
      shipping_address: None,
      
    };
    OrderInfoBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn email_address(&self) -> &Option<String> { &self.email_address }
  
  pub fn shipping_address(&self) -> &Option<Address> { &self.shipping_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OrderInfoBuilder {
  instance: OrderInfo
}

impl OrderInfoBuilder {
  fn new(instance: OrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> OrderInfo {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn email_address(&mut self, email_address: String) -> &mut Self {
    self.instance.email_address = Some(email_address);
    self
  }
  
  pub fn shipping_address(&mut self, shipping_address: Address) -> &mut Self {
    self.instance.shipping_address = Some(shipping_address);
    self
  }
  
}


/// This class is an abstract base class. Describes a block of an instant view web page. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlock: Debug {}



impl Object for PageBlock {}





/// The title of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockTitle

  /// Title.
  title: Option<Box<RichText>>,


}


impl Clone for PageBlockTitle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockTitle {}


impl PageBlockTitle {
  
  pub fn builder() -> PageBlockTitleBuilder {
    let instance = Self {
      tdfname: "pageBlockTitle".to_string(),
      title: None,
      
    };
    PageBlockTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<Box<RichText>> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockTitleBuilder {
  instance: PageBlockTitle
}

impl PageBlockTitleBuilder {
  fn new(instance: PageBlockTitle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTitle {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: Box<RichText>) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// The subtitle of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubtitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockSubtitle

  /// Subtitle.
  subtitle: Option<Box<RichText>>,


}


impl Clone for PageBlockSubtitle {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockSubtitle {}


impl PageBlockSubtitle {
  
  pub fn builder() -> PageBlockSubtitleBuilder {
    let instance = Self {
      tdfname: "pageBlockSubtitle".to_string(),
      subtitle: None,
      
    };
    PageBlockSubtitleBuilder::new(instance)
  }
  
  
  pub fn subtitle(&self) -> &Option<Box<RichText>> { &self.subtitle }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockSubtitleBuilder {
  instance: PageBlockSubtitle
}

impl PageBlockSubtitleBuilder {
  fn new(instance: PageBlockSubtitle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSubtitle {
    self.instance.clone()
  }
  
  pub fn subtitle(&mut self, subtitle: Box<RichText>) -> &mut Self {
    self.instance.subtitle = Some(subtitle);
    self
  }
  
}


/// The author and publishing date of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockAuthorDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockAuthorDate

  /// Author.
  author: Option<Box<RichText>>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,


}


impl Clone for PageBlockAuthorDate {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockAuthorDate {}


impl PageBlockAuthorDate {
  
  pub fn builder() -> PageBlockAuthorDateBuilder {
    let instance = Self {
      tdfname: "pageBlockAuthorDate".to_string(),
      author: None,
      publish_date: None,
      
    };
    PageBlockAuthorDateBuilder::new(instance)
  }
  
  
  pub fn author(&self) -> &Option<Box<RichText>> { &self.author }
  
  pub fn publish_date(&self) -> &Option<i32> { &self.publish_date }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockAuthorDateBuilder {
  instance: PageBlockAuthorDate
}

impl PageBlockAuthorDateBuilder {
  fn new(instance: PageBlockAuthorDate) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAuthorDate {
    self.instance.clone()
  }
  
  pub fn author(&mut self, author: Box<RichText>) -> &mut Self {
    self.instance.author = Some(author);
    self
  }
  
  pub fn publish_date(&mut self, publish_date: i32) -> &mut Self {
    self.instance.publish_date = Some(publish_date);
    self
  }
  
}


/// A header. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockHeader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockHeader

  /// Header.
  header: Option<Box<RichText>>,


}


impl Clone for PageBlockHeader {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockHeader {}


impl PageBlockHeader {
  
  pub fn builder() -> PageBlockHeaderBuilder {
    let instance = Self {
      tdfname: "pageBlockHeader".to_string(),
      header: None,
      
    };
    PageBlockHeaderBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> &Option<Box<RichText>> { &self.header }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockHeaderBuilder {
  instance: PageBlockHeader
}

impl PageBlockHeaderBuilder {
  fn new(instance: PageBlockHeader) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHeader {
    self.instance.clone()
  }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
}


/// A subheader. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSubheader {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockSubheader

  /// Subheader.
  subheader: Option<Box<RichText>>,


}


impl Clone for PageBlockSubheader {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockSubheader {}


impl PageBlockSubheader {
  
  pub fn builder() -> PageBlockSubheaderBuilder {
    let instance = Self {
      tdfname: "pageBlockSubheader".to_string(),
      subheader: None,
      
    };
    PageBlockSubheaderBuilder::new(instance)
  }
  
  
  pub fn subheader(&self) -> &Option<Box<RichText>> { &self.subheader }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockSubheaderBuilder {
  instance: PageBlockSubheader
}

impl PageBlockSubheaderBuilder {
  fn new(instance: PageBlockSubheader) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSubheader {
    self.instance.clone()
  }
  
  pub fn subheader(&mut self, subheader: Box<RichText>) -> &mut Self {
    self.instance.subheader = Some(subheader);
    self
  }
  
}


/// A kicker. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockKicker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockKicker

  /// Kicker.
  kicker: Option<Box<RichText>>,


}


impl Clone for PageBlockKicker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockKicker {}


impl PageBlockKicker {
  
  pub fn builder() -> PageBlockKickerBuilder {
    let instance = Self {
      tdfname: "pageBlockKicker".to_string(),
      kicker: None,
      
    };
    PageBlockKickerBuilder::new(instance)
  }
  
  
  pub fn kicker(&self) -> &Option<Box<RichText>> { &self.kicker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockKickerBuilder {
  instance: PageBlockKicker
}

impl PageBlockKickerBuilder {
  fn new(instance: PageBlockKicker) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockKicker {
    self.instance.clone()
  }
  
  pub fn kicker(&mut self, kicker: Box<RichText>) -> &mut Self {
    self.instance.kicker = Some(kicker);
    self
  }
  
}


/// A text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockParagraph {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockParagraph

  /// Paragraph text.
  text: Option<Box<RichText>>,


}


impl Clone for PageBlockParagraph {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockParagraph {}


impl PageBlockParagraph {
  
  pub fn builder() -> PageBlockParagraphBuilder {
    let instance = Self {
      tdfname: "pageBlockParagraph".to_string(),
      text: None,
      
    };
    PageBlockParagraphBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockParagraphBuilder {
  instance: PageBlockParagraph
}

impl PageBlockParagraphBuilder {
  fn new(instance: PageBlockParagraph) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockParagraph {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A preformatted text paragraph. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPreformatted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockPreformatted

  /// Paragraph text.
  text: Option<Box<RichText>>,
  /// Programming language for which the text should be formatted.
  language: Option<String>,


}


impl Clone for PageBlockPreformatted {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockPreformatted {}


impl PageBlockPreformatted {
  
  pub fn builder() -> PageBlockPreformattedBuilder {
    let instance = Self {
      tdfname: "pageBlockPreformatted".to_string(),
      text: None,
      language: None,
      
    };
    PageBlockPreformattedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn language(&self) -> &Option<String> { &self.language }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockPreformattedBuilder {
  instance: PageBlockPreformatted
}

impl PageBlockPreformattedBuilder {
  fn new(instance: PageBlockPreformatted) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPreformatted {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn language(&mut self, language: String) -> &mut Self {
    self.instance.language = Some(language);
    self
  }
  
}


/// The footer of a page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockFooter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockFooter

  /// Footer.
  footer: Option<Box<RichText>>,


}


impl Clone for PageBlockFooter {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockFooter {}


impl PageBlockFooter {
  
  pub fn builder() -> PageBlockFooterBuilder {
    let instance = Self {
      tdfname: "pageBlockFooter".to_string(),
      footer: None,
      
    };
    PageBlockFooterBuilder::new(instance)
  }
  
  
  pub fn footer(&self) -> &Option<Box<RichText>> { &self.footer }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockFooterBuilder {
  instance: PageBlockFooter
}

impl PageBlockFooterBuilder {
  fn new(instance: PageBlockFooter) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockFooter {
    self.instance.clone()
  }
  
  pub fn footer(&mut self, footer: Box<RichText>) -> &mut Self {
    self.instance.footer = Some(footer);
    self
  }
  
}


/// An empty block separating a page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockDivider {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockDivider

}



#[typetag::serde]
impl PageBlock for PageBlockDivider {}


impl PageBlockDivider {
  
  pub fn builder() -> PageBlockDividerBuilder {
    let instance = Self {
      tdfname: "pageBlockDivider".to_string(),
      
    };
    PageBlockDividerBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockDividerBuilder {
  instance: PageBlockDivider
}

impl PageBlockDividerBuilder {
  fn new(instance: PageBlockDivider) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockDivider {
    self.instance.clone()
  }
  
}


/// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockAnchor

  /// Name of the anchor.
  name: Option<String>,


}



#[typetag::serde]
impl PageBlock for PageBlockAnchor {}


impl PageBlockAnchor {
  
  pub fn builder() -> PageBlockAnchorBuilder {
    let instance = Self {
      tdfname: "pageBlockAnchor".to_string(),
      name: None,
      
    };
    PageBlockAnchorBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockAnchorBuilder {
  instance: PageBlockAnchor
}

impl PageBlockAnchorBuilder {
  fn new(instance: PageBlockAnchor) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAnchor {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
}


/// A list of data blocks. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockList {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockList

  /// The items of the list.
  items: Option<Vec<PageBlockListItem>>,


}



#[typetag::serde]
impl PageBlock for PageBlockList {}


impl PageBlockList {
  
  pub fn builder() -> PageBlockListBuilder {
    let instance = Self {
      tdfname: "pageBlockList".to_string(),
      items: None,
      
    };
    PageBlockListBuilder::new(instance)
  }
  
  
  pub fn items(&self) -> &Option<Vec<PageBlockListItem>> { &self.items }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockListBuilder {
  instance: PageBlockList
}

impl PageBlockListBuilder {
  fn new(instance: PageBlockList) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockList {
    self.instance.clone()
  }
  
  pub fn items(&mut self, items: Vec<PageBlockListItem>) -> &mut Self {
    self.instance.items = Some(items);
    self
  }
  
}


/// A block quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockBlockQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockBlockQuote

  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,


}


impl Clone for PageBlockBlockQuote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockBlockQuote {}


impl PageBlockBlockQuote {
  
  pub fn builder() -> PageBlockBlockQuoteBuilder {
    let instance = Self {
      tdfname: "pageBlockBlockQuote".to_string(),
      text: None,
      credit: None,
      
    };
    PageBlockBlockQuoteBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn credit(&self) -> &Option<Box<RichText>> { &self.credit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockBlockQuoteBuilder {
  instance: PageBlockBlockQuote
}

impl PageBlockBlockQuoteBuilder {
  fn new(instance: PageBlockBlockQuote) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockBlockQuote {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}


/// A pull quote. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockPullQuote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockPullQuote

  /// Quote text.
  text: Option<Box<RichText>>,
  /// Quote credit.
  credit: Option<Box<RichText>>,


}


impl Clone for PageBlockPullQuote {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockPullQuote {}


impl PageBlockPullQuote {
  
  pub fn builder() -> PageBlockPullQuoteBuilder {
    let instance = Self {
      tdfname: "pageBlockPullQuote".to_string(),
      text: None,
      credit: None,
      
    };
    PageBlockPullQuoteBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn credit(&self) -> &Option<Box<RichText>> { &self.credit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockPullQuoteBuilder {
  instance: PageBlockPullQuote
}

impl PageBlockPullQuoteBuilder {
  fn new(instance: PageBlockPullQuote) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPullQuote {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}


/// An animation. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockAnimation

  /// Animation file; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<PageBlockCaption>,
  /// True, if the animation should be played automatically.
  need_autoplay: Option<bool>,


}



#[typetag::serde]
impl PageBlock for PageBlockAnimation {}


impl PageBlockAnimation {
  
  pub fn builder() -> PageBlockAnimationBuilder {
    let instance = Self {
      tdfname: "pageBlockAnimation".to_string(),
      animation: None,
      caption: None,
      need_autoplay: None,
      
    };
    PageBlockAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  pub fn need_autoplay(&self) -> &Option<bool> { &self.need_autoplay }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockAnimationBuilder {
  instance: PageBlockAnimation
}

impl PageBlockAnimationBuilder {
  fn new(instance: PageBlockAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn need_autoplay(&mut self, need_autoplay: bool) -> &mut Self {
    self.instance.need_autoplay = Some(need_autoplay);
    self
  }
  
}


/// An audio file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockAudio

  /// Audio file; may be null.
  audio: Option<Audio>,
  /// Audio file caption.
  caption: Option<PageBlockCaption>,


}



#[typetag::serde]
impl PageBlock for PageBlockAudio {}


impl PageBlockAudio {
  
  pub fn builder() -> PageBlockAudioBuilder {
    let instance = Self {
      tdfname: "pageBlockAudio".to_string(),
      audio: None,
      caption: None,
      
    };
    PageBlockAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> &Option<Audio> { &self.audio }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockAudioBuilder {
  instance: PageBlockAudio
}

impl PageBlockAudioBuilder {
  fn new(instance: PageBlockAudio) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockAudio {
    self.instance.clone()
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockPhoto

  /// Photo file; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<PageBlockCaption>,
  /// URL that needs to be opened when the photo is clicked.
  url: Option<String>,


}



#[typetag::serde]
impl PageBlock for PageBlockPhoto {}


impl PageBlockPhoto {
  
  pub fn builder() -> PageBlockPhotoBuilder {
    let instance = Self {
      tdfname: "pageBlockPhoto".to_string(),
      photo: None,
      caption: None,
      url: None,
      
    };
    PageBlockPhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockPhotoBuilder {
  instance: PageBlockPhoto
}

impl PageBlockPhotoBuilder {
  fn new(instance: PageBlockPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockPhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// A video. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockVideo

  /// Video file; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<PageBlockCaption>,
  /// True, if the video should be played automatically.
  need_autoplay: Option<bool>,
  /// True, if the video should be looped.
  is_looped: Option<bool>,


}



#[typetag::serde]
impl PageBlock for PageBlockVideo {}


impl PageBlockVideo {
  
  pub fn builder() -> PageBlockVideoBuilder {
    let instance = Self {
      tdfname: "pageBlockVideo".to_string(),
      video: None,
      caption: None,
      need_autoplay: None,
      is_looped: None,
      
    };
    PageBlockVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> &Option<Video> { &self.video }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  pub fn need_autoplay(&self) -> &Option<bool> { &self.need_autoplay }
  
  pub fn is_looped(&self) -> &Option<bool> { &self.is_looped }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockVideoBuilder {
  instance: PageBlockVideo
}

impl PageBlockVideoBuilder {
  fn new(instance: PageBlockVideo) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVideo {
    self.instance.clone()
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn need_autoplay(&mut self, need_autoplay: bool) -> &mut Self {
    self.instance.need_autoplay = Some(need_autoplay);
    self
  }
  
  pub fn is_looped(&mut self, is_looped: bool) -> &mut Self {
    self.instance.is_looped = Some(is_looped);
    self
  }
  
}


/// A page cover. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCover {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockCover

  /// Cover.
  cover: Option<Box<PageBlock>>,


}


impl Clone for PageBlockCover {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockCover {}


impl PageBlockCover {
  
  pub fn builder() -> PageBlockCoverBuilder {
    let instance = Self {
      tdfname: "pageBlockCover".to_string(),
      cover: None,
      
    };
    PageBlockCoverBuilder::new(instance)
  }
  
  
  pub fn cover(&self) -> &Option<Box<PageBlock>> { &self.cover }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockCoverBuilder {
  instance: PageBlockCover
}

impl PageBlockCoverBuilder {
  fn new(instance: PageBlockCover) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCover {
    self.instance.clone()
  }
  
  pub fn cover(&mut self, cover: Box<PageBlock>) -> &mut Self {
    self.instance.cover = Some(cover);
    self
  }
  
}


/// An embedded web page. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockEmbedded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockEmbedded

  /// Web page URL, if available.
  url: Option<String>,
  /// HTML-markup of the embedded page.
  html: Option<String>,
  /// Poster photo, if available; may be null.
  poster_photo: Option<Photo>,
  /// Block width, 0 if unknown.
  width: Option<i32>,
  /// Block height, 0 if unknown.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,
  /// True, if the block should be full width.
  is_full_width: Option<bool>,
  /// True, if scrolling should be allowed.
  allow_scrolling: Option<bool>,


}



#[typetag::serde]
impl PageBlock for PageBlockEmbedded {}


impl PageBlockEmbedded {
  
  pub fn builder() -> PageBlockEmbeddedBuilder {
    let instance = Self {
      tdfname: "pageBlockEmbedded".to_string(),
      url: None,
      html: None,
      poster_photo: None,
      width: None,
      height: None,
      caption: None,
      is_full_width: None,
      allow_scrolling: None,
      
    };
    PageBlockEmbeddedBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn html(&self) -> &Option<String> { &self.html }
  
  pub fn poster_photo(&self) -> &Option<Photo> { &self.poster_photo }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  pub fn is_full_width(&self) -> &Option<bool> { &self.is_full_width }
  
  pub fn allow_scrolling(&self) -> &Option<bool> { &self.allow_scrolling }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockEmbeddedBuilder {
  instance: PageBlockEmbedded
}

impl PageBlockEmbeddedBuilder {
  fn new(instance: PageBlockEmbedded) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockEmbedded {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn html(&mut self, html: String) -> &mut Self {
    self.instance.html = Some(html);
    self
  }
  
  pub fn poster_photo(&mut self, poster_photo: Photo) -> &mut Self {
    self.instance.poster_photo = Some(poster_photo);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_full_width(&mut self, is_full_width: bool) -> &mut Self {
    self.instance.is_full_width = Some(is_full_width);
    self
  }
  
  pub fn allow_scrolling(&mut self, allow_scrolling: bool) -> &mut Self {
    self.instance.allow_scrolling = Some(allow_scrolling);
    self
  }
  
}


/// An embedded post. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockEmbeddedPost {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockEmbeddedPost

  /// Web page URL.
  url: Option<String>,
  /// Post author.
  author: Option<String>,
  /// Post author photo.
  author_photo: Option<Photo>,
  /// Point in time (Unix timestamp) when the post was created; 0 if unknown.
  date: Option<i32>,
  /// Post content.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Post caption.
  caption: Option<PageBlockCaption>,


}


impl Clone for PageBlockEmbeddedPost {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockEmbeddedPost {}


impl PageBlockEmbeddedPost {
  
  pub fn builder() -> PageBlockEmbeddedPostBuilder {
    let instance = Self {
      tdfname: "pageBlockEmbeddedPost".to_string(),
      url: None,
      author: None,
      author_photo: None,
      date: None,
      page_blocks: None,
      caption: None,
      
    };
    PageBlockEmbeddedPostBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn author(&self) -> &Option<String> { &self.author }
  
  pub fn author_photo(&self) -> &Option<Photo> { &self.author_photo }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockEmbeddedPostBuilder {
  instance: PageBlockEmbeddedPost
}

impl PageBlockEmbeddedPostBuilder {
  fn new(instance: PageBlockEmbeddedPost) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockEmbeddedPost {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn author(&mut self, author: String) -> &mut Self {
    self.instance.author = Some(author);
    self
  }
  
  pub fn author_photo(&mut self, author_photo: Photo) -> &mut Self {
    self.instance.author_photo = Some(author_photo);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A collage. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCollage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockCollage

  /// Collage item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,


}


impl Clone for PageBlockCollage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockCollage {}


impl PageBlockCollage {
  
  pub fn builder() -> PageBlockCollageBuilder {
    let instance = Self {
      tdfname: "pageBlockCollage".to_string(),
      page_blocks: None,
      caption: None,
      
    };
    PageBlockCollageBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockCollageBuilder {
  instance: PageBlockCollage
}

impl PageBlockCollageBuilder {
  fn new(instance: PageBlockCollage) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCollage {
    self.instance.clone()
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A slideshow. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockSlideshow {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockSlideshow

  /// Slideshow item contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Block caption.
  caption: Option<PageBlockCaption>,


}


impl Clone for PageBlockSlideshow {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockSlideshow {}


impl PageBlockSlideshow {
  
  pub fn builder() -> PageBlockSlideshowBuilder {
    let instance = Self {
      tdfname: "pageBlockSlideshow".to_string(),
      page_blocks: None,
      caption: None,
      
    };
    PageBlockSlideshowBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockSlideshowBuilder {
  instance: PageBlockSlideshow
}

impl PageBlockSlideshowBuilder {
  fn new(instance: PageBlockSlideshow) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockSlideshow {
    self.instance.clone()
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// A link to a chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockChatLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockChatLink

  /// Chat title.
  title: Option<String>,
  /// Chat photo; may be null.
  photo: Option<ChatPhoto>,
  /// Chat username, by which all other information about the chat should be resolved.
  username: Option<String>,


}



#[typetag::serde]
impl PageBlock for PageBlockChatLink {}


impl PageBlockChatLink {
  
  pub fn builder() -> PageBlockChatLinkBuilder {
    let instance = Self {
      tdfname: "pageBlockChatLink".to_string(),
      title: None,
      photo: None,
      username: None,
      
    };
    PageBlockChatLinkBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn photo(&self) -> &Option<ChatPhoto> { &self.photo }
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockChatLinkBuilder {
  instance: PageBlockChatLink
}

impl PageBlockChatLinkBuilder {
  fn new(instance: PageBlockChatLink) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockChatLink {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn photo(&mut self, photo: ChatPhoto) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
}


/// A table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockTable

  /// Table caption.
  caption: Option<Box<RichText>>,
  /// Table cells.
  cells: Option<Vec<Vec<PageBlockTableCell>>>,
  /// True, if the table is bordered.
  is_bordered: Option<bool>,
  /// True, if the table is striped.
  is_striped: Option<bool>,


}


impl Clone for PageBlockTable {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockTable {}


impl PageBlockTable {
  
  pub fn builder() -> PageBlockTableBuilder {
    let instance = Self {
      tdfname: "pageBlockTable".to_string(),
      caption: None,
      cells: None,
      is_bordered: None,
      is_striped: None,
      
    };
    PageBlockTableBuilder::new(instance)
  }
  
  
  pub fn caption(&self) -> &Option<Box<RichText>> { &self.caption }
  
  pub fn cells(&self) -> &Option<Vec<Vec<PageBlockTableCell>>> { &self.cells }
  
  pub fn is_bordered(&self) -> &Option<bool> { &self.is_bordered }
  
  pub fn is_striped(&self) -> &Option<bool> { &self.is_striped }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockTableBuilder {
  instance: PageBlockTable
}

impl PageBlockTableBuilder {
  fn new(instance: PageBlockTable) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTable {
    self.instance.clone()
  }
  
  pub fn caption(&mut self, caption: Box<RichText>) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn cells(&mut self, cells: Vec<Vec<PageBlockTableCell>>) -> &mut Self {
    self.instance.cells = Some(cells);
    self
  }
  
  pub fn is_bordered(&mut self, is_bordered: bool) -> &mut Self {
    self.instance.is_bordered = Some(is_bordered);
    self
  }
  
  pub fn is_striped(&mut self, is_striped: bool) -> &mut Self {
    self.instance.is_striped = Some(is_striped);
    self
  }
  
}


/// A collapsible block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockDetails

  /// Always visible heading for the block.
  header: Option<Box<RichText>>,
  /// Block contents.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// True, if the block is open by default.
  is_open: Option<bool>,


}


impl Clone for PageBlockDetails {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockDetails {}


impl PageBlockDetails {
  
  pub fn builder() -> PageBlockDetailsBuilder {
    let instance = Self {
      tdfname: "pageBlockDetails".to_string(),
      header: None,
      page_blocks: None,
      is_open: None,
      
    };
    PageBlockDetailsBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> &Option<Box<RichText>> { &self.header }
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  pub fn is_open(&self) -> &Option<bool> { &self.is_open }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockDetailsBuilder {
  instance: PageBlockDetails
}

impl PageBlockDetailsBuilder {
  fn new(instance: PageBlockDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockDetails {
    self.instance.clone()
  }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn is_open(&mut self, is_open: bool) -> &mut Self {
    self.instance.is_open = Some(is_open);
    self
  }
  
}


/// Related articles. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockRelatedArticles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockRelatedArticles

  /// Block header.
  header: Option<Box<RichText>>,
  /// List of related articles.
  articles: Option<Vec<PageBlockRelatedArticle>>,


}


impl Clone for PageBlockRelatedArticles {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl PageBlock for PageBlockRelatedArticles {}


impl PageBlockRelatedArticles {
  
  pub fn builder() -> PageBlockRelatedArticlesBuilder {
    let instance = Self {
      tdfname: "pageBlockRelatedArticles".to_string(),
      header: None,
      articles: None,
      
    };
    PageBlockRelatedArticlesBuilder::new(instance)
  }
  
  
  pub fn header(&self) -> &Option<Box<RichText>> { &self.header }
  
  pub fn articles(&self) -> &Option<Vec<PageBlockRelatedArticle>> { &self.articles }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockRelatedArticlesBuilder {
  instance: PageBlockRelatedArticles
}

impl PageBlockRelatedArticlesBuilder {
  fn new(instance: PageBlockRelatedArticles) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockRelatedArticles {
    self.instance.clone()
  }
  
  pub fn header(&mut self, header: Box<RichText>) -> &mut Self {
    self.instance.header = Some(header);
    self
  }
  
  pub fn articles(&mut self, articles: Vec<PageBlockRelatedArticle>) -> &mut Self {
    self.instance.articles = Some(articles);
    self
  }
  
}


/// A map. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockMap {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockMap

  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level.
  zoom: Option<i32>,
  /// Map width.
  width: Option<i32>,
  /// Map height.
  height: Option<i32>,
  /// Block caption.
  caption: Option<PageBlockCaption>,


}



#[typetag::serde]
impl PageBlock for PageBlockMap {}


impl PageBlockMap {
  
  pub fn builder() -> PageBlockMapBuilder {
    let instance = Self {
      tdfname: "pageBlockMap".to_string(),
      location: None,
      zoom: None,
      width: None,
      height: None,
      caption: None,
      
    };
    PageBlockMapBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn zoom(&self) -> &Option<i32> { &self.zoom }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn caption(&self) -> &Option<PageBlockCaption> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockMapBuilder {
  instance: PageBlockMap
}

impl PageBlockMapBuilder {
  fn new(instance: PageBlockMap) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockMap {
    self.instance.clone()
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn zoom(&mut self, zoom: i32) -> &mut Self {
    self.instance.zoom = Some(zoom);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn caption(&mut self, caption: PageBlockCaption) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// Contains a caption of an instant view web page block, consisting of a text and a trailing credit. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockCaption

  /// Content of the caption.
  text: Option<Box<RichText>>,
  /// Block credit (like HTML tag <cite>).
  credit: Option<Box<RichText>>,


}


impl Clone for PageBlockCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PageBlockCaption {}


impl PageBlockCaption {
  
  pub fn builder() -> PageBlockCaptionBuilder {
    let instance = Self {
      tdfname: "pageBlockCaption".to_string(),
      text: None,
      credit: None,
      
    };
    PageBlockCaptionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn credit(&self) -> &Option<Box<RichText>> { &self.credit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockCaptionBuilder {
  instance: PageBlockCaption
}

impl PageBlockCaptionBuilder {
  fn new(instance: PageBlockCaption) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockCaption {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn credit(&mut self, credit: Box<RichText>) -> &mut Self {
    self.instance.credit = Some(credit);
    self
  }
  
}


/// This class is an abstract base class. Describes a horizontal alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockHorizontalAlignment: Debug {}



impl Object for PageBlockHorizontalAlignment {}





/// The content should be left-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentLeft {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockHorizontalAlignmentLeft

}



#[typetag::serde]
impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentLeft {}


impl PageBlockHorizontalAlignmentLeft {
  
  pub fn builder() -> PageBlockHorizontalAlignmentLeftBuilder {
    let instance = Self {
      tdfname: "pageBlockHorizontalAlignmentLeft".to_string(),
      
    };
    PageBlockHorizontalAlignmentLeftBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockHorizontalAlignmentLeftBuilder {
  instance: PageBlockHorizontalAlignmentLeft
}

impl PageBlockHorizontalAlignmentLeftBuilder {
  fn new(instance: PageBlockHorizontalAlignmentLeft) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentLeft {
    self.instance.clone()
  }
  
}


/// The content should be center-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentCenter {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockHorizontalAlignmentCenter

}



#[typetag::serde]
impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentCenter {}


impl PageBlockHorizontalAlignmentCenter {
  
  pub fn builder() -> PageBlockHorizontalAlignmentCenterBuilder {
    let instance = Self {
      tdfname: "pageBlockHorizontalAlignmentCenter".to_string(),
      
    };
    PageBlockHorizontalAlignmentCenterBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockHorizontalAlignmentCenterBuilder {
  instance: PageBlockHorizontalAlignmentCenter
}

impl PageBlockHorizontalAlignmentCenterBuilder {
  fn new(instance: PageBlockHorizontalAlignmentCenter) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentCenter {
    self.instance.clone()
  }
  
}


/// The content should be right-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockHorizontalAlignmentRight {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockHorizontalAlignmentRight

}



#[typetag::serde]
impl PageBlockHorizontalAlignment for PageBlockHorizontalAlignmentRight {}


impl PageBlockHorizontalAlignmentRight {
  
  pub fn builder() -> PageBlockHorizontalAlignmentRightBuilder {
    let instance = Self {
      tdfname: "pageBlockHorizontalAlignmentRight".to_string(),
      
    };
    PageBlockHorizontalAlignmentRightBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockHorizontalAlignmentRightBuilder {
  instance: PageBlockHorizontalAlignmentRight
}

impl PageBlockHorizontalAlignmentRightBuilder {
  fn new(instance: PageBlockHorizontalAlignmentRight) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockHorizontalAlignmentRight {
    self.instance.clone()
  }
  
}


/// Describes an item of a list page block. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockListItem {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockListItem

  /// Item label.
  label: Option<String>,
  /// Item blocks.
  page_blocks: Option<Vec<Box<PageBlock>>>,


}


impl Clone for PageBlockListItem {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PageBlockListItem {}


impl PageBlockListItem {
  
  pub fn builder() -> PageBlockListItemBuilder {
    let instance = Self {
      tdfname: "pageBlockListItem".to_string(),
      label: None,
      page_blocks: None,
      
    };
    PageBlockListItemBuilder::new(instance)
  }
  
  
  pub fn label(&self) -> &Option<String> { &self.label }
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockListItemBuilder {
  instance: PageBlockListItem
}

impl PageBlockListItemBuilder {
  fn new(instance: PageBlockListItem) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockListItem {
    self.instance.clone()
  }
  
  pub fn label(&mut self, label: String) -> &mut Self {
    self.instance.label = Some(label);
    self
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
}


/// Contains information about a related article. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockRelatedArticle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockRelatedArticle

  /// Related article URL.
  url: Option<String>,
  /// Article title; may be empty.
  title: Option<String>,
  /// Article description; may be empty.
  description: Option<String>,
  /// Article photo; may be null.
  photo: Option<Photo>,
  /// Article author; may be empty.
  author: Option<String>,
  /// Point in time (Unix timestamp) when the article was published; 0 if unknown.
  publish_date: Option<i32>,


}




impl Object for PageBlockRelatedArticle {}


impl PageBlockRelatedArticle {
  
  pub fn builder() -> PageBlockRelatedArticleBuilder {
    let instance = Self {
      tdfname: "pageBlockRelatedArticle".to_string(),
      url: None,
      title: None,
      description: None,
      photo: None,
      author: None,
      publish_date: None,
      
    };
    PageBlockRelatedArticleBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn author(&self) -> &Option<String> { &self.author }
  
  pub fn publish_date(&self) -> &Option<i32> { &self.publish_date }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockRelatedArticleBuilder {
  instance: PageBlockRelatedArticle
}

impl PageBlockRelatedArticleBuilder {
  fn new(instance: PageBlockRelatedArticle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockRelatedArticle {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn author(&mut self, author: String) -> &mut Self {
    self.instance.author = Some(author);
    self
  }
  
  pub fn publish_date(&mut self, publish_date: i32) -> &mut Self {
    self.instance.publish_date = Some(publish_date);
    self
  }
  
}


/// Represents a cell of a table. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PageBlockTableCell {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockTableCell

  /// Cell text.
  text: Option<Box<RichText>>,
  /// True, if it is a header cell.
  is_header: Option<bool>,
  /// The number of columns the cell should span.
  colspan: Option<i32>,
  /// The number of rows the cell should span.
  rowspan: Option<i32>,
  /// Horizontal cell content alignment.
  align: Option<Box<PageBlockHorizontalAlignment>>,
  /// Vertical cell content alignment.
  valign: Option<Box<PageBlockVerticalAlignment>>,


}


impl Clone for PageBlockTableCell {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PageBlockTableCell {}


impl PageBlockTableCell {
  
  pub fn builder() -> PageBlockTableCellBuilder {
    let instance = Self {
      tdfname: "pageBlockTableCell".to_string(),
      text: None,
      is_header: None,
      colspan: None,
      rowspan: None,
      align: None,
      valign: None,
      
    };
    PageBlockTableCellBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn is_header(&self) -> &Option<bool> { &self.is_header }
  
  pub fn colspan(&self) -> &Option<i32> { &self.colspan }
  
  pub fn rowspan(&self) -> &Option<i32> { &self.rowspan }
  
  pub fn align(&self) -> &Option<Box<PageBlockHorizontalAlignment>> { &self.align }
  
  pub fn valign(&self) -> &Option<Box<PageBlockVerticalAlignment>> { &self.valign }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockTableCellBuilder {
  instance: PageBlockTableCell
}

impl PageBlockTableCellBuilder {
  fn new(instance: PageBlockTableCell) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockTableCell {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn is_header(&mut self, is_header: bool) -> &mut Self {
    self.instance.is_header = Some(is_header);
    self
  }
  
  pub fn colspan(&mut self, colspan: i32) -> &mut Self {
    self.instance.colspan = Some(colspan);
    self
  }
  
  pub fn rowspan(&mut self, rowspan: i32) -> &mut Self {
    self.instance.rowspan = Some(rowspan);
    self
  }
  
  pub fn align(&mut self, align: Box<PageBlockHorizontalAlignment>) -> &mut Self {
    self.instance.align = Some(align);
    self
  }
  
  pub fn valign(&mut self, valign: Box<PageBlockVerticalAlignment>) -> &mut Self {
    self.instance.valign = Some(valign);
    self
  }
  
}


/// This class is an abstract base class. Describes a Vertical alignment of a table cell content. 
#[typetag::serde(tag = "@struct")]
pub trait PageBlockVerticalAlignment: Debug {}



impl Object for PageBlockVerticalAlignment {}





/// The content should be top-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentTop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockVerticalAlignmentTop

}



#[typetag::serde]
impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentTop {}


impl PageBlockVerticalAlignmentTop {
  
  pub fn builder() -> PageBlockVerticalAlignmentTopBuilder {
    let instance = Self {
      tdfname: "pageBlockVerticalAlignmentTop".to_string(),
      
    };
    PageBlockVerticalAlignmentTopBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockVerticalAlignmentTopBuilder {
  instance: PageBlockVerticalAlignmentTop
}

impl PageBlockVerticalAlignmentTopBuilder {
  fn new(instance: PageBlockVerticalAlignmentTop) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentTop {
    self.instance.clone()
  }
  
}


/// The content should be middle-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentMiddle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockVerticalAlignmentMiddle

}



#[typetag::serde]
impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentMiddle {}


impl PageBlockVerticalAlignmentMiddle {
  
  pub fn builder() -> PageBlockVerticalAlignmentMiddleBuilder {
    let instance = Self {
      tdfname: "pageBlockVerticalAlignmentMiddle".to_string(),
      
    };
    PageBlockVerticalAlignmentMiddleBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockVerticalAlignmentMiddleBuilder {
  instance: PageBlockVerticalAlignmentMiddle
}

impl PageBlockVerticalAlignmentMiddleBuilder {
  fn new(instance: PageBlockVerticalAlignmentMiddle) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentMiddle {
    self.instance.clone()
  }
  
}


/// The content should be bottom-aligned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageBlockVerticalAlignmentBottom {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pageBlockVerticalAlignmentBottom

}



#[typetag::serde]
impl PageBlockVerticalAlignment for PageBlockVerticalAlignmentBottom {}


impl PageBlockVerticalAlignmentBottom {
  
  pub fn builder() -> PageBlockVerticalAlignmentBottomBuilder {
    let instance = Self {
      tdfname: "pageBlockVerticalAlignmentBottom".to_string(),
      
    };
    PageBlockVerticalAlignmentBottomBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PageBlockVerticalAlignmentBottomBuilder {
  instance: PageBlockVerticalAlignmentBottom
}

impl PageBlockVerticalAlignmentBottomBuilder {
  fn new(instance: PageBlockVerticalAlignmentBottom) -> Self { Self { instance } }

  pub fn build(&self) -> PageBlockVerticalAlignmentBottom {
    self.instance.clone()
  }
  
}


/// Contains information about a Telegram Passport authorization form that was requested. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportAuthorizationForm

  /// Unique identifier of the authorization form.
  id: Option<i32>,
  /// Information about the Telegram Passport elements that need to be provided to complete the form.
  required_elements: Option<Vec<PassportRequiredElement>>,
  /// URL for the privacy policy of the service; may be empty.
  privacy_policy_url: Option<String>,


}




impl Object for PassportAuthorizationForm {}


impl PassportAuthorizationForm {
  
  pub fn builder() -> PassportAuthorizationFormBuilder {
    let instance = Self {
      tdfname: "passportAuthorizationForm".to_string(),
      id: None,
      required_elements: None,
      privacy_policy_url: None,
      
    };
    PassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn required_elements(&self) -> &Option<Vec<PassportRequiredElement>> { &self.required_elements }
  
  pub fn privacy_policy_url(&self) -> &Option<String> { &self.privacy_policy_url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportAuthorizationFormBuilder {
  instance: PassportAuthorizationForm
}

impl PassportAuthorizationFormBuilder {
  fn new(instance: PassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> PassportAuthorizationForm {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn required_elements(&mut self, required_elements: Vec<PassportRequiredElement>) -> &mut Self {
    self.instance.required_elements = Some(required_elements);
    self
  }
  
  pub fn privacy_policy_url(&mut self, privacy_policy_url: String) -> &mut Self {
    self.instance.privacy_policy_url = Some(privacy_policy_url);
    self
  }
  
}


/// This class is an abstract base class. Contains information about a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElement: Debug {}



impl Object for PassportElement {}





/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementPersonalDetails

  /// Personal details of the user.
  personal_details: Option<PersonalDetails>,


}



#[typetag::serde]
impl PassportElement for PassportElementPersonalDetails {}


impl PassportElementPersonalDetails {
  
  pub fn builder() -> PassportElementPersonalDetailsBuilder {
    let instance = Self {
      tdfname: "passportElementPersonalDetails".to_string(),
      personal_details: None,
      
    };
    PassportElementPersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn personal_details(&self) -> &Option<PersonalDetails> { &self.personal_details }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementPersonalDetailsBuilder {
  instance: PassportElementPersonalDetails
}

impl PassportElementPersonalDetailsBuilder {
  fn new(instance: PassportElementPersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPersonalDetails {
    self.instance.clone()
  }
  
  pub fn personal_details(&mut self, personal_details: PersonalDetails) -> &mut Self {
    self.instance.personal_details = Some(personal_details);
    self
  }
  
}


/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementPassport

  /// Passport.
  passport: Option<IdentityDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementPassport {}


impl PassportElementPassport {
  
  pub fn builder() -> PassportElementPassportBuilder {
    let instance = Self {
      tdfname: "passportElementPassport".to_string(),
      passport: None,
      
    };
    PassportElementPassportBuilder::new(instance)
  }
  
  
  pub fn passport(&self) -> &Option<IdentityDocument> { &self.passport }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementPassportBuilder {
  instance: PassportElementPassport
}

impl PassportElementPassportBuilder {
  fn new(instance: PassportElementPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPassport {
    self.instance.clone()
  }
  
  pub fn passport(&mut self, passport: IdentityDocument) -> &mut Self {
    self.instance.passport = Some(passport);
    self
  }
  
}


/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementDriverLicense

  /// Driver license.
  driver_license: Option<IdentityDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementDriverLicense {}


impl PassportElementDriverLicense {
  
  pub fn builder() -> PassportElementDriverLicenseBuilder {
    let instance = Self {
      tdfname: "passportElementDriverLicense".to_string(),
      driver_license: None,
      
    };
    PassportElementDriverLicenseBuilder::new(instance)
  }
  
  
  pub fn driver_license(&self) -> &Option<IdentityDocument> { &self.driver_license }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementDriverLicenseBuilder {
  instance: PassportElementDriverLicense
}

impl PassportElementDriverLicenseBuilder {
  fn new(instance: PassportElementDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementDriverLicense {
    self.instance.clone()
  }
  
  pub fn driver_license(&mut self, driver_license: IdentityDocument) -> &mut Self {
    self.instance.driver_license = Some(driver_license);
    self
  }
  
}


/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementIdentityCard

  /// Identity card.
  identity_card: Option<IdentityDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementIdentityCard {}


impl PassportElementIdentityCard {
  
  pub fn builder() -> PassportElementIdentityCardBuilder {
    let instance = Self {
      tdfname: "passportElementIdentityCard".to_string(),
      identity_card: None,
      
    };
    PassportElementIdentityCardBuilder::new(instance)
  }
  
  
  pub fn identity_card(&self) -> &Option<IdentityDocument> { &self.identity_card }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementIdentityCardBuilder {
  instance: PassportElementIdentityCard
}

impl PassportElementIdentityCardBuilder {
  fn new(instance: PassportElementIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementIdentityCard {
    self.instance.clone()
  }
  
  pub fn identity_card(&mut self, identity_card: IdentityDocument) -> &mut Self {
    self.instance.identity_card = Some(identity_card);
    self
  }
  
}


/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementInternalPassport

  /// Internal passport.
  internal_passport: Option<IdentityDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementInternalPassport {}


impl PassportElementInternalPassport {
  
  pub fn builder() -> PassportElementInternalPassportBuilder {
    let instance = Self {
      tdfname: "passportElementInternalPassport".to_string(),
      internal_passport: None,
      
    };
    PassportElementInternalPassportBuilder::new(instance)
  }
  
  
  pub fn internal_passport(&self) -> &Option<IdentityDocument> { &self.internal_passport }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementInternalPassportBuilder {
  instance: PassportElementInternalPassport
}

impl PassportElementInternalPassportBuilder {
  fn new(instance: PassportElementInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementInternalPassport {
    self.instance.clone()
  }
  
  pub fn internal_passport(&mut self, internal_passport: IdentityDocument) -> &mut Self {
    self.instance.internal_passport = Some(internal_passport);
    self
  }
  
}


/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementAddress

  /// Address.
  address: Option<Address>,


}



#[typetag::serde]
impl PassportElement for PassportElementAddress {}


impl PassportElementAddress {
  
  pub fn builder() -> PassportElementAddressBuilder {
    let instance = Self {
      tdfname: "passportElementAddress".to_string(),
      address: None,
      
    };
    PassportElementAddressBuilder::new(instance)
  }
  
  
  pub fn address(&self) -> &Option<Address> { &self.address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementAddressBuilder {
  instance: PassportElementAddress
}

impl PassportElementAddressBuilder {
  fn new(instance: PassportElementAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementAddress {
    self.instance.clone()
  }
  
  pub fn address(&mut self, address: Address) -> &mut Self {
    self.instance.address = Some(address);
    self
  }
  
}


/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementUtilityBill

  /// Utility bill.
  utility_bill: Option<PersonalDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementUtilityBill {}


impl PassportElementUtilityBill {
  
  pub fn builder() -> PassportElementUtilityBillBuilder {
    let instance = Self {
      tdfname: "passportElementUtilityBill".to_string(),
      utility_bill: None,
      
    };
    PassportElementUtilityBillBuilder::new(instance)
  }
  
  
  pub fn utility_bill(&self) -> &Option<PersonalDocument> { &self.utility_bill }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementUtilityBillBuilder {
  instance: PassportElementUtilityBill
}

impl PassportElementUtilityBillBuilder {
  fn new(instance: PassportElementUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementUtilityBill {
    self.instance.clone()
  }
  
  pub fn utility_bill(&mut self, utility_bill: PersonalDocument) -> &mut Self {
    self.instance.utility_bill = Some(utility_bill);
    self
  }
  
}


/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementBankStatement

  /// Bank statement.
  bank_statement: Option<PersonalDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementBankStatement {}


impl PassportElementBankStatement {
  
  pub fn builder() -> PassportElementBankStatementBuilder {
    let instance = Self {
      tdfname: "passportElementBankStatement".to_string(),
      bank_statement: None,
      
    };
    PassportElementBankStatementBuilder::new(instance)
  }
  
  
  pub fn bank_statement(&self) -> &Option<PersonalDocument> { &self.bank_statement }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementBankStatementBuilder {
  instance: PassportElementBankStatement
}

impl PassportElementBankStatementBuilder {
  fn new(instance: PassportElementBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementBankStatement {
    self.instance.clone()
  }
  
  pub fn bank_statement(&mut self, bank_statement: PersonalDocument) -> &mut Self {
    self.instance.bank_statement = Some(bank_statement);
    self
  }
  
}


/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementRentalAgreement

  /// Rental agreement.
  rental_agreement: Option<PersonalDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementRentalAgreement {}


impl PassportElementRentalAgreement {
  
  pub fn builder() -> PassportElementRentalAgreementBuilder {
    let instance = Self {
      tdfname: "passportElementRentalAgreement".to_string(),
      rental_agreement: None,
      
    };
    PassportElementRentalAgreementBuilder::new(instance)
  }
  
  
  pub fn rental_agreement(&self) -> &Option<PersonalDocument> { &self.rental_agreement }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementRentalAgreementBuilder {
  instance: PassportElementRentalAgreement
}

impl PassportElementRentalAgreementBuilder {
  fn new(instance: PassportElementRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementRentalAgreement {
    self.instance.clone()
  }
  
  pub fn rental_agreement(&mut self, rental_agreement: PersonalDocument) -> &mut Self {
    self.instance.rental_agreement = Some(rental_agreement);
    self
  }
  
}


/// A Telegram Passport element containing the user's passport registration pages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementPassportRegistration

  /// Passport registration pages.
  passport_registration: Option<PersonalDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementPassportRegistration {}


impl PassportElementPassportRegistration {
  
  pub fn builder() -> PassportElementPassportRegistrationBuilder {
    let instance = Self {
      tdfname: "passportElementPassportRegistration".to_string(),
      passport_registration: None,
      
    };
    PassportElementPassportRegistrationBuilder::new(instance)
  }
  
  
  pub fn passport_registration(&self) -> &Option<PersonalDocument> { &self.passport_registration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementPassportRegistrationBuilder {
  instance: PassportElementPassportRegistration
}

impl PassportElementPassportRegistrationBuilder {
  fn new(instance: PassportElementPassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPassportRegistration {
    self.instance.clone()
  }
  
  pub fn passport_registration(&mut self, passport_registration: PersonalDocument) -> &mut Self {
    self.instance.passport_registration = Some(passport_registration);
    self
  }
  
}


/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTemporaryRegistration

  /// Temporary registration.
  temporary_registration: Option<PersonalDocument>,


}



#[typetag::serde]
impl PassportElement for PassportElementTemporaryRegistration {}


impl PassportElementTemporaryRegistration {
  
  pub fn builder() -> PassportElementTemporaryRegistrationBuilder {
    let instance = Self {
      tdfname: "passportElementTemporaryRegistration".to_string(),
      temporary_registration: None,
      
    };
    PassportElementTemporaryRegistrationBuilder::new(instance)
  }
  
  
  pub fn temporary_registration(&self) -> &Option<PersonalDocument> { &self.temporary_registration }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTemporaryRegistrationBuilder {
  instance: PassportElementTemporaryRegistration
}

impl PassportElementTemporaryRegistrationBuilder {
  fn new(instance: PassportElementTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTemporaryRegistration {
    self.instance.clone()
  }
  
  pub fn temporary_registration(&mut self, temporary_registration: PersonalDocument) -> &mut Self {
    self.instance.temporary_registration = Some(temporary_registration);
    self
  }
  
}


/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementPhoneNumber

  /// Phone number.
  phone_number: Option<String>,


}



#[typetag::serde]
impl PassportElement for PassportElementPhoneNumber {}


impl PassportElementPhoneNumber {
  
  pub fn builder() -> PassportElementPhoneNumberBuilder {
    let instance = Self {
      tdfname: "passportElementPhoneNumber".to_string(),
      phone_number: None,
      
    };
    PassportElementPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementPhoneNumberBuilder {
  instance: PassportElementPhoneNumber
}

impl PassportElementPhoneNumberBuilder {
  fn new(instance: PassportElementPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementPhoneNumber {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
}


/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementEmailAddress

  /// Email address.
  email_address: Option<String>,


}



#[typetag::serde]
impl PassportElement for PassportElementEmailAddress {}


impl PassportElementEmailAddress {
  
  pub fn builder() -> PassportElementEmailAddressBuilder {
    let instance = Self {
      tdfname: "passportElementEmailAddress".to_string(),
      email_address: None,
      
    };
    PassportElementEmailAddressBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> &Option<String> { &self.email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementEmailAddressBuilder {
  instance: PassportElementEmailAddress
}

impl PassportElementEmailAddressBuilder {
  fn new(instance: PassportElementEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementEmailAddress {
    self.instance.clone()
  }
  
  pub fn email_address(&mut self, email_address: String) -> &mut Self {
    self.instance.email_address = Some(email_address);
    self
  }
  
}


/// Contains the description of an error in a Telegram Passport element. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementError

  /// Type of the Telegram Passport element which has the error.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Error message.
  message: Option<String>,
  /// Error source.
  source: Option<Box<PassportElementErrorSource>>,


}


impl Clone for PassportElementError {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PassportElementError {}


impl PassportElementError {
  
  pub fn builder() -> PassportElementErrorBuilder {
    let instance = Self {
      tdfname: "passportElementError".to_string(),
      type_: None,
      message: None,
      source: None,
      
    };
    PassportElementErrorBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  pub fn message(&self) -> &Option<String> { &self.message }
  
  pub fn source(&self) -> &Option<Box<PassportElementErrorSource>> { &self.source }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorBuilder {
  instance: PassportElementError
}

impl PassportElementErrorBuilder {
  fn new(instance: PassportElementError) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementError {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn message(&mut self, message: String) -> &mut Self {
    self.instance.message = Some(message);
    self
  }
  
  pub fn source(&mut self, source: Box<PassportElementErrorSource>) -> &mut Self {
    self.instance.source = Some(source);
    self
  }
  
}


/// This class is an abstract base class. Contains the description of an error in a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementErrorSource: Debug {}



impl Object for PassportElementErrorSource {}





/// The element contains an error in an unspecified place. The error will be considered resolved when new data is added. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceUnspecified {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceUnspecified

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceUnspecified {}


impl PassportElementErrorSourceUnspecified {
  
  pub fn builder() -> PassportElementErrorSourceUnspecifiedBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceUnspecified".to_string(),
      
    };
    PassportElementErrorSourceUnspecifiedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceUnspecifiedBuilder {
  instance: PassportElementErrorSourceUnspecified
}

impl PassportElementErrorSourceUnspecifiedBuilder {
  fn new(instance: PassportElementErrorSourceUnspecified) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceUnspecified {
    self.instance.clone()
  }
  
}


/// One of the data fields contains an error. The error will be considered resolved when the value of the field changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceDataField {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceDataField

  /// Field name.
  field_name: Option<String>,


}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceDataField {}


impl PassportElementErrorSourceDataField {
  
  pub fn builder() -> PassportElementErrorSourceDataFieldBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceDataField".to_string(),
      field_name: None,
      
    };
    PassportElementErrorSourceDataFieldBuilder::new(instance)
  }
  
  
  pub fn field_name(&self) -> &Option<String> { &self.field_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceDataFieldBuilder {
  instance: PassportElementErrorSourceDataField
}

impl PassportElementErrorSourceDataFieldBuilder {
  fn new(instance: PassportElementErrorSourceDataField) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceDataField {
    self.instance.clone()
  }
  
  pub fn field_name(&mut self, field_name: String) -> &mut Self {
    self.instance.field_name = Some(field_name);
    self
  }
  
}


/// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFrontSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceFrontSide

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceFrontSide {}


impl PassportElementErrorSourceFrontSide {
  
  pub fn builder() -> PassportElementErrorSourceFrontSideBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceFrontSide".to_string(),
      
    };
    PassportElementErrorSourceFrontSideBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceFrontSideBuilder {
  instance: PassportElementErrorSourceFrontSide
}

impl PassportElementErrorSourceFrontSideBuilder {
  fn new(instance: PassportElementErrorSourceFrontSide) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFrontSide {
    self.instance.clone()
  }
  
}


/// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceReverseSide {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceReverseSide

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceReverseSide {}


impl PassportElementErrorSourceReverseSide {
  
  pub fn builder() -> PassportElementErrorSourceReverseSideBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceReverseSide".to_string(),
      
    };
    PassportElementErrorSourceReverseSideBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceReverseSideBuilder {
  instance: PassportElementErrorSourceReverseSide
}

impl PassportElementErrorSourceReverseSideBuilder {
  fn new(instance: PassportElementErrorSourceReverseSide) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceReverseSide {
    self.instance.clone()
  }
  
}


/// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceSelfie {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceSelfie

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceSelfie {}


impl PassportElementErrorSourceSelfie {
  
  pub fn builder() -> PassportElementErrorSourceSelfieBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceSelfie".to_string(),
      
    };
    PassportElementErrorSourceSelfieBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceSelfieBuilder {
  instance: PassportElementErrorSourceSelfie
}

impl PassportElementErrorSourceSelfieBuilder {
  fn new(instance: PassportElementErrorSourceSelfie) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceSelfie {
    self.instance.clone()
  }
  
}


/// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceTranslationFile

  /// Index of a file with the error.
  file_index: Option<i32>,


}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceTranslationFile {}


impl PassportElementErrorSourceTranslationFile {
  
  pub fn builder() -> PassportElementErrorSourceTranslationFileBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceTranslationFile".to_string(),
      file_index: None,
      
    };
    PassportElementErrorSourceTranslationFileBuilder::new(instance)
  }
  
  
  pub fn file_index(&self) -> &Option<i32> { &self.file_index }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceTranslationFileBuilder {
  instance: PassportElementErrorSourceTranslationFile
}

impl PassportElementErrorSourceTranslationFileBuilder {
  fn new(instance: PassportElementErrorSourceTranslationFile) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceTranslationFile {
    self.instance.clone()
  }
  
  pub fn file_index(&mut self, file_index: i32) -> &mut Self {
    self.instance.file_index = Some(file_index);
    self
  }
  
}


/// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceTranslationFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceTranslationFiles

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceTranslationFiles {}


impl PassportElementErrorSourceTranslationFiles {
  
  pub fn builder() -> PassportElementErrorSourceTranslationFilesBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceTranslationFiles".to_string(),
      
    };
    PassportElementErrorSourceTranslationFilesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceTranslationFilesBuilder {
  instance: PassportElementErrorSourceTranslationFiles
}

impl PassportElementErrorSourceTranslationFilesBuilder {
  fn new(instance: PassportElementErrorSourceTranslationFiles) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceTranslationFiles {
    self.instance.clone()
  }
  
}


/// The file contains an error. The error will be considered resolved when the file changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceFile

  /// Index of a file with the error.
  file_index: Option<i32>,


}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceFile {}


impl PassportElementErrorSourceFile {
  
  pub fn builder() -> PassportElementErrorSourceFileBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceFile".to_string(),
      file_index: None,
      
    };
    PassportElementErrorSourceFileBuilder::new(instance)
  }
  
  
  pub fn file_index(&self) -> &Option<i32> { &self.file_index }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceFileBuilder {
  instance: PassportElementErrorSourceFile
}

impl PassportElementErrorSourceFileBuilder {
  fn new(instance: PassportElementErrorSourceFile) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFile {
    self.instance.clone()
  }
  
  pub fn file_index(&mut self, file_index: i32) -> &mut Self {
    self.instance.file_index = Some(file_index);
    self
  }
  
}


/// The list of attached files contains an error. The error will be considered resolved when the list of files changes. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementErrorSourceFiles {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementErrorSourceFiles

}



#[typetag::serde]
impl PassportElementErrorSource for PassportElementErrorSourceFiles {}


impl PassportElementErrorSourceFiles {
  
  pub fn builder() -> PassportElementErrorSourceFilesBuilder {
    let instance = Self {
      tdfname: "passportElementErrorSourceFiles".to_string(),
      
    };
    PassportElementErrorSourceFilesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementErrorSourceFilesBuilder {
  instance: PassportElementErrorSourceFiles
}

impl PassportElementErrorSourceFilesBuilder {
  fn new(instance: PassportElementErrorSourceFiles) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementErrorSourceFiles {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Contains the type of a Telegram Passport element. 
#[typetag::serde(tag = "@struct")]
pub trait PassportElementType: Debug {}



impl Object for PassportElementType {}





/// A Telegram Passport element containing the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypePersonalDetails

}



#[typetag::serde]
impl PassportElementType for PassportElementTypePersonalDetails {}


impl PassportElementTypePersonalDetails {
  
  pub fn builder() -> PassportElementTypePersonalDetailsBuilder {
    let instance = Self {
      tdfname: "passportElementTypePersonalDetails".to_string(),
      
    };
    PassportElementTypePersonalDetailsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypePersonalDetailsBuilder {
  instance: PassportElementTypePersonalDetails
}

impl PassportElementTypePersonalDetailsBuilder {
  fn new(instance: PassportElementTypePersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePersonalDetails {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypePassport

}



#[typetag::serde]
impl PassportElementType for PassportElementTypePassport {}


impl PassportElementTypePassport {
  
  pub fn builder() -> PassportElementTypePassportBuilder {
    let instance = Self {
      tdfname: "passportElementTypePassport".to_string(),
      
    };
    PassportElementTypePassportBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypePassportBuilder {
  instance: PassportElementTypePassport
}

impl PassportElementTypePassportBuilder {
  fn new(instance: PassportElementTypePassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePassport {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's driver license. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeDriverLicense {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeDriverLicense

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeDriverLicense {}


impl PassportElementTypeDriverLicense {
  
  pub fn builder() -> PassportElementTypeDriverLicenseBuilder {
    let instance = Self {
      tdfname: "passportElementTypeDriverLicense".to_string(),
      
    };
    PassportElementTypeDriverLicenseBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeDriverLicenseBuilder {
  instance: PassportElementTypeDriverLicense
}

impl PassportElementTypeDriverLicenseBuilder {
  fn new(instance: PassportElementTypeDriverLicense) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeDriverLicense {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's identity card. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeIdentityCard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeIdentityCard

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeIdentityCard {}


impl PassportElementTypeIdentityCard {
  
  pub fn builder() -> PassportElementTypeIdentityCardBuilder {
    let instance = Self {
      tdfname: "passportElementTypeIdentityCard".to_string(),
      
    };
    PassportElementTypeIdentityCardBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeIdentityCardBuilder {
  instance: PassportElementTypeIdentityCard
}

impl PassportElementTypeIdentityCardBuilder {
  fn new(instance: PassportElementTypeIdentityCard) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeIdentityCard {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's internal passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeInternalPassport {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeInternalPassport

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeInternalPassport {}


impl PassportElementTypeInternalPassport {
  
  pub fn builder() -> PassportElementTypeInternalPassportBuilder {
    let instance = Self {
      tdfname: "passportElementTypeInternalPassport".to_string(),
      
    };
    PassportElementTypeInternalPassportBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeInternalPassportBuilder {
  instance: PassportElementTypeInternalPassport
}

impl PassportElementTypeInternalPassportBuilder {
  fn new(instance: PassportElementTypeInternalPassport) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeInternalPassport {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeAddress

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeAddress {}


impl PassportElementTypeAddress {
  
  pub fn builder() -> PassportElementTypeAddressBuilder {
    let instance = Self {
      tdfname: "passportElementTypeAddress".to_string(),
      
    };
    PassportElementTypeAddressBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeAddressBuilder {
  instance: PassportElementTypeAddress
}

impl PassportElementTypeAddressBuilder {
  fn new(instance: PassportElementTypeAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeAddress {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's utility bill. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeUtilityBill {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeUtilityBill

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeUtilityBill {}


impl PassportElementTypeUtilityBill {
  
  pub fn builder() -> PassportElementTypeUtilityBillBuilder {
    let instance = Self {
      tdfname: "passportElementTypeUtilityBill".to_string(),
      
    };
    PassportElementTypeUtilityBillBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeUtilityBillBuilder {
  instance: PassportElementTypeUtilityBill
}

impl PassportElementTypeUtilityBillBuilder {
  fn new(instance: PassportElementTypeUtilityBill) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeUtilityBill {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's bank statement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeBankStatement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeBankStatement

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeBankStatement {}


impl PassportElementTypeBankStatement {
  
  pub fn builder() -> PassportElementTypeBankStatementBuilder {
    let instance = Self {
      tdfname: "passportElementTypeBankStatement".to_string(),
      
    };
    PassportElementTypeBankStatementBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeBankStatementBuilder {
  instance: PassportElementTypeBankStatement
}

impl PassportElementTypeBankStatementBuilder {
  fn new(instance: PassportElementTypeBankStatement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeBankStatement {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's rental agreement. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeRentalAgreement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeRentalAgreement

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeRentalAgreement {}


impl PassportElementTypeRentalAgreement {
  
  pub fn builder() -> PassportElementTypeRentalAgreementBuilder {
    let instance = Self {
      tdfname: "passportElementTypeRentalAgreement".to_string(),
      
    };
    PassportElementTypeRentalAgreementBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeRentalAgreementBuilder {
  instance: PassportElementTypeRentalAgreement
}

impl PassportElementTypeRentalAgreementBuilder {
  fn new(instance: PassportElementTypeRentalAgreement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeRentalAgreement {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the registration page of the user's passport. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePassportRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypePassportRegistration

}



#[typetag::serde]
impl PassportElementType for PassportElementTypePassportRegistration {}


impl PassportElementTypePassportRegistration {
  
  pub fn builder() -> PassportElementTypePassportRegistrationBuilder {
    let instance = Self {
      tdfname: "passportElementTypePassportRegistration".to_string(),
      
    };
    PassportElementTypePassportRegistrationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypePassportRegistrationBuilder {
  instance: PassportElementTypePassportRegistration
}

impl PassportElementTypePassportRegistrationBuilder {
  fn new(instance: PassportElementTypePassportRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePassportRegistration {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's temporary registration. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeTemporaryRegistration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeTemporaryRegistration

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeTemporaryRegistration {}


impl PassportElementTypeTemporaryRegistration {
  
  pub fn builder() -> PassportElementTypeTemporaryRegistrationBuilder {
    let instance = Self {
      tdfname: "passportElementTypeTemporaryRegistration".to_string(),
      
    };
    PassportElementTypeTemporaryRegistrationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeTemporaryRegistrationBuilder {
  instance: PassportElementTypeTemporaryRegistration
}

impl PassportElementTypeTemporaryRegistrationBuilder {
  fn new(instance: PassportElementTypeTemporaryRegistration) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeTemporaryRegistration {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypePhoneNumber

}



#[typetag::serde]
impl PassportElementType for PassportElementTypePhoneNumber {}


impl PassportElementTypePhoneNumber {
  
  pub fn builder() -> PassportElementTypePhoneNumberBuilder {
    let instance = Self {
      tdfname: "passportElementTypePhoneNumber".to_string(),
      
    };
    PassportElementTypePhoneNumberBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypePhoneNumberBuilder {
  instance: PassportElementTypePhoneNumber
}

impl PassportElementTypePhoneNumberBuilder {
  fn new(instance: PassportElementTypePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypePhoneNumber {
    self.instance.clone()
  }
  
}


/// A Telegram Passport element containing the user's email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportElementTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementTypeEmailAddress

}



#[typetag::serde]
impl PassportElementType for PassportElementTypeEmailAddress {}


impl PassportElementTypeEmailAddress {
  
  pub fn builder() -> PassportElementTypeEmailAddressBuilder {
    let instance = Self {
      tdfname: "passportElementTypeEmailAddress".to_string(),
      
    };
    PassportElementTypeEmailAddressBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementTypeEmailAddressBuilder {
  instance: PassportElementTypeEmailAddress
}

impl PassportElementTypeEmailAddressBuilder {
  fn new(instance: PassportElementTypeEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementTypeEmailAddress {
    self.instance.clone()
  }
  
}


/// Contains information about saved Telegram Passport elements. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElements

  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,


}


impl Clone for PassportElements {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PassportElements {}


impl PassportElements {
  
  pub fn builder() -> PassportElementsBuilder {
    let instance = Self {
      tdfname: "passportElements".to_string(),
      elements: None,
      
    };
    PassportElementsBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> &Option<Vec<Box<PassportElement>>> { &self.elements }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementsBuilder {
  instance: PassportElements
}

impl PassportElementsBuilder {
  fn new(instance: PassportElements) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElements {
    self.instance.clone()
  }
  
  pub fn elements(&mut self, elements: Vec<Box<PassportElement>>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
}


/// Contains information about a Telegram Passport elements and corresponding errors. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportElementsWithErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportElementsWithErrors

  /// Telegram Passport elements.
  elements: Option<Vec<Box<PassportElement>>>,
  /// Errors in the elements that are already available.
  errors: Option<Vec<PassportElementError>>,


}


impl Clone for PassportElementsWithErrors {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PassportElementsWithErrors {}


impl PassportElementsWithErrors {
  
  pub fn builder() -> PassportElementsWithErrorsBuilder {
    let instance = Self {
      tdfname: "passportElementsWithErrors".to_string(),
      elements: None,
      errors: None,
      
    };
    PassportElementsWithErrorsBuilder::new(instance)
  }
  
  
  pub fn elements(&self) -> &Option<Vec<Box<PassportElement>>> { &self.elements }
  
  pub fn errors(&self) -> &Option<Vec<PassportElementError>> { &self.errors }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportElementsWithErrorsBuilder {
  instance: PassportElementsWithErrors
}

impl PassportElementsWithErrorsBuilder {
  fn new(instance: PassportElementsWithErrors) -> Self { Self { instance } }

  pub fn build(&self) -> PassportElementsWithErrors {
    self.instance.clone()
  }
  
  pub fn elements(&mut self, elements: Vec<Box<PassportElement>>) -> &mut Self {
    self.instance.elements = Some(elements);
    self
  }
  
  pub fn errors(&mut self, errors: Vec<PassportElementError>) -> &mut Self {
    self.instance.errors = Some(errors);
    self
  }
  
}


/// Contains a description of the required Telegram Passport element that was requested by a service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PassportRequiredElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportRequiredElement

  /// List of Telegram Passport elements any of which is enough to provide.
  suitable_elements: Option<Vec<PassportSuitableElement>>,


}




impl Object for PassportRequiredElement {}


impl PassportRequiredElement {
  
  pub fn builder() -> PassportRequiredElementBuilder {
    let instance = Self {
      tdfname: "passportRequiredElement".to_string(),
      suitable_elements: None,
      
    };
    PassportRequiredElementBuilder::new(instance)
  }
  
  
  pub fn suitable_elements(&self) -> &Option<Vec<PassportSuitableElement>> { &self.suitable_elements }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportRequiredElementBuilder {
  instance: PassportRequiredElement
}

impl PassportRequiredElementBuilder {
  fn new(instance: PassportRequiredElement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportRequiredElement {
    self.instance.clone()
  }
  
  pub fn suitable_elements(&mut self, suitable_elements: Vec<PassportSuitableElement>) -> &mut Self {
    self.instance.suitable_elements = Some(suitable_elements);
    self
  }
  
}


/// Contains information about a Telegram Passport element that was requested by a service. 
#[derive(Debug, Serialize, Deserialize)]
pub struct PassportSuitableElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passportSuitableElement

  /// Type of the element.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// True, if a selfie is required with the identity document.
  is_selfie_required: Option<bool>,
  /// True, if a certified English translation is required with the document.
  is_translation_required: Option<bool>,
  /// True, if personal details must include the user's name in the language of their country of residence.
  is_native_name_required: Option<bool>,


}


impl Clone for PassportSuitableElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for PassportSuitableElement {}


impl PassportSuitableElement {
  
  pub fn builder() -> PassportSuitableElementBuilder {
    let instance = Self {
      tdfname: "passportSuitableElement".to_string(),
      type_: None,
      is_selfie_required: None,
      is_translation_required: None,
      is_native_name_required: None,
      
    };
    PassportSuitableElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  pub fn is_selfie_required(&self) -> &Option<bool> { &self.is_selfie_required }
  
  pub fn is_translation_required(&self) -> &Option<bool> { &self.is_translation_required }
  
  pub fn is_native_name_required(&self) -> &Option<bool> { &self.is_native_name_required }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PassportSuitableElementBuilder {
  instance: PassportSuitableElement
}

impl PassportSuitableElementBuilder {
  fn new(instance: PassportSuitableElement) -> Self { Self { instance } }

  pub fn build(&self) -> PassportSuitableElement {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn is_selfie_required(&mut self, is_selfie_required: bool) -> &mut Self {
    self.instance.is_selfie_required = Some(is_selfie_required);
    self
  }
  
  pub fn is_translation_required(&mut self, is_translation_required: bool) -> &mut Self {
    self.instance.is_translation_required = Some(is_translation_required);
    self
  }
  
  pub fn is_native_name_required(&mut self, is_native_name_required: bool) -> &mut Self {
    self.instance.is_native_name_required = Some(is_native_name_required);
    self
  }
  
}


/// Represents the current state of 2-step verification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // passwordState

  /// True, if a 2-step verification password is set.
  has_password: Option<bool>,
  /// Hint for the password; may be empty.
  password_hint: Option<String>,
  /// True, if a recovery email is set.
  has_recovery_email_address: Option<bool>,
  /// True, if some Telegram Passport elements were saved.
  has_passport_data: Option<bool>,
  /// Information about the recovery email address to which the confirmation email was sent; may be null.
  recovery_email_address_code_info: Option<EmailAddressAuthenticationCodeInfo>,


}




impl Object for PasswordState {}


impl PasswordState {
  
  pub fn builder() -> PasswordStateBuilder {
    let instance = Self {
      tdfname: "passwordState".to_string(),
      has_password: None,
      password_hint: None,
      has_recovery_email_address: None,
      has_passport_data: None,
      recovery_email_address_code_info: None,
      
    };
    PasswordStateBuilder::new(instance)
  }
  
  
  pub fn has_password(&self) -> &Option<bool> { &self.has_password }
  
  pub fn password_hint(&self) -> &Option<String> { &self.password_hint }
  
  pub fn has_recovery_email_address(&self) -> &Option<bool> { &self.has_recovery_email_address }
  
  pub fn has_passport_data(&self) -> &Option<bool> { &self.has_passport_data }
  
  pub fn recovery_email_address_code_info(&self) -> &Option<EmailAddressAuthenticationCodeInfo> { &self.recovery_email_address_code_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PasswordStateBuilder {
  instance: PasswordState
}

impl PasswordStateBuilder {
  fn new(instance: PasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> PasswordState {
    self.instance.clone()
  }
  
  pub fn has_password(&mut self, has_password: bool) -> &mut Self {
    self.instance.has_password = Some(has_password);
    self
  }
  
  pub fn password_hint(&mut self, password_hint: String) -> &mut Self {
    self.instance.password_hint = Some(password_hint);
    self
  }
  
  pub fn has_recovery_email_address(&mut self, has_recovery_email_address: bool) -> &mut Self {
    self.instance.has_recovery_email_address = Some(has_recovery_email_address);
    self
  }
  
  pub fn has_passport_data(&mut self, has_passport_data: bool) -> &mut Self {
    self.instance.has_passport_data = Some(has_passport_data);
    self
  }
  
  pub fn recovery_email_address_code_info(&mut self, recovery_email_address_code_info: EmailAddressAuthenticationCodeInfo) -> &mut Self {
    self.instance.recovery_email_address_code_info = Some(recovery_email_address_code_info);
    self
  }
  
}


/// Contains information about an invoice payment form. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // paymentForm

  /// Full information of the invoice.
  invoice: Option<Invoice>,
  /// Payment form URL.
  url: Option<String>,
  /// Contains information about the payment provider, if available, to support it natively without the need for opening the URL; may be null.
  payments_provider: Option<PaymentsProviderStripe>,
  /// Saved server-side order information; may be null.
  saved_order_info: Option<OrderInfo>,
  /// Contains information about saved card credentials; may be null.
  saved_credentials: Option<SavedCredentials>,
  /// True, if the user can choose to save credentials.
  can_save_credentials: Option<bool>,
  /// True, if the user will be able to save credentials protected by a password they set up.
  need_password: Option<bool>,


}




impl Object for PaymentForm {}


impl PaymentForm {
  
  pub fn builder() -> PaymentFormBuilder {
    let instance = Self {
      tdfname: "paymentForm".to_string(),
      invoice: None,
      url: None,
      payments_provider: None,
      saved_order_info: None,
      saved_credentials: None,
      can_save_credentials: None,
      need_password: None,
      
    };
    PaymentFormBuilder::new(instance)
  }
  
  
  pub fn invoice(&self) -> &Option<Invoice> { &self.invoice }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn payments_provider(&self) -> &Option<PaymentsProviderStripe> { &self.payments_provider }
  
  pub fn saved_order_info(&self) -> &Option<OrderInfo> { &self.saved_order_info }
  
  pub fn saved_credentials(&self) -> &Option<SavedCredentials> { &self.saved_credentials }
  
  pub fn can_save_credentials(&self) -> &Option<bool> { &self.can_save_credentials }
  
  pub fn need_password(&self) -> &Option<bool> { &self.need_password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PaymentFormBuilder {
  instance: PaymentForm
}

impl PaymentFormBuilder {
  fn new(instance: PaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentForm {
    self.instance.clone()
  }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn payments_provider(&mut self, payments_provider: PaymentsProviderStripe) -> &mut Self {
    self.instance.payments_provider = Some(payments_provider);
    self
  }
  
  pub fn saved_order_info(&mut self, saved_order_info: OrderInfo) -> &mut Self {
    self.instance.saved_order_info = Some(saved_order_info);
    self
  }
  
  pub fn saved_credentials(&mut self, saved_credentials: SavedCredentials) -> &mut Self {
    self.instance.saved_credentials = Some(saved_credentials);
    self
  }
  
  pub fn can_save_credentials(&mut self, can_save_credentials: bool) -> &mut Self {
    self.instance.can_save_credentials = Some(can_save_credentials);
    self
  }
  
  pub fn need_password(&mut self, need_password: bool) -> &mut Self {
    self.instance.need_password = Some(need_password);
    self
  }
  
}


/// Contains information about a successful payment. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // paymentReceipt

  /// Point in time (Unix timestamp) when the payment was made.
  date: Option<i32>,
  /// User identifier of the payment provider bot.
  payments_provider_user_id: Option<i32>,
  /// Contains information about the invoice.
  invoice: Option<Invoice>,
  /// Contains order information; may be null.
  order_info: Option<OrderInfo>,
  /// Chosen shipping option; may be null.
  shipping_option: Option<ShippingOption>,
  /// Title of the saved credentials.
  credentials_title: Option<String>,


}




impl Object for PaymentReceipt {}


impl PaymentReceipt {
  
  pub fn builder() -> PaymentReceiptBuilder {
    let instance = Self {
      tdfname: "paymentReceipt".to_string(),
      date: None,
      payments_provider_user_id: None,
      invoice: None,
      order_info: None,
      shipping_option: None,
      credentials_title: None,
      
    };
    PaymentReceiptBuilder::new(instance)
  }
  
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn payments_provider_user_id(&self) -> &Option<i32> { &self.payments_provider_user_id }
  
  pub fn invoice(&self) -> &Option<Invoice> { &self.invoice }
  
  pub fn order_info(&self) -> &Option<OrderInfo> { &self.order_info }
  
  pub fn shipping_option(&self) -> &Option<ShippingOption> { &self.shipping_option }
  
  pub fn credentials_title(&self) -> &Option<String> { &self.credentials_title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PaymentReceiptBuilder {
  instance: PaymentReceipt
}

impl PaymentReceiptBuilder {
  fn new(instance: PaymentReceipt) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentReceipt {
    self.instance.clone()
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn payments_provider_user_id(&mut self, payments_provider_user_id: i32) -> &mut Self {
    self.instance.payments_provider_user_id = Some(payments_provider_user_id);
    self
  }
  
  pub fn invoice(&mut self, invoice: Invoice) -> &mut Self {
    self.instance.invoice = Some(invoice);
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn shipping_option(&mut self, shipping_option: ShippingOption) -> &mut Self {
    self.instance.shipping_option = Some(shipping_option);
    self
  }
  
  pub fn credentials_title(&mut self, credentials_title: String) -> &mut Self {
    self.instance.credentials_title = Some(credentials_title);
    self
  }
  
}


/// Contains the result of a payment request. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // paymentResult

  /// True, if the payment request was successful; otherwise the verification_url will be not empty.
  success: Option<bool>,
  /// URL for additional payment credentials verification.
  verification_url: Option<String>,


}




impl Object for PaymentResult {}


impl PaymentResult {
  
  pub fn builder() -> PaymentResultBuilder {
    let instance = Self {
      tdfname: "paymentResult".to_string(),
      success: None,
      verification_url: None,
      
    };
    PaymentResultBuilder::new(instance)
  }
  
  
  pub fn success(&self) -> &Option<bool> { &self.success }
  
  pub fn verification_url(&self) -> &Option<String> { &self.verification_url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PaymentResultBuilder {
  instance: PaymentResult
}

impl PaymentResultBuilder {
  fn new(instance: PaymentResult) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentResult {
    self.instance.clone()
  }
  
  pub fn success(&mut self, success: bool) -> &mut Self {
    self.instance.success = Some(success);
    self
  }
  
  pub fn verification_url(&mut self, verification_url: String) -> &mut Self {
    self.instance.verification_url = Some(verification_url);
    self
  }
  
}


/// Stripe payment provider. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentsProviderStripe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // paymentsProviderStripe

  /// Stripe API publishable key.
  publishable_key: Option<String>,
  /// True, if the user country must be provided.
  need_country: Option<bool>,
  /// True, if the user ZIP/postal code must be provided.
  need_postal_code: Option<bool>,
  /// True, if the cardholder name must be provided.
  need_cardholder_name: Option<bool>,


}




impl Object for PaymentsProviderStripe {}


impl PaymentsProviderStripe {
  
  pub fn builder() -> PaymentsProviderStripeBuilder {
    let instance = Self {
      tdfname: "paymentsProviderStripe".to_string(),
      publishable_key: None,
      need_country: None,
      need_postal_code: None,
      need_cardholder_name: None,
      
    };
    PaymentsProviderStripeBuilder::new(instance)
  }
  
  
  pub fn publishable_key(&self) -> &Option<String> { &self.publishable_key }
  
  pub fn need_country(&self) -> &Option<bool> { &self.need_country }
  
  pub fn need_postal_code(&self) -> &Option<bool> { &self.need_postal_code }
  
  pub fn need_cardholder_name(&self) -> &Option<bool> { &self.need_cardholder_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PaymentsProviderStripeBuilder {
  instance: PaymentsProviderStripe
}

impl PaymentsProviderStripeBuilder {
  fn new(instance: PaymentsProviderStripe) -> Self { Self { instance } }

  pub fn build(&self) -> PaymentsProviderStripe {
    self.instance.clone()
  }
  
  pub fn publishable_key(&mut self, publishable_key: String) -> &mut Self {
    self.instance.publishable_key = Some(publishable_key);
    self
  }
  
  pub fn need_country(&mut self, need_country: bool) -> &mut Self {
    self.instance.need_country = Some(need_country);
    self
  }
  
  pub fn need_postal_code(&mut self, need_postal_code: bool) -> &mut Self {
    self.instance.need_postal_code = Some(need_postal_code);
    self
  }
  
  pub fn need_cardholder_name(&mut self, need_cardholder_name: bool) -> &mut Self {
    self.instance.need_cardholder_name = Some(need_cardholder_name);
    self
  }
  
}


/// Contains the user's personal details. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDetails {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // personalDetails

  /// First name of the user written in English; 1-255 characters.
  first_name: Option<String>,
  /// Middle name of the user written in English; 0-255 characters.
  middle_name: Option<String>,
  /// Last name of the user written in English; 1-255 characters.
  last_name: Option<String>,
  /// Native first name of the user; 1-255 characters.
  native_first_name: Option<String>,
  /// Native middle name of the user; 0-255 characters.
  native_middle_name: Option<String>,
  /// Native last name of the user; 1-255 characters.
  native_last_name: Option<String>,
  /// Birthdate of the user.
  birthdate: Option<Date>,
  /// Gender of the user, "male" or "female".
  gender: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's country.
  country_code: Option<String>,
  /// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country.
  residence_country_code: Option<String>,


}




impl Object for PersonalDetails {}


impl PersonalDetails {
  
  pub fn builder() -> PersonalDetailsBuilder {
    let instance = Self {
      tdfname: "personalDetails".to_string(),
      first_name: None,
      middle_name: None,
      last_name: None,
      native_first_name: None,
      native_middle_name: None,
      native_last_name: None,
      birthdate: None,
      gender: None,
      country_code: None,
      residence_country_code: None,
      
    };
    PersonalDetailsBuilder::new(instance)
  }
  
  
  pub fn first_name(&self) -> &Option<String> { &self.first_name }
  
  pub fn middle_name(&self) -> &Option<String> { &self.middle_name }
  
  pub fn last_name(&self) -> &Option<String> { &self.last_name }
  
  pub fn native_first_name(&self) -> &Option<String> { &self.native_first_name }
  
  pub fn native_middle_name(&self) -> &Option<String> { &self.native_middle_name }
  
  pub fn native_last_name(&self) -> &Option<String> { &self.native_last_name }
  
  pub fn birthdate(&self) -> &Option<Date> { &self.birthdate }
  
  pub fn gender(&self) -> &Option<String> { &self.gender }
  
  pub fn country_code(&self) -> &Option<String> { &self.country_code }
  
  pub fn residence_country_code(&self) -> &Option<String> { &self.residence_country_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PersonalDetailsBuilder {
  instance: PersonalDetails
}

impl PersonalDetailsBuilder {
  fn new(instance: PersonalDetails) -> Self { Self { instance } }

  pub fn build(&self) -> PersonalDetails {
    self.instance.clone()
  }
  
  pub fn first_name(&mut self, first_name: String) -> &mut Self {
    self.instance.first_name = Some(first_name);
    self
  }
  
  pub fn middle_name(&mut self, middle_name: String) -> &mut Self {
    self.instance.middle_name = Some(middle_name);
    self
  }
  
  pub fn last_name(&mut self, last_name: String) -> &mut Self {
    self.instance.last_name = Some(last_name);
    self
  }
  
  pub fn native_first_name(&mut self, native_first_name: String) -> &mut Self {
    self.instance.native_first_name = Some(native_first_name);
    self
  }
  
  pub fn native_middle_name(&mut self, native_middle_name: String) -> &mut Self {
    self.instance.native_middle_name = Some(native_middle_name);
    self
  }
  
  pub fn native_last_name(&mut self, native_last_name: String) -> &mut Self {
    self.instance.native_last_name = Some(native_last_name);
    self
  }
  
  pub fn birthdate(&mut self, birthdate: Date) -> &mut Self {
    self.instance.birthdate = Some(birthdate);
    self
  }
  
  pub fn gender(&mut self, gender: String) -> &mut Self {
    self.instance.gender = Some(gender);
    self
  }
  
  pub fn country_code(&mut self, country_code: String) -> &mut Self {
    self.instance.country_code = Some(country_code);
    self
  }
  
  pub fn residence_country_code(&mut self, residence_country_code: String) -> &mut Self {
    self.instance.residence_country_code = Some(residence_country_code);
    self
  }
  
}


/// A personal document, containing some information about a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersonalDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // personalDocument

  /// List of files containing the pages of the document.
  files: Option<Vec<DatedFile>>,
  /// List of files containing a certified English translation of the document.
  translation: Option<Vec<DatedFile>>,


}




impl Object for PersonalDocument {}


impl PersonalDocument {
  
  pub fn builder() -> PersonalDocumentBuilder {
    let instance = Self {
      tdfname: "personalDocument".to_string(),
      files: None,
      translation: None,
      
    };
    PersonalDocumentBuilder::new(instance)
  }
  
  
  pub fn files(&self) -> &Option<Vec<DatedFile>> { &self.files }
  
  pub fn translation(&self) -> &Option<Vec<DatedFile>> { &self.translation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PersonalDocumentBuilder {
  instance: PersonalDocument
}

impl PersonalDocumentBuilder {
  fn new(instance: PersonalDocument) -> Self { Self { instance } }

  pub fn build(&self) -> PersonalDocument {
    self.instance.clone()
  }
  
  pub fn files(&mut self, files: Vec<DatedFile>) -> &mut Self {
    self.instance.files = Some(files);
    self
  }
  
  pub fn translation(&mut self, translation: Vec<DatedFile>) -> &mut Self {
    self.instance.translation = Some(translation);
    self
  }
  
}


/// Describes a photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Photo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // photo

  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// Available variants of the photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,


}




impl Object for Photo {}


impl Photo {
  
  pub fn builder() -> PhotoBuilder {
    let instance = Self {
      tdfname: "photo".to_string(),
      has_stickers: None,
      sizes: None,
      
    };
    PhotoBuilder::new(instance)
  }
  
  
  pub fn has_stickers(&self) -> &Option<bool> { &self.has_stickers }
  
  pub fn sizes(&self) -> &Option<Vec<PhotoSize>> { &self.sizes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PhotoBuilder {
  instance: Photo
}

impl PhotoBuilder {
  fn new(instance: Photo) -> Self { Self { instance } }

  pub fn build(&self) -> Photo {
    self.instance.clone()
  }
  
  pub fn has_stickers(&mut self, has_stickers: bool) -> &mut Self {
    self.instance.has_stickers = Some(has_stickers);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
}


/// Photo description. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhotoSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // photoSize

  /// Thumbnail type (see https://core.telegram.org/constructor/photoSize).
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Information about the photo file.
  photo: Option<File>,
  /// Photo width.
  width: Option<i32>,
  /// Photo height.
  height: Option<i32>,


}




impl Object for PhotoSize {}


impl PhotoSize {
  
  pub fn builder() -> PhotoSizeBuilder {
    let instance = Self {
      tdfname: "photoSize".to_string(),
      type_: None,
      photo: None,
      width: None,
      height: None,
      
    };
    PhotoSizeBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<String> { &self.type_ }
  
  pub fn photo(&self) -> &Option<File> { &self.photo }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PhotoSizeBuilder {
  instance: PhotoSize
}

impl PhotoSizeBuilder {
  fn new(instance: PhotoSize) -> Self { Self { instance } }

  pub fn build(&self) -> PhotoSize {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: String) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn photo(&mut self, photo: File) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}


/// Describes a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Poll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // poll

  /// Unique poll identifier.
  id: Option<i64>,
  /// Poll question, 1-255 characters.
  question: Option<String>,
  /// List of poll answer options.
  options: Option<Vec<PollOption>>,
  /// Total number of voters, participating in the poll.
  total_voter_count: Option<i32>,
  /// True, if the poll is closed.
  is_closed: Option<bool>,


}




impl Object for Poll {}


impl Poll {
  
  pub fn builder() -> PollBuilder {
    let instance = Self {
      tdfname: "poll".to_string(),
      id: None,
      question: None,
      options: None,
      total_voter_count: None,
      is_closed: None,
      
    };
    PollBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn question(&self) -> &Option<String> { &self.question }
  
  pub fn options(&self) -> &Option<Vec<PollOption>> { &self.options }
  
  pub fn total_voter_count(&self) -> &Option<i32> { &self.total_voter_count }
  
  pub fn is_closed(&self) -> &Option<bool> { &self.is_closed }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PollBuilder {
  instance: Poll
}

impl PollBuilder {
  fn new(instance: Poll) -> Self { Self { instance } }

  pub fn build(&self) -> Poll {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn question(&mut self, question: String) -> &mut Self {
    self.instance.question = Some(question);
    self
  }
  
  pub fn options(&mut self, options: Vec<PollOption>) -> &mut Self {
    self.instance.options = Some(options);
    self
  }
  
  pub fn total_voter_count(&mut self, total_voter_count: i32) -> &mut Self {
    self.instance.total_voter_count = Some(total_voter_count);
    self
  }
  
  pub fn is_closed(&mut self, is_closed: bool) -> &mut Self {
    self.instance.is_closed = Some(is_closed);
    self
  }
  
}


/// Describes one answer option of a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PollOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pollOption

  /// Option text, 1-100 characters.
  text: Option<String>,
  /// Number of voters for this option, available only for closed or voted polls.
  voter_count: Option<i32>,
  /// The percentage of votes for this option, 0-100.
  vote_percentage: Option<i32>,
  /// True, if the option was chosen by the user.
  is_chosen: Option<bool>,
  /// True, if the option is being chosen by a pending setPollAnswer request.
  is_being_chosen: Option<bool>,


}




impl Object for PollOption {}


impl PollOption {
  
  pub fn builder() -> PollOptionBuilder {
    let instance = Self {
      tdfname: "pollOption".to_string(),
      text: None,
      voter_count: None,
      vote_percentage: None,
      is_chosen: None,
      is_being_chosen: None,
      
    };
    PollOptionBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn voter_count(&self) -> &Option<i32> { &self.voter_count }
  
  pub fn vote_percentage(&self) -> &Option<i32> { &self.vote_percentage }
  
  pub fn is_chosen(&self) -> &Option<bool> { &self.is_chosen }
  
  pub fn is_being_chosen(&self) -> &Option<bool> { &self.is_being_chosen }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PollOptionBuilder {
  instance: PollOption
}

impl PollOptionBuilder {
  fn new(instance: PollOption) -> Self { Self { instance } }

  pub fn build(&self) -> PollOption {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn voter_count(&mut self, voter_count: i32) -> &mut Self {
    self.instance.voter_count = Some(voter_count);
    self
  }
  
  pub fn vote_percentage(&mut self, vote_percentage: i32) -> &mut Self {
    self.instance.vote_percentage = Some(vote_percentage);
    self
  }
  
  pub fn is_chosen(&mut self, is_chosen: bool) -> &mut Self {
    self.instance.is_chosen = Some(is_chosen);
    self
  }
  
  pub fn is_being_chosen(&mut self, is_being_chosen: bool) -> &mut Self {
    self.instance.is_being_chosen = Some(is_being_chosen);
    self
  }
  
}


/// Describes a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // profilePhoto

  /// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of userProfilePhotos.
  id: Option<i64>,
  /// A small (160x160) user profile photo.
  small: Option<File>,
  /// A big (640x640) user profile photo.
  big: Option<File>,


}




impl Object for ProfilePhoto {}


impl ProfilePhoto {
  
  pub fn builder() -> ProfilePhotoBuilder {
    let instance = Self {
      tdfname: "profilePhoto".to_string(),
      id: None,
      small: None,
      big: None,
      
    };
    ProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn small(&self) -> &Option<File> { &self.small }
  
  pub fn big(&self) -> &Option<File> { &self.big }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProfilePhotoBuilder {
  instance: ProfilePhoto
}

impl ProfilePhotoBuilder {
  fn new(instance: ProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> ProfilePhoto {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn small(&mut self, small: File) -> &mut Self {
    self.instance.small = Some(small);
    self
  }
  
  pub fn big(&mut self, big: File) -> &mut Self {
    self.instance.big = Some(big);
    self
  }
  
}


/// Represents a list of proxy servers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Proxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // proxies

  /// List of proxy servers.
  proxies: Option<Vec<Proxy>>,


}




impl Object for Proxies {}


impl Proxies {
  
  pub fn builder() -> ProxiesBuilder {
    let instance = Self {
      tdfname: "proxies".to_string(),
      proxies: None,
      
    };
    ProxiesBuilder::new(instance)
  }
  
  
  pub fn proxies(&self) -> &Option<Vec<Proxy>> { &self.proxies }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProxiesBuilder {
  instance: Proxies
}

impl ProxiesBuilder {
  fn new(instance: Proxies) -> Self { Self { instance } }

  pub fn build(&self) -> Proxies {
    self.instance.clone()
  }
  
  pub fn proxies(&mut self, proxies: Vec<Proxy>) -> &mut Self {
    self.instance.proxies = Some(proxies);
    self
  }
  
}


/// Contains information about a proxy server. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Proxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // proxy

  /// Unique identifier of the proxy.
  id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// Point in time (Unix timestamp) when the proxy was last used; 0 if never.
  last_used_date: Option<i32>,
  /// True, if the proxy is enabled now.
  is_enabled: Option<bool>,
  /// Type of the proxy.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,


}


impl Clone for Proxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Proxy {}


impl Proxy {
  
  pub fn builder() -> ProxyBuilder {
    let instance = Self {
      tdfname: "proxy".to_string(),
      id: None,
      server: None,
      port: None,
      last_used_date: None,
      is_enabled: None,
      type_: None,
      
    };
    ProxyBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn server(&self) -> &Option<String> { &self.server }
  
  pub fn port(&self) -> &Option<i32> { &self.port }
  
  pub fn last_used_date(&self) -> &Option<i32> { &self.last_used_date }
  
  pub fn is_enabled(&self) -> &Option<bool> { &self.is_enabled }
  
  pub fn type_(&self) -> &Option<Box<ProxyType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProxyBuilder {
  instance: Proxy
}

impl ProxyBuilder {
  fn new(instance: Proxy) -> Self { Self { instance } }

  pub fn build(&self) -> Proxy {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn server(&mut self, server: String) -> &mut Self {
    self.instance.server = Some(server);
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn last_used_date(&mut self, last_used_date: i32) -> &mut Self {
    self.instance.last_used_date = Some(last_used_date);
    self
  }
  
  pub fn is_enabled(&mut self, is_enabled: bool) -> &mut Self {
    self.instance.is_enabled = Some(is_enabled);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// This class is an abstract base class. Describes the type of the proxy server. 
#[typetag::serde(tag = "@struct")]
pub trait ProxyType: Debug {}



impl Object for ProxyType {}





/// A SOCKS5 proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeSocks5 {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // proxyTypeSocks5

  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,


}



#[typetag::serde]
impl ProxyType for ProxyTypeSocks5 {}


impl ProxyTypeSocks5 {
  
  pub fn builder() -> ProxyTypeSocks5Builder {
    let instance = Self {
      tdfname: "proxyTypeSocks5".to_string(),
      username: None,
      password: None,
      
    };
    ProxyTypeSocks5Builder::new(instance)
  }
  
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProxyTypeSocks5Builder {
  instance: ProxyTypeSocks5
}

impl ProxyTypeSocks5Builder {
  fn new(instance: ProxyTypeSocks5) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeSocks5 {
    self.instance.clone()
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// A HTTP transparent proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeHttp {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // proxyTypeHttp

  /// Username for logging in; may be empty.
  username: Option<String>,
  /// Password for logging in; may be empty.
  password: Option<String>,
  /// Pass true, if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method.
  http_only: Option<bool>,


}



#[typetag::serde]
impl ProxyType for ProxyTypeHttp {}


impl ProxyTypeHttp {
  
  pub fn builder() -> ProxyTypeHttpBuilder {
    let instance = Self {
      tdfname: "proxyTypeHttp".to_string(),
      username: None,
      password: None,
      http_only: None,
      
    };
    ProxyTypeHttpBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  pub fn http_only(&self) -> &Option<bool> { &self.http_only }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProxyTypeHttpBuilder {
  instance: ProxyTypeHttp
}

impl ProxyTypeHttpBuilder {
  fn new(instance: ProxyTypeHttp) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeHttp {
    self.instance.clone()
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
  pub fn http_only(&mut self, http_only: bool) -> &mut Self {
    self.instance.http_only = Some(http_only);
    self
  }
  
}


/// An MTProto proxy server. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyTypeMtproto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // proxyTypeMtproto

  /// The proxy's secret in hexadecimal encoding.
  secret: Option<String>,


}



#[typetag::serde]
impl ProxyType for ProxyTypeMtproto {}


impl ProxyTypeMtproto {
  
  pub fn builder() -> ProxyTypeMtprotoBuilder {
    let instance = Self {
      tdfname: "proxyTypeMtproto".to_string(),
      secret: None,
      
    };
    ProxyTypeMtprotoBuilder::new(instance)
  }
  
  
  pub fn secret(&self) -> &Option<String> { &self.secret }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProxyTypeMtprotoBuilder {
  instance: ProxyTypeMtproto
}

impl ProxyTypeMtprotoBuilder {
  fn new(instance: ProxyTypeMtproto) -> Self { Self { instance } }

  pub fn build(&self) -> ProxyTypeMtproto {
    self.instance.clone()
  }
  
  pub fn secret(&mut self, secret: String) -> &mut Self {
    self.instance.secret = Some(secret);
    self
  }
  
}


/// Contains a public HTTPS link to a message in a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // publicMessageLink

  /// Message link.
  link: Option<String>,
  /// HTML-code for embedding the message.
  html: Option<String>,


}




impl Object for PublicMessageLink {}


impl PublicMessageLink {
  
  pub fn builder() -> PublicMessageLinkBuilder {
    let instance = Self {
      tdfname: "publicMessageLink".to_string(),
      link: None,
      html: None,
      
    };
    PublicMessageLinkBuilder::new(instance)
  }
  
  
  pub fn link(&self) -> &Option<String> { &self.link }
  
  pub fn html(&self) -> &Option<String> { &self.html }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PublicMessageLinkBuilder {
  instance: PublicMessageLink
}

impl PublicMessageLinkBuilder {
  fn new(instance: PublicMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> PublicMessageLink {
    self.instance.clone()
  }
  
  pub fn link(&mut self, link: String) -> &mut Self {
    self.instance.link = Some(link);
    self
  }
  
  pub fn html(&mut self, html: String) -> &mut Self {
    self.instance.html = Some(html);
    self
  }
  
}


/// This class is an abstract base class. Contains content of a push message notification. 
#[typetag::serde(tag = "@struct")]
pub trait PushMessageContent: Debug {}



impl Object for PushMessageContent {}





/// A general message with hidden content. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentHidden {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentHidden

  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentHidden {}


impl PushMessageContentHidden {
  
  pub fn builder() -> PushMessageContentHiddenBuilder {
    let instance = Self {
      tdfname: "pushMessageContentHidden".to_string(),
      is_pinned: None,
      
    };
    PushMessageContentHiddenBuilder::new(instance)
  }
  
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentHiddenBuilder {
  instance: PushMessageContentHidden
}

impl PushMessageContentHiddenBuilder {
  fn new(instance: PushMessageContentHidden) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentHidden {
    self.instance.clone()
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// An animation message (GIF-style.) 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentAnimation

  /// Message content; may be null.
  animation: Option<Animation>,
  /// Animation caption.
  caption: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentAnimation {}


impl PushMessageContentAnimation {
  
  pub fn builder() -> PushMessageContentAnimationBuilder {
    let instance = Self {
      tdfname: "pushMessageContentAnimation".to_string(),
      animation: None,
      caption: None,
      is_pinned: None,
      
    };
    PushMessageContentAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  pub fn caption(&self) -> &Option<String> { &self.caption }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentAnimationBuilder {
  instance: PushMessageContentAnimation
}

impl PushMessageContentAnimationBuilder {
  fn new(instance: PushMessageContentAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn caption(&mut self, caption: String) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// An audio message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentAudio

  /// Message content; may be null.
  audio: Option<Audio>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentAudio {}


impl PushMessageContentAudio {
  
  pub fn builder() -> PushMessageContentAudioBuilder {
    let instance = Self {
      tdfname: "pushMessageContentAudio".to_string(),
      audio: None,
      is_pinned: None,
      
    };
    PushMessageContentAudioBuilder::new(instance)
  }
  
  
  pub fn audio(&self) -> &Option<Audio> { &self.audio }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentAudioBuilder {
  instance: PushMessageContentAudio
}

impl PushMessageContentAudioBuilder {
  fn new(instance: PushMessageContentAudio) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentAudio {
    self.instance.clone()
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A message with a user contact. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContact {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentContact

  /// Contact's name.
  name: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentContact {}


impl PushMessageContentContact {
  
  pub fn builder() -> PushMessageContentContactBuilder {
    let instance = Self {
      tdfname: "pushMessageContentContact".to_string(),
      name: None,
      is_pinned: None,
      
    };
    PushMessageContentContactBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentContactBuilder {
  instance: PushMessageContentContact
}

impl PushMessageContentContactBuilder {
  fn new(instance: PushMessageContentContact) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentContact {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A contact has registered with Telegram. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentContactRegistered {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentContactRegistered

}



#[typetag::serde]
impl PushMessageContent for PushMessageContentContactRegistered {}


impl PushMessageContentContactRegistered {
  
  pub fn builder() -> PushMessageContentContactRegisteredBuilder {
    let instance = Self {
      tdfname: "pushMessageContentContactRegistered".to_string(),
      
    };
    PushMessageContentContactRegisteredBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentContactRegisteredBuilder {
  instance: PushMessageContentContactRegistered
}

impl PushMessageContentContactRegisteredBuilder {
  fn new(instance: PushMessageContentContactRegistered) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentContactRegistered {
    self.instance.clone()
  }
  
}


/// A document message (a general file). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentDocument

  /// Message content; may be null.
  document: Option<Document>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentDocument {}


impl PushMessageContentDocument {
  
  pub fn builder() -> PushMessageContentDocumentBuilder {
    let instance = Self {
      tdfname: "pushMessageContentDocument".to_string(),
      document: None,
      is_pinned: None,
      
    };
    PushMessageContentDocumentBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> &Option<Document> { &self.document }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentDocumentBuilder {
  instance: PushMessageContentDocument
}

impl PushMessageContentDocumentBuilder {
  fn new(instance: PushMessageContentDocument) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentDocument {
    self.instance.clone()
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A message with a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGame {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentGame

  /// Game title, empty for pinned game message.
  title: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentGame {}


impl PushMessageContentGame {
  
  pub fn builder() -> PushMessageContentGameBuilder {
    let instance = Self {
      tdfname: "pushMessageContentGame".to_string(),
      title: None,
      is_pinned: None,
      
    };
    PushMessageContentGameBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentGameBuilder {
  instance: PushMessageContentGame
}

impl PushMessageContentGameBuilder {
  fn new(instance: PushMessageContentGame) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentGame {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A new high score was achieved in a game. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentGameScore

  /// Game title, empty for pinned message.
  title: Option<String>,
  /// New score, 0 for pinned message.
  score: Option<i32>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentGameScore {}


impl PushMessageContentGameScore {
  
  pub fn builder() -> PushMessageContentGameScoreBuilder {
    let instance = Self {
      tdfname: "pushMessageContentGameScore".to_string(),
      title: None,
      score: None,
      is_pinned: None,
      
    };
    PushMessageContentGameScoreBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn score(&self) -> &Option<i32> { &self.score }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentGameScoreBuilder {
  instance: PushMessageContentGameScore
}

impl PushMessageContentGameScoreBuilder {
  fn new(instance: PushMessageContentGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentGameScore {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A message with an invoice from a bot. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentInvoice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentInvoice

  /// Product price.
  price: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentInvoice {}


impl PushMessageContentInvoice {
  
  pub fn builder() -> PushMessageContentInvoiceBuilder {
    let instance = Self {
      tdfname: "pushMessageContentInvoice".to_string(),
      price: None,
      is_pinned: None,
      
    };
    PushMessageContentInvoiceBuilder::new(instance)
  }
  
  
  pub fn price(&self) -> &Option<String> { &self.price }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentInvoiceBuilder {
  instance: PushMessageContentInvoice
}

impl PushMessageContentInvoiceBuilder {
  fn new(instance: PushMessageContentInvoice) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentInvoice {
    self.instance.clone()
  }
  
  pub fn price(&mut self, price: String) -> &mut Self {
    self.instance.price = Some(price);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A message with a location. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentLocation

  /// True, if the location is live.
  is_live: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentLocation {}


impl PushMessageContentLocation {
  
  pub fn builder() -> PushMessageContentLocationBuilder {
    let instance = Self {
      tdfname: "pushMessageContentLocation".to_string(),
      is_live: None,
      is_pinned: None,
      
    };
    PushMessageContentLocationBuilder::new(instance)
  }
  
  
  pub fn is_live(&self) -> &Option<bool> { &self.is_live }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentLocationBuilder {
  instance: PushMessageContentLocation
}

impl PushMessageContentLocationBuilder {
  fn new(instance: PushMessageContentLocation) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentLocation {
    self.instance.clone()
  }
  
  pub fn is_live(&mut self, is_live: bool) -> &mut Self {
    self.instance.is_live = Some(is_live);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A photo message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentPhoto

  /// Message content; may be null.
  photo: Option<Photo>,
  /// Photo caption.
  caption: Option<String>,
  /// True, if the photo is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentPhoto {}


impl PushMessageContentPhoto {
  
  pub fn builder() -> PushMessageContentPhotoBuilder {
    let instance = Self {
      tdfname: "pushMessageContentPhoto".to_string(),
      photo: None,
      caption: None,
      is_secret: None,
      is_pinned: None,
      
    };
    PushMessageContentPhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn caption(&self) -> &Option<String> { &self.caption }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentPhotoBuilder {
  instance: PushMessageContentPhoto
}

impl PushMessageContentPhotoBuilder {
  fn new(instance: PushMessageContentPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentPhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn caption(&mut self, caption: String) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A message with a poll. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentPoll

  /// Poll question.
  question: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentPoll {}


impl PushMessageContentPoll {
  
  pub fn builder() -> PushMessageContentPollBuilder {
    let instance = Self {
      tdfname: "pushMessageContentPoll".to_string(),
      question: None,
      is_pinned: None,
      
    };
    PushMessageContentPollBuilder::new(instance)
  }
  
  
  pub fn question(&self) -> &Option<String> { &self.question }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentPollBuilder {
  instance: PushMessageContentPoll
}

impl PushMessageContentPollBuilder {
  fn new(instance: PushMessageContentPoll) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentPoll {
    self.instance.clone()
  }
  
  pub fn question(&mut self, question: String) -> &mut Self {
    self.instance.question = Some(question);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A screenshot of a message in the chat has been taken. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentScreenshotTaken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentScreenshotTaken

}



#[typetag::serde]
impl PushMessageContent for PushMessageContentScreenshotTaken {}


impl PushMessageContentScreenshotTaken {
  
  pub fn builder() -> PushMessageContentScreenshotTakenBuilder {
    let instance = Self {
      tdfname: "pushMessageContentScreenshotTaken".to_string(),
      
    };
    PushMessageContentScreenshotTakenBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentScreenshotTakenBuilder {
  instance: PushMessageContentScreenshotTaken
}

impl PushMessageContentScreenshotTakenBuilder {
  fn new(instance: PushMessageContentScreenshotTaken) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentScreenshotTaken {
    self.instance.clone()
  }
  
}


/// A message with a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentSticker

  /// Message content; may be null.
  sticker: Option<Sticker>,
  /// Emoji corresponding to the sticker; may be empty.
  emoji: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentSticker {}


impl PushMessageContentSticker {
  
  pub fn builder() -> PushMessageContentStickerBuilder {
    let instance = Self {
      tdfname: "pushMessageContentSticker".to_string(),
      sticker: None,
      emoji: None,
      is_pinned: None,
      
    };
    PushMessageContentStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Sticker> { &self.sticker }
  
  pub fn emoji(&self) -> &Option<String> { &self.emoji }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentStickerBuilder {
  instance: PushMessageContentSticker
}

impl PushMessageContentStickerBuilder {
  fn new(instance: PushMessageContentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentSticker {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn emoji(&mut self, emoji: String) -> &mut Self {
    self.instance.emoji = Some(emoji);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A text message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentText

  /// Message text.
  text: Option<String>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentText {}


impl PushMessageContentText {
  
  pub fn builder() -> PushMessageContentTextBuilder {
    let instance = Self {
      tdfname: "pushMessageContentText".to_string(),
      text: None,
      is_pinned: None,
      
    };
    PushMessageContentTextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentTextBuilder {
  instance: PushMessageContentText
}

impl PushMessageContentTextBuilder {
  fn new(instance: PushMessageContentText) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentText {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A video message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentVideo

  /// Message content; may be null.
  video: Option<Video>,
  /// Video caption.
  caption: Option<String>,
  /// True, if the video is secret.
  is_secret: Option<bool>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentVideo {}


impl PushMessageContentVideo {
  
  pub fn builder() -> PushMessageContentVideoBuilder {
    let instance = Self {
      tdfname: "pushMessageContentVideo".to_string(),
      video: None,
      caption: None,
      is_secret: None,
      is_pinned: None,
      
    };
    PushMessageContentVideoBuilder::new(instance)
  }
  
  
  pub fn video(&self) -> &Option<Video> { &self.video }
  
  pub fn caption(&self) -> &Option<String> { &self.caption }
  
  pub fn is_secret(&self) -> &Option<bool> { &self.is_secret }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentVideoBuilder {
  instance: PushMessageContentVideo
}

impl PushMessageContentVideoBuilder {
  fn new(instance: PushMessageContentVideo) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVideo {
    self.instance.clone()
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn caption(&mut self, caption: String) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
  pub fn is_secret(&mut self, is_secret: bool) -> &mut Self {
    self.instance.is_secret = Some(is_secret);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A video note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentVideoNote

  /// Message content; may be null.
  video_note: Option<VideoNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentVideoNote {}


impl PushMessageContentVideoNote {
  
  pub fn builder() -> PushMessageContentVideoNoteBuilder {
    let instance = Self {
      tdfname: "pushMessageContentVideoNote".to_string(),
      video_note: None,
      is_pinned: None,
      
    };
    PushMessageContentVideoNoteBuilder::new(instance)
  }
  
  
  pub fn video_note(&self) -> &Option<VideoNote> { &self.video_note }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentVideoNoteBuilder {
  instance: PushMessageContentVideoNote
}

impl PushMessageContentVideoNoteBuilder {
  fn new(instance: PushMessageContentVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVideoNote {
    self.instance.clone()
  }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A voice note message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentVoiceNote

  /// Message content; may be null.
  voice_note: Option<VoiceNote>,
  /// True, if the message is a pinned message with the specified content.
  is_pinned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentVoiceNote {}


impl PushMessageContentVoiceNote {
  
  pub fn builder() -> PushMessageContentVoiceNoteBuilder {
    let instance = Self {
      tdfname: "pushMessageContentVoiceNote".to_string(),
      voice_note: None,
      is_pinned: None,
      
    };
    PushMessageContentVoiceNoteBuilder::new(instance)
  }
  
  
  pub fn voice_note(&self) -> &Option<VoiceNote> { &self.voice_note }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentVoiceNoteBuilder {
  instance: PushMessageContentVoiceNote
}

impl PushMessageContentVoiceNoteBuilder {
  fn new(instance: PushMessageContentVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentVoiceNote {
    self.instance.clone()
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// A newly created basic group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentBasicGroupChatCreate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentBasicGroupChatCreate

}



#[typetag::serde]
impl PushMessageContent for PushMessageContentBasicGroupChatCreate {}


impl PushMessageContentBasicGroupChatCreate {
  
  pub fn builder() -> PushMessageContentBasicGroupChatCreateBuilder {
    let instance = Self {
      tdfname: "pushMessageContentBasicGroupChatCreate".to_string(),
      
    };
    PushMessageContentBasicGroupChatCreateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentBasicGroupChatCreateBuilder {
  instance: PushMessageContentBasicGroupChatCreate
}

impl PushMessageContentBasicGroupChatCreateBuilder {
  fn new(instance: PushMessageContentBasicGroupChatCreate) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentBasicGroupChatCreate {
    self.instance.clone()
  }
  
}


/// New chat members were invited to a group. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatAddMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentChatAddMembers

  /// Name of the added member.
  member_name: Option<String>,
  /// True, if the current user was added to the group.
  is_current_user: Option<bool>,
  /// True, if the user has returned to the group himself.
  is_returned: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentChatAddMembers {}


impl PushMessageContentChatAddMembers {
  
  pub fn builder() -> PushMessageContentChatAddMembersBuilder {
    let instance = Self {
      tdfname: "pushMessageContentChatAddMembers".to_string(),
      member_name: None,
      is_current_user: None,
      is_returned: None,
      
    };
    PushMessageContentChatAddMembersBuilder::new(instance)
  }
  
  
  pub fn member_name(&self) -> &Option<String> { &self.member_name }
  
  pub fn is_current_user(&self) -> &Option<bool> { &self.is_current_user }
  
  pub fn is_returned(&self) -> &Option<bool> { &self.is_returned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentChatAddMembersBuilder {
  instance: PushMessageContentChatAddMembers
}

impl PushMessageContentChatAddMembersBuilder {
  fn new(instance: PushMessageContentChatAddMembers) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatAddMembers {
    self.instance.clone()
  }
  
  pub fn member_name(&mut self, member_name: String) -> &mut Self {
    self.instance.member_name = Some(member_name);
    self
  }
  
  pub fn is_current_user(&mut self, is_current_user: bool) -> &mut Self {
    self.instance.is_current_user = Some(is_current_user);
    self
  }
  
  pub fn is_returned(&mut self, is_returned: bool) -> &mut Self {
    self.instance.is_returned = Some(is_returned);
    self
  }
  
}


/// A chat photo was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentChatChangePhoto

}



#[typetag::serde]
impl PushMessageContent for PushMessageContentChatChangePhoto {}


impl PushMessageContentChatChangePhoto {
  
  pub fn builder() -> PushMessageContentChatChangePhotoBuilder {
    let instance = Self {
      tdfname: "pushMessageContentChatChangePhoto".to_string(),
      
    };
    PushMessageContentChatChangePhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentChatChangePhotoBuilder {
  instance: PushMessageContentChatChangePhoto
}

impl PushMessageContentChatChangePhotoBuilder {
  fn new(instance: PushMessageContentChatChangePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatChangePhoto {
    self.instance.clone()
  }
  
}


/// A chat title was edited. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatChangeTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentChatChangeTitle

  /// New chat title.
  title: Option<String>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentChatChangeTitle {}


impl PushMessageContentChatChangeTitle {
  
  pub fn builder() -> PushMessageContentChatChangeTitleBuilder {
    let instance = Self {
      tdfname: "pushMessageContentChatChangeTitle".to_string(),
      title: None,
      
    };
    PushMessageContentChatChangeTitleBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentChatChangeTitleBuilder {
  instance: PushMessageContentChatChangeTitle
}

impl PushMessageContentChatChangeTitleBuilder {
  fn new(instance: PushMessageContentChatChangeTitle) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatChangeTitle {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// A chat member was deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatDeleteMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentChatDeleteMember

  /// Name of the deleted member.
  member_name: Option<String>,
  /// True, if the current user was deleted from the group.
  is_current_user: Option<bool>,
  /// True, if the user has left the group himself.
  is_left: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentChatDeleteMember {}


impl PushMessageContentChatDeleteMember {
  
  pub fn builder() -> PushMessageContentChatDeleteMemberBuilder {
    let instance = Self {
      tdfname: "pushMessageContentChatDeleteMember".to_string(),
      member_name: None,
      is_current_user: None,
      is_left: None,
      
    };
    PushMessageContentChatDeleteMemberBuilder::new(instance)
  }
  
  
  pub fn member_name(&self) -> &Option<String> { &self.member_name }
  
  pub fn is_current_user(&self) -> &Option<bool> { &self.is_current_user }
  
  pub fn is_left(&self) -> &Option<bool> { &self.is_left }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentChatDeleteMemberBuilder {
  instance: PushMessageContentChatDeleteMember
}

impl PushMessageContentChatDeleteMemberBuilder {
  fn new(instance: PushMessageContentChatDeleteMember) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatDeleteMember {
    self.instance.clone()
  }
  
  pub fn member_name(&mut self, member_name: String) -> &mut Self {
    self.instance.member_name = Some(member_name);
    self
  }
  
  pub fn is_current_user(&mut self, is_current_user: bool) -> &mut Self {
    self.instance.is_current_user = Some(is_current_user);
    self
  }
  
  pub fn is_left(&mut self, is_left: bool) -> &mut Self {
    self.instance.is_left = Some(is_left);
    self
  }
  
}


/// A new member joined the chat by invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentChatJoinByLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentChatJoinByLink

}



#[typetag::serde]
impl PushMessageContent for PushMessageContentChatJoinByLink {}


impl PushMessageContentChatJoinByLink {
  
  pub fn builder() -> PushMessageContentChatJoinByLinkBuilder {
    let instance = Self {
      tdfname: "pushMessageContentChatJoinByLink".to_string(),
      
    };
    PushMessageContentChatJoinByLinkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentChatJoinByLinkBuilder {
  instance: PushMessageContentChatJoinByLink
}

impl PushMessageContentChatJoinByLinkBuilder {
  fn new(instance: PushMessageContentChatJoinByLink) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentChatJoinByLink {
    self.instance.clone()
  }
  
}


/// A forwarded messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMessageForwards {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentMessageForwards

  /// Number of forwarded messages.
  total_count: Option<i32>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentMessageForwards {}


impl PushMessageContentMessageForwards {
  
  pub fn builder() -> PushMessageContentMessageForwardsBuilder {
    let instance = Self {
      tdfname: "pushMessageContentMessageForwards".to_string(),
      total_count: None,
      
    };
    PushMessageContentMessageForwardsBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentMessageForwardsBuilder {
  instance: PushMessageContentMessageForwards
}

impl PushMessageContentMessageForwardsBuilder {
  fn new(instance: PushMessageContentMessageForwards) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentMessageForwards {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
}


/// A media album. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushMessageContentMediaAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushMessageContentMediaAlbum

  /// Number of messages in the album.
  total_count: Option<i32>,
  /// True, if the album has at least one photo.
  has_photos: Option<bool>,
  /// True, if the album has at least one video.
  has_videos: Option<bool>,


}



#[typetag::serde]
impl PushMessageContent for PushMessageContentMediaAlbum {}


impl PushMessageContentMediaAlbum {
  
  pub fn builder() -> PushMessageContentMediaAlbumBuilder {
    let instance = Self {
      tdfname: "pushMessageContentMediaAlbum".to_string(),
      total_count: None,
      has_photos: None,
      has_videos: None,
      
    };
    PushMessageContentMediaAlbumBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn has_photos(&self) -> &Option<bool> { &self.has_photos }
  
  pub fn has_videos(&self) -> &Option<bool> { &self.has_videos }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushMessageContentMediaAlbumBuilder {
  instance: PushMessageContentMediaAlbum
}

impl PushMessageContentMediaAlbumBuilder {
  fn new(instance: PushMessageContentMediaAlbum) -> Self { Self { instance } }

  pub fn build(&self) -> PushMessageContentMediaAlbum {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn has_photos(&mut self, has_photos: bool) -> &mut Self {
    self.instance.has_photos = Some(has_photos);
    self
  }
  
  pub fn has_videos(&mut self, has_videos: bool) -> &mut Self {
    self.instance.has_videos = Some(has_videos);
    self
  }
  
}


/// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pushReceiverId

  /// The globally unique identifier of push notification subscription.
  id: Option<i64>,


}




impl Object for PushReceiverId {}


impl PushReceiverId {
  
  pub fn builder() -> PushReceiverIdBuilder {
    let instance = Self {
      tdfname: "pushReceiverId".to_string(),
      id: None,
      
    };
    PushReceiverIdBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PushReceiverIdBuilder {
  instance: PushReceiverId
}

impl PushReceiverIdBuilder {
  fn new(instance: PushReceiverId) -> Self { Self { instance } }

  pub fn build(&self) -> PushReceiverId {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
}


/// Contains information about the current recovery email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // recoveryEmailAddress

  /// Recovery email address.
  recovery_email_address: Option<String>,


}




impl Object for RecoveryEmailAddress {}


impl RecoveryEmailAddress {
  
  pub fn builder() -> RecoveryEmailAddressBuilder {
    let instance = Self {
      tdfname: "recoveryEmailAddress".to_string(),
      recovery_email_address: None,
      
    };
    RecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn recovery_email_address(&self) -> &Option<String> { &self.recovery_email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RecoveryEmailAddressBuilder {
  instance: RecoveryEmailAddress
}

impl RecoveryEmailAddressBuilder {
  fn new(instance: RecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> RecoveryEmailAddress {
    self.instance.clone()
  }
  
  pub fn recovery_email_address(&mut self, recovery_email_address: String) -> &mut Self {
    self.instance.recovery_email_address = Some(recovery_email_address);
    self
  }
  
}


/// Represents a remote file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // remoteFile

  /// Remote file identifier; may be empty. Can be used across application restarts or even from other devices for the current user. If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the client with the HTTP URL in the original_path and "#url#" as the conversion string. Clients should generate the file by downloading it to the specified location.
  id: Option<String>,
  /// True, if the file is currently being uploaded (or a remote copy is being generated by some other means).
  is_uploading_active: Option<bool>,
  /// True, if a remote copy is fully available.
  is_uploading_completed: Option<bool>,
  /// Size of the remote available part of the file; 0 if unknown.
  uploaded_size: Option<i32>,


}




impl Object for RemoteFile {}


impl RemoteFile {
  
  pub fn builder() -> RemoteFileBuilder {
    let instance = Self {
      tdfname: "remoteFile".to_string(),
      id: None,
      is_uploading_active: None,
      is_uploading_completed: None,
      uploaded_size: None,
      
    };
    RemoteFileBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn is_uploading_active(&self) -> &Option<bool> { &self.is_uploading_active }
  
  pub fn is_uploading_completed(&self) -> &Option<bool> { &self.is_uploading_completed }
  
  pub fn uploaded_size(&self) -> &Option<i32> { &self.uploaded_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoteFileBuilder {
  instance: RemoteFile
}

impl RemoteFileBuilder {
  fn new(instance: RemoteFile) -> Self { Self { instance } }

  pub fn build(&self) -> RemoteFile {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn is_uploading_active(&mut self, is_uploading_active: bool) -> &mut Self {
    self.instance.is_uploading_active = Some(is_uploading_active);
    self
  }
  
  pub fn is_uploading_completed(&mut self, is_uploading_completed: bool) -> &mut Self {
    self.instance.is_uploading_completed = Some(is_uploading_completed);
    self
  }
  
  pub fn uploaded_size(&mut self, uploaded_size: i32) -> &mut Self {
    self.instance.uploaded_size = Some(uploaded_size);
    self
  }
  
}


/// This class is an abstract base class. Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots. 
#[typetag::serde(tag = "@struct")]
pub trait ReplyMarkup: Debug {}



impl Object for ReplyMarkup {}





/// Instructs clients to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupRemoveKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // replyMarkupRemoveKeyboard

  /// True, if the keyboard is removed only for the mentioned users or the target user of a reply.
  is_personal: Option<bool>,


}



#[typetag::serde]
impl ReplyMarkup for ReplyMarkupRemoveKeyboard {}


impl ReplyMarkupRemoveKeyboard {
  
  pub fn builder() -> ReplyMarkupRemoveKeyboardBuilder {
    let instance = Self {
      tdfname: "replyMarkupRemoveKeyboard".to_string(),
      is_personal: None,
      
    };
    ReplyMarkupRemoveKeyboardBuilder::new(instance)
  }
  
  
  pub fn is_personal(&self) -> &Option<bool> { &self.is_personal }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReplyMarkupRemoveKeyboardBuilder {
  instance: ReplyMarkupRemoveKeyboard
}

impl ReplyMarkupRemoveKeyboardBuilder {
  fn new(instance: ReplyMarkupRemoveKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupRemoveKeyboard {
    self.instance.clone()
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}


/// Instructs clients to force a reply to this message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupForceReply {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // replyMarkupForceReply

  /// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,


}



#[typetag::serde]
impl ReplyMarkup for ReplyMarkupForceReply {}


impl ReplyMarkupForceReply {
  
  pub fn builder() -> ReplyMarkupForceReplyBuilder {
    let instance = Self {
      tdfname: "replyMarkupForceReply".to_string(),
      is_personal: None,
      
    };
    ReplyMarkupForceReplyBuilder::new(instance)
  }
  
  
  pub fn is_personal(&self) -> &Option<bool> { &self.is_personal }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReplyMarkupForceReplyBuilder {
  instance: ReplyMarkupForceReply
}

impl ReplyMarkupForceReplyBuilder {
  fn new(instance: ReplyMarkupForceReply) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupForceReply {
    self.instance.clone()
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}


/// Contains a custom keyboard layout to quickly reply to bots. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupShowKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // replyMarkupShowKeyboard

  /// A list of rows of bot keyboard buttons.
  rows: Option<Vec<Vec<KeyboardButton>>>,
  /// True, if the client needs to resize the keyboard vertically.
  resize_keyboard: Option<bool>,
  /// True, if the client needs to hide the keyboard after use.
  one_time: Option<bool>,
  /// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply.
  is_personal: Option<bool>,


}



#[typetag::serde]
impl ReplyMarkup for ReplyMarkupShowKeyboard {}


impl ReplyMarkupShowKeyboard {
  
  pub fn builder() -> ReplyMarkupShowKeyboardBuilder {
    let instance = Self {
      tdfname: "replyMarkupShowKeyboard".to_string(),
      rows: None,
      resize_keyboard: None,
      one_time: None,
      is_personal: None,
      
    };
    ReplyMarkupShowKeyboardBuilder::new(instance)
  }
  
  
  pub fn rows(&self) -> &Option<Vec<Vec<KeyboardButton>>> { &self.rows }
  
  pub fn resize_keyboard(&self) -> &Option<bool> { &self.resize_keyboard }
  
  pub fn one_time(&self) -> &Option<bool> { &self.one_time }
  
  pub fn is_personal(&self) -> &Option<bool> { &self.is_personal }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReplyMarkupShowKeyboardBuilder {
  instance: ReplyMarkupShowKeyboard
}

impl ReplyMarkupShowKeyboardBuilder {
  fn new(instance: ReplyMarkupShowKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupShowKeyboard {
    self.instance.clone()
  }
  
  pub fn rows(&mut self, rows: Vec<Vec<KeyboardButton>>) -> &mut Self {
    self.instance.rows = Some(rows);
    self
  }
  
  pub fn resize_keyboard(&mut self, resize_keyboard: bool) -> &mut Self {
    self.instance.resize_keyboard = Some(resize_keyboard);
    self
  }
  
  pub fn one_time(&mut self, one_time: bool) -> &mut Self {
    self.instance.one_time = Some(one_time);
    self
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
}


/// Contains an inline keyboard layout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReplyMarkupInlineKeyboard {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // replyMarkupInlineKeyboard

  /// A list of rows of inline keyboard buttons.
  rows: Option<Vec<Vec<InlineKeyboardButton>>>,


}



#[typetag::serde]
impl ReplyMarkup for ReplyMarkupInlineKeyboard {}


impl ReplyMarkupInlineKeyboard {
  
  pub fn builder() -> ReplyMarkupInlineKeyboardBuilder {
    let instance = Self {
      tdfname: "replyMarkupInlineKeyboard".to_string(),
      rows: None,
      
    };
    ReplyMarkupInlineKeyboardBuilder::new(instance)
  }
  
  
  pub fn rows(&self) -> &Option<Vec<Vec<InlineKeyboardButton>>> { &self.rows }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReplyMarkupInlineKeyboardBuilder {
  instance: ReplyMarkupInlineKeyboard
}

impl ReplyMarkupInlineKeyboardBuilder {
  fn new(instance: ReplyMarkupInlineKeyboard) -> Self { Self { instance } }

  pub fn build(&self) -> ReplyMarkupInlineKeyboard {
    self.instance.clone()
  }
  
  pub fn rows(&mut self, rows: Vec<Vec<InlineKeyboardButton>>) -> &mut Self {
    self.instance.rows = Some(rows);
    self
  }
  
}


/// This class is an abstract base class. Describes a text object inside an instant-view web page. 
#[typetag::serde(tag = "@struct")]
pub trait RichText: Debug {}



impl Object for RichText {}





/// A plain text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextPlain {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextPlain

  /// Text.
  text: Option<String>,


}



#[typetag::serde]
impl RichText for RichTextPlain {}


impl RichTextPlain {
  
  pub fn builder() -> RichTextPlainBuilder {
    let instance = Self {
      tdfname: "richTextPlain".to_string(),
      text: None,
      
    };
    RichTextPlainBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextPlainBuilder {
  instance: RichTextPlain
}

impl RichTextPlainBuilder {
  fn new(instance: RichTextPlain) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextPlain {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A bold rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextBold

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextBold {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextBold {}


impl RichTextBold {
  
  pub fn builder() -> RichTextBoldBuilder {
    let instance = Self {
      tdfname: "richTextBold".to_string(),
      text: None,
      
    };
    RichTextBoldBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextBoldBuilder {
  instance: RichTextBold
}

impl RichTextBoldBuilder {
  fn new(instance: RichTextBold) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextBold {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// An italicized rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextItalic

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextItalic {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextItalic {}


impl RichTextItalic {
  
  pub fn builder() -> RichTextItalicBuilder {
    let instance = Self {
      tdfname: "richTextItalic".to_string(),
      text: None,
      
    };
    RichTextItalicBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextItalicBuilder {
  instance: RichTextItalic
}

impl RichTextItalicBuilder {
  fn new(instance: RichTextItalic) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextItalic {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// An underlined rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUnderline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextUnderline

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextUnderline {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextUnderline {}


impl RichTextUnderline {
  
  pub fn builder() -> RichTextUnderlineBuilder {
    let instance = Self {
      tdfname: "richTextUnderline".to_string(),
      text: None,
      
    };
    RichTextUnderlineBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextUnderlineBuilder {
  instance: RichTextUnderline
}

impl RichTextUnderlineBuilder {
  fn new(instance: RichTextUnderline) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextUnderline {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A strike-through rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextStrikethrough {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextStrikethrough

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextStrikethrough {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextStrikethrough {}


impl RichTextStrikethrough {
  
  pub fn builder() -> RichTextStrikethroughBuilder {
    let instance = Self {
      tdfname: "richTextStrikethrough".to_string(),
      text: None,
      
    };
    RichTextStrikethroughBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextStrikethroughBuilder {
  instance: RichTextStrikethrough
}

impl RichTextStrikethroughBuilder {
  fn new(instance: RichTextStrikethrough) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextStrikethrough {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A fixed-width rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextFixed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextFixed

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextFixed {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextFixed {}


impl RichTextFixed {
  
  pub fn builder() -> RichTextFixedBuilder {
    let instance = Self {
      tdfname: "richTextFixed".to_string(),
      text: None,
      
    };
    RichTextFixedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextFixedBuilder {
  instance: RichTextFixed
}

impl RichTextFixedBuilder {
  fn new(instance: RichTextFixed) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextFixed {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A rich text URL link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextUrl

  /// Text.
  text: Option<Box<RichText>>,
  /// URL.
  url: Option<String>,


}


impl Clone for RichTextUrl {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextUrl {}


impl RichTextUrl {
  
  pub fn builder() -> RichTextUrlBuilder {
    let instance = Self {
      tdfname: "richTextUrl".to_string(),
      text: None,
      url: None,
      
    };
    RichTextUrlBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextUrlBuilder {
  instance: RichTextUrl
}

impl RichTextUrlBuilder {
  fn new(instance: RichTextUrl) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextUrl {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// A rich text email link. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextEmailAddress

  /// Text.
  text: Option<Box<RichText>>,
  /// Email address.
  email_address: Option<String>,


}


impl Clone for RichTextEmailAddress {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextEmailAddress {}


impl RichTextEmailAddress {
  
  pub fn builder() -> RichTextEmailAddressBuilder {
    let instance = Self {
      tdfname: "richTextEmailAddress".to_string(),
      text: None,
      email_address: None,
      
    };
    RichTextEmailAddressBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn email_address(&self) -> &Option<String> { &self.email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextEmailAddressBuilder {
  instance: RichTextEmailAddress
}

impl RichTextEmailAddressBuilder {
  fn new(instance: RichTextEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextEmailAddress {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn email_address(&mut self, email_address: String) -> &mut Self {
    self.instance.email_address = Some(email_address);
    self
  }
  
}


/// A subscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSubscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextSubscript

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextSubscript {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextSubscript {}


impl RichTextSubscript {
  
  pub fn builder() -> RichTextSubscriptBuilder {
    let instance = Self {
      tdfname: "richTextSubscript".to_string(),
      text: None,
      
    };
    RichTextSubscriptBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextSubscriptBuilder {
  instance: RichTextSubscript
}

impl RichTextSubscriptBuilder {
  fn new(instance: RichTextSubscript) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextSubscript {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A superscript rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextSuperscript {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextSuperscript

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextSuperscript {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextSuperscript {}


impl RichTextSuperscript {
  
  pub fn builder() -> RichTextSuperscriptBuilder {
    let instance = Self {
      tdfname: "richTextSuperscript".to_string(),
      text: None,
      
    };
    RichTextSuperscriptBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextSuperscriptBuilder {
  instance: RichTextSuperscript
}

impl RichTextSuperscriptBuilder {
  fn new(instance: RichTextSuperscript) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextSuperscript {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A marked rich text. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextMarked {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextMarked

  /// Text.
  text: Option<Box<RichText>>,


}


impl Clone for RichTextMarked {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextMarked {}


impl RichTextMarked {
  
  pub fn builder() -> RichTextMarkedBuilder {
    let instance = Self {
      tdfname: "richTextMarked".to_string(),
      text: None,
      
    };
    RichTextMarkedBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextMarkedBuilder {
  instance: RichTextMarked
}

impl RichTextMarkedBuilder {
  fn new(instance: RichTextMarked) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextMarked {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// A rich text phone number. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextPhoneNumber

  /// Text.
  text: Option<Box<RichText>>,
  /// Phone number.
  phone_number: Option<String>,


}


impl Clone for RichTextPhoneNumber {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextPhoneNumber {}


impl RichTextPhoneNumber {
  
  pub fn builder() -> RichTextPhoneNumberBuilder {
    let instance = Self {
      tdfname: "richTextPhoneNumber".to_string(),
      text: None,
      phone_number: None,
      
    };
    RichTextPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextPhoneNumberBuilder {
  instance: RichTextPhoneNumber
}

impl RichTextPhoneNumberBuilder {
  fn new(instance: RichTextPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextPhoneNumber {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
}


/// A small image inside the text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichTextIcon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextIcon

  /// The image represented as a document. The image can be in GIF, JPEG or PNG format.
  document: Option<Document>,
  /// Width of a bounding box in which the image should be shown, 0 if unknown.
  width: Option<i32>,
  /// Height of a bounding box in which the image should be shown, 0 if unknown.
  height: Option<i32>,


}



#[typetag::serde]
impl RichText for RichTextIcon {}


impl RichTextIcon {
  
  pub fn builder() -> RichTextIconBuilder {
    let instance = Self {
      tdfname: "richTextIcon".to_string(),
      document: None,
      width: None,
      height: None,
      
    };
    RichTextIconBuilder::new(instance)
  }
  
  
  pub fn document(&self) -> &Option<Document> { &self.document }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextIconBuilder {
  instance: RichTextIcon
}

impl RichTextIconBuilder {
  fn new(instance: RichTextIcon) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextIcon {
    self.instance.clone()
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
}


/// A rich text anchor. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTextAnchor {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTextAnchor

  /// Text.
  text: Option<Box<RichText>>,
  /// Anchor name.
  name: Option<String>,


}


impl Clone for RichTextAnchor {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTextAnchor {}


impl RichTextAnchor {
  
  pub fn builder() -> RichTextAnchorBuilder {
    let instance = Self {
      tdfname: "richTextAnchor".to_string(),
      text: None,
      name: None,
      
    };
    RichTextAnchorBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<Box<RichText>> { &self.text }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextAnchorBuilder {
  instance: RichTextAnchor
}

impl RichTextAnchorBuilder {
  fn new(instance: RichTextAnchor) -> Self { Self { instance } }

  pub fn build(&self) -> RichTextAnchor {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: Box<RichText>) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
}


/// A concatenation of rich texts. 
#[derive(Debug, Serialize, Deserialize)]
pub struct RichTexts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // richTexts

  /// Texts.
  texts: Option<Vec<Box<RichText>>>,


}


impl Clone for RichTexts {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl RichText for RichTexts {}


impl RichTexts {
  
  pub fn builder() -> RichTextsBuilder {
    let instance = Self {
      tdfname: "richTexts".to_string(),
      texts: None,
      
    };
    RichTextsBuilder::new(instance)
  }
  
  
  pub fn texts(&self) -> &Option<Vec<Box<RichText>>> { &self.texts }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RichTextsBuilder {
  instance: RichTexts
}

impl RichTextsBuilder {
  fn new(instance: RichTexts) -> Self { Self { instance } }

  pub fn build(&self) -> RichTexts {
    self.instance.clone()
  }
  
  pub fn texts(&mut self, texts: Vec<Box<RichText>>) -> &mut Self {
    self.instance.texts = Some(texts);
    self
  }
  
}


/// Contains information about saved card credentials. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // savedCredentials

  /// Unique identifier of the saved credentials.
  id: Option<String>,
  /// Title of the saved credentials.
  title: Option<String>,


}




impl Object for SavedCredentials {}


impl SavedCredentials {
  
  pub fn builder() -> SavedCredentialsBuilder {
    let instance = Self {
      tdfname: "savedCredentials".to_string(),
      id: None,
      title: None,
      
    };
    SavedCredentialsBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SavedCredentialsBuilder {
  instance: SavedCredentials
}

impl SavedCredentialsBuilder {
  fn new(instance: SavedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> SavedCredentials {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// Contains information about notification settings for several chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // scopeNotificationSettings

  /// Time left before notifications will be unmuted, in seconds.
  mute_for: Option<i32>,
  /// The name of an audio file to be used for notification sounds; only applies to iOS applications.
  sound: Option<String>,
  /// True, if message content should be displayed in notifications.
  show_preview: Option<bool>,
  /// True, if notifications for incoming pinned messages will be created as for an ordinary unread message.
  disable_pinned_message_notifications: Option<bool>,
  /// True, if notifications for messages with mentions will be created as for an ordinary unread message.
  disable_mention_notifications: Option<bool>,


}




impl Object for ScopeNotificationSettings {}


impl ScopeNotificationSettings {
  
  pub fn builder() -> ScopeNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "scopeNotificationSettings".to_string(),
      mute_for: None,
      sound: None,
      show_preview: None,
      disable_pinned_message_notifications: None,
      disable_mention_notifications: None,
      
    };
    ScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn mute_for(&self) -> &Option<i32> { &self.mute_for }
  
  pub fn sound(&self) -> &Option<String> { &self.sound }
  
  pub fn show_preview(&self) -> &Option<bool> { &self.show_preview }
  
  pub fn disable_pinned_message_notifications(&self) -> &Option<bool> { &self.disable_pinned_message_notifications }
  
  pub fn disable_mention_notifications(&self) -> &Option<bool> { &self.disable_mention_notifications }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ScopeNotificationSettingsBuilder {
  instance: ScopeNotificationSettings
}

impl ScopeNotificationSettingsBuilder {
  fn new(instance: ScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ScopeNotificationSettings {
    self.instance.clone()
  }
  
  pub fn mute_for(&mut self, mute_for: i32) -> &mut Self {
    self.instance.mute_for = Some(mute_for);
    self
  }
  
  pub fn sound(&mut self, sound: String) -> &mut Self {
    self.instance.sound = Some(sound);
    self
  }
  
  pub fn show_preview(&mut self, show_preview: bool) -> &mut Self {
    self.instance.show_preview = Some(show_preview);
    self
  }
  
  pub fn disable_pinned_message_notifications(&mut self, disable_pinned_message_notifications: bool) -> &mut Self {
    self.instance.disable_pinned_message_notifications = Some(disable_pinned_message_notifications);
    self
  }
  
  pub fn disable_mention_notifications(&mut self, disable_mention_notifications: bool) -> &mut Self {
    self.instance.disable_mention_notifications = Some(disable_mention_notifications);
    self
  }
  
}


/// This class is an abstract base class. Represents a filter for message search results. 
#[typetag::serde(tag = "@struct")]
pub trait SearchMessagesFilter: Debug {}



impl Object for SearchMessagesFilter {}





/// Returns all found messages, no filter is applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterEmpty

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterEmpty {}


impl SearchMessagesFilterEmpty {
  
  pub fn builder() -> SearchMessagesFilterEmptyBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterEmpty".to_string(),
      
    };
    SearchMessagesFilterEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterEmptyBuilder {
  instance: SearchMessagesFilterEmpty
}

impl SearchMessagesFilterEmptyBuilder {
  fn new(instance: SearchMessagesFilterEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterEmpty {
    self.instance.clone()
  }
  
}


/// Returns only animation messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterAnimation

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterAnimation {}


impl SearchMessagesFilterAnimation {
  
  pub fn builder() -> SearchMessagesFilterAnimationBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterAnimation".to_string(),
      
    };
    SearchMessagesFilterAnimationBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterAnimationBuilder {
  instance: SearchMessagesFilterAnimation
}

impl SearchMessagesFilterAnimationBuilder {
  fn new(instance: SearchMessagesFilterAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterAnimation {
    self.instance.clone()
  }
  
}


/// Returns only audio messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterAudio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterAudio

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterAudio {}


impl SearchMessagesFilterAudio {
  
  pub fn builder() -> SearchMessagesFilterAudioBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterAudio".to_string(),
      
    };
    SearchMessagesFilterAudioBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterAudioBuilder {
  instance: SearchMessagesFilterAudio
}

impl SearchMessagesFilterAudioBuilder {
  fn new(instance: SearchMessagesFilterAudio) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterAudio {
    self.instance.clone()
  }
  
}


/// Returns only document messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterDocument {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterDocument

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterDocument {}


impl SearchMessagesFilterDocument {
  
  pub fn builder() -> SearchMessagesFilterDocumentBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterDocument".to_string(),
      
    };
    SearchMessagesFilterDocumentBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterDocumentBuilder {
  instance: SearchMessagesFilterDocument
}

impl SearchMessagesFilterDocumentBuilder {
  fn new(instance: SearchMessagesFilterDocument) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterDocument {
    self.instance.clone()
  }
  
}


/// Returns only photo messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterPhoto

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterPhoto {}


impl SearchMessagesFilterPhoto {
  
  pub fn builder() -> SearchMessagesFilterPhotoBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterPhoto".to_string(),
      
    };
    SearchMessagesFilterPhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterPhotoBuilder {
  instance: SearchMessagesFilterPhoto
}

impl SearchMessagesFilterPhotoBuilder {
  fn new(instance: SearchMessagesFilterPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterPhoto {
    self.instance.clone()
  }
  
}


/// Returns only video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterVideo

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterVideo {}


impl SearchMessagesFilterVideo {
  
  pub fn builder() -> SearchMessagesFilterVideoBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterVideo".to_string(),
      
    };
    SearchMessagesFilterVideoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterVideoBuilder {
  instance: SearchMessagesFilterVideo
}

impl SearchMessagesFilterVideoBuilder {
  fn new(instance: SearchMessagesFilterVideo) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVideo {
    self.instance.clone()
  }
  
}


/// Returns only voice note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterVoiceNote

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterVoiceNote {}


impl SearchMessagesFilterVoiceNote {
  
  pub fn builder() -> SearchMessagesFilterVoiceNoteBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterVoiceNote".to_string(),
      
    };
    SearchMessagesFilterVoiceNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterVoiceNoteBuilder {
  instance: SearchMessagesFilterVoiceNote
}

impl SearchMessagesFilterVoiceNoteBuilder {
  fn new(instance: SearchMessagesFilterVoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVoiceNote {
    self.instance.clone()
  }
  
}


/// Returns only photo and video messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterPhotoAndVideo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterPhotoAndVideo

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterPhotoAndVideo {}


impl SearchMessagesFilterPhotoAndVideo {
  
  pub fn builder() -> SearchMessagesFilterPhotoAndVideoBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterPhotoAndVideo".to_string(),
      
    };
    SearchMessagesFilterPhotoAndVideoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterPhotoAndVideoBuilder {
  instance: SearchMessagesFilterPhotoAndVideo
}

impl SearchMessagesFilterPhotoAndVideoBuilder {
  fn new(instance: SearchMessagesFilterPhotoAndVideo) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterPhotoAndVideo {
    self.instance.clone()
  }
  
}


/// Returns only messages containing URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterUrl

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterUrl {}


impl SearchMessagesFilterUrl {
  
  pub fn builder() -> SearchMessagesFilterUrlBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterUrl".to_string(),
      
    };
    SearchMessagesFilterUrlBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterUrlBuilder {
  instance: SearchMessagesFilterUrl
}

impl SearchMessagesFilterUrlBuilder {
  fn new(instance: SearchMessagesFilterUrl) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterUrl {
    self.instance.clone()
  }
  
}


/// Returns only messages containing chat photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterChatPhoto

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterChatPhoto {}


impl SearchMessagesFilterChatPhoto {
  
  pub fn builder() -> SearchMessagesFilterChatPhotoBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterChatPhoto".to_string(),
      
    };
    SearchMessagesFilterChatPhotoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterChatPhotoBuilder {
  instance: SearchMessagesFilterChatPhoto
}

impl SearchMessagesFilterChatPhotoBuilder {
  fn new(instance: SearchMessagesFilterChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterChatPhoto {
    self.instance.clone()
  }
  
}


/// Returns only call messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterCall

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterCall {}


impl SearchMessagesFilterCall {
  
  pub fn builder() -> SearchMessagesFilterCallBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterCall".to_string(),
      
    };
    SearchMessagesFilterCallBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterCallBuilder {
  instance: SearchMessagesFilterCall
}

impl SearchMessagesFilterCallBuilder {
  fn new(instance: SearchMessagesFilterCall) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterCall {
    self.instance.clone()
  }
  
}


/// Returns only incoming call messages with missed/declined discard reasons. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMissedCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterMissedCall

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterMissedCall {}


impl SearchMessagesFilterMissedCall {
  
  pub fn builder() -> SearchMessagesFilterMissedCallBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterMissedCall".to_string(),
      
    };
    SearchMessagesFilterMissedCallBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterMissedCallBuilder {
  instance: SearchMessagesFilterMissedCall
}

impl SearchMessagesFilterMissedCallBuilder {
  fn new(instance: SearchMessagesFilterMissedCall) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterMissedCall {
    self.instance.clone()
  }
  
}


/// Returns only video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterVideoNote

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterVideoNote {}


impl SearchMessagesFilterVideoNote {
  
  pub fn builder() -> SearchMessagesFilterVideoNoteBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterVideoNote".to_string(),
      
    };
    SearchMessagesFilterVideoNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterVideoNoteBuilder {
  instance: SearchMessagesFilterVideoNote
}

impl SearchMessagesFilterVideoNoteBuilder {
  fn new(instance: SearchMessagesFilterVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVideoNote {
    self.instance.clone()
  }
  
}


/// Returns only voice and video note messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterVoiceAndVideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterVoiceAndVideoNote

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterVoiceAndVideoNote {}


impl SearchMessagesFilterVoiceAndVideoNote {
  
  pub fn builder() -> SearchMessagesFilterVoiceAndVideoNoteBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterVoiceAndVideoNote".to_string(),
      
    };
    SearchMessagesFilterVoiceAndVideoNoteBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterVoiceAndVideoNoteBuilder {
  instance: SearchMessagesFilterVoiceAndVideoNote
}

impl SearchMessagesFilterVoiceAndVideoNoteBuilder {
  fn new(instance: SearchMessagesFilterVoiceAndVideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterVoiceAndVideoNote {
    self.instance.clone()
  }
  
}


/// Returns only messages with mentions of the current user, or messages that are replies to their messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterMention

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterMention {}


impl SearchMessagesFilterMention {
  
  pub fn builder() -> SearchMessagesFilterMentionBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterMention".to_string(),
      
    };
    SearchMessagesFilterMentionBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterMentionBuilder {
  instance: SearchMessagesFilterMention
}

impl SearchMessagesFilterMentionBuilder {
  fn new(instance: SearchMessagesFilterMention) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterMention {
    self.instance.clone()
  }
  
}


/// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query or by the sending user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessagesFilterUnreadMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessagesFilterUnreadMention

}



#[typetag::serde]
impl SearchMessagesFilter for SearchMessagesFilterUnreadMention {}


impl SearchMessagesFilterUnreadMention {
  
  pub fn builder() -> SearchMessagesFilterUnreadMentionBuilder {
    let instance = Self {
      tdfname: "searchMessagesFilterUnreadMention".to_string(),
      
    };
    SearchMessagesFilterUnreadMentionBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesFilterUnreadMentionBuilder {
  instance: SearchMessagesFilterUnreadMention
}

impl SearchMessagesFilterUnreadMentionBuilder {
  fn new(instance: SearchMessagesFilterUnreadMention) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessagesFilterUnreadMention {
    self.instance.clone()
  }
  
}


/// Contains a value representing a number of seconds. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Seconds {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // seconds

  /// Number of seconds.
  seconds: Option<f64>,


}




impl Object for Seconds {}


impl Seconds {
  
  pub fn builder() -> SecondsBuilder {
    let instance = Self {
      tdfname: "seconds".to_string(),
      seconds: None,
      
    };
    SecondsBuilder::new(instance)
  }
  
  
  pub fn seconds(&self) -> &Option<f64> { &self.seconds }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SecondsBuilder {
  instance: Seconds
}

impl SecondsBuilder {
  fn new(instance: Seconds) -> Self { Self { instance } }

  pub fn build(&self) -> Seconds {
    self.instance.clone()
  }
  
  pub fn seconds(&mut self, seconds: f64) -> &mut Self {
    self.instance.seconds = Some(seconds);
    self
  }
  
}


/// Represents a secret chat. 
#[derive(Debug, Serialize, Deserialize)]
pub struct SecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // secretChat

  /// Secret chat identifier.
  id: Option<i32>,
  /// Identifier of the chat partner.
  user_id: Option<i32>,
  /// State of the secret chat.
  state: Option<Box<SecretChatState>>,
  /// True, if the chat was created by the current user; otherwise false.
  is_outbound: Option<bool>,
  /// Current message Time To Live setting (self-destruct timer) for the chat, in seconds.
  ttl: Option<i32>,
  /// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 bytes, which must be used to make a 12x12 square image with a color depth of 4. The first 16 bytes should be used to make a central 8x8 square, while the remaining 20 bytes should be used to construct a 2-pixel-wide border around that square. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers.
  key_hash: Option<String>,
  /// Secret chat layer; determines features supported by the other client. Video notes are supported if the layer >= 66.
  layer: Option<i32>,


}


impl Clone for SecretChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for SecretChat {}


impl SecretChat {
  
  pub fn builder() -> SecretChatBuilder {
    let instance = Self {
      tdfname: "secretChat".to_string(),
      id: None,
      user_id: None,
      state: None,
      is_outbound: None,
      ttl: None,
      key_hash: None,
      layer: None,
      
    };
    SecretChatBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn state(&self) -> &Option<Box<SecretChatState>> { &self.state }
  
  pub fn is_outbound(&self) -> &Option<bool> { &self.is_outbound }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  pub fn key_hash(&self) -> &Option<String> { &self.key_hash }
  
  pub fn layer(&self) -> &Option<i32> { &self.layer }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SecretChatBuilder {
  instance: SecretChat
}

impl SecretChatBuilder {
  fn new(instance: SecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChat {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn state(&mut self, state: Box<SecretChatState>) -> &mut Self {
    self.instance.state = Some(state);
    self
  }
  
  pub fn is_outbound(&mut self, is_outbound: bool) -> &mut Self {
    self.instance.is_outbound = Some(is_outbound);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn key_hash(&mut self, key_hash: String) -> &mut Self {
    self.instance.key_hash = Some(key_hash);
    self
  }
  
  pub fn layer(&mut self, layer: i32) -> &mut Self {
    self.instance.layer = Some(layer);
    self
  }
  
}


/// This class is an abstract base class. Describes the current secret chat state. 
#[typetag::serde(tag = "@struct")]
pub trait SecretChatState: Debug {}



impl Object for SecretChatState {}





/// The secret chat is not yet created; waiting for the other user to get online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStatePending {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // secretChatStatePending

}



#[typetag::serde]
impl SecretChatState for SecretChatStatePending {}


impl SecretChatStatePending {
  
  pub fn builder() -> SecretChatStatePendingBuilder {
    let instance = Self {
      tdfname: "secretChatStatePending".to_string(),
      
    };
    SecretChatStatePendingBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SecretChatStatePendingBuilder {
  instance: SecretChatStatePending
}

impl SecretChatStatePendingBuilder {
  fn new(instance: SecretChatStatePending) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStatePending {
    self.instance.clone()
  }
  
}


/// The secret chat is ready to use. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateReady {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // secretChatStateReady

}



#[typetag::serde]
impl SecretChatState for SecretChatStateReady {}


impl SecretChatStateReady {
  
  pub fn builder() -> SecretChatStateReadyBuilder {
    let instance = Self {
      tdfname: "secretChatStateReady".to_string(),
      
    };
    SecretChatStateReadyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SecretChatStateReadyBuilder {
  instance: SecretChatStateReady
}

impl SecretChatStateReadyBuilder {
  fn new(instance: SecretChatStateReady) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStateReady {
    self.instance.clone()
  }
  
}


/// The secret chat is closed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecretChatStateClosed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // secretChatStateClosed

}



#[typetag::serde]
impl SecretChatState for SecretChatStateClosed {}


impl SecretChatStateClosed {
  
  pub fn builder() -> SecretChatStateClosedBuilder {
    let instance = Self {
      tdfname: "secretChatStateClosed".to_string(),
      
    };
    SecretChatStateClosedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SecretChatStateClosedBuilder {
  instance: SecretChatStateClosed
}

impl SecretChatStateClosedBuilder {
  fn new(instance: SecretChatStateClosed) -> Self { Self { instance } }

  pub fn build(&self) -> SecretChatStateClosed {
    self.instance.clone()
  }
  
}


/// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Session {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // session

  /// Session identifier.
  id: Option<i64>,
  /// True, if this session is the current session.
  is_current: Option<bool>,
  /// True, if a password is needed to complete authorization of the session.
  is_password_pending: Option<bool>,
  /// Telegram API identifier, as provided by the application.
  api_id: Option<i32>,
  /// Name of the application, as provided by the application.
  application_name: Option<String>,
  /// The version of the application, as provided by the application.
  application_version: Option<String>,
  /// True, if the application is an official application or uses the api_id of an official application.
  is_official_application: Option<bool>,
  /// Model of the device the application has been run or is running on, as provided by the application.
  device_model: Option<String>,
  /// Operating system the application has been run or is running on, as provided by the application.
  platform: Option<String>,
  /// Version of the operating system the application has been run or is running on, as provided by the application.
  system_version: Option<String>,
  /// Point in time (Unix timestamp) when the user has logged in.
  log_in_date: Option<i32>,
  /// Point in time (Unix timestamp) when the session was last used.
  last_active_date: Option<i32>,
  /// IP address from which the session was created, in human-readable format.
  ip: Option<String>,
  /// A two-letter country code for the country from which the session was created, based on the IP address.
  country: Option<String>,
  /// Region code from which the session was created, based on the IP address.
  region: Option<String>,


}




impl Object for Session {}


impl Session {
  
  pub fn builder() -> SessionBuilder {
    let instance = Self {
      tdfname: "session".to_string(),
      id: None,
      is_current: None,
      is_password_pending: None,
      api_id: None,
      application_name: None,
      application_version: None,
      is_official_application: None,
      device_model: None,
      platform: None,
      system_version: None,
      log_in_date: None,
      last_active_date: None,
      ip: None,
      country: None,
      region: None,
      
    };
    SessionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn is_current(&self) -> &Option<bool> { &self.is_current }
  
  pub fn is_password_pending(&self) -> &Option<bool> { &self.is_password_pending }
  
  pub fn api_id(&self) -> &Option<i32> { &self.api_id }
  
  pub fn application_name(&self) -> &Option<String> { &self.application_name }
  
  pub fn application_version(&self) -> &Option<String> { &self.application_version }
  
  pub fn is_official_application(&self) -> &Option<bool> { &self.is_official_application }
  
  pub fn device_model(&self) -> &Option<String> { &self.device_model }
  
  pub fn platform(&self) -> &Option<String> { &self.platform }
  
  pub fn system_version(&self) -> &Option<String> { &self.system_version }
  
  pub fn log_in_date(&self) -> &Option<i32> { &self.log_in_date }
  
  pub fn last_active_date(&self) -> &Option<i32> { &self.last_active_date }
  
  pub fn ip(&self) -> &Option<String> { &self.ip }
  
  pub fn country(&self) -> &Option<String> { &self.country }
  
  pub fn region(&self) -> &Option<String> { &self.region }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SessionBuilder {
  instance: Session
}

impl SessionBuilder {
  fn new(instance: Session) -> Self { Self { instance } }

  pub fn build(&self) -> Session {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn is_current(&mut self, is_current: bool) -> &mut Self {
    self.instance.is_current = Some(is_current);
    self
  }
  
  pub fn is_password_pending(&mut self, is_password_pending: bool) -> &mut Self {
    self.instance.is_password_pending = Some(is_password_pending);
    self
  }
  
  pub fn api_id(&mut self, api_id: i32) -> &mut Self {
    self.instance.api_id = Some(api_id);
    self
  }
  
  pub fn application_name(&mut self, application_name: String) -> &mut Self {
    self.instance.application_name = Some(application_name);
    self
  }
  
  pub fn application_version(&mut self, application_version: String) -> &mut Self {
    self.instance.application_version = Some(application_version);
    self
  }
  
  pub fn is_official_application(&mut self, is_official_application: bool) -> &mut Self {
    self.instance.is_official_application = Some(is_official_application);
    self
  }
  
  pub fn device_model(&mut self, device_model: String) -> &mut Self {
    self.instance.device_model = Some(device_model);
    self
  }
  
  pub fn platform(&mut self, platform: String) -> &mut Self {
    self.instance.platform = Some(platform);
    self
  }
  
  pub fn system_version(&mut self, system_version: String) -> &mut Self {
    self.instance.system_version = Some(system_version);
    self
  }
  
  pub fn log_in_date(&mut self, log_in_date: i32) -> &mut Self {
    self.instance.log_in_date = Some(log_in_date);
    self
  }
  
  pub fn last_active_date(&mut self, last_active_date: i32) -> &mut Self {
    self.instance.last_active_date = Some(last_active_date);
    self
  }
  
  pub fn ip(&mut self, ip: String) -> &mut Self {
    self.instance.ip = Some(ip);
    self
  }
  
  pub fn country(&mut self, country: String) -> &mut Self {
    self.instance.country = Some(country);
    self
  }
  
  pub fn region(&mut self, region: String) -> &mut Self {
    self.instance.region = Some(region);
    self
  }
  
}


/// Contains a list of sessions. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sessions

  /// List of sessions.
  sessions: Option<Vec<Session>>,


}




impl Object for Sessions {}


impl Sessions {
  
  pub fn builder() -> SessionsBuilder {
    let instance = Self {
      tdfname: "sessions".to_string(),
      sessions: None,
      
    };
    SessionsBuilder::new(instance)
  }
  
  
  pub fn sessions(&self) -> &Option<Vec<Session>> { &self.sessions }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SessionsBuilder {
  instance: Sessions
}

impl SessionsBuilder {
  fn new(instance: Sessions) -> Self { Self { instance } }

  pub fn build(&self) -> Sessions {
    self.instance.clone()
  }
  
  pub fn sessions(&mut self, sessions: Vec<Session>) -> &mut Self {
    self.instance.sessions = Some(sessions);
    self
  }
  
}


/// One shipping option. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShippingOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // shippingOption

  /// Shipping option identifier.
  id: Option<String>,
  /// Option title.
  title: Option<String>,
  /// A list of objects used to calculate the total shipping costs.
  price_parts: Option<Vec<LabeledPricePart>>,


}




impl Object for ShippingOption {}


impl ShippingOption {
  
  pub fn builder() -> ShippingOptionBuilder {
    let instance = Self {
      tdfname: "shippingOption".to_string(),
      id: None,
      title: None,
      price_parts: None,
      
    };
    ShippingOptionBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn price_parts(&self) -> &Option<Vec<LabeledPricePart>> { &self.price_parts }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ShippingOptionBuilder {
  instance: ShippingOption
}

impl ShippingOptionBuilder {
  fn new(instance: ShippingOption) -> Self { Self { instance } }

  pub fn build(&self) -> ShippingOption {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn price_parts(&mut self, price_parts: Vec<LabeledPricePart>) -> &mut Self {
    self.instance.price_parts = Some(price_parts);
    self
  }
  
}


/// Describes a sticker. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sticker

  /// The identifier of the sticker set to which the sticker belongs; 0 if none.
  set_id: Option<i64>,
  /// Sticker width; as defined by the sender.
  width: Option<i32>,
  /// Sticker height; as defined by the sender.
  height: Option<i32>,
  /// Emoji corresponding to the sticker.
  emoji: Option<String>,
  /// True, if the sticker is a mask.
  is_mask: Option<bool>,
  /// Position where the mask should be placed; may be null.
  mask_position: Option<MaskPosition>,
  /// Sticker thumbnail in WEBP or JPEG format; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the sticker.
  sticker: Option<File>,


}




impl Object for Sticker {}


impl Sticker {
  
  pub fn builder() -> StickerBuilder {
    let instance = Self {
      tdfname: "sticker".to_string(),
      set_id: None,
      width: None,
      height: None,
      emoji: None,
      is_mask: None,
      mask_position: None,
      thumbnail: None,
      sticker: None,
      
    };
    StickerBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> &Option<i64> { &self.set_id }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn emoji(&self) -> &Option<String> { &self.emoji }
  
  pub fn is_mask(&self) -> &Option<bool> { &self.is_mask }
  
  pub fn mask_position(&self) -> &Option<MaskPosition> { &self.mask_position }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  pub fn sticker(&self) -> &Option<File> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickerBuilder {
  instance: Sticker
}

impl StickerBuilder {
  fn new(instance: Sticker) -> Self { Self { instance } }

  pub fn build(&self) -> Sticker {
    self.instance.clone()
  }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn emoji(&mut self, emoji: String) -> &mut Self {
    self.instance.emoji = Some(emoji);
    self
  }
  
  pub fn is_mask(&mut self, is_mask: bool) -> &mut Self {
    self.instance.is_mask = Some(is_mask);
    self
  }
  
  pub fn mask_position(&mut self, mask_position: MaskPosition) -> &mut Self {
    self.instance.mask_position = Some(mask_position);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn sticker(&mut self, sticker: File) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Represents a list of all emoji corresponding to a sticker in a sticker set. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stickerEmojis

  /// List of emojis.
  emojis: Option<Vec<String>>,


}




impl Object for StickerEmojis {}


impl StickerEmojis {
  
  pub fn builder() -> StickerEmojisBuilder {
    let instance = Self {
      tdfname: "stickerEmojis".to_string(),
      emojis: None,
      
    };
    StickerEmojisBuilder::new(instance)
  }
  
  
  pub fn emojis(&self) -> &Option<Vec<String>> { &self.emojis }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickerEmojisBuilder {
  instance: StickerEmojis
}

impl StickerEmojisBuilder {
  fn new(instance: StickerEmojis) -> Self { Self { instance } }

  pub fn build(&self) -> StickerEmojis {
    self.instance.clone()
  }
  
  pub fn emojis(&mut self, emojis: Vec<String>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
}


/// Represents a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stickerSet

  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by the current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// List of stickers in this set.
  stickers: Option<Vec<Sticker>>,
  /// A list of emoji corresponding to the stickers in the same order.
  emojis: Option<Vec<StickerEmojis>>,


}




impl Object for StickerSet {}


impl StickerSet {
  
  pub fn builder() -> StickerSetBuilder {
    let instance = Self {
      tdfname: "stickerSet".to_string(),
      id: None,
      title: None,
      name: None,
      is_installed: None,
      is_archived: None,
      is_official: None,
      is_masks: None,
      is_viewed: None,
      stickers: None,
      emojis: None,
      
    };
    StickerSetBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn is_installed(&self) -> &Option<bool> { &self.is_installed }
  
  pub fn is_archived(&self) -> &Option<bool> { &self.is_archived }
  
  pub fn is_official(&self) -> &Option<bool> { &self.is_official }
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn is_viewed(&self) -> &Option<bool> { &self.is_viewed }
  
  pub fn stickers(&self) -> &Option<Vec<Sticker>> { &self.stickers }
  
  pub fn emojis(&self) -> &Option<Vec<StickerEmojis>> { &self.emojis }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickerSetBuilder {
  instance: StickerSet
}

impl StickerSetBuilder {
  fn new(instance: StickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSet {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn stickers(&mut self, stickers: Vec<Sticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
  pub fn emojis(&mut self, emojis: Vec<StickerEmojis>) -> &mut Self {
    self.instance.emojis = Some(emojis);
    self
  }
  
}


/// Represents short information about a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stickerSetInfo

  /// Identifier of the sticker set.
  id: Option<i64>,
  /// Title of the sticker set.
  title: Option<String>,
  /// Name of the sticker set.
  name: Option<String>,
  /// True, if the sticker set has been installed by current user.
  is_installed: Option<bool>,
  /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,
  /// True, if the sticker set is official.
  is_official: Option<bool>,
  /// True, if the stickers in the set are masks.
  is_masks: Option<bool>,
  /// True for already viewed trending sticker sets.
  is_viewed: Option<bool>,
  /// Total number of stickers in the set.
  size: Option<i32>,
  /// Contains up to the first 5 stickers from the set, depending on the context. If the client needs more stickers the full set should be requested.
  covers: Option<Vec<Sticker>>,


}




impl Object for StickerSetInfo {}


impl StickerSetInfo {
  
  pub fn builder() -> StickerSetInfoBuilder {
    let instance = Self {
      tdfname: "stickerSetInfo".to_string(),
      id: None,
      title: None,
      name: None,
      is_installed: None,
      is_archived: None,
      is_official: None,
      is_masks: None,
      is_viewed: None,
      size: None,
      covers: None,
      
    };
    StickerSetInfoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn is_installed(&self) -> &Option<bool> { &self.is_installed }
  
  pub fn is_archived(&self) -> &Option<bool> { &self.is_archived }
  
  pub fn is_official(&self) -> &Option<bool> { &self.is_official }
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn is_viewed(&self) -> &Option<bool> { &self.is_viewed }
  
  pub fn size(&self) -> &Option<i32> { &self.size }
  
  pub fn covers(&self) -> &Option<Vec<Sticker>> { &self.covers }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickerSetInfoBuilder {
  instance: StickerSetInfo
}

impl StickerSetInfoBuilder {
  fn new(instance: StickerSetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSetInfo {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
  pub fn is_official(&mut self, is_official: bool) -> &mut Self {
    self.instance.is_official = Some(is_official);
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn is_viewed(&mut self, is_viewed: bool) -> &mut Self {
    self.instance.is_viewed = Some(is_viewed);
    self
  }
  
  pub fn size(&mut self, size: i32) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn covers(&mut self, covers: Vec<Sticker>) -> &mut Self {
    self.instance.covers = Some(covers);
    self
  }
  
}


/// Represents a list of sticker sets. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stickerSets

  /// Approximate total number of sticker sets found.
  total_count: Option<i32>,
  /// List of sticker sets.
  sets: Option<Vec<StickerSetInfo>>,


}




impl Object for StickerSets {}


impl StickerSets {
  
  pub fn builder() -> StickerSetsBuilder {
    let instance = Self {
      tdfname: "stickerSets".to_string(),
      total_count: None,
      sets: None,
      
    };
    StickerSetsBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn sets(&self) -> &Option<Vec<StickerSetInfo>> { &self.sets }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickerSetsBuilder {
  instance: StickerSets
}

impl StickerSetsBuilder {
  fn new(instance: StickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> StickerSets {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn sets(&mut self, sets: Vec<StickerSetInfo>) -> &mut Self {
    self.instance.sets = Some(sets);
    self
  }
  
}


/// Represents a list of stickers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Stickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stickers

  /// List of stickers.
  stickers: Option<Vec<Sticker>>,


}




impl Object for Stickers {}


impl Stickers {
  
  pub fn builder() -> StickersBuilder {
    let instance = Self {
      tdfname: "stickers".to_string(),
      stickers: None,
      
    };
    StickersBuilder::new(instance)
  }
  
  
  pub fn stickers(&self) -> &Option<Vec<Sticker>> { &self.stickers }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StickersBuilder {
  instance: Stickers
}

impl StickersBuilder {
  fn new(instance: Stickers) -> Self { Self { instance } }

  pub fn build(&self) -> Stickers {
    self.instance.clone()
  }
  
  pub fn stickers(&mut self, stickers: Vec<Sticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
}


/// Contains the exact storage usage statistics split by chats and file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // storageStatistics

  /// Total size of files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,
  /// Statistics split by chats.
  by_chat: Option<Vec<StorageStatisticsByChat>>,


}




impl Object for StorageStatistics {}


impl StorageStatistics {
  
  pub fn builder() -> StorageStatisticsBuilder {
    let instance = Self {
      tdfname: "storageStatistics".to_string(),
      size: None,
      count: None,
      by_chat: None,
      
    };
    StorageStatisticsBuilder::new(instance)
  }
  
  
  pub fn size(&self) -> &Option<i64> { &self.size }
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  pub fn by_chat(&self) -> &Option<Vec<StorageStatisticsByChat>> { &self.by_chat }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StorageStatisticsBuilder {
  instance: StorageStatistics
}

impl StorageStatisticsBuilder {
  fn new(instance: StorageStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatistics {
    self.instance.clone()
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn by_chat(&mut self, by_chat: Vec<StorageStatisticsByChat>) -> &mut Self {
    self.instance.by_chat = Some(by_chat);
    self
  }
  
}


/// Contains the storage usage statistics for a specific chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsByChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // storageStatisticsByChat

  /// Chat identifier; 0 if none.
  chat_id: Option<i64>,
  /// Total size of the files in the chat.
  size: Option<i64>,
  /// Total number of files in the chat.
  count: Option<i32>,
  /// Statistics split by file types.
  by_file_type: Option<Vec<StorageStatisticsByFileType>>,


}




impl Object for StorageStatisticsByChat {}


impl StorageStatisticsByChat {
  
  pub fn builder() -> StorageStatisticsByChatBuilder {
    let instance = Self {
      tdfname: "storageStatisticsByChat".to_string(),
      chat_id: None,
      size: None,
      count: None,
      by_file_type: None,
      
    };
    StorageStatisticsByChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn size(&self) -> &Option<i64> { &self.size }
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  pub fn by_file_type(&self) -> &Option<Vec<StorageStatisticsByFileType>> { &self.by_file_type }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StorageStatisticsByChatBuilder {
  instance: StorageStatisticsByChat
}

impl StorageStatisticsByChatBuilder {
  fn new(instance: StorageStatisticsByChat) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsByChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn by_file_type(&mut self, by_file_type: Vec<StorageStatisticsByFileType>) -> &mut Self {
    self.instance.by_file_type = Some(by_file_type);
    self
  }
  
}


/// Contains the storage usage statistics for a specific file type. 
#[derive(Debug, Serialize, Deserialize)]
pub struct StorageStatisticsByFileType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // storageStatisticsByFileType

  /// File type.
  file_type: Option<Box<FileType>>,
  /// Total size of the files.
  size: Option<i64>,
  /// Total number of files.
  count: Option<i32>,


}


impl Clone for StorageStatisticsByFileType {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for StorageStatisticsByFileType {}


impl StorageStatisticsByFileType {
  
  pub fn builder() -> StorageStatisticsByFileTypeBuilder {
    let instance = Self {
      tdfname: "storageStatisticsByFileType".to_string(),
      file_type: None,
      size: None,
      count: None,
      
    };
    StorageStatisticsByFileTypeBuilder::new(instance)
  }
  
  
  pub fn file_type(&self) -> &Option<Box<FileType>> { &self.file_type }
  
  pub fn size(&self) -> &Option<i64> { &self.size }
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StorageStatisticsByFileTypeBuilder {
  instance: StorageStatisticsByFileType
}

impl StorageStatisticsByFileTypeBuilder {
  fn new(instance: StorageStatisticsByFileType) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsByFileType {
    self.instance.clone()
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}


/// Contains approximate storage usage statistics, excluding files of unknown file type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // storageStatisticsFast

  /// Approximate total size of files.
  files_size: Option<i64>,
  /// Approximate number of files.
  file_count: Option<i32>,
  /// Size of the database.
  database_size: Option<i64>,
  /// Size of the language pack database.
  language_pack_database_size: Option<i64>,
  /// Size of the TDLib internal log.
  log_size: Option<i64>,


}




impl Object for StorageStatisticsFast {}


impl StorageStatisticsFast {
  
  pub fn builder() -> StorageStatisticsFastBuilder {
    let instance = Self {
      tdfname: "storageStatisticsFast".to_string(),
      files_size: None,
      file_count: None,
      database_size: None,
      language_pack_database_size: None,
      log_size: None,
      
    };
    StorageStatisticsFastBuilder::new(instance)
  }
  
  
  pub fn files_size(&self) -> &Option<i64> { &self.files_size }
  
  pub fn file_count(&self) -> &Option<i32> { &self.file_count }
  
  pub fn database_size(&self) -> &Option<i64> { &self.database_size }
  
  pub fn language_pack_database_size(&self) -> &Option<i64> { &self.language_pack_database_size }
  
  pub fn log_size(&self) -> &Option<i64> { &self.log_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StorageStatisticsFastBuilder {
  instance: StorageStatisticsFast
}

impl StorageStatisticsFastBuilder {
  fn new(instance: StorageStatisticsFast) -> Self { Self { instance } }

  pub fn build(&self) -> StorageStatisticsFast {
    self.instance.clone()
  }
  
  pub fn files_size(&mut self, files_size: i64) -> &mut Self {
    self.instance.files_size = Some(files_size);
    self
  }
  
  pub fn file_count(&mut self, file_count: i32) -> &mut Self {
    self.instance.file_count = Some(file_count);
    self
  }
  
  pub fn database_size(&mut self, database_size: i64) -> &mut Self {
    self.instance.database_size = Some(database_size);
    self
  }
  
  pub fn language_pack_database_size(&mut self, language_pack_database_size: i64) -> &mut Self {
    self.instance.language_pack_database_size = Some(language_pack_database_size);
    self
  }
  
  pub fn log_size(&mut self, log_size: i64) -> &mut Self {
    self.instance.log_size = Some(log_size);
    self
  }
  
}


/// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Supergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroup

  /// Supergroup or channel identifier.
  id: Option<i32>,
  /// Username of the supergroup or channel; empty for private supergroups or channels.
  username: Option<String>,
  /// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member.
  date: Option<i32>,
  /// Status of the current user in the supergroup or channel.
  status: Option<Box<ChatMemberStatus>>,
  /// Member count; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was found through SearchPublicChats.
  member_count: Option<i32>,
  /// True, if any member of the supergroup can invite other members. This field has no meaning for channels.
  anyone_can_invite: Option<bool>,
  /// True, if messages sent to the channel should contain information about the sender. This field is only applicable to channels.
  sign_messages: Option<bool>,
  /// True, if the supergroup is a channel.
  is_channel: Option<bool>,
  /// True, if the supergroup or channel is verified.
  is_verified: Option<bool>,
  /// If non-empty, contains the reason why access to this supergroup or channel must be restricted. Format of the string is "{type}: {description}". {type} Contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,


}


impl Clone for Supergroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Supergroup {}


impl Supergroup {
  
  pub fn builder() -> SupergroupBuilder {
    let instance = Self {
      tdfname: "supergroup".to_string(),
      id: None,
      username: None,
      date: None,
      status: None,
      member_count: None,
      anyone_can_invite: None,
      sign_messages: None,
      is_channel: None,
      is_verified: None,
      restriction_reason: None,
      
    };
    SupergroupBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  pub fn status(&self) -> &Option<Box<ChatMemberStatus>> { &self.status }
  
  pub fn member_count(&self) -> &Option<i32> { &self.member_count }
  
  pub fn anyone_can_invite(&self) -> &Option<bool> { &self.anyone_can_invite }
  
  pub fn sign_messages(&self) -> &Option<bool> { &self.sign_messages }
  
  pub fn is_channel(&self) -> &Option<bool> { &self.is_channel }
  
  pub fn is_verified(&self) -> &Option<bool> { &self.is_verified }
  
  pub fn restriction_reason(&self) -> &Option<String> { &self.restriction_reason }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupBuilder {
  instance: Supergroup
}

impl SupergroupBuilder {
  fn new(instance: Supergroup) -> Self { Self { instance } }

  pub fn build(&self) -> Supergroup {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
  pub fn is_verified(&mut self, is_verified: bool) -> &mut Self {
    self.instance.is_verified = Some(is_verified);
    self
  }
  
  pub fn restriction_reason(&mut self, restriction_reason: String) -> &mut Self {
    self.instance.restriction_reason = Some(restriction_reason);
    self
  }
  
}


/// Contains full information about a supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupFullInfo

  /// Supergroup or channel description.
  description: Option<String>,
  /// Number of members in the supergroup or channel; 0 if unknown.
  member_count: Option<i32>,
  /// Number of privileged users in the supergroup or channel; 0 if unknown.
  administrator_count: Option<i32>,
  /// Number of restricted users in the supergroup; 0 if unknown.
  restricted_count: Option<i32>,
  /// Number of users banned from chat; 0 if unknown.
  banned_count: Option<i32>,
  /// True, if members of the chat can be retrieved.
  can_get_members: Option<bool>,
  /// True, if the chat can be made public.
  can_set_username: Option<bool>,
  /// True, if the supergroup sticker set can be changed.
  can_set_sticker_set: Option<bool>,
  /// True, if the channel statistics is available through getChatStatisticsUrl.
  can_view_statistics: Option<bool>,
  /// True, if new chat members will have access to old messages. In public supergroups and both public and private channels, old messages are always available, so this option affects only private supergroups. The value of this field is only available for chat administrators.
  is_all_history_available: Option<bool>,
  /// Identifier of the supergroup sticker set; 0 if none.
  sticker_set_id: Option<i64>,
  /// Invite link for this chat.
  invite_link: Option<String>,
  /// Identifier of the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_basic_group_id: Option<i32>,
  /// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none.
  upgraded_from_max_message_id: Option<i64>,


}




impl Object for SupergroupFullInfo {}


impl SupergroupFullInfo {
  
  pub fn builder() -> SupergroupFullInfoBuilder {
    let instance = Self {
      tdfname: "supergroupFullInfo".to_string(),
      description: None,
      member_count: None,
      administrator_count: None,
      restricted_count: None,
      banned_count: None,
      can_get_members: None,
      can_set_username: None,
      can_set_sticker_set: None,
      can_view_statistics: None,
      is_all_history_available: None,
      sticker_set_id: None,
      invite_link: None,
      upgraded_from_basic_group_id: None,
      upgraded_from_max_message_id: None,
      
    };
    SupergroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn member_count(&self) -> &Option<i32> { &self.member_count }
  
  pub fn administrator_count(&self) -> &Option<i32> { &self.administrator_count }
  
  pub fn restricted_count(&self) -> &Option<i32> { &self.restricted_count }
  
  pub fn banned_count(&self) -> &Option<i32> { &self.banned_count }
  
  pub fn can_get_members(&self) -> &Option<bool> { &self.can_get_members }
  
  pub fn can_set_username(&self) -> &Option<bool> { &self.can_set_username }
  
  pub fn can_set_sticker_set(&self) -> &Option<bool> { &self.can_set_sticker_set }
  
  pub fn can_view_statistics(&self) -> &Option<bool> { &self.can_view_statistics }
  
  pub fn is_all_history_available(&self) -> &Option<bool> { &self.is_all_history_available }
  
  pub fn sticker_set_id(&self) -> &Option<i64> { &self.sticker_set_id }
  
  pub fn invite_link(&self) -> &Option<String> { &self.invite_link }
  
  pub fn upgraded_from_basic_group_id(&self) -> &Option<i32> { &self.upgraded_from_basic_group_id }
  
  pub fn upgraded_from_max_message_id(&self) -> &Option<i64> { &self.upgraded_from_max_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupFullInfoBuilder {
  instance: SupergroupFullInfo
}

impl SupergroupFullInfoBuilder {
  fn new(instance: SupergroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupFullInfo {
    self.instance.clone()
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn member_count(&mut self, member_count: i32) -> &mut Self {
    self.instance.member_count = Some(member_count);
    self
  }
  
  pub fn administrator_count(&mut self, administrator_count: i32) -> &mut Self {
    self.instance.administrator_count = Some(administrator_count);
    self
  }
  
  pub fn restricted_count(&mut self, restricted_count: i32) -> &mut Self {
    self.instance.restricted_count = Some(restricted_count);
    self
  }
  
  pub fn banned_count(&mut self, banned_count: i32) -> &mut Self {
    self.instance.banned_count = Some(banned_count);
    self
  }
  
  pub fn can_get_members(&mut self, can_get_members: bool) -> &mut Self {
    self.instance.can_get_members = Some(can_get_members);
    self
  }
  
  pub fn can_set_username(&mut self, can_set_username: bool) -> &mut Self {
    self.instance.can_set_username = Some(can_set_username);
    self
  }
  
  pub fn can_set_sticker_set(&mut self, can_set_sticker_set: bool) -> &mut Self {
    self.instance.can_set_sticker_set = Some(can_set_sticker_set);
    self
  }
  
  pub fn can_view_statistics(&mut self, can_view_statistics: bool) -> &mut Self {
    self.instance.can_view_statistics = Some(can_view_statistics);
    self
  }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
  pub fn invite_link(&mut self, invite_link: String) -> &mut Self {
    self.instance.invite_link = Some(invite_link);
    self
  }
  
  pub fn upgraded_from_basic_group_id(&mut self, upgraded_from_basic_group_id: i32) -> &mut Self {
    self.instance.upgraded_from_basic_group_id = Some(upgraded_from_basic_group_id);
    self
  }
  
  pub fn upgraded_from_max_message_id(&mut self, upgraded_from_max_message_id: i64) -> &mut Self {
    self.instance.upgraded_from_max_message_id = Some(upgraded_from_max_message_id);
    self
  }
  
}


/// This class is an abstract base class. Specifies the kind of chat members to return in 
#[typetag::serde(tag = "@struct")]
pub trait SupergroupMembersFilter: Debug {}



impl Object for SupergroupMembersFilter {}





/// Returns recently active users in reverse chronological order. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRecent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterRecent

}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterRecent {}


impl SupergroupMembersFilterRecent {
  
  pub fn builder() -> SupergroupMembersFilterRecentBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterRecent".to_string(),
      
    };
    SupergroupMembersFilterRecentBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterRecentBuilder {
  instance: SupergroupMembersFilterRecent
}

impl SupergroupMembersFilterRecentBuilder {
  fn new(instance: SupergroupMembersFilterRecent) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterRecent {
    self.instance.clone()
  }
  
}


/// Returns the creator and administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterAdministrators

}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterAdministrators {}


impl SupergroupMembersFilterAdministrators {
  
  pub fn builder() -> SupergroupMembersFilterAdministratorsBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterAdministrators".to_string(),
      
    };
    SupergroupMembersFilterAdministratorsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterAdministratorsBuilder {
  instance: SupergroupMembersFilterAdministrators
}

impl SupergroupMembersFilterAdministratorsBuilder {
  fn new(instance: SupergroupMembersFilterAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterAdministrators {
    self.instance.clone()
  }
  
}


/// Used to search for supergroup or channel members via a (string) query. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterSearch {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterSearch

  /// Query to search for.
  query: Option<String>,


}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterSearch {}


impl SupergroupMembersFilterSearch {
  
  pub fn builder() -> SupergroupMembersFilterSearchBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterSearch".to_string(),
      query: None,
      
    };
    SupergroupMembersFilterSearchBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterSearchBuilder {
  instance: SupergroupMembersFilterSearch
}

impl SupergroupMembersFilterSearchBuilder {
  fn new(instance: SupergroupMembersFilterSearch) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterSearch {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
}


/// Returns restricted supergroup members; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterRestricted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterRestricted

  /// Query to search for.
  query: Option<String>,


}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterRestricted {}


impl SupergroupMembersFilterRestricted {
  
  pub fn builder() -> SupergroupMembersFilterRestrictedBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterRestricted".to_string(),
      query: None,
      
    };
    SupergroupMembersFilterRestrictedBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterRestrictedBuilder {
  instance: SupergroupMembersFilterRestricted
}

impl SupergroupMembersFilterRestrictedBuilder {
  fn new(instance: SupergroupMembersFilterRestricted) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterRestricted {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
}


/// Returns users banned from the supergroup or channel; can be used only by administrators. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBanned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterBanned

  /// Query to search for.
  query: Option<String>,


}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterBanned {}


impl SupergroupMembersFilterBanned {
  
  pub fn builder() -> SupergroupMembersFilterBannedBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterBanned".to_string(),
      query: None,
      
    };
    SupergroupMembersFilterBannedBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterBannedBuilder {
  instance: SupergroupMembersFilterBanned
}

impl SupergroupMembersFilterBannedBuilder {
  fn new(instance: SupergroupMembersFilterBanned) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterBanned {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
}


/// Returns bot members of the supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupergroupMembersFilterBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // supergroupMembersFilterBots

}



#[typetag::serde]
impl SupergroupMembersFilter for SupergroupMembersFilterBots {}


impl SupergroupMembersFilterBots {
  
  pub fn builder() -> SupergroupMembersFilterBotsBuilder {
    let instance = Self {
      tdfname: "supergroupMembersFilterBots".to_string(),
      
    };
    SupergroupMembersFilterBotsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SupergroupMembersFilterBotsBuilder {
  instance: SupergroupMembersFilterBots
}

impl SupergroupMembersFilterBotsBuilder {
  fn new(instance: SupergroupMembersFilterBots) -> Self { Self { instance } }

  pub fn build(&self) -> SupergroupMembersFilterBots {
    self.instance.clone()
  }
  
}


/// Represents a URL linking to an internal Telegram entity. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TMeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrl

  /// URL.
  url: Option<String>,
  /// Type of the URL.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TMeUrlType>>,


}


impl Clone for TMeUrl {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for TMeUrl {}


impl TMeUrl {
  
  pub fn builder() -> TMeUrlBuilder {
    let instance = Self {
      tdfname: "tMeUrl".to_string(),
      url: None,
      type_: None,
      
    };
    TMeUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn type_(&self) -> &Option<Box<TMeUrlType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlBuilder {
  instance: TMeUrl
}

impl TMeUrlBuilder {
  fn new(instance: TMeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrl {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn type_(&mut self, type_: Box<TMeUrlType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// This class is an abstract base class. Describes the type of a URL linking to an internal Telegram entity. 
#[typetag::serde(tag = "@struct")]
pub trait TMeUrlType: Debug {}



impl Object for TMeUrlType {}





/// A URL linking to a user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrlTypeUser

  /// Identifier of the user.
  user_id: Option<i32>,


}



#[typetag::serde]
impl TMeUrlType for TMeUrlTypeUser {}


impl TMeUrlTypeUser {
  
  pub fn builder() -> TMeUrlTypeUserBuilder {
    let instance = Self {
      tdfname: "tMeUrlTypeUser".to_string(),
      user_id: None,
      
    };
    TMeUrlTypeUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlTypeUserBuilder {
  instance: TMeUrlTypeUser
}

impl TMeUrlTypeUserBuilder {
  fn new(instance: TMeUrlTypeUser) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeUser {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// A URL linking to a public supergroup or channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrlTypeSupergroup

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i64>,


}



#[typetag::serde]
impl TMeUrlType for TMeUrlTypeSupergroup {}


impl TMeUrlTypeSupergroup {
  
  pub fn builder() -> TMeUrlTypeSupergroupBuilder {
    let instance = Self {
      tdfname: "tMeUrlTypeSupergroup".to_string(),
      supergroup_id: None,
      
    };
    TMeUrlTypeSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i64> { &self.supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlTypeSupergroupBuilder {
  instance: TMeUrlTypeSupergroup
}

impl TMeUrlTypeSupergroupBuilder {
  fn new(instance: TMeUrlTypeSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeSupergroup {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i64) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}


/// A chat invite link. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeChatInvite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrlTypeChatInvite

  /// Chat invite link info.
  info: Option<ChatInviteLinkInfo>,


}



#[typetag::serde]
impl TMeUrlType for TMeUrlTypeChatInvite {}


impl TMeUrlTypeChatInvite {
  
  pub fn builder() -> TMeUrlTypeChatInviteBuilder {
    let instance = Self {
      tdfname: "tMeUrlTypeChatInvite".to_string(),
      info: None,
      
    };
    TMeUrlTypeChatInviteBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> &Option<ChatInviteLinkInfo> { &self.info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlTypeChatInviteBuilder {
  instance: TMeUrlTypeChatInvite
}

impl TMeUrlTypeChatInviteBuilder {
  fn new(instance: TMeUrlTypeChatInvite) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeChatInvite {
    self.instance.clone()
  }
  
  pub fn info(&mut self, info: ChatInviteLinkInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
}


/// A URL linking to a sticker set. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrlTypeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrlTypeStickerSet

  /// Identifier of the sticker set.
  sticker_set_id: Option<i64>,


}



#[typetag::serde]
impl TMeUrlType for TMeUrlTypeStickerSet {}


impl TMeUrlTypeStickerSet {
  
  pub fn builder() -> TMeUrlTypeStickerSetBuilder {
    let instance = Self {
      tdfname: "tMeUrlTypeStickerSet".to_string(),
      sticker_set_id: None,
      
    };
    TMeUrlTypeStickerSetBuilder::new(instance)
  }
  
  
  pub fn sticker_set_id(&self) -> &Option<i64> { &self.sticker_set_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlTypeStickerSetBuilder {
  instance: TMeUrlTypeStickerSet
}

impl TMeUrlTypeStickerSetBuilder {
  fn new(instance: TMeUrlTypeStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrlTypeStickerSet {
    self.instance.clone()
  }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
}


/// Contains a list of t.me URLs. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tMeUrls

  /// List of URLs.
  urls: Option<Vec<TMeUrl>>,


}




impl Object for TMeUrls {}


impl TMeUrls {
  
  pub fn builder() -> TMeUrlsBuilder {
    let instance = Self {
      tdfname: "tMeUrls".to_string(),
      urls: None,
      
    };
    TMeUrlsBuilder::new(instance)
  }
  
  
  pub fn urls(&self) -> &Option<Vec<TMeUrl>> { &self.urls }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TMeUrlsBuilder {
  instance: TMeUrls
}

impl TMeUrlsBuilder {
  fn new(instance: TMeUrls) -> Self { Self { instance } }

  pub fn build(&self) -> TMeUrls {
    self.instance.clone()
  }
  
  pub fn urls(&mut self, urls: Vec<TMeUrl>) -> &mut Self {
    self.instance.urls = Some(urls);
    self
  }
  
}


/// Contains parameters for TDLib initialization. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // tdlibParameters

  /// If set to true, the Telegram test environment will be used instead of the production environment.
  use_test_dc: Option<bool>,
  /// The path to the directory for the persistent database; if empty, the current working directory will be used.
  database_directory: Option<String>,
  /// The path to the directory for storing files; if empty, database_directory will be used.
  files_directory: Option<String>,
  /// If set to true, information about downloaded and uploaded files will be saved between application restarts.
  use_file_database: Option<bool>,
  /// If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database.
  use_chat_info_database: Option<bool>,
  /// If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database.
  use_message_database: Option<bool>,
  /// If set to true, support for secret chats will be enabled.
  use_secret_chats: Option<bool>,
  /// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org.
  api_id: Option<i32>,
  /// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org.
  api_hash: Option<String>,
  /// IETF language tag of the user's operating system language; must be non-empty.
  system_language_code: Option<String>,
  /// Model of the device the application is being run on; must be non-empty.
  device_model: Option<String>,
  /// Version of the operating system the application is being run on; must be non-empty.
  system_version: Option<String>,
  /// Application version; must be non-empty.
  application_version: Option<String>,
  /// If set to true, old files will automatically be deleted.
  enable_storage_optimizer: Option<bool>,
  /// If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name.
  ignore_file_names: Option<bool>,


}




impl Object for TdlibParameters {}


impl TdlibParameters {
  
  pub fn builder() -> TdlibParametersBuilder {
    let instance = Self {
      tdfname: "tdlibParameters".to_string(),
      use_test_dc: None,
      database_directory: None,
      files_directory: None,
      use_file_database: None,
      use_chat_info_database: None,
      use_message_database: None,
      use_secret_chats: None,
      api_id: None,
      api_hash: None,
      system_language_code: None,
      device_model: None,
      system_version: None,
      application_version: None,
      enable_storage_optimizer: None,
      ignore_file_names: None,
      
    };
    TdlibParametersBuilder::new(instance)
  }
  
  
  pub fn use_test_dc(&self) -> &Option<bool> { &self.use_test_dc }
  
  pub fn database_directory(&self) -> &Option<String> { &self.database_directory }
  
  pub fn files_directory(&self) -> &Option<String> { &self.files_directory }
  
  pub fn use_file_database(&self) -> &Option<bool> { &self.use_file_database }
  
  pub fn use_chat_info_database(&self) -> &Option<bool> { &self.use_chat_info_database }
  
  pub fn use_message_database(&self) -> &Option<bool> { &self.use_message_database }
  
  pub fn use_secret_chats(&self) -> &Option<bool> { &self.use_secret_chats }
  
  pub fn api_id(&self) -> &Option<i32> { &self.api_id }
  
  pub fn api_hash(&self) -> &Option<String> { &self.api_hash }
  
  pub fn system_language_code(&self) -> &Option<String> { &self.system_language_code }
  
  pub fn device_model(&self) -> &Option<String> { &self.device_model }
  
  pub fn system_version(&self) -> &Option<String> { &self.system_version }
  
  pub fn application_version(&self) -> &Option<String> { &self.application_version }
  
  pub fn enable_storage_optimizer(&self) -> &Option<bool> { &self.enable_storage_optimizer }
  
  pub fn ignore_file_names(&self) -> &Option<bool> { &self.ignore_file_names }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TdlibParametersBuilder {
  instance: TdlibParameters
}

impl TdlibParametersBuilder {
  fn new(instance: TdlibParameters) -> Self { Self { instance } }

  pub fn build(&self) -> TdlibParameters {
    self.instance.clone()
  }
  
  pub fn use_test_dc(&mut self, use_test_dc: bool) -> &mut Self {
    self.instance.use_test_dc = Some(use_test_dc);
    self
  }
  
  pub fn database_directory(&mut self, database_directory: String) -> &mut Self {
    self.instance.database_directory = Some(database_directory);
    self
  }
  
  pub fn files_directory(&mut self, files_directory: String) -> &mut Self {
    self.instance.files_directory = Some(files_directory);
    self
  }
  
  pub fn use_file_database(&mut self, use_file_database: bool) -> &mut Self {
    self.instance.use_file_database = Some(use_file_database);
    self
  }
  
  pub fn use_chat_info_database(&mut self, use_chat_info_database: bool) -> &mut Self {
    self.instance.use_chat_info_database = Some(use_chat_info_database);
    self
  }
  
  pub fn use_message_database(&mut self, use_message_database: bool) -> &mut Self {
    self.instance.use_message_database = Some(use_message_database);
    self
  }
  
  pub fn use_secret_chats(&mut self, use_secret_chats: bool) -> &mut Self {
    self.instance.use_secret_chats = Some(use_secret_chats);
    self
  }
  
  pub fn api_id(&mut self, api_id: i32) -> &mut Self {
    self.instance.api_id = Some(api_id);
    self
  }
  
  pub fn api_hash(&mut self, api_hash: String) -> &mut Self {
    self.instance.api_hash = Some(api_hash);
    self
  }
  
  pub fn system_language_code(&mut self, system_language_code: String) -> &mut Self {
    self.instance.system_language_code = Some(system_language_code);
    self
  }
  
  pub fn device_model(&mut self, device_model: String) -> &mut Self {
    self.instance.device_model = Some(device_model);
    self
  }
  
  pub fn system_version(&mut self, system_version: String) -> &mut Self {
    self.instance.system_version = Some(system_version);
    self
  }
  
  pub fn application_version(&mut self, application_version: String) -> &mut Self {
    self.instance.application_version = Some(application_version);
    self
  }
  
  pub fn enable_storage_optimizer(&mut self, enable_storage_optimizer: bool) -> &mut Self {
    self.instance.enable_storage_optimizer = Some(enable_storage_optimizer);
    self
  }
  
  pub fn ignore_file_names(&mut self, ignore_file_names: bool) -> &mut Self {
    self.instance.ignore_file_names = Some(ignore_file_names);
    self
  }
  
}


/// Returns information about the availability of a temporary password, which can be used for payments. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // temporaryPasswordState

  /// True, if a temporary password is available.
  has_password: Option<bool>,
  /// Time left before the temporary password expires, in seconds.
  valid_for: Option<i32>,


}




impl Object for TemporaryPasswordState {}


impl TemporaryPasswordState {
  
  pub fn builder() -> TemporaryPasswordStateBuilder {
    let instance = Self {
      tdfname: "temporaryPasswordState".to_string(),
      has_password: None,
      valid_for: None,
      
    };
    TemporaryPasswordStateBuilder::new(instance)
  }
  
  
  pub fn has_password(&self) -> &Option<bool> { &self.has_password }
  
  pub fn valid_for(&self) -> &Option<i32> { &self.valid_for }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TemporaryPasswordStateBuilder {
  instance: TemporaryPasswordState
}

impl TemporaryPasswordStateBuilder {
  fn new(instance: TemporaryPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> TemporaryPasswordState {
    self.instance.clone()
  }
  
  pub fn has_password(&mut self, has_password: bool) -> &mut Self {
    self.instance.has_password = Some(has_password);
    self
  }
  
  pub fn valid_for(&mut self, valid_for: i32) -> &mut Self {
    self.instance.valid_for = Some(valid_for);
    self
  }
  
}


/// Contains Telegram terms of service. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // termsOfService

  /// Text of the terms of service.
  text: Option<FormattedText>,
  /// Mininum age of a user to be able to accept the terms; 0 if any.
  min_user_age: Option<i32>,
  /// True, if a blocking popup with terms of service must be shown to the user.
  show_popup: Option<bool>,


}




impl Object for TermsOfService {}


impl TermsOfService {
  
  pub fn builder() -> TermsOfServiceBuilder {
    let instance = Self {
      tdfname: "termsOfService".to_string(),
      text: None,
      min_user_age: None,
      show_popup: None,
      
    };
    TermsOfServiceBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  pub fn min_user_age(&self) -> &Option<i32> { &self.min_user_age }
  
  pub fn show_popup(&self) -> &Option<bool> { &self.show_popup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TermsOfServiceBuilder {
  instance: TermsOfService
}

impl TermsOfServiceBuilder {
  fn new(instance: TermsOfService) -> Self { Self { instance } }

  pub fn build(&self) -> TermsOfService {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn min_user_age(&mut self, min_user_age: i32) -> &mut Self {
    self.instance.min_user_age = Some(min_user_age);
    self
  }
  
  pub fn show_popup(&mut self, show_popup: bool) -> &mut Self {
    self.instance.show_popup = Some(show_popup);
    self
  }
  
}


/// A simple object containing a sequence of bytes; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testBytes

  /// Bytes.
  value: Option<String>,


}




impl Object for TestBytes {}


impl TestBytes {
  
  pub fn builder() -> TestBytesBuilder {
    let instance = Self {
      tdfname: "testBytes".to_string(),
      value: None,
      
    };
    TestBytesBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<String> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestBytesBuilder {
  instance: TestBytes
}

impl TestBytesBuilder {
  fn new(instance: TestBytes) -> Self { Self { instance } }

  pub fn build(&self) -> TestBytes {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: String) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testInt

  /// Number.
  value: Option<i32>,


}




impl Object for TestInt {}


impl TestInt {
  
  pub fn builder() -> TestIntBuilder {
    let instance = Self {
      tdfname: "testInt".to_string(),
      value: None,
      
    };
    TestIntBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<i32> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestIntBuilder {
  instance: TestInt
}

impl TestIntBuilder {
  fn new(instance: TestInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestInt {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: i32) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testString

  /// String.
  value: Option<String>,


}




impl Object for TestString {}


impl TestString {
  
  pub fn builder() -> TestStringBuilder {
    let instance = Self {
      tdfname: "testString".to_string(),
      value: None,
      
    };
    TestStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<String> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestStringBuilder {
  instance: TestString
}

impl TestStringBuilder {
  fn new(instance: TestString) -> Self { Self { instance } }

  pub fn build(&self) -> TestString {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: String) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a vector of numbers; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testVectorInt

  /// Vector of numbers.
  value: Option<Vec<i32>>,


}




impl Object for TestVectorInt {}


impl TestVectorInt {
  
  pub fn builder() -> TestVectorIntBuilder {
    let instance = Self {
      tdfname: "testVectorInt".to_string(),
      value: None,
      
    };
    TestVectorIntBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<Vec<i32>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestVectorIntBuilder {
  instance: TestVectorInt
}

impl TestVectorIntBuilder {
  fn new(instance: TestVectorInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorInt {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: Vec<i32>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a vector of objects that hold a number; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testVectorIntObject

  /// Vector of objects.
  value: Option<Vec<TestInt>>,


}




impl Object for TestVectorIntObject {}


impl TestVectorIntObject {
  
  pub fn builder() -> TestVectorIntObjectBuilder {
    let instance = Self {
      tdfname: "testVectorIntObject".to_string(),
      value: None,
      
    };
    TestVectorIntObjectBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<Vec<TestInt>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestVectorIntObjectBuilder {
  instance: TestVectorIntObject
}

impl TestVectorIntObjectBuilder {
  fn new(instance: TestVectorIntObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorIntObject {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: Vec<TestInt>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a vector of strings; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testVectorString

  /// Vector of strings.
  value: Option<Vec<String>>,


}




impl Object for TestVectorString {}


impl TestVectorString {
  
  pub fn builder() -> TestVectorStringBuilder {
    let instance = Self {
      tdfname: "testVectorString".to_string(),
      value: None,
      
    };
    TestVectorStringBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<Vec<String>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestVectorStringBuilder {
  instance: TestVectorString
}

impl TestVectorStringBuilder {
  fn new(instance: TestVectorString) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorString {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: Vec<String>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// A simple object containing a vector of objects that hold a string; for testing only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testVectorStringObject

  /// Vector of objects.
  value: Option<Vec<TestString>>,


}




impl Object for TestVectorStringObject {}


impl TestVectorStringObject {
  
  pub fn builder() -> TestVectorStringObjectBuilder {
    let instance = Self {
      tdfname: "testVectorStringObject".to_string(),
      value: None,
      
    };
    TestVectorStringObjectBuilder::new(instance)
  }
  
  
  pub fn value(&self) -> &Option<Vec<TestString>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestVectorStringObjectBuilder {
  instance: TestVectorStringObject
}

impl TestVectorStringObjectBuilder {
  fn new(instance: TestVectorStringObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestVectorStringObject {
    self.instance.clone()
  }
  
  pub fn value(&mut self, value: Vec<TestString>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// Contains some text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Text {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // text

  /// Text.
  text: Option<String>,


}




impl Object for Text {}


impl Text {
  
  pub fn builder() -> TextBuilder {
    let instance = Self {
      tdfname: "text".to_string(),
      text: None,
      
    };
    TextBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextBuilder {
  instance: Text
}

impl TextBuilder {
  fn new(instance: Text) -> Self { Self { instance } }

  pub fn build(&self) -> Text {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// Contains a list of text entities. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntities

  /// List of text entities.
  entities: Option<Vec<TextEntity>>,


}




impl Object for TextEntities {}


impl TextEntities {
  
  pub fn builder() -> TextEntitiesBuilder {
    let instance = Self {
      tdfname: "textEntities".to_string(),
      entities: None,
      
    };
    TextEntitiesBuilder::new(instance)
  }
  
  
  pub fn entities(&self) -> &Option<Vec<TextEntity>> { &self.entities }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntitiesBuilder {
  instance: TextEntities
}

impl TextEntitiesBuilder {
  fn new(instance: TextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntities {
    self.instance.clone()
  }
  
  pub fn entities(&mut self, entities: Vec<TextEntity>) -> &mut Self {
    self.instance.entities = Some(entities);
    self
  }
  
}


/// Represents a part of the text that needs to be formatted in some unusual way. 
#[derive(Debug, Serialize, Deserialize)]
pub struct TextEntity {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntity

  /// Offset of the entity in UTF-16 code points.
  offset: Option<i32>,
  /// Length of the entity, in UTF-16 code points.
  length: Option<i32>,
  /// Type of the entity.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<TextEntityType>>,


}


impl Clone for TextEntity {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for TextEntity {}


impl TextEntity {
  
  pub fn builder() -> TextEntityBuilder {
    let instance = Self {
      tdfname: "textEntity".to_string(),
      offset: None,
      length: None,
      type_: None,
      
    };
    TextEntityBuilder::new(instance)
  }
  
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  pub fn type_(&self) -> &Option<Box<TextEntityType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityBuilder {
  instance: TextEntity
}

impl TextEntityBuilder {
  fn new(instance: TextEntity) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntity {
    self.instance.clone()
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
  pub fn type_(&mut self, type_: Box<TextEntityType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// This class is an abstract base class. Represents a part of the text which must be formatted differently. 
#[typetag::serde(tag = "@struct")]
pub trait TextEntityType: Debug {}



impl Object for TextEntityType {}





/// A mention of a user by their username. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMention {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeMention

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeMention {}


impl TextEntityTypeMention {
  
  pub fn builder() -> TextEntityTypeMentionBuilder {
    let instance = Self {
      tdfname: "textEntityTypeMention".to_string(),
      
    };
    TextEntityTypeMentionBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeMentionBuilder {
  instance: TextEntityTypeMention
}

impl TextEntityTypeMentionBuilder {
  fn new(instance: TextEntityTypeMention) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeMention {
    self.instance.clone()
  }
  
}


/// A hashtag text, beginning with "#". 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeHashtag

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeHashtag {}


impl TextEntityTypeHashtag {
  
  pub fn builder() -> TextEntityTypeHashtagBuilder {
    let instance = Self {
      tdfname: "textEntityTypeHashtag".to_string(),
      
    };
    TextEntityTypeHashtagBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeHashtagBuilder {
  instance: TextEntityTypeHashtag
}

impl TextEntityTypeHashtagBuilder {
  fn new(instance: TextEntityTypeHashtag) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeHashtag {
    self.instance.clone()
  }
  
}


/// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD"). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeCashtag

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeCashtag {}


impl TextEntityTypeCashtag {
  
  pub fn builder() -> TextEntityTypeCashtagBuilder {
    let instance = Self {
      tdfname: "textEntityTypeCashtag".to_string(),
      
    };
    TextEntityTypeCashtagBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeCashtagBuilder {
  instance: TextEntityTypeCashtag
}

impl TextEntityTypeCashtagBuilder {
  fn new(instance: TextEntityTypeCashtag) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeCashtag {
    self.instance.clone()
  }
  
}


/// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBotCommand {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeBotCommand

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeBotCommand {}


impl TextEntityTypeBotCommand {
  
  pub fn builder() -> TextEntityTypeBotCommandBuilder {
    let instance = Self {
      tdfname: "textEntityTypeBotCommand".to_string(),
      
    };
    TextEntityTypeBotCommandBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeBotCommandBuilder {
  instance: TextEntityTypeBotCommand
}

impl TextEntityTypeBotCommandBuilder {
  fn new(instance: TextEntityTypeBotCommand) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeBotCommand {
    self.instance.clone()
  }
  
}


/// An HTTP URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeUrl

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeUrl {}


impl TextEntityTypeUrl {
  
  pub fn builder() -> TextEntityTypeUrlBuilder {
    let instance = Self {
      tdfname: "textEntityTypeUrl".to_string(),
      
    };
    TextEntityTypeUrlBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeUrlBuilder {
  instance: TextEntityTypeUrl
}

impl TextEntityTypeUrlBuilder {
  fn new(instance: TextEntityTypeUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeUrl {
    self.instance.clone()
  }
  
}


/// An email address. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeEmailAddress

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeEmailAddress {}


impl TextEntityTypeEmailAddress {
  
  pub fn builder() -> TextEntityTypeEmailAddressBuilder {
    let instance = Self {
      tdfname: "textEntityTypeEmailAddress".to_string(),
      
    };
    TextEntityTypeEmailAddressBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeEmailAddressBuilder {
  instance: TextEntityTypeEmailAddress
}

impl TextEntityTypeEmailAddressBuilder {
  fn new(instance: TextEntityTypeEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeEmailAddress {
    self.instance.clone()
  }
  
}


/// A bold text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeBold {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeBold

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeBold {}


impl TextEntityTypeBold {
  
  pub fn builder() -> TextEntityTypeBoldBuilder {
    let instance = Self {
      tdfname: "textEntityTypeBold".to_string(),
      
    };
    TextEntityTypeBoldBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeBoldBuilder {
  instance: TextEntityTypeBold
}

impl TextEntityTypeBoldBuilder {
  fn new(instance: TextEntityTypeBold) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeBold {
    self.instance.clone()
  }
  
}


/// An italic text. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeItalic {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeItalic

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeItalic {}


impl TextEntityTypeItalic {
  
  pub fn builder() -> TextEntityTypeItalicBuilder {
    let instance = Self {
      tdfname: "textEntityTypeItalic".to_string(),
      
    };
    TextEntityTypeItalicBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeItalicBuilder {
  instance: TextEntityTypeItalic
}

impl TextEntityTypeItalicBuilder {
  fn new(instance: TextEntityTypeItalic) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeItalic {
    self.instance.clone()
  }
  
}


/// Text that must be formatted as if inside a code HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeCode

}



#[typetag::serde]
impl TextEntityType for TextEntityTypeCode {}


impl TextEntityTypeCode {
  
  pub fn builder() -> TextEntityTypeCodeBuilder {
    let instance = Self {
      tdfname: "textEntityTypeCode".to_string(),
      
    };
    TextEntityTypeCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeCodeBuilder {
  instance: TextEntityTypeCode
}

impl TextEntityTypeCodeBuilder {
  fn new(instance: TextEntityTypeCode) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeCode {
    self.instance.clone()
  }
  
}


/// Text that must be formatted as if inside a pre HTML tag. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePre {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypePre

}



#[typetag::serde]
impl TextEntityType for TextEntityTypePre {}


impl TextEntityTypePre {
  
  pub fn builder() -> TextEntityTypePreBuilder {
    let instance = Self {
      tdfname: "textEntityTypePre".to_string(),
      
    };
    TextEntityTypePreBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypePreBuilder {
  instance: TextEntityTypePre
}

impl TextEntityTypePreBuilder {
  fn new(instance: TextEntityTypePre) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePre {
    self.instance.clone()
  }
  
}


/// Text that must be formatted as if inside pre, and code HTML tags. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePreCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypePreCode

  /// Programming language of the code; as defined by the sender.
  language: Option<String>,


}



#[typetag::serde]
impl TextEntityType for TextEntityTypePreCode {}


impl TextEntityTypePreCode {
  
  pub fn builder() -> TextEntityTypePreCodeBuilder {
    let instance = Self {
      tdfname: "textEntityTypePreCode".to_string(),
      language: None,
      
    };
    TextEntityTypePreCodeBuilder::new(instance)
  }
  
  
  pub fn language(&self) -> &Option<String> { &self.language }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypePreCodeBuilder {
  instance: TextEntityTypePreCode
}

impl TextEntityTypePreCodeBuilder {
  fn new(instance: TextEntityTypePreCode) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePreCode {
    self.instance.clone()
  }
  
  pub fn language(&mut self, language: String) -> &mut Self {
    self.instance.language = Some(language);
    self
  }
  
}


/// A text description shown instead of a raw URL. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeTextUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeTextUrl

  /// HTTP or tg:// URL to be opened when the link is clicked.
  url: Option<String>,


}



#[typetag::serde]
impl TextEntityType for TextEntityTypeTextUrl {}


impl TextEntityTypeTextUrl {
  
  pub fn builder() -> TextEntityTypeTextUrlBuilder {
    let instance = Self {
      tdfname: "textEntityTypeTextUrl".to_string(),
      url: None,
      
    };
    TextEntityTypeTextUrlBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeTextUrlBuilder {
  instance: TextEntityTypeTextUrl
}

impl TextEntityTypeTextUrlBuilder {
  fn new(instance: TextEntityTypeTextUrl) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeTextUrl {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
}


/// A text shows instead of a raw mention of the user (e.g., when the user has no username). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypeMentionName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypeMentionName

  /// Identifier of the mentioned user.
  user_id: Option<i32>,


}



#[typetag::serde]
impl TextEntityType for TextEntityTypeMentionName {}


impl TextEntityTypeMentionName {
  
  pub fn builder() -> TextEntityTypeMentionNameBuilder {
    let instance = Self {
      tdfname: "textEntityTypeMentionName".to_string(),
      user_id: None,
      
    };
    TextEntityTypeMentionNameBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypeMentionNameBuilder {
  instance: TextEntityTypeMentionName
}

impl TextEntityTypeMentionNameBuilder {
  fn new(instance: TextEntityTypeMentionName) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypeMentionName {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// A phone number. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEntityTypePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textEntityTypePhoneNumber

}



#[typetag::serde]
impl TextEntityType for TextEntityTypePhoneNumber {}


impl TextEntityTypePhoneNumber {
  
  pub fn builder() -> TextEntityTypePhoneNumberBuilder {
    let instance = Self {
      tdfname: "textEntityTypePhoneNumber".to_string(),
      
    };
    TextEntityTypePhoneNumberBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextEntityTypePhoneNumberBuilder {
  instance: TextEntityTypePhoneNumber
}

impl TextEntityTypePhoneNumberBuilder {
  fn new(instance: TextEntityTypePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> TextEntityTypePhoneNumber {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Describes the way the text should be parsed for TextEntities. 
#[typetag::serde(tag = "@struct")]
pub trait TextParseMode: Debug {}



impl Object for TextParseMode {}





/// The text should be parsed in markdown-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeMarkdown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textParseModeMarkdown

}



#[typetag::serde]
impl TextParseMode for TextParseModeMarkdown {}


impl TextParseModeMarkdown {
  
  pub fn builder() -> TextParseModeMarkdownBuilder {
    let instance = Self {
      tdfname: "textParseModeMarkdown".to_string(),
      
    };
    TextParseModeMarkdownBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextParseModeMarkdownBuilder {
  instance: TextParseModeMarkdown
}

impl TextParseModeMarkdownBuilder {
  fn new(instance: TextParseModeMarkdown) -> Self { Self { instance } }

  pub fn build(&self) -> TextParseModeMarkdown {
    self.instance.clone()
  }
  
}


/// The text should be parsed in HTML-style. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextParseModeHTML {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // textParseModeHTML

}



#[typetag::serde]
impl TextParseMode for TextParseModeHTML {}


impl TextParseModeHTML {
  
  pub fn builder() -> TextParseModeHTMLBuilder {
    let instance = Self {
      tdfname: "textParseModeHTML".to_string(),
      
    };
    TextParseModeHTMLBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TextParseModeHTMLBuilder {
  instance: TextParseModeHTML
}

impl TextParseModeHTMLBuilder {
  fn new(instance: TextParseModeHTML) -> Self { Self { instance } }

  pub fn build(&self) -> TextParseModeHTML {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Represents the categories of chats for which a list of frequently used chats can be retrieved. 
#[typetag::serde(tag = "@struct")]
pub trait TopChatCategory: Debug {}



impl Object for TopChatCategory {}





/// A category containing frequently used private chats with non-bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryUsers

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryUsers {}


impl TopChatCategoryUsers {
  
  pub fn builder() -> TopChatCategoryUsersBuilder {
    let instance = Self {
      tdfname: "topChatCategoryUsers".to_string(),
      
    };
    TopChatCategoryUsersBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryUsersBuilder {
  instance: TopChatCategoryUsers
}

impl TopChatCategoryUsersBuilder {
  fn new(instance: TopChatCategoryUsers) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryUsers {
    self.instance.clone()
  }
  
}


/// A category containing frequently used private chats with bot users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryBots

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryBots {}


impl TopChatCategoryBots {
  
  pub fn builder() -> TopChatCategoryBotsBuilder {
    let instance = Self {
      tdfname: "topChatCategoryBots".to_string(),
      
    };
    TopChatCategoryBotsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryBotsBuilder {
  instance: TopChatCategoryBots
}

impl TopChatCategoryBotsBuilder {
  fn new(instance: TopChatCategoryBots) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryBots {
    self.instance.clone()
  }
  
}


/// A category containing frequently used basic groups and supergroups. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryGroups {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryGroups

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryGroups {}


impl TopChatCategoryGroups {
  
  pub fn builder() -> TopChatCategoryGroupsBuilder {
    let instance = Self {
      tdfname: "topChatCategoryGroups".to_string(),
      
    };
    TopChatCategoryGroupsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryGroupsBuilder {
  instance: TopChatCategoryGroups
}

impl TopChatCategoryGroupsBuilder {
  fn new(instance: TopChatCategoryGroups) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryGroups {
    self.instance.clone()
  }
  
}


/// A category containing frequently used channels. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryChannels {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryChannels

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryChannels {}


impl TopChatCategoryChannels {
  
  pub fn builder() -> TopChatCategoryChannelsBuilder {
    let instance = Self {
      tdfname: "topChatCategoryChannels".to_string(),
      
    };
    TopChatCategoryChannelsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryChannelsBuilder {
  instance: TopChatCategoryChannels
}

impl TopChatCategoryChannelsBuilder {
  fn new(instance: TopChatCategoryChannels) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryChannels {
    self.instance.clone()
  }
  
}


/// A category containing frequently used chats with inline bots sorted by their usage in inline mode. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryInlineBots

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryInlineBots {}


impl TopChatCategoryInlineBots {
  
  pub fn builder() -> TopChatCategoryInlineBotsBuilder {
    let instance = Self {
      tdfname: "topChatCategoryInlineBots".to_string(),
      
    };
    TopChatCategoryInlineBotsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryInlineBotsBuilder {
  instance: TopChatCategoryInlineBots
}

impl TopChatCategoryInlineBotsBuilder {
  fn new(instance: TopChatCategoryInlineBots) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryInlineBots {
    self.instance.clone()
  }
  
}


/// A category containing frequently used chats used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TopChatCategoryCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // topChatCategoryCalls

}



#[typetag::serde]
impl TopChatCategory for TopChatCategoryCalls {}


impl TopChatCategoryCalls {
  
  pub fn builder() -> TopChatCategoryCallsBuilder {
    let instance = Self {
      tdfname: "topChatCategoryCalls".to_string(),
      
    };
    TopChatCategoryCallsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TopChatCategoryCallsBuilder {
  instance: TopChatCategoryCalls
}

impl TopChatCategoryCallsBuilder {
  fn new(instance: TopChatCategoryCalls) -> Self { Self { instance } }

  pub fn build(&self) -> TopChatCategoryCalls {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Contains notifications about data changes. 
#[typetag::serde(tag = "@struct")]
pub trait Update: Debug {}



impl Object for Update {}





/// The user authorization state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateAuthorizationState

  /// New authorization state.
  authorization_state: Option<Box<AuthorizationState>>,


}


impl Clone for UpdateAuthorizationState {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateAuthorizationState {}


impl UpdateAuthorizationState {
  
  
  pub fn authorization_state(&self) -> &Option<Box<AuthorizationState>> { &self.authorization_state }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new message was received; can also be an outgoing message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewMessage

  /// The new message.
  message: Option<Message>,


}



#[typetag::serde]
impl Update for UpdateNewMessage {}


impl UpdateNewMessage {
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendAcknowledged {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageSendAcknowledged

  /// The chat identifier of the sent message.
  chat_id: Option<i64>,
  /// A temporary message identifier.
  message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateMessageSendAcknowledged {}


impl UpdateMessageSendAcknowledged {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A message has been successfully sent. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendSucceeded {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageSendSucceeded

  /// Information about the sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateMessageSendSucceeded {}


impl UpdateMessageSendSucceeded {
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  pub fn old_message_id(&self) -> &Option<i64> { &self.old_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageSendFailed {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageSendFailed

  /// Contains information about the message that failed to send.
  message: Option<Message>,
  /// The previous temporary message identifier.
  old_message_id: Option<i64>,
  /// An error code.
  error_code: Option<i32>,
  /// Error message.
  error_message: Option<String>,


}



#[typetag::serde]
impl Update for UpdateMessageSendFailed {}


impl UpdateMessageSendFailed {
  
  
  pub fn message(&self) -> &Option<Message> { &self.message }
  
  pub fn old_message_id(&self) -> &Option<i64> { &self.old_message_id }
  
  pub fn error_code(&self) -> &Option<i32> { &self.error_code }
  
  pub fn error_message(&self) -> &Option<String> { &self.error_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The message content has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageContent

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New message content.
  new_content: Option<Box<MessageContent>>,


}


impl Clone for UpdateMessageContent {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateMessageContent {}


impl UpdateMessageContent {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn new_content(&self) -> &Option<Box<MessageContent>> { &self.new_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A message was edited. Changes in the message content will come in a separate 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateMessageEdited {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageEdited

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Point in time (Unix timestamp) when the message was edited.
  edit_date: Option<i32>,
  /// New message reply markup; may be null.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for UpdateMessageEdited {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateMessageEdited {}


impl UpdateMessageEdited {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn edit_date(&self) -> &Option<i32> { &self.edit_date }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The view count of the message has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageViews {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageViews

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// New value of the view count.
  views: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateMessageViews {}


impl UpdateMessageViews {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn views(&self) -> &Option<i32> { &self.views }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageContentOpened {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageContentOpened

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateMessageContentOpened {}


impl UpdateMessageContentOpened {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A message with an unread mention was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMessageMentionRead {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateMessageMentionRead

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The new number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateMessageMentionRead {}


impl UpdateMessageMentionRead {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn unread_mention_count(&self) -> &Option<i32> { &self.unread_mention_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the client. The chat field changes will be reported through separate updates. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewChat

  /// The chat.
  chat: Option<Chat>,


}



#[typetag::serde]
impl Update for UpdateNewChat {}


impl UpdateNewChat {
  
  
  pub fn chat(&self) -> &Option<Chat> { &self.chat }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The title of a chat was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatTitle

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat title.
  title: Option<String>,


}



#[typetag::serde]
impl Update for UpdateChatTitle {}


impl UpdateChatTitle {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A chat photo was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatPhoto

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new chat photo; may be null.
  photo: Option<ChatPhoto>,


}



#[typetag::serde]
impl Update for UpdateChatPhoto {}


impl UpdateChatPhoto {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn photo(&self) -> &Option<ChatPhoto> { &self.photo }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The last message of a chat was changed. If last_message is null then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatLastMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatLastMessage

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new last message in the chat; may be null.
  last_message: Option<Message>,
  /// New value of the chat order.
  order: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatLastMessage {}


impl UpdateChatLastMessage {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn last_message(&self) -> &Option<Message> { &self.last_message }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The order of the chat in the chat list has changed. Instead of this update 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOrder {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatOrder

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of the order.
  order: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatOrder {}


impl UpdateChatOrder {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A chat was pinned or unpinned. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatIsPinned

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,
  /// New value of the chat order.
  order: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatIsPinned {}


impl UpdateChatIsPinned {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A chat was marked as unread or was read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatIsMarkedAsUnread

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,


}



#[typetag::serde]
impl Update for UpdateChatIsMarkedAsUnread {}


impl UpdateChatIsMarkedAsUnread {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_marked_as_unread(&self) -> &Option<bool> { &self.is_marked_as_unread }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A chat's is_sponsored field has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatIsSponsored {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatIsSponsored

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_sponsored.
  is_sponsored: Option<bool>,
  /// New value of chat order.
  order: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatIsSponsored {}


impl UpdateChatIsSponsored {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_sponsored(&self) -> &Option<bool> { &self.is_sponsored }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatDefaultDisableNotification

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new default_disable_notification value.
  default_disable_notification: Option<bool>,


}



#[typetag::serde]
impl Update for UpdateChatDefaultDisableNotification {}


impl UpdateChatDefaultDisableNotification {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn default_disable_notification(&self) -> &Option<bool> { &self.default_disable_notification }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Incoming messages were read or number of unread messages has been changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadInbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatReadInbox

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the last read incoming message.
  last_read_inbox_message_id: Option<i64>,
  /// The number of unread messages left in the chat.
  unread_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateChatReadInbox {}


impl UpdateChatReadInbox {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn last_read_inbox_message_id(&self) -> &Option<i64> { &self.last_read_inbox_message_id }
  
  pub fn unread_count(&self) -> &Option<i32> { &self.unread_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Outgoing messages were read. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReadOutbox {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatReadOutbox

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of last read outgoing message.
  last_read_outbox_message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatReadOutbox {}


impl UpdateChatReadOutbox {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn last_read_outbox_message_id(&self) -> &Option<i64> { &self.last_read_outbox_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The chat unread_mention_count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatUnreadMentionCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatUnreadMentionCount

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The number of unread mention messages left in the chat.
  unread_mention_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateChatUnreadMentionCount {}


impl UpdateChatUnreadMentionCount {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn unread_mention_count(&self) -> &Option<i32> { &self.unread_mention_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Notification settings for a chat were changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatNotificationSettings

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new notification settings.
  notification_settings: Option<ChatNotificationSettings>,


}



#[typetag::serde]
impl Update for UpdateChatNotificationSettings {}


impl UpdateChatNotificationSettings {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn notification_settings(&self) -> &Option<ChatNotificationSettings> { &self.notification_settings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Notification settings for some type of chats were updated. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateScopeNotificationSettings

  /// Types of chats for which notification settings were updated.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings.
  notification_settings: Option<ScopeNotificationSettings>,


}


impl Clone for UpdateScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateScopeNotificationSettings {}


impl UpdateScopeNotificationSettings {
  
  
  pub fn scope(&self) -> &Option<Box<NotificationSettingsScope>> { &self.scope }
  
  pub fn notification_settings(&self) -> &Option<ScopeNotificationSettings> { &self.notification_settings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The chat pinned message was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatPinnedMessage

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new identifier of the pinned message; 0 if there is no pinned message in the chat.
  pinned_message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatPinnedMessage {}


impl UpdateChatPinnedMessage {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn pinned_message_id(&self) -> &Option<i64> { &self.pinned_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatReplyMarkup

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat.
  reply_markup_message_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatReplyMarkup {}


impl UpdateChatReplyMarkup {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn reply_markup_message_id(&self) -> &Option<i64> { &self.reply_markup_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatDraftMessage

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The new draft message; may be null.
  draft_message: Option<DraftMessage>,
  /// New value of the chat order.
  order: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateChatDraftMessage {}


impl UpdateChatDraftMessage {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn draft_message(&self) -> &Option<DraftMessage> { &self.draft_message }
  
  pub fn order(&self) -> &Option<i64> { &self.order }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateChatOnlineMemberCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateChatOnlineMemberCount

  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// New number of online members in the chat, or 0 if unknown.
  online_member_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateChatOnlineMemberCount {}


impl UpdateChatOnlineMemberCount {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn online_member_count(&self) -> &Option<i32> { &self.online_member_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A notification was changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNotification

  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// Changed notification.
  notification: Option<Notification>,


}



#[typetag::serde]
impl Update for UpdateNotification {}


impl UpdateNotification {
  
  
  pub fn notification_group_id(&self) -> &Option<i32> { &self.notification_group_id }
  
  pub fn notification(&self) -> &Option<Notification> { &self.notification }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A list of active notifications in a notification group has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNotificationGroup

  /// Unique notification group identifier.
  notification_group_id: Option<i32>,
  /// New type of the notification group.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NotificationGroupType>>,
  /// Identifier of a chat to which all notifications in the group belong.
  chat_id: Option<i64>,
  /// Chat identifier, which notification settings must be applied to the added notifications.
  notification_settings_chat_id: Option<i64>,
  /// True, if the notifications should be shown without sound.
  is_silent: Option<bool>,
  /// Total number of unread notifications in the group, can be bigger than number of active notifications.
  total_count: Option<i32>,
  /// List of added group notifications, sorted by notification ID.
  added_notifications: Option<Vec<Notification>>,
  /// Identifiers of removed group notifications, sorted by notification ID.
  removed_notification_ids: Option<Vec<i32>>,


}


impl Clone for UpdateNotificationGroup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateNotificationGroup {}


impl UpdateNotificationGroup {
  
  
  pub fn notification_group_id(&self) -> &Option<i32> { &self.notification_group_id }
  
  pub fn type_(&self) -> &Option<Box<NotificationGroupType>> { &self.type_ }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn notification_settings_chat_id(&self) -> &Option<i64> { &self.notification_settings_chat_id }
  
  pub fn is_silent(&self) -> &Option<bool> { &self.is_silent }
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn added_notifications(&self) -> &Option<Vec<Notification>> { &self.added_notifications }
  
  pub fn removed_notification_ids(&self) -> &Option<Vec<i32>> { &self.removed_notification_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Contains active notifications that was shown on previous application launches. This update is sent only if a message database is used. In that case it comes once before any 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateActiveNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateActiveNotifications

  /// Lists of active notification groups.
  groups: Option<Vec<NotificationGroup>>,


}



#[typetag::serde]
impl Update for UpdateActiveNotifications {}


impl UpdateActiveNotifications {
  
  
  pub fn groups(&self) -> &Option<Vec<NotificationGroup>> { &self.groups }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Describes, whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateHavePendingNotifications {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateHavePendingNotifications

  /// True, if there are some delayed notification updates, which will be sent soon.
  have_delayed_notifications: Option<bool>,
  /// True, if there can be some yet unreceived notifications, which are being fetched from the server.
  have_unreceived_notifications: Option<bool>,


}



#[typetag::serde]
impl Update for UpdateHavePendingNotifications {}


impl UpdateHavePendingNotifications {
  
  
  pub fn have_delayed_notifications(&self) -> &Option<bool> { &self.have_delayed_notifications }
  
  pub fn have_unreceived_notifications(&self) -> &Option<bool> { &self.have_unreceived_notifications }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some messages were deleted. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateDeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateDeleteMessages

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the deleted messages.
  message_ids: Option<Vec<i64>>,
  /// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible).
  is_permanent: Option<bool>,
  /// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future.
  from_cache: Option<bool>,


}



#[typetag::serde]
impl Update for UpdateDeleteMessages {}


impl UpdateDeleteMessages {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  pub fn is_permanent(&self) -> &Option<bool> { &self.is_permanent }
  
  pub fn from_cache(&self) -> &Option<bool> { &self.from_cache }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// User activity in the chat has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUserChatAction

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of a user performing an action.
  user_id: Option<i32>,
  /// The action description.
  action: Option<Box<ChatAction>>,


}


impl Clone for UpdateUserChatAction {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateUserChatAction {}


impl UpdateUserChatAction {
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn action(&self) -> &Option<Box<ChatAction>> { &self.action }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The user went online or offline. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUserStatus

  /// User identifier.
  user_id: Option<i32>,
  /// New status of the user.
  status: Option<Box<UserStatus>>,


}


impl Clone for UpdateUserStatus {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateUserStatus {}


impl UpdateUserStatus {
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn status(&self) -> &Option<Box<UserStatus>> { &self.status }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUser

  /// New data about the user.
  user: Option<User>,


}



#[typetag::serde]
impl Update for UpdateUser {}


impl UpdateUser {
  
  
  pub fn user(&self) -> &Option<User> { &self.user }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateBasicGroup

  /// New data about the group.
  basic_group: Option<BasicGroup>,


}



#[typetag::serde]
impl Update for UpdateBasicGroup {}


impl UpdateBasicGroup {
  
  
  pub fn basic_group(&self) -> &Option<BasicGroup> { &self.basic_group }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateSupergroup

  /// New data about the supergroup.
  supergroup: Option<Supergroup>,


}



#[typetag::serde]
impl Update for UpdateSupergroup {}


impl UpdateSupergroup {
  
  
  pub fn supergroup(&self) -> &Option<Supergroup> { &self.supergroup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateSecretChat

  /// New data about the secret chat.
  secret_chat: Option<SecretChat>,


}



#[typetag::serde]
impl Update for UpdateSecretChat {}


impl UpdateSecretChat {
  
  
  pub fn secret_chat(&self) -> &Option<SecretChat> { &self.secret_chat }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUserFullInfo

  /// User identifier.
  user_id: Option<i32>,
  /// New full information about the user.
  user_full_info: Option<UserFullInfo>,


}



#[typetag::serde]
impl Update for UpdateUserFullInfo {}


impl UpdateUserFullInfo {
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn user_full_info(&self) -> &Option<UserFullInfo> { &self.user_full_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateBasicGroupFullInfo

  /// Identifier of a basic group.
  basic_group_id: Option<i32>,
  /// New full information about the group.
  basic_group_full_info: Option<BasicGroupFullInfo>,


}



#[typetag::serde]
impl Update for UpdateBasicGroupFullInfo {}


impl UpdateBasicGroupFullInfo {
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  pub fn basic_group_full_info(&self) -> &Option<BasicGroupFullInfo> { &self.basic_group_full_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some data from 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateSupergroupFullInfo

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New full information about the supergroup.
  supergroup_full_info: Option<SupergroupFullInfo>,


}



#[typetag::serde]
impl Update for UpdateSupergroupFullInfo {}


impl UpdateSupergroupFullInfo {
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn supergroup_full_info(&self) -> &Option<SupergroupFullInfo> { &self.supergroup_full_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Service notification from the server. Upon receiving this the client must show a popup with the content of the notification. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateServiceNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateServiceNotification

  /// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" should be shown under notification; if user presses the second, all local data should be destroyed using Destroy method.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Notification content.
  content: Option<Box<MessageContent>>,


}


impl Clone for UpdateServiceNotification {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateServiceNotification {}


impl UpdateServiceNotification {
  
  
  pub fn type_(&self) -> &Option<String> { &self.type_ }
  
  pub fn content(&self) -> &Option<Box<MessageContent>> { &self.content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Information about a file was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateFile

  /// New data about the file.
  file: Option<File>,


}



#[typetag::serde]
impl Update for UpdateFile {}


impl UpdateFile {
  
  
  pub fn file(&self) -> &Option<File> { &self.file }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The file generation process needs to be started by the client. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateFileGenerationStart

  /// Unique identifier for the generation process.
  generation_id: Option<i64>,
  /// The path to a file from which a new file is generated; may be empty.
  original_path: Option<String>,
  /// The path to a file that should be created and where the new file should be generated.
  destination_path: Option<String>,
  /// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which should be downloaded by the client.
  conversion: Option<String>,


}



#[typetag::serde]
impl Update for UpdateFileGenerationStart {}


impl UpdateFileGenerationStart {
  
  
  pub fn generation_id(&self) -> &Option<i64> { &self.generation_id }
  
  pub fn original_path(&self) -> &Option<String> { &self.original_path }
  
  pub fn destination_path(&self) -> &Option<String> { &self.destination_path }
  
  pub fn conversion(&self) -> &Option<String> { &self.conversion }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// File generation is no longer needed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFileGenerationStop {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateFileGenerationStop

  /// Unique identifier for the generation process.
  generation_id: Option<i64>,


}



#[typetag::serde]
impl Update for UpdateFileGenerationStop {}


impl UpdateFileGenerationStop {
  
  
  pub fn generation_id(&self) -> &Option<i64> { &self.generation_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// New call was created or information about a call was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateCall

  /// New data about a call.
  call: Option<Call>,


}



#[typetag::serde]
impl Update for UpdateCall {}


impl UpdateCall {
  
  
  pub fn call(&self) -> &Option<Call> { &self.call }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some privacy setting rules have been changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUserPrivacySettingRules

  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// New privacy rules.
  rules: Option<UserPrivacySettingRules>,


}


impl Clone for UpdateUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateUserPrivacySettingRules {}


impl UpdateUserPrivacySettingRules {
  
  
  pub fn setting(&self) -> &Option<Box<UserPrivacySetting>> { &self.setting }
  
  pub fn rules(&self) -> &Option<UserPrivacySettingRules> { &self.rules }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Number of unread messages has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUnreadMessageCount

  /// Total number of unread messages.
  unread_count: Option<i32>,
  /// Total number of unread messages in unmuted chats.
  unread_unmuted_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateUnreadMessageCount {}


impl UpdateUnreadMessageCount {
  
  
  pub fn unread_count(&self) -> &Option<i32> { &self.unread_count }
  
  pub fn unread_unmuted_count(&self) -> &Option<i32> { &self.unread_unmuted_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if a message database is used. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateUnreadChatCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateUnreadChatCount

  /// Total number of unread chats.
  unread_count: Option<i32>,
  /// Total number of unread unmuted chats.
  unread_unmuted_count: Option<i32>,
  /// Total number of chats marked as unread.
  marked_as_unread_count: Option<i32>,
  /// Total number of unmuted chats marked as unread.
  marked_as_unread_unmuted_count: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateUnreadChatCount {}


impl UpdateUnreadChatCount {
  
  
  pub fn unread_count(&self) -> &Option<i32> { &self.unread_count }
  
  pub fn unread_unmuted_count(&self) -> &Option<i32> { &self.unread_unmuted_count }
  
  pub fn marked_as_unread_count(&self) -> &Option<i32> { &self.marked_as_unread_count }
  
  pub fn marked_as_unread_unmuted_count(&self) -> &Option<i32> { &self.marked_as_unread_unmuted_count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// An option changed its value. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateOption

  /// The option name.
  name: Option<String>,
  /// The new option value.
  value: Option<Box<OptionValue>>,


}


impl Clone for UpdateOption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateOption {}


impl UpdateOption {
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn value(&self) -> &Option<Box<OptionValue>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The list of installed sticker sets was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateInstalledStickerSets

  /// True, if the list of installed mask sticker sets was updated.
  is_masks: Option<bool>,
  /// The new list of installed ordinary sticker sets.
  sticker_set_ids: Option<Vec<i64>>,


}



#[typetag::serde]
impl Update for UpdateInstalledStickerSets {}


impl UpdateInstalledStickerSets {
  
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn sticker_set_ids(&self) -> &Option<Vec<i64>> { &self.sticker_set_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The list of trending sticker sets was updated or some of them were viewed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateTrendingStickerSets

  /// The new list of trending sticker sets.
  sticker_sets: Option<StickerSets>,


}



#[typetag::serde]
impl Update for UpdateTrendingStickerSets {}


impl UpdateTrendingStickerSets {
  
  
  pub fn sticker_sets(&self) -> &Option<StickerSets> { &self.sticker_sets }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The list of recently used stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateRecentStickers

  /// True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated.
  is_attached: Option<bool>,
  /// The new list of file identifiers of recently used stickers.
  sticker_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl Update for UpdateRecentStickers {}


impl UpdateRecentStickers {
  
  
  pub fn is_attached(&self) -> &Option<bool> { &self.is_attached }
  
  pub fn sticker_ids(&self) -> &Option<Vec<i32>> { &self.sticker_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The list of favorite stickers was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateFavoriteStickers

  /// The new list of file identifiers of favorite stickers.
  sticker_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl Update for UpdateFavoriteStickers {}


impl UpdateFavoriteStickers {
  
  
  pub fn sticker_ids(&self) -> &Option<Vec<i32>> { &self.sticker_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The list of saved animations was updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateSavedAnimations

  /// The new list of file identifiers of saved animations.
  animation_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl Update for UpdateSavedAnimations {}


impl UpdateSavedAnimations {
  
  
  pub fn animation_ids(&self) -> &Option<Vec<i32>> { &self.animation_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Some language pack strings have been updated. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateLanguagePackStrings

  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Identifier of the updated language pack.
  language_pack_id: Option<String>,
  /// List of changed language pack strings.
  strings: Option<Vec<LanguagePackString>>,


}



#[typetag::serde]
impl Update for UpdateLanguagePackStrings {}


impl UpdateLanguagePackStrings {
  
  
  pub fn localization_target(&self) -> &Option<String> { &self.localization_target }
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  pub fn strings(&self) -> &Option<Vec<LanguagePackString>> { &self.strings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The connection state has changed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateConnectionState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateConnectionState

  /// The new connection state.
  state: Option<Box<ConnectionState>>,


}


impl Clone for UpdateConnectionState {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateConnectionState {}


impl UpdateConnectionState {
  
  
  pub fn state(&self) -> &Option<Box<ConnectionState>> { &self.state }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// New terms of service must be accepted by the user. If the terms of service are declined, then the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateTermsOfService

  /// Identifier of the terms of service.
  terms_of_service_id: Option<String>,
  /// The new terms of service.
  terms_of_service: Option<TermsOfService>,


}



#[typetag::serde]
impl Update for UpdateTermsOfService {}


impl UpdateTermsOfService {
  
  
  pub fn terms_of_service_id(&self) -> &Option<String> { &self.terms_of_service_id }
  
  pub fn terms_of_service(&self) -> &Option<TermsOfService> { &self.terms_of_service }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewInlineQuery

  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,


}



#[typetag::serde]
impl Update for UpdateNewInlineQuery {}


impl UpdateNewInlineQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn user_location(&self) -> &Option<Location> { &self.user_location }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn offset(&self) -> &Option<String> { &self.offset }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// The user has chosen a result of an inline query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewChosenInlineResult {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewChosenInlineResult

  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// User location, provided by the client; may be null.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Identifier of the chosen result.
  result_id: Option<String>,
  /// Identifier of the sent inline message, if known.
  inline_message_id: Option<String>,


}



#[typetag::serde]
impl Update for UpdateNewChosenInlineResult {}


impl UpdateNewChosenInlineResult {
  
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn user_location(&self) -> &Option<Location> { &self.user_location }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn result_id(&self) -> &Option<String> { &self.result_id }
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming callback query; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewCallbackQuery

  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the chat, in which the query was sent.
  chat_id: Option<i64>,
  /// Identifier of the message, from which the query originated.
  message_id: Option<i64>,
  /// Identifier that uniquely corresponds to the chat to which the message was sent.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,


}


impl Clone for UpdateNewCallbackQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateNewCallbackQuery {}


impl UpdateNewCallbackQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn chat_instance(&self) -> &Option<i64> { &self.chat_instance }
  
  pub fn payload(&self) -> &Option<Box<CallbackQueryPayload>> { &self.payload }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming callback query from a message sent via a bot; for bots only. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UpdateNewInlineCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewInlineCallbackQuery

  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Identifier of the inline message, from which the query originated.
  inline_message_id: Option<String>,
  /// An identifier uniquely corresponding to the chat a message was sent to.
  chat_instance: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,


}


impl Clone for UpdateNewInlineCallbackQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}


#[typetag::serde]
impl Update for UpdateNewInlineCallbackQuery {}


impl UpdateNewInlineCallbackQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn chat_instance(&self) -> &Option<i64> { &self.chat_instance }
  
  pub fn payload(&self) -> &Option<Box<CallbackQueryPayload>> { &self.payload }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming shipping query; for bots only. Only for invoices with flexible price. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewShippingQuery

  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// User shipping address.
  shipping_address: Option<Address>,


}



#[typetag::serde]
impl Update for UpdateNewShippingQuery {}


impl UpdateNewShippingQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn invoice_payload(&self) -> &Option<String> { &self.invoice_payload }
  
  pub fn shipping_address(&self) -> &Option<Address> { &self.shipping_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming pre-checkout query; for bots only. Contains full information about a checkout. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewPreCheckoutQuery

  /// Unique query identifier.
  id: Option<i64>,
  /// Identifier of the user who sent the query.
  sender_user_id: Option<i32>,
  /// Currency for the product price.
  currency: Option<String>,
  /// Total price for the product, in the minimal quantity of the currency.
  total_amount: Option<i64>,
  /// Invoice payload.
  invoice_payload: Option<String>,
  /// Identifier of a shipping option chosen by the user; may be empty if not applicable.
  shipping_option_id: Option<String>,
  /// Information about the order; may be null.
  order_info: Option<OrderInfo>,


}



#[typetag::serde]
impl Update for UpdateNewPreCheckoutQuery {}


impl UpdateNewPreCheckoutQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn currency(&self) -> &Option<String> { &self.currency }
  
  pub fn total_amount(&self) -> &Option<i64> { &self.total_amount }
  
  pub fn invoice_payload(&self) -> &Option<String> { &self.invoice_payload }
  
  pub fn shipping_option_id(&self) -> &Option<String> { &self.shipping_option_id }
  
  pub fn order_info(&self) -> &Option<OrderInfo> { &self.order_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming event; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomEvent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewCustomEvent

  /// A JSON-serialized event.
  event: Option<String>,


}



#[typetag::serde]
impl Update for UpdateNewCustomEvent {}


impl UpdateNewCustomEvent {
  
  
  pub fn event(&self) -> &Option<String> { &self.event }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// A new incoming query; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateNewCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updateNewCustomQuery

  /// The query identifier.
  id: Option<i64>,
  /// JSON-serialized query data.
  data: Option<String>,
  /// Query timeout.
  timeout: Option<i32>,


}



#[typetag::serde]
impl Update for UpdateNewCustomQuery {}


impl UpdateNewCustomQuery {
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  pub fn timeout(&self) -> &Option<i32> { &self.timeout }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Information about a poll was updated; for bots only. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdatePoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updatePoll

  /// New data about the poll.
  poll: Option<Poll>,


}



#[typetag::serde]
impl Update for UpdatePoll {}


impl UpdatePoll {
  
  
  pub fn poll(&self) -> &Option<Poll> { &self.poll }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}




/// Contains a list of updates. 
#[derive(Debug, Serialize, Deserialize)]
pub struct Updates {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // updates

  /// List of updates.
  updates: Option<Vec<Box<Update>>>,


}


impl Clone for Updates {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for Updates {}


impl Updates {
  
  pub fn builder() -> UpdatesBuilder {
    let instance = Self {
      tdfname: "updates".to_string(),
      updates: None,
      
    };
    UpdatesBuilder::new(instance)
  }
  
  
  pub fn updates(&self) -> &Option<Vec<Box<Update>>> { &self.updates }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UpdatesBuilder {
  instance: Updates
}

impl UpdatesBuilder {
  fn new(instance: Updates) -> Self { Self { instance } }

  pub fn build(&self) -> Updates {
    self.instance.clone()
  }
  
  pub fn updates(&mut self, updates: Vec<Box<Update>>) -> &mut Self {
    self.instance.updates = Some(updates);
    self
  }
  
}


/// Represents a user. 
#[derive(Debug, Serialize, Deserialize)]
pub struct User {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // user

  /// User identifier.
  id: Option<i32>,
  /// First name of the user.
  first_name: Option<String>,
  /// Last name of the user.
  last_name: Option<String>,
  /// Username of the user.
  username: Option<String>,
  /// Phone number of the user.
  phone_number: Option<String>,
  /// Current online status of the user.
  status: Option<Box<UserStatus>>,
  /// Profile photo of the user; may be null.
  profile_photo: Option<ProfilePhoto>,
  /// Relationship from the current user to the other user.
  outgoing_link: Option<Box<LinkState>>,
  /// Relationship from the other user to the current user.
  incoming_link: Option<Box<LinkState>>,
  /// True, if the user is verified.
  is_verified: Option<bool>,
  /// True, if the user is Telegram support account.
  is_support: Option<bool>,
  /// If non-empty, it contains the reason why access to this user must be restricted. The format of the string is "{type}: {description}". {type} contains the type of the restriction and at least one of the suffixes "-all", "-ios", "-android", or "-wp", which describe the platforms on which access should be restricted. (For example, "terms-ios-android". {description} contains a human-readable description of the restriction, which can be shown to the user.)
  restriction_reason: Option<String>,
  /// If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser.
  have_access: Option<bool>,
  /// Type of the user.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<UserType>>,
  /// IETF language tag of the user's language; only available to bots.
  language_code: Option<String>,


}


impl Clone for User {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for User {}


impl User {
  
  pub fn builder() -> UserBuilder {
    let instance = Self {
      tdfname: "user".to_string(),
      id: None,
      first_name: None,
      last_name: None,
      username: None,
      phone_number: None,
      status: None,
      profile_photo: None,
      outgoing_link: None,
      incoming_link: None,
      is_verified: None,
      is_support: None,
      restriction_reason: None,
      have_access: None,
      type_: None,
      language_code: None,
      
    };
    UserBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn first_name(&self) -> &Option<String> { &self.first_name }
  
  pub fn last_name(&self) -> &Option<String> { &self.last_name }
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn status(&self) -> &Option<Box<UserStatus>> { &self.status }
  
  pub fn profile_photo(&self) -> &Option<ProfilePhoto> { &self.profile_photo }
  
  pub fn outgoing_link(&self) -> &Option<Box<LinkState>> { &self.outgoing_link }
  
  pub fn incoming_link(&self) -> &Option<Box<LinkState>> { &self.incoming_link }
  
  pub fn is_verified(&self) -> &Option<bool> { &self.is_verified }
  
  pub fn is_support(&self) -> &Option<bool> { &self.is_support }
  
  pub fn restriction_reason(&self) -> &Option<String> { &self.restriction_reason }
  
  pub fn have_access(&self) -> &Option<bool> { &self.have_access }
  
  pub fn type_(&self) -> &Option<Box<UserType>> { &self.type_ }
  
  pub fn language_code(&self) -> &Option<String> { &self.language_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserBuilder {
  instance: User
}

impl UserBuilder {
  fn new(instance: User) -> Self { Self { instance } }

  pub fn build(&self) -> User {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn first_name(&mut self, first_name: String) -> &mut Self {
    self.instance.first_name = Some(first_name);
    self
  }
  
  pub fn last_name(&mut self, last_name: String) -> &mut Self {
    self.instance.last_name = Some(last_name);
    self
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn status(&mut self, status: Box<UserStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
  pub fn profile_photo(&mut self, profile_photo: ProfilePhoto) -> &mut Self {
    self.instance.profile_photo = Some(profile_photo);
    self
  }
  
  pub fn outgoing_link(&mut self, outgoing_link: Box<LinkState>) -> &mut Self {
    self.instance.outgoing_link = Some(outgoing_link);
    self
  }
  
  pub fn incoming_link(&mut self, incoming_link: Box<LinkState>) -> &mut Self {
    self.instance.incoming_link = Some(incoming_link);
    self
  }
  
  pub fn is_verified(&mut self, is_verified: bool) -> &mut Self {
    self.instance.is_verified = Some(is_verified);
    self
  }
  
  pub fn is_support(&mut self, is_support: bool) -> &mut Self {
    self.instance.is_support = Some(is_support);
    self
  }
  
  pub fn restriction_reason(&mut self, restriction_reason: String) -> &mut Self {
    self.instance.restriction_reason = Some(restriction_reason);
    self
  }
  
  pub fn have_access(&mut self, have_access: bool) -> &mut Self {
    self.instance.have_access = Some(have_access);
    self
  }
  
  pub fn type_(&mut self, type_: Box<UserType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn language_code(&mut self, language_code: String) -> &mut Self {
    self.instance.language_code = Some(language_code);
    self
  }
  
}


/// Contains full information about a user (except the full list of profile photos). 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userFullInfo

  /// True, if the user is blacklisted by the current user.
  is_blocked: Option<bool>,
  /// True, if the user can be called.
  can_be_called: Option<bool>,
  /// True, if the user can't be called due to their privacy settings.
  has_private_calls: Option<bool>,
  /// A short user bio.
  bio: Option<String>,
  /// For bots, the text that is included with the link when users share the bot.
  share_text: Option<String>,
  /// Number of group chats where both the other user and the current user are a member; 0 for the current user.
  group_in_common_count: Option<i32>,
  /// If the user is a bot, information about the bot; may be null.
  bot_info: Option<BotInfo>,


}




impl Object for UserFullInfo {}


impl UserFullInfo {
  
  pub fn builder() -> UserFullInfoBuilder {
    let instance = Self {
      tdfname: "userFullInfo".to_string(),
      is_blocked: None,
      can_be_called: None,
      has_private_calls: None,
      bio: None,
      share_text: None,
      group_in_common_count: None,
      bot_info: None,
      
    };
    UserFullInfoBuilder::new(instance)
  }
  
  
  pub fn is_blocked(&self) -> &Option<bool> { &self.is_blocked }
  
  pub fn can_be_called(&self) -> &Option<bool> { &self.can_be_called }
  
  pub fn has_private_calls(&self) -> &Option<bool> { &self.has_private_calls }
  
  pub fn bio(&self) -> &Option<String> { &self.bio }
  
  pub fn share_text(&self) -> &Option<String> { &self.share_text }
  
  pub fn group_in_common_count(&self) -> &Option<i32> { &self.group_in_common_count }
  
  pub fn bot_info(&self) -> &Option<BotInfo> { &self.bot_info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserFullInfoBuilder {
  instance: UserFullInfo
}

impl UserFullInfoBuilder {
  fn new(instance: UserFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> UserFullInfo {
    self.instance.clone()
  }
  
  pub fn is_blocked(&mut self, is_blocked: bool) -> &mut Self {
    self.instance.is_blocked = Some(is_blocked);
    self
  }
  
  pub fn can_be_called(&mut self, can_be_called: bool) -> &mut Self {
    self.instance.can_be_called = Some(can_be_called);
    self
  }
  
  pub fn has_private_calls(&mut self, has_private_calls: bool) -> &mut Self {
    self.instance.has_private_calls = Some(has_private_calls);
    self
  }
  
  pub fn bio(&mut self, bio: String) -> &mut Self {
    self.instance.bio = Some(bio);
    self
  }
  
  pub fn share_text(&mut self, share_text: String) -> &mut Self {
    self.instance.share_text = Some(share_text);
    self
  }
  
  pub fn group_in_common_count(&mut self, group_in_common_count: i32) -> &mut Self {
    self.instance.group_in_common_count = Some(group_in_common_count);
    self
  }
  
  pub fn bot_info(&mut self, bot_info: BotInfo) -> &mut Self {
    self.instance.bot_info = Some(bot_info);
    self
  }
  
}


/// This class is an abstract base class. Describes available user privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySetting: Debug {}



impl Object for UserPrivacySetting {}





/// A privacy setting for managing whether the user's online status is visible. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingShowStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingShowStatus

}



#[typetag::serde]
impl UserPrivacySetting for UserPrivacySettingShowStatus {}


impl UserPrivacySettingShowStatus {
  
  pub fn builder() -> UserPrivacySettingShowStatusBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingShowStatus".to_string(),
      
    };
    UserPrivacySettingShowStatusBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingShowStatusBuilder {
  instance: UserPrivacySettingShowStatus
}

impl UserPrivacySettingShowStatusBuilder {
  fn new(instance: UserPrivacySettingShowStatus) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingShowStatus {
    self.instance.clone()
  }
  
}


/// A privacy setting for managing whether the user can be invited to chats. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowChatInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingAllowChatInvites

}



#[typetag::serde]
impl UserPrivacySetting for UserPrivacySettingAllowChatInvites {}


impl UserPrivacySettingAllowChatInvites {
  
  pub fn builder() -> UserPrivacySettingAllowChatInvitesBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingAllowChatInvites".to_string(),
      
    };
    UserPrivacySettingAllowChatInvitesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingAllowChatInvitesBuilder {
  instance: UserPrivacySettingAllowChatInvites
}

impl UserPrivacySettingAllowChatInvitesBuilder {
  fn new(instance: UserPrivacySettingAllowChatInvites) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowChatInvites {
    self.instance.clone()
  }
  
}


/// A privacy setting for managing whether the user can be called. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingAllowCalls

}



#[typetag::serde]
impl UserPrivacySetting for UserPrivacySettingAllowCalls {}


impl UserPrivacySettingAllowCalls {
  
  pub fn builder() -> UserPrivacySettingAllowCallsBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingAllowCalls".to_string(),
      
    };
    UserPrivacySettingAllowCallsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingAllowCallsBuilder {
  instance: UserPrivacySettingAllowCalls
}

impl UserPrivacySettingAllowCallsBuilder {
  fn new(instance: UserPrivacySettingAllowCalls) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowCalls {
    self.instance.clone()
  }
  
}


/// A privacy setting for managing whether peer-to-peer connections can be used for calls. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingAllowPeerToPeerCalls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingAllowPeerToPeerCalls

}



#[typetag::serde]
impl UserPrivacySetting for UserPrivacySettingAllowPeerToPeerCalls {}


impl UserPrivacySettingAllowPeerToPeerCalls {
  
  pub fn builder() -> UserPrivacySettingAllowPeerToPeerCallsBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingAllowPeerToPeerCalls".to_string(),
      
    };
    UserPrivacySettingAllowPeerToPeerCallsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingAllowPeerToPeerCallsBuilder {
  instance: UserPrivacySettingAllowPeerToPeerCalls
}

impl UserPrivacySettingAllowPeerToPeerCallsBuilder {
  fn new(instance: UserPrivacySettingAllowPeerToPeerCalls) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingAllowPeerToPeerCalls {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Represents a single rule for managing privacy settings. 
#[typetag::serde(tag = "@struct")]
pub trait UserPrivacySettingRule: Debug {}



impl Object for UserPrivacySettingRule {}





/// A rule to allow all users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleAllowAll

}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleAllowAll {}


impl UserPrivacySettingRuleAllowAll {
  
  pub fn builder() -> UserPrivacySettingRuleAllowAllBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleAllowAll".to_string(),
      
    };
    UserPrivacySettingRuleAllowAllBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleAllowAllBuilder {
  instance: UserPrivacySettingRuleAllowAll
}

impl UserPrivacySettingRuleAllowAllBuilder {
  fn new(instance: UserPrivacySettingRuleAllowAll) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowAll {
    self.instance.clone()
  }
  
}


/// A rule to allow all of a user's contacts to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleAllowContacts

}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleAllowContacts {}


impl UserPrivacySettingRuleAllowContacts {
  
  pub fn builder() -> UserPrivacySettingRuleAllowContactsBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleAllowContacts".to_string(),
      
    };
    UserPrivacySettingRuleAllowContactsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleAllowContactsBuilder {
  instance: UserPrivacySettingRuleAllowContacts
}

impl UserPrivacySettingRuleAllowContactsBuilder {
  fn new(instance: UserPrivacySettingRuleAllowContacts) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowContacts {
    self.instance.clone()
  }
  
}


/// A rule to allow certain specified users to do something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleAllowUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleAllowUsers

  /// The user identifiers.
  user_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleAllowUsers {}


impl UserPrivacySettingRuleAllowUsers {
  
  pub fn builder() -> UserPrivacySettingRuleAllowUsersBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleAllowUsers".to_string(),
      user_ids: None,
      
    };
    UserPrivacySettingRuleAllowUsersBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleAllowUsersBuilder {
  instance: UserPrivacySettingRuleAllowUsers
}

impl UserPrivacySettingRuleAllowUsersBuilder {
  fn new(instance: UserPrivacySettingRuleAllowUsers) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleAllowUsers {
    self.instance.clone()
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// A rule to restrict all users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictAll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleRestrictAll

}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictAll {}


impl UserPrivacySettingRuleRestrictAll {
  
  pub fn builder() -> UserPrivacySettingRuleRestrictAllBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleRestrictAll".to_string(),
      
    };
    UserPrivacySettingRuleRestrictAllBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleRestrictAllBuilder {
  instance: UserPrivacySettingRuleRestrictAll
}

impl UserPrivacySettingRuleRestrictAllBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictAll) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictAll {
    self.instance.clone()
  }
  
}


/// A rule to restrict all contacts of a user from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleRestrictContacts

}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictContacts {}


impl UserPrivacySettingRuleRestrictContacts {
  
  pub fn builder() -> UserPrivacySettingRuleRestrictContactsBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleRestrictContacts".to_string(),
      
    };
    UserPrivacySettingRuleRestrictContactsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleRestrictContactsBuilder {
  instance: UserPrivacySettingRuleRestrictContacts
}

impl UserPrivacySettingRuleRestrictContactsBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictContacts) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictContacts {
    self.instance.clone()
  }
  
}


/// A rule to restrict all specified users from doing something. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserPrivacySettingRuleRestrictUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRuleRestrictUsers

  /// The user identifiers.
  user_ids: Option<Vec<i32>>,


}



#[typetag::serde]
impl UserPrivacySettingRule for UserPrivacySettingRuleRestrictUsers {}


impl UserPrivacySettingRuleRestrictUsers {
  
  pub fn builder() -> UserPrivacySettingRuleRestrictUsersBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRuleRestrictUsers".to_string(),
      user_ids: None,
      
    };
    UserPrivacySettingRuleRestrictUsersBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRuleRestrictUsersBuilder {
  instance: UserPrivacySettingRuleRestrictUsers
}

impl UserPrivacySettingRuleRestrictUsersBuilder {
  fn new(instance: UserPrivacySettingRuleRestrictUsers) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRuleRestrictUsers {
    self.instance.clone()
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userPrivacySettingRules

  /// A list of rules.
  rules: Option<Vec<Box<UserPrivacySettingRule>>>,


}


impl Clone for UserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for UserPrivacySettingRules {}


impl UserPrivacySettingRules {
  
  pub fn builder() -> UserPrivacySettingRulesBuilder {
    let instance = Self {
      tdfname: "userPrivacySettingRules".to_string(),
      rules: None,
      
    };
    UserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn rules(&self) -> &Option<Vec<Box<UserPrivacySettingRule>>> { &self.rules }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserPrivacySettingRulesBuilder {
  instance: UserPrivacySettingRules
}

impl UserPrivacySettingRulesBuilder {
  fn new(instance: UserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> UserPrivacySettingRules {
    self.instance.clone()
  }
  
  pub fn rules(&mut self, rules: Vec<Box<UserPrivacySettingRule>>) -> &mut Self {
    self.instance.rules = Some(rules);
    self
  }
  
}


/// Contains full information about a user profile photo. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userProfilePhoto

  /// Unique user profile photo identifier.
  id: Option<i64>,
  /// Point in time (Unix timestamp) when the photo has been added.
  added_date: Option<i32>,
  /// Available variants of the user photo, in different sizes.
  sizes: Option<Vec<PhotoSize>>,


}




impl Object for UserProfilePhoto {}


impl UserProfilePhoto {
  
  pub fn builder() -> UserProfilePhotoBuilder {
    let instance = Self {
      tdfname: "userProfilePhoto".to_string(),
      id: None,
      added_date: None,
      sizes: None,
      
    };
    UserProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i64> { &self.id }
  
  pub fn added_date(&self) -> &Option<i32> { &self.added_date }
  
  pub fn sizes(&self) -> &Option<Vec<PhotoSize>> { &self.sizes }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserProfilePhotoBuilder {
  instance: UserProfilePhoto
}

impl UserProfilePhotoBuilder {
  fn new(instance: UserProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> UserProfilePhoto {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i64) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn added_date(&mut self, added_date: i32) -> &mut Self {
    self.instance.added_date = Some(added_date);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
}


/// Contains part of the list of user photos. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userProfilePhotos

  /// Total number of user profile photos.
  total_count: Option<i32>,
  /// A list of photos.
  photos: Option<Vec<UserProfilePhoto>>,


}




impl Object for UserProfilePhotos {}


impl UserProfilePhotos {
  
  pub fn builder() -> UserProfilePhotosBuilder {
    let instance = Self {
      tdfname: "userProfilePhotos".to_string(),
      total_count: None,
      photos: None,
      
    };
    UserProfilePhotosBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn photos(&self) -> &Option<Vec<UserProfilePhoto>> { &self.photos }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserProfilePhotosBuilder {
  instance: UserProfilePhotos
}

impl UserProfilePhotosBuilder {
  fn new(instance: UserProfilePhotos) -> Self { Self { instance } }

  pub fn build(&self) -> UserProfilePhotos {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn photos(&mut self, photos: Vec<UserProfilePhoto>) -> &mut Self {
    self.instance.photos = Some(photos);
    self
  }
  
}


/// This class is an abstract base class. Describes the last time the user was online. 
#[typetag::serde(tag = "@struct")]
pub trait UserStatus: Debug {}



impl Object for UserStatus {}





/// The user status was never changed. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusEmpty

}



#[typetag::serde]
impl UserStatus for UserStatusEmpty {}


impl UserStatusEmpty {
  
  pub fn builder() -> UserStatusEmptyBuilder {
    let instance = Self {
      tdfname: "userStatusEmpty".to_string(),
      
    };
    UserStatusEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusEmptyBuilder {
  instance: UserStatusEmpty
}

impl UserStatusEmptyBuilder {
  fn new(instance: UserStatusEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusEmpty {
    self.instance.clone()
  }
  
}


/// The user is online. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOnline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusOnline

  /// Point in time (Unix timestamp) when the user's online status will expire.
  expires: Option<i32>,


}



#[typetag::serde]
impl UserStatus for UserStatusOnline {}


impl UserStatusOnline {
  
  pub fn builder() -> UserStatusOnlineBuilder {
    let instance = Self {
      tdfname: "userStatusOnline".to_string(),
      expires: None,
      
    };
    UserStatusOnlineBuilder::new(instance)
  }
  
  
  pub fn expires(&self) -> &Option<i32> { &self.expires }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusOnlineBuilder {
  instance: UserStatusOnline
}

impl UserStatusOnlineBuilder {
  fn new(instance: UserStatusOnline) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusOnline {
    self.instance.clone()
  }
  
  pub fn expires(&mut self, expires: i32) -> &mut Self {
    self.instance.expires = Some(expires);
    self
  }
  
}


/// The user is offline. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusOffline {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusOffline

  /// Point in time (Unix timestamp) when the user was last online.
  was_online: Option<i32>,


}



#[typetag::serde]
impl UserStatus for UserStatusOffline {}


impl UserStatusOffline {
  
  pub fn builder() -> UserStatusOfflineBuilder {
    let instance = Self {
      tdfname: "userStatusOffline".to_string(),
      was_online: None,
      
    };
    UserStatusOfflineBuilder::new(instance)
  }
  
  
  pub fn was_online(&self) -> &Option<i32> { &self.was_online }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusOfflineBuilder {
  instance: UserStatusOffline
}

impl UserStatusOfflineBuilder {
  fn new(instance: UserStatusOffline) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusOffline {
    self.instance.clone()
  }
  
  pub fn was_online(&mut self, was_online: i32) -> &mut Self {
    self.instance.was_online = Some(was_online);
    self
  }
  
}


/// The user was online recently. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusRecently {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusRecently

}



#[typetag::serde]
impl UserStatus for UserStatusRecently {}


impl UserStatusRecently {
  
  pub fn builder() -> UserStatusRecentlyBuilder {
    let instance = Self {
      tdfname: "userStatusRecently".to_string(),
      
    };
    UserStatusRecentlyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusRecentlyBuilder {
  instance: UserStatusRecently
}

impl UserStatusRecentlyBuilder {
  fn new(instance: UserStatusRecently) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusRecently {
    self.instance.clone()
  }
  
}


/// The user is offline, but was online last week. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastWeek {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusLastWeek

}



#[typetag::serde]
impl UserStatus for UserStatusLastWeek {}


impl UserStatusLastWeek {
  
  pub fn builder() -> UserStatusLastWeekBuilder {
    let instance = Self {
      tdfname: "userStatusLastWeek".to_string(),
      
    };
    UserStatusLastWeekBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusLastWeekBuilder {
  instance: UserStatusLastWeek
}

impl UserStatusLastWeekBuilder {
  fn new(instance: UserStatusLastWeek) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusLastWeek {
    self.instance.clone()
  }
  
}


/// The user is offline, but was online last month. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserStatusLastMonth {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userStatusLastMonth

}



#[typetag::serde]
impl UserStatus for UserStatusLastMonth {}


impl UserStatusLastMonth {
  
  pub fn builder() -> UserStatusLastMonthBuilder {
    let instance = Self {
      tdfname: "userStatusLastMonth".to_string(),
      
    };
    UserStatusLastMonthBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserStatusLastMonthBuilder {
  instance: UserStatusLastMonth
}

impl UserStatusLastMonthBuilder {
  fn new(instance: UserStatusLastMonth) -> Self { Self { instance } }

  pub fn build(&self) -> UserStatusLastMonth {
    self.instance.clone()
  }
  
}


/// This class is an abstract base class. Represents the type of the user. The following types are possible: regular users, deleted users and bots. 
#[typetag::serde(tag = "@struct")]
pub trait UserType: Debug {}



impl Object for UserType {}





/// A regular user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeRegular {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userTypeRegular

}



#[typetag::serde]
impl UserType for UserTypeRegular {}


impl UserTypeRegular {
  
  pub fn builder() -> UserTypeRegularBuilder {
    let instance = Self {
      tdfname: "userTypeRegular".to_string(),
      
    };
    UserTypeRegularBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserTypeRegularBuilder {
  instance: UserTypeRegular
}

impl UserTypeRegularBuilder {
  fn new(instance: UserTypeRegular) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeRegular {
    self.instance.clone()
  }
  
}


/// A deleted user or deleted bot. No information on the user besides the user_id is available. It is not possible to perform any active actions on this type of user. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeDeleted {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userTypeDeleted

}



#[typetag::serde]
impl UserType for UserTypeDeleted {}


impl UserTypeDeleted {
  
  pub fn builder() -> UserTypeDeletedBuilder {
    let instance = Self {
      tdfname: "userTypeDeleted".to_string(),
      
    };
    UserTypeDeletedBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserTypeDeletedBuilder {
  instance: UserTypeDeleted
}

impl UserTypeDeletedBuilder {
  fn new(instance: UserTypeDeleted) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeDeleted {
    self.instance.clone()
  }
  
}


/// A bot (see 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeBot {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userTypeBot

  /// True, if the bot can be invited to basic group and supergroup chats.
  can_join_groups: Option<bool>,
  /// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages.
  can_read_all_group_messages: Option<bool>,
  /// True, if the bot supports inline queries.
  is_inline: Option<bool>,
  /// Placeholder for inline queries (displayed on the client input field).
  inline_query_placeholder: Option<String>,
  /// True, if the location of the user should be sent with every inline query to this bot.
  need_location: Option<bool>,


}



#[typetag::serde]
impl UserType for UserTypeBot {}


impl UserTypeBot {
  
  pub fn builder() -> UserTypeBotBuilder {
    let instance = Self {
      tdfname: "userTypeBot".to_string(),
      can_join_groups: None,
      can_read_all_group_messages: None,
      is_inline: None,
      inline_query_placeholder: None,
      need_location: None,
      
    };
    UserTypeBotBuilder::new(instance)
  }
  
  
  pub fn can_join_groups(&self) -> &Option<bool> { &self.can_join_groups }
  
  pub fn can_read_all_group_messages(&self) -> &Option<bool> { &self.can_read_all_group_messages }
  
  pub fn is_inline(&self) -> &Option<bool> { &self.is_inline }
  
  pub fn inline_query_placeholder(&self) -> &Option<String> { &self.inline_query_placeholder }
  
  pub fn need_location(&self) -> &Option<bool> { &self.need_location }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserTypeBotBuilder {
  instance: UserTypeBot
}

impl UserTypeBotBuilder {
  fn new(instance: UserTypeBot) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeBot {
    self.instance.clone()
  }
  
  pub fn can_join_groups(&mut self, can_join_groups: bool) -> &mut Self {
    self.instance.can_join_groups = Some(can_join_groups);
    self
  }
  
  pub fn can_read_all_group_messages(&mut self, can_read_all_group_messages: bool) -> &mut Self {
    self.instance.can_read_all_group_messages = Some(can_read_all_group_messages);
    self
  }
  
  pub fn is_inline(&mut self, is_inline: bool) -> &mut Self {
    self.instance.is_inline = Some(is_inline);
    self
  }
  
  pub fn inline_query_placeholder(&mut self, inline_query_placeholder: String) -> &mut Self {
    self.instance.inline_query_placeholder = Some(inline_query_placeholder);
    self
  }
  
  pub fn need_location(&mut self, need_location: bool) -> &mut Self {
    self.instance.need_location = Some(need_location);
    self
  }
  
}


/// No information on the user besides the user_id is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserTypeUnknown {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // userTypeUnknown

}



#[typetag::serde]
impl UserType for UserTypeUnknown {}


impl UserTypeUnknown {
  
  pub fn builder() -> UserTypeUnknownBuilder {
    let instance = Self {
      tdfname: "userTypeUnknown".to_string(),
      
    };
    UserTypeUnknownBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UserTypeUnknownBuilder {
  instance: UserTypeUnknown
}

impl UserTypeUnknownBuilder {
  fn new(instance: UserTypeUnknown) -> Self { Self { instance } }

  pub fn build(&self) -> UserTypeUnknown {
    self.instance.clone()
  }
  
}


/// Represents a list of users. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Users {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // users

  /// Approximate total count of users found.
  total_count: Option<i32>,
  /// A list of user identifiers.
  user_ids: Option<Vec<i32>>,


}




impl Object for Users {}


impl Users {
  
  pub fn builder() -> UsersBuilder {
    let instance = Self {
      tdfname: "users".to_string(),
      total_count: None,
      user_ids: None,
      
    };
    UsersBuilder::new(instance)
  }
  
  
  pub fn total_count(&self) -> &Option<i32> { &self.total_count }
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UsersBuilder {
  instance: Users
}

impl UsersBuilder {
  fn new(instance: Users) -> Self { Self { instance } }

  pub fn build(&self) -> Users {
    self.instance.clone()
  }
  
  pub fn total_count(&mut self, total_count: i32) -> &mut Self {
    self.instance.total_count = Some(total_count);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidatedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // validatedOrderInfo

  /// Temporary identifier of the order information.
  order_info_id: Option<String>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,


}




impl Object for ValidatedOrderInfo {}


impl ValidatedOrderInfo {
  
  pub fn builder() -> ValidatedOrderInfoBuilder {
    let instance = Self {
      tdfname: "validatedOrderInfo".to_string(),
      order_info_id: None,
      shipping_options: None,
      
    };
    ValidatedOrderInfoBuilder::new(instance)
  }
  
  
  pub fn order_info_id(&self) -> &Option<String> { &self.order_info_id }
  
  pub fn shipping_options(&self) -> &Option<Vec<ShippingOption>> { &self.shipping_options }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ValidatedOrderInfoBuilder {
  instance: ValidatedOrderInfo
}

impl ValidatedOrderInfoBuilder {
  fn new(instance: ValidatedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ValidatedOrderInfo {
    self.instance.clone()
  }
  
  pub fn order_info_id(&mut self, order_info_id: String) -> &mut Self {
    self.instance.order_info_id = Some(order_info_id);
    self
  }
  
  pub fn shipping_options(&mut self, shipping_options: Vec<ShippingOption>) -> &mut Self {
    self.instance.shipping_options = Some(shipping_options);
    self
  }
  
}


/// Describes a venue. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Venue {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // venue

  /// Venue location; as defined by the sender.
  location: Option<Location>,
  /// Venue name; as defined by the sender.
  title: Option<String>,
  /// Venue address; as defined by the sender.
  address: Option<String>,
  /// Provider of the venue database; as defined by the sender. Currently only "foursquare" needs to be supported.
  provider: Option<String>,
  /// Identifier of the venue in the provider database; as defined by the sender.
  id: Option<String>,
  /// Type of the venue in the provider database; as defined by the sender.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,


}




impl Object for Venue {}


impl Venue {
  
  pub fn builder() -> VenueBuilder {
    let instance = Self {
      tdfname: "venue".to_string(),
      location: None,
      title: None,
      address: None,
      provider: None,
      id: None,
      type_: None,
      
    };
    VenueBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn address(&self) -> &Option<String> { &self.address }
  
  pub fn provider(&self) -> &Option<String> { &self.provider }
  
  pub fn id(&self) -> &Option<String> { &self.id }
  
  pub fn type_(&self) -> &Option<String> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct VenueBuilder {
  instance: Venue
}

impl VenueBuilder {
  fn new(instance: Venue) -> Self { Self { instance } }

  pub fn build(&self) -> Venue {
    self.instance.clone()
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn address(&mut self, address: String) -> &mut Self {
    self.instance.address = Some(address);
    self
  }
  
  pub fn provider(&mut self, provider: String) -> &mut Self {
    self.instance.provider = Some(provider);
    self
  }
  
  pub fn id(&mut self, id: String) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn type_(&mut self, type_: String) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Describes a video file. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Video {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // video

  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width; as defined by the sender.
  width: Option<i32>,
  /// Video height; as defined by the sender.
  height: Option<i32>,
  /// Original name of the file; as defined by the sender.
  file_name: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// True, if stickers were added to the photo.
  has_stickers: Option<bool>,
  /// True, if the video should be tried to be streamed.
  supports_streaming: Option<bool>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,


}




impl Object for Video {}


impl Video {
  
  pub fn builder() -> VideoBuilder {
    let instance = Self {
      tdfname: "video".to_string(),
      duration: None,
      width: None,
      height: None,
      file_name: None,
      mime_type: None,
      has_stickers: None,
      supports_streaming: None,
      thumbnail: None,
      video: None,
      
    };
    VideoBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn has_stickers(&self) -> &Option<bool> { &self.has_stickers }
  
  pub fn supports_streaming(&self) -> &Option<bool> { &self.supports_streaming }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  pub fn video(&self) -> &Option<File> { &self.video }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct VideoBuilder {
  instance: Video
}

impl VideoBuilder {
  fn new(instance: Video) -> Self { Self { instance } }

  pub fn build(&self) -> Video {
    self.instance.clone()
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn has_stickers(&mut self, has_stickers: bool) -> &mut Self {
    self.instance.has_stickers = Some(has_stickers);
    self
  }
  
  pub fn supports_streaming(&mut self, supports_streaming: bool) -> &mut Self {
    self.instance.supports_streaming = Some(supports_streaming);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn video(&mut self, video: File) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
}


/// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VideoNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // videoNote

  /// Duration of the video, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// Video width and height; as defined by the sender.
  length: Option<i32>,
  /// Video thumbnail; as defined by the sender; may be null.
  thumbnail: Option<PhotoSize>,
  /// File containing the video.
  video: Option<File>,


}




impl Object for VideoNote {}


impl VideoNote {
  
  pub fn builder() -> VideoNoteBuilder {
    let instance = Self {
      tdfname: "videoNote".to_string(),
      duration: None,
      length: None,
      thumbnail: None,
      video: None,
      
    };
    VideoNoteBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn length(&self) -> &Option<i32> { &self.length }
  
  pub fn thumbnail(&self) -> &Option<PhotoSize> { &self.thumbnail }
  
  pub fn video(&self) -> &Option<File> { &self.video }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct VideoNoteBuilder {
  instance: VideoNote
}

impl VideoNoteBuilder {
  fn new(instance: VideoNote) -> Self { Self { instance } }

  pub fn build(&self) -> VideoNote {
    self.instance.clone()
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn length(&mut self, length: i32) -> &mut Self {
    self.instance.length = Some(length);
    self
  }
  
  pub fn thumbnail(&mut self, thumbnail: PhotoSize) -> &mut Self {
    self.instance.thumbnail = Some(thumbnail);
    self
  }
  
  pub fn video(&mut self, video: File) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
}


/// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VoiceNote {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // voiceNote

  /// Duration of the voice note, in seconds; as defined by the sender.
  duration: Option<i32>,
  /// A waveform representation of the voice note in 5-bit format.
  waveform: Option<String>,
  /// MIME type of the file; as defined by the sender.
  mime_type: Option<String>,
  /// File containing the voice note.
  voice: Option<File>,


}




impl Object for VoiceNote {}


impl VoiceNote {
  
  pub fn builder() -> VoiceNoteBuilder {
    let instance = Self {
      tdfname: "voiceNote".to_string(),
      duration: None,
      waveform: None,
      mime_type: None,
      voice: None,
      
    };
    VoiceNoteBuilder::new(instance)
  }
  
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn waveform(&self) -> &Option<String> { &self.waveform }
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  pub fn voice(&self) -> &Option<File> { &self.voice }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct VoiceNoteBuilder {
  instance: VoiceNote
}

impl VoiceNoteBuilder {
  fn new(instance: VoiceNote) -> Self { Self { instance } }

  pub fn build(&self) -> VoiceNote {
    self.instance.clone()
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn waveform(&mut self, waveform: String) -> &mut Self {
    self.instance.waveform = Some(waveform);
    self
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
  pub fn voice(&mut self, voice: File) -> &mut Self {
    self.instance.voice = Some(voice);
    self
  }
  
}


/// Contains information about a wallpaper. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpaper {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // wallpaper

  /// Unique persistent wallpaper identifier.
  id: Option<i32>,
  /// Available variants of the wallpaper in different sizes. These photos can only be downloaded; they can't be sent in a message.
  sizes: Option<Vec<PhotoSize>>,
  /// Main color of the wallpaper in RGB24 format; should be treated as background color if no photos are specified.
  color: Option<i32>,


}




impl Object for Wallpaper {}


impl Wallpaper {
  
  pub fn builder() -> WallpaperBuilder {
    let instance = Self {
      tdfname: "wallpaper".to_string(),
      id: None,
      sizes: None,
      color: None,
      
    };
    WallpaperBuilder::new(instance)
  }
  
  
  pub fn id(&self) -> &Option<i32> { &self.id }
  
  pub fn sizes(&self) -> &Option<Vec<PhotoSize>> { &self.sizes }
  
  pub fn color(&self) -> &Option<i32> { &self.color }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct WallpaperBuilder {
  instance: Wallpaper
}

impl WallpaperBuilder {
  fn new(instance: Wallpaper) -> Self { Self { instance } }

  pub fn build(&self) -> Wallpaper {
    self.instance.clone()
  }
  
  pub fn id(&mut self, id: i32) -> &mut Self {
    self.instance.id = Some(id);
    self
  }
  
  pub fn sizes(&mut self, sizes: Vec<PhotoSize>) -> &mut Self {
    self.instance.sizes = Some(sizes);
    self
  }
  
  pub fn color(&mut self, color: i32) -> &mut Self {
    self.instance.color = Some(color);
    self
  }
  
}


/// Contains a list of wallpapers. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // wallpapers

  /// A list of wallpapers.
  wallpapers: Option<Vec<Wallpaper>>,


}




impl Object for Wallpapers {}


impl Wallpapers {
  
  pub fn builder() -> WallpapersBuilder {
    let instance = Self {
      tdfname: "wallpapers".to_string(),
      wallpapers: None,
      
    };
    WallpapersBuilder::new(instance)
  }
  
  
  pub fn wallpapers(&self) -> &Option<Vec<Wallpaper>> { &self.wallpapers }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct WallpapersBuilder {
  instance: Wallpapers
}

impl WallpapersBuilder {
  fn new(instance: Wallpapers) -> Self { Self { instance } }

  pub fn build(&self) -> Wallpapers {
    self.instance.clone()
  }
  
  pub fn wallpapers(&mut self, wallpapers: Vec<Wallpaper>) -> &mut Self {
    self.instance.wallpapers = Some(wallpapers);
    self
  }
  
}


/// Describes a web page preview. 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebPage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // webPage

  /// Original URL of the link.
  url: Option<String>,
  /// URL to display.
  display_url: Option<String>,
  /// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<String>,
  /// Short name of the site (e.g., Google Docs, App Store).
  site_name: Option<String>,
  /// Title of the content.
  title: Option<String>,
  /// Description of the content.
  description: Option<String>,
  /// Image representing the content; may be null.
  photo: Option<Photo>,
  /// URL to show in the embedded preview.
  embed_url: Option<String>,
  /// MIME type of the embedded preview, (e.g., text/html or video/mp4).
  embed_type: Option<String>,
  /// Width of the embedded preview.
  embed_width: Option<i32>,
  /// Height of the embedded preview.
  embed_height: Option<i32>,
  /// Duration of the content, in seconds.
  duration: Option<i32>,
  /// Author of the content.
  author: Option<String>,
  /// Preview of the content as an animation, if available; may be null.
  animation: Option<Animation>,
  /// Preview of the content as an audio file, if available; may be null.
  audio: Option<Audio>,
  /// Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null.
  document: Option<Document>,
  /// Preview of the content as a sticker for small WEBP files, if available; may be null.
  sticker: Option<Sticker>,
  /// Preview of the content as a video, if available; may be null.
  video: Option<Video>,
  /// Preview of the content as a video note, if available; may be null.
  video_note: Option<VideoNote>,
  /// Preview of the content as a voice note, if available; may be null.
  voice_note: Option<VoiceNote>,
  /// Version of instant view, available for the web page (currently can be 1 or 2), 0 if none.
  instant_view_version: Option<i32>,


}




impl Object for WebPage {}


impl WebPage {
  
  pub fn builder() -> WebPageBuilder {
    let instance = Self {
      tdfname: "webPage".to_string(),
      url: None,
      display_url: None,
      type_: None,
      site_name: None,
      title: None,
      description: None,
      photo: None,
      embed_url: None,
      embed_type: None,
      embed_width: None,
      embed_height: None,
      duration: None,
      author: None,
      animation: None,
      audio: None,
      document: None,
      sticker: None,
      video: None,
      video_note: None,
      voice_note: None,
      instant_view_version: None,
      
    };
    WebPageBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn display_url(&self) -> &Option<String> { &self.display_url }
  
  pub fn type_(&self) -> &Option<String> { &self.type_ }
  
  pub fn site_name(&self) -> &Option<String> { &self.site_name }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  pub fn photo(&self) -> &Option<Photo> { &self.photo }
  
  pub fn embed_url(&self) -> &Option<String> { &self.embed_url }
  
  pub fn embed_type(&self) -> &Option<String> { &self.embed_type }
  
  pub fn embed_width(&self) -> &Option<i32> { &self.embed_width }
  
  pub fn embed_height(&self) -> &Option<i32> { &self.embed_height }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn author(&self) -> &Option<String> { &self.author }
  
  pub fn animation(&self) -> &Option<Animation> { &self.animation }
  
  pub fn audio(&self) -> &Option<Audio> { &self.audio }
  
  pub fn document(&self) -> &Option<Document> { &self.document }
  
  pub fn sticker(&self) -> &Option<Sticker> { &self.sticker }
  
  pub fn video(&self) -> &Option<Video> { &self.video }
  
  pub fn video_note(&self) -> &Option<VideoNote> { &self.video_note }
  
  pub fn voice_note(&self) -> &Option<VoiceNote> { &self.voice_note }
  
  pub fn instant_view_version(&self) -> &Option<i32> { &self.instant_view_version }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct WebPageBuilder {
  instance: WebPage
}

impl WebPageBuilder {
  fn new(instance: WebPage) -> Self { Self { instance } }

  pub fn build(&self) -> WebPage {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn display_url(&mut self, display_url: String) -> &mut Self {
    self.instance.display_url = Some(display_url);
    self
  }
  
  pub fn type_(&mut self, type_: String) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn site_name(&mut self, site_name: String) -> &mut Self {
    self.instance.site_name = Some(site_name);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
  pub fn photo(&mut self, photo: Photo) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
  pub fn embed_url(&mut self, embed_url: String) -> &mut Self {
    self.instance.embed_url = Some(embed_url);
    self
  }
  
  pub fn embed_type(&mut self, embed_type: String) -> &mut Self {
    self.instance.embed_type = Some(embed_type);
    self
  }
  
  pub fn embed_width(&mut self, embed_width: i32) -> &mut Self {
    self.instance.embed_width = Some(embed_width);
    self
  }
  
  pub fn embed_height(&mut self, embed_height: i32) -> &mut Self {
    self.instance.embed_height = Some(embed_height);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn author(&mut self, author: String) -> &mut Self {
    self.instance.author = Some(author);
    self
  }
  
  pub fn animation(&mut self, animation: Animation) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
  pub fn audio(&mut self, audio: Audio) -> &mut Self {
    self.instance.audio = Some(audio);
    self
  }
  
  pub fn document(&mut self, document: Document) -> &mut Self {
    self.instance.document = Some(document);
    self
  }
  
  pub fn sticker(&mut self, sticker: Sticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn video(&mut self, video: Video) -> &mut Self {
    self.instance.video = Some(video);
    self
  }
  
  pub fn video_note(&mut self, video_note: VideoNote) -> &mut Self {
    self.instance.video_note = Some(video_note);
    self
  }
  
  pub fn voice_note(&mut self, voice_note: VoiceNote) -> &mut Self {
    self.instance.voice_note = Some(voice_note);
    self
  }
  
  pub fn instant_view_version(&mut self, instant_view_version: i32) -> &mut Self {
    self.instance.instant_view_version = Some(instant_view_version);
    self
  }
  
}


/// Describes an instant view page for a web page. 
#[derive(Debug, Serialize, Deserialize)]
pub struct WebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // webPageInstantView

  /// Content of the web page.
  page_blocks: Option<Vec<Box<PageBlock>>>,
  /// Version of the instant view, currently can be 1 or 2.
  version: Option<i32>,
  /// Instant view URL; may be different from WebPage.url and must be used for the correct anchors handling.
  url: Option<String>,
  /// True, if the instant view must be shown from right to left.
  is_rtl: Option<bool>,
  /// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view.
  is_full: Option<bool>,


}


impl Clone for WebPageInstantView {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Object for WebPageInstantView {}


impl WebPageInstantView {
  
  pub fn builder() -> WebPageInstantViewBuilder {
    let instance = Self {
      tdfname: "webPageInstantView".to_string(),
      page_blocks: None,
      version: None,
      url: None,
      is_rtl: None,
      is_full: None,
      
    };
    WebPageInstantViewBuilder::new(instance)
  }
  
  
  pub fn page_blocks(&self) -> &Option<Vec<Box<PageBlock>>> { &self.page_blocks }
  
  pub fn version(&self) -> &Option<i32> { &self.version }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn is_rtl(&self) -> &Option<bool> { &self.is_rtl }
  
  pub fn is_full(&self) -> &Option<bool> { &self.is_full }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct WebPageInstantViewBuilder {
  instance: WebPageInstantView
}

impl WebPageInstantViewBuilder {
  fn new(instance: WebPageInstantView) -> Self { Self { instance } }

  pub fn build(&self) -> WebPageInstantView {
    self.instance.clone()
  }
  
  pub fn page_blocks(&mut self, page_blocks: Vec<Box<PageBlock>>) -> &mut Self {
    self.instance.page_blocks = Some(page_blocks);
    self
  }
  
  pub fn version(&mut self, version: i32) -> &mut Self {
    self.instance.version = Some(version);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn is_rtl(&mut self, is_rtl: bool) -> &mut Self {
    self.instance.is_rtl = Some(is_rtl);
    self
  }
  
  pub fn is_full(&mut self, is_full: bool) -> &mut Self {
    self.instance.is_full = Some(is_full);
    self
  }
  
}


/// Accepts an incoming call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // acceptCall

  /// Call identifier.
  call_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,


}




impl Function for AcceptCall {}


impl AcceptCall {
  
  pub fn builder() -> AcceptCallBuilder {
    let instance = Self {
      tdfname: "acceptCall".to_string(),
      call_id: None,
      protocol: None,
      
    };
    AcceptCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> &Option<i32> { &self.call_id }
  
  pub fn protocol(&self) -> &Option<CallProtocol> { &self.protocol }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AcceptCallBuilder {
  instance: AcceptCall
}

impl AcceptCallBuilder {
  fn new(instance: AcceptCall) -> Self { Self { instance } }

  pub fn build(&self) -> AcceptCall {
    self.instance.clone()
  }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
}


/// Accepts Telegram terms of services.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AcceptTermsOfService {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // acceptTermsOfService

  /// Terms of service identifier.
  terms_of_service_id: Option<String>,


}




impl Function for AcceptTermsOfService {}


impl AcceptTermsOfService {
  
  pub fn builder() -> AcceptTermsOfServiceBuilder {
    let instance = Self {
      tdfname: "acceptTermsOfService".to_string(),
      terms_of_service_id: None,
      
    };
    AcceptTermsOfServiceBuilder::new(instance)
  }
  
  
  pub fn terms_of_service_id(&self) -> &Option<String> { &self.terms_of_service_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AcceptTermsOfServiceBuilder {
  instance: AcceptTermsOfService
}

impl AcceptTermsOfServiceBuilder {
  fn new(instance: AcceptTermsOfService) -> Self { Self { instance } }

  pub fn build(&self) -> AcceptTermsOfService {
    self.instance.clone()
  }
  
  pub fn terms_of_service_id(&mut self, terms_of_service_id: String) -> &mut Self {
    self.instance.terms_of_service_id = Some(terms_of_service_id);
    self
  }
  
}


/// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addChatMember

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the user.
  user_id: Option<i32>,
  /// The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels.
  forward_limit: Option<i32>,


}




impl Function for AddChatMember {}


impl AddChatMember {
  
  pub fn builder() -> AddChatMemberBuilder {
    let instance = Self {
      tdfname: "addChatMember".to_string(),
      chat_id: None,
      user_id: None,
      forward_limit: None,
      
    };
    AddChatMemberBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn forward_limit(&self) -> &Option<i32> { &self.forward_limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddChatMemberBuilder {
  instance: AddChatMember
}

impl AddChatMemberBuilder {
  fn new(instance: AddChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> AddChatMember {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn forward_limit(&mut self, forward_limit: i32) -> &mut Self {
    self.instance.forward_limit = Some(forward_limit);
    self
  }
  
}


/// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addChatMembers

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the users to be added to the chat.
  user_ids: Option<Vec<i32>>,


}




impl Function for AddChatMembers {}


impl AddChatMembers {
  
  pub fn builder() -> AddChatMembersBuilder {
    let instance = Self {
      tdfname: "addChatMembers".to_string(),
      chat_id: None,
      user_ids: None,
      
    };
    AddChatMembersBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddChatMembersBuilder {
  instance: AddChatMembers
}

impl AddChatMembersBuilder {
  fn new(instance: AddChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> AddChatMembers {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddCustomServerLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addCustomServerLanguagePack

  /// Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link.
  language_pack_id: Option<String>,


}




impl Function for AddCustomServerLanguagePack {}


impl AddCustomServerLanguagePack {
  
  pub fn builder() -> AddCustomServerLanguagePackBuilder {
    let instance = Self {
      tdfname: "addCustomServerLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    AddCustomServerLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddCustomServerLanguagePackBuilder {
  instance: AddCustomServerLanguagePack
}

impl AddCustomServerLanguagePackBuilder {
  fn new(instance: AddCustomServerLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> AddCustomServerLanguagePack {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
}


/// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addFavoriteSticker

  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,


}


impl Clone for AddFavoriteSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddFavoriteSticker {}


impl AddFavoriteSticker {
  
  pub fn builder() -> AddFavoriteStickerBuilder {
    let instance = Self {
      tdfname: "addFavoriteSticker".to_string(),
      sticker: None,
      
    };
    AddFavoriteStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddFavoriteStickerBuilder {
  instance: AddFavoriteSticker
}

impl AddFavoriteStickerBuilder {
  fn new(instance: AddFavoriteSticker) -> Self { Self { instance } }

  pub fn build(&self) -> AddFavoriteSticker {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddLocalMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addLocalMessage

  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the user who will be shown as the sender of the message; may be 0 for channel posts.
  sender_user_id: Option<i32>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message.
  disable_notification: Option<bool>,
  /// The content of the message to be added.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for AddLocalMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddLocalMessage {}


impl AddLocalMessage {
  
  pub fn builder() -> AddLocalMessageBuilder {
    let instance = Self {
      tdfname: "addLocalMessage".to_string(),
      chat_id: None,
      sender_user_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      input_message_content: None,
      
    };
    AddLocalMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddLocalMessageBuilder {
  instance: AddLocalMessage
}

impl AddLocalMessageBuilder {
  fn new(instance: AddLocalMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AddLocalMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Adds a message to TDLib internal log. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddLogMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addLogMessage

  /// Minimum verbosity level needed for the message to be logged, 0-1023.
  verbosity_level: Option<i32>,
  /// Text of a message to log.
  text: Option<String>,


}




impl Function for AddLogMessage {}


impl AddLogMessage {
  
  pub fn builder() -> AddLogMessageBuilder {
    let instance = Self {
      tdfname: "addLogMessage".to_string(),
      verbosity_level: None,
      text: None,
      
    };
    AddLogMessageBuilder::new(instance)
  }
  
  
  pub fn verbosity_level(&self) -> &Option<i32> { &self.verbosity_level }
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddLogMessageBuilder {
  instance: AddLogMessage
}

impl AddLogMessageBuilder {
  fn new(instance: AddLogMessage) -> Self { Self { instance } }

  pub fn build(&self) -> AddLogMessage {
    self.instance.clone()
  }
  
  pub fn verbosity_level(&mut self, verbosity_level: i32) -> &mut Self {
    self.instance.verbosity_level = Some(verbosity_level);
    self
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// Adds the specified data to data usage statistics. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addNetworkStatistics

  /// The network statistics entry with the data to be added to statistics.
  entry: Option<Box<NetworkStatisticsEntry>>,


}


impl Clone for AddNetworkStatistics {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddNetworkStatistics {}


impl AddNetworkStatistics {
  
  pub fn builder() -> AddNetworkStatisticsBuilder {
    let instance = Self {
      tdfname: "addNetworkStatistics".to_string(),
      entry: None,
      
    };
    AddNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn entry(&self) -> &Option<Box<NetworkStatisticsEntry>> { &self.entry }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddNetworkStatisticsBuilder {
  instance: AddNetworkStatistics
}

impl AddNetworkStatisticsBuilder {
  fn new(instance: AddNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> AddNetworkStatistics {
    self.instance.clone()
  }
  
  pub fn entry(&mut self, entry: Box<NetworkStatisticsEntry>) -> &mut Self {
    self.instance.entry = Some(entry);
    self
  }
  
}


/// Adds a proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addProxy

  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,


}


impl Clone for AddProxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddProxy {}


impl AddProxy {
  
  pub fn builder() -> AddProxyBuilder {
    let instance = Self {
      tdfname: "addProxy".to_string(),
      server: None,
      port: None,
      enable: None,
      type_: None,
      
    };
    AddProxyBuilder::new(instance)
  }
  
  
  pub fn server(&self) -> &Option<String> { &self.server }
  
  pub fn port(&self) -> &Option<i32> { &self.port }
  
  pub fn enable(&self) -> &Option<bool> { &self.enable }
  
  pub fn type_(&self) -> &Option<Box<ProxyType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddProxyBuilder {
  instance: AddProxy
}

impl AddProxyBuilder {
  fn new(instance: AddProxy) -> Self { Self { instance } }

  pub fn build(&self) -> AddProxy {
    self.instance.clone()
  }
  
  pub fn server(&mut self, server: String) -> &mut Self {
    self.instance.server = Some(server);
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn enable(&mut self, enable: bool) -> &mut Self {
    self.instance.enable = Some(enable);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addRecentSticker

  /// Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to add.
  sticker: Option<Box<InputFile>>,


}


impl Clone for AddRecentSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddRecentSticker {}


impl AddRecentSticker {
  
  pub fn builder() -> AddRecentStickerBuilder {
    let instance = Self {
      tdfname: "addRecentSticker".to_string(),
      is_attached: None,
      sticker: None,
      
    };
    AddRecentStickerBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> &Option<bool> { &self.is_attached }
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddRecentStickerBuilder {
  instance: AddRecentSticker
}

impl AddRecentStickerBuilder {
  fn new(instance: AddRecentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> AddRecentSticker {
    self.instance.clone()
  }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addRecentlyFoundChat

  /// Identifier of the chat to add.
  chat_id: Option<i64>,


}




impl Function for AddRecentlyFoundChat {}


impl AddRecentlyFoundChat {
  
  pub fn builder() -> AddRecentlyFoundChatBuilder {
    let instance = Self {
      tdfname: "addRecentlyFoundChat".to_string(),
      chat_id: None,
      
    };
    AddRecentlyFoundChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddRecentlyFoundChatBuilder {
  instance: AddRecentlyFoundChat
}

impl AddRecentlyFoundChatBuilder {
  fn new(instance: AddRecentlyFoundChat) -> Self { Self { instance } }

  pub fn build(&self) -> AddRecentlyFoundChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list.
#[derive(Debug, Serialize, Deserialize)]
pub struct AddSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addSavedAnimation

  /// The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list.
  animation: Option<Box<InputFile>>,


}


impl Clone for AddSavedAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AddSavedAnimation {}


impl AddSavedAnimation {
  
  pub fn builder() -> AddSavedAnimationBuilder {
    let instance = Self {
      tdfname: "addSavedAnimation".to_string(),
      animation: None,
      
    };
    AddSavedAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Box<InputFile>> { &self.animation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddSavedAnimationBuilder {
  instance: AddSavedAnimation
}

impl AddSavedAnimationBuilder {
  fn new(instance: AddSavedAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> AddSavedAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}


/// Adds a new sticker to a set; for bots only. Returns the sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddStickerToSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // addStickerToSet

  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set name.
  name: Option<String>,
  /// Sticker to add to the set.
  sticker: Option<InputSticker>,


}




impl Function for AddStickerToSet {}


impl AddStickerToSet {
  
  pub fn builder() -> AddStickerToSetBuilder {
    let instance = Self {
      tdfname: "addStickerToSet".to_string(),
      user_id: None,
      name: None,
      sticker: None,
      
    };
    AddStickerToSetBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn sticker(&self) -> &Option<InputSticker> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AddStickerToSetBuilder {
  instance: AddStickerToSet
}

impl AddStickerToSetBuilder {
  fn new(instance: AddStickerToSet) -> Self { Self { instance } }

  pub fn build(&self) -> AddStickerToSet {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn sticker(&mut self, sticker: InputSticker) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Sets the result of a callback query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCallbackQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // answerCallbackQuery

  /// Identifier of the callback query.
  callback_query_id: Option<i64>,
  /// Text of the answer.
  text: Option<String>,
  /// If true, an alert should be shown to the user instead of a toast notification.
  show_alert: Option<bool>,
  /// URL to be opened.
  url: Option<String>,
  /// Time during which the result of the query can be cached, in seconds.
  cache_time: Option<i32>,


}




impl Function for AnswerCallbackQuery {}


impl AnswerCallbackQuery {
  
  pub fn builder() -> AnswerCallbackQueryBuilder {
    let instance = Self {
      tdfname: "answerCallbackQuery".to_string(),
      callback_query_id: None,
      text: None,
      show_alert: None,
      url: None,
      cache_time: None,
      
    };
    AnswerCallbackQueryBuilder::new(instance)
  }
  
  
  pub fn callback_query_id(&self) -> &Option<i64> { &self.callback_query_id }
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn show_alert(&self) -> &Option<bool> { &self.show_alert }
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn cache_time(&self) -> &Option<i32> { &self.cache_time }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnswerCallbackQueryBuilder {
  instance: AnswerCallbackQuery
}

impl AnswerCallbackQueryBuilder {
  fn new(instance: AnswerCallbackQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerCallbackQuery {
    self.instance.clone()
  }
  
  pub fn callback_query_id(&mut self, callback_query_id: i64) -> &mut Self {
    self.instance.callback_query_id = Some(callback_query_id);
    self
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn show_alert(&mut self, show_alert: bool) -> &mut Self {
    self.instance.show_alert = Some(show_alert);
    self
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn cache_time(&mut self, cache_time: i32) -> &mut Self {
    self.instance.cache_time = Some(cache_time);
    self
  }
  
}


/// Answers a custom query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerCustomQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // answerCustomQuery

  /// Identifier of a custom query.
  custom_query_id: Option<i64>,
  /// JSON-serialized answer to the query.
  data: Option<String>,


}




impl Function for AnswerCustomQuery {}


impl AnswerCustomQuery {
  
  pub fn builder() -> AnswerCustomQueryBuilder {
    let instance = Self {
      tdfname: "answerCustomQuery".to_string(),
      custom_query_id: None,
      data: None,
      
    };
    AnswerCustomQueryBuilder::new(instance)
  }
  
  
  pub fn custom_query_id(&self) -> &Option<i64> { &self.custom_query_id }
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnswerCustomQueryBuilder {
  instance: AnswerCustomQuery
}

impl AnswerCustomQueryBuilder {
  fn new(instance: AnswerCustomQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerCustomQuery {
    self.instance.clone()
  }
  
  pub fn custom_query_id(&mut self, custom_query_id: i64) -> &mut Self {
    self.instance.custom_query_id = Some(custom_query_id);
    self
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


/// Sets the result of an inline query; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct AnswerInlineQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // answerInlineQuery

  /// Identifier of the inline query.
  inline_query_id: Option<i64>,
  /// True, if the result of the query can be cached for the specified user.
  is_personal: Option<bool>,
  /// The results of the query.
  results: Option<Vec<Box<InputInlineQueryResult>>>,
  /// Allowed time to cache the results of the query, in seconds.
  cache_time: Option<i32>,
  /// Offset for the next inline query; pass an empty string if there are no more results.
  next_offset: Option<String>,
  /// If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter.
  switch_pm_text: Option<String>,
  /// The parameter for the bot start message.
  switch_pm_parameter: Option<String>,


}


impl Clone for AnswerInlineQuery {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for AnswerInlineQuery {}


impl AnswerInlineQuery {
  
  pub fn builder() -> AnswerInlineQueryBuilder {
    let instance = Self {
      tdfname: "answerInlineQuery".to_string(),
      inline_query_id: None,
      is_personal: None,
      results: None,
      cache_time: None,
      next_offset: None,
      switch_pm_text: None,
      switch_pm_parameter: None,
      
    };
    AnswerInlineQueryBuilder::new(instance)
  }
  
  
  pub fn inline_query_id(&self) -> &Option<i64> { &self.inline_query_id }
  
  pub fn is_personal(&self) -> &Option<bool> { &self.is_personal }
  
  pub fn results(&self) -> &Option<Vec<Box<InputInlineQueryResult>>> { &self.results }
  
  pub fn cache_time(&self) -> &Option<i32> { &self.cache_time }
  
  pub fn next_offset(&self) -> &Option<String> { &self.next_offset }
  
  pub fn switch_pm_text(&self) -> &Option<String> { &self.switch_pm_text }
  
  pub fn switch_pm_parameter(&self) -> &Option<String> { &self.switch_pm_parameter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnswerInlineQueryBuilder {
  instance: AnswerInlineQuery
}

impl AnswerInlineQueryBuilder {
  fn new(instance: AnswerInlineQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerInlineQuery {
    self.instance.clone()
  }
  
  pub fn inline_query_id(&mut self, inline_query_id: i64) -> &mut Self {
    self.instance.inline_query_id = Some(inline_query_id);
    self
  }
  
  pub fn is_personal(&mut self, is_personal: bool) -> &mut Self {
    self.instance.is_personal = Some(is_personal);
    self
  }
  
  pub fn results(&mut self, results: Vec<Box<InputInlineQueryResult>>) -> &mut Self {
    self.instance.results = Some(results);
    self
  }
  
  pub fn cache_time(&mut self, cache_time: i32) -> &mut Self {
    self.instance.cache_time = Some(cache_time);
    self
  }
  
  pub fn next_offset(&mut self, next_offset: String) -> &mut Self {
    self.instance.next_offset = Some(next_offset);
    self
  }
  
  pub fn switch_pm_text(&mut self, switch_pm_text: String) -> &mut Self {
    self.instance.switch_pm_text = Some(switch_pm_text);
    self
  }
  
  pub fn switch_pm_parameter(&mut self, switch_pm_parameter: String) -> &mut Self {
    self.instance.switch_pm_parameter = Some(switch_pm_parameter);
    self
  }
  
}


/// Sets the result of a pre-checkout query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerPreCheckoutQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // answerPreCheckoutQuery

  /// Identifier of the pre-checkout query.
  pre_checkout_query_id: Option<i64>,
  /// An error message, empty on success.
  error_message: Option<String>,


}




impl Function for AnswerPreCheckoutQuery {}


impl AnswerPreCheckoutQuery {
  
  pub fn builder() -> AnswerPreCheckoutQueryBuilder {
    let instance = Self {
      tdfname: "answerPreCheckoutQuery".to_string(),
      pre_checkout_query_id: None,
      error_message: None,
      
    };
    AnswerPreCheckoutQueryBuilder::new(instance)
  }
  
  
  pub fn pre_checkout_query_id(&self) -> &Option<i64> { &self.pre_checkout_query_id }
  
  pub fn error_message(&self) -> &Option<String> { &self.error_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnswerPreCheckoutQueryBuilder {
  instance: AnswerPreCheckoutQuery
}

impl AnswerPreCheckoutQueryBuilder {
  fn new(instance: AnswerPreCheckoutQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerPreCheckoutQuery {
    self.instance.clone()
  }
  
  pub fn pre_checkout_query_id(&mut self, pre_checkout_query_id: i64) -> &mut Self {
    self.instance.pre_checkout_query_id = Some(pre_checkout_query_id);
    self
  }
  
  pub fn error_message(&mut self, error_message: String) -> &mut Self {
    self.instance.error_message = Some(error_message);
    self
  }
  
}


/// Sets the result of a shipping query; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnswerShippingQuery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // answerShippingQuery

  /// Identifier of the shipping query.
  shipping_query_id: Option<i64>,
  /// Available shipping options.
  shipping_options: Option<Vec<ShippingOption>>,
  /// An error message, empty on success.
  error_message: Option<String>,


}




impl Function for AnswerShippingQuery {}


impl AnswerShippingQuery {
  
  pub fn builder() -> AnswerShippingQueryBuilder {
    let instance = Self {
      tdfname: "answerShippingQuery".to_string(),
      shipping_query_id: None,
      shipping_options: None,
      error_message: None,
      
    };
    AnswerShippingQueryBuilder::new(instance)
  }
  
  
  pub fn shipping_query_id(&self) -> &Option<i64> { &self.shipping_query_id }
  
  pub fn shipping_options(&self) -> &Option<Vec<ShippingOption>> { &self.shipping_options }
  
  pub fn error_message(&self) -> &Option<String> { &self.error_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct AnswerShippingQueryBuilder {
  instance: AnswerShippingQuery
}

impl AnswerShippingQueryBuilder {
  fn new(instance: AnswerShippingQuery) -> Self { Self { instance } }

  pub fn build(&self) -> AnswerShippingQuery {
    self.instance.clone()
  }
  
  pub fn shipping_query_id(&mut self, shipping_query_id: i64) -> &mut Self {
    self.instance.shipping_query_id = Some(shipping_query_id);
    self
  }
  
  pub fn shipping_options(&mut self, shipping_options: Vec<ShippingOption>) -> &mut Self {
    self.instance.shipping_options = Some(shipping_options);
    self
  }
  
  pub fn error_message(&mut self, error_message: String) -> &mut Self {
    self.instance.error_message = Some(error_message);
    self
  }
  
}


/// Adds a user to the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // blockUser

  /// User identifier.
  user_id: Option<i32>,


}




impl Function for BlockUser {}


impl BlockUser {
  
  pub fn builder() -> BlockUserBuilder {
    let instance = Self {
      tdfname: "blockUser".to_string(),
      user_id: None,
      
    };
    BlockUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct BlockUserBuilder {
  instance: BlockUser
}

impl BlockUserBuilder {
  fn new(instance: BlockUser) -> Self { Self { instance } }

  pub fn build(&self) -> BlockUser {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Stops the downloading of a file. If a file has already been downloaded, does nothing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelDownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // cancelDownloadFile

  /// Identifier of a file to stop downloading.
  file_id: Option<i32>,
  /// Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server.
  only_if_pending: Option<bool>,


}




impl Function for CancelDownloadFile {}


impl CancelDownloadFile {
  
  pub fn builder() -> CancelDownloadFileBuilder {
    let instance = Self {
      tdfname: "cancelDownloadFile".to_string(),
      file_id: None,
      only_if_pending: None,
      
    };
    CancelDownloadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  pub fn only_if_pending(&self) -> &Option<bool> { &self.only_if_pending }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CancelDownloadFileBuilder {
  instance: CancelDownloadFile
}

impl CancelDownloadFileBuilder {
  fn new(instance: CancelDownloadFile) -> Self { Self { instance } }

  pub fn build(&self) -> CancelDownloadFile {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn only_if_pending(&mut self, only_if_pending: bool) -> &mut Self {
    self.instance.only_if_pending = Some(only_if_pending);
    self
  }
  
}


/// Stops the uploading of a file. Supported only for files uploaded by using 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelUploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // cancelUploadFile

  /// Identifier of the file to stop uploading.
  file_id: Option<i32>,


}




impl Function for CancelUploadFile {}


impl CancelUploadFile {
  
  pub fn builder() -> CancelUploadFileBuilder {
    let instance = Self {
      tdfname: "cancelUploadFile".to_string(),
      file_id: None,
      
    };
    CancelUploadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CancelUploadFileBuilder {
  instance: CancelUploadFile
}

impl CancelUploadFileBuilder {
  fn new(instance: CancelUploadFile) -> Self { Self { instance } }

  pub fn build(&self) -> CancelUploadFile {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}


/// Reports to the server whether a chat is a spam chat or not. Can be used only if ChatReportSpamState.can_report_spam is true. After this request, ChatReportSpamState.can_report_spam becomes false forever.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // changeChatReportSpamState

  /// Chat identifier.
  chat_id: Option<i64>,
  /// If true, the chat will be reported as spam; otherwise it will be marked as not spam.
  is_spam_chat: Option<bool>,


}




impl Function for ChangeChatReportSpamState {}


impl ChangeChatReportSpamState {
  
  pub fn builder() -> ChangeChatReportSpamStateBuilder {
    let instance = Self {
      tdfname: "changeChatReportSpamState".to_string(),
      chat_id: None,
      is_spam_chat: None,
      
    };
    ChangeChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_spam_chat(&self) -> &Option<bool> { &self.is_spam_chat }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChangeChatReportSpamStateBuilder {
  instance: ChangeChatReportSpamState
}

impl ChangeChatReportSpamStateBuilder {
  fn new(instance: ChangeChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeChatReportSpamState {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_spam_chat(&mut self, is_spam_chat: bool) -> &mut Self {
    self.instance.is_spam_chat = Some(is_spam_chat);
    self
  }
  
}


/// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. Query result depends on the result of the previous query, so only one query is possible at the same time.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // changeImportedContacts

  /// The new list of contacts, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,


}




impl Function for ChangeImportedContacts {}


impl ChangeImportedContacts {
  
  pub fn builder() -> ChangeImportedContactsBuilder {
    let instance = Self {
      tdfname: "changeImportedContacts".to_string(),
      contacts: None,
      
    };
    ChangeImportedContactsBuilder::new(instance)
  }
  
  
  pub fn contacts(&self) -> &Option<Vec<Contact>> { &self.contacts }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChangeImportedContactsBuilder {
  instance: ChangeImportedContacts
}

impl ChangeImportedContactsBuilder {
  fn new(instance: ChangeImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeImportedContacts {
    self.instance.clone()
  }
  
  pub fn contacts(&mut self, contacts: Vec<Contact>) -> &mut Self {
    self.instance.contacts = Some(contacts);
    self
  }
  
}


/// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangePhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // changePhoneNumber

  /// The new phone number of the user in international format.
  phone_number: Option<String>,
  /// Pass true if the code can be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,


}




impl Function for ChangePhoneNumber {}


impl ChangePhoneNumber {
  
  pub fn builder() -> ChangePhoneNumberBuilder {
    let instance = Self {
      tdfname: "changePhoneNumber".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    ChangePhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn allow_flash_call(&self) -> &Option<bool> { &self.allow_flash_call }
  
  pub fn is_current_phone_number(&self) -> &Option<bool> { &self.is_current_phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChangePhoneNumberBuilder {
  instance: ChangePhoneNumber
}

impl ChangePhoneNumberBuilder {
  fn new(instance: ChangePhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> ChangePhoneNumber {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}


/// Installs/uninstalls or activates/archives a sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChangeStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // changeStickerSet

  /// Identifier of the sticker set.
  set_id: Option<i64>,
  /// The new value of is_installed.
  is_installed: Option<bool>,
  /// The new value of is_archived. A sticker set can't be installed and archived simultaneously.
  is_archived: Option<bool>,


}




impl Function for ChangeStickerSet {}


impl ChangeStickerSet {
  
  pub fn builder() -> ChangeStickerSetBuilder {
    let instance = Self {
      tdfname: "changeStickerSet".to_string(),
      set_id: None,
      is_installed: None,
      is_archived: None,
      
    };
    ChangeStickerSetBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> &Option<i64> { &self.set_id }
  
  pub fn is_installed(&self) -> &Option<bool> { &self.is_installed }
  
  pub fn is_archived(&self) -> &Option<bool> { &self.is_archived }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ChangeStickerSetBuilder {
  instance: ChangeStickerSet
}

impl ChangeStickerSetBuilder {
  fn new(instance: ChangeStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> ChangeStickerSet {
    self.instance.clone()
  }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
  pub fn is_installed(&mut self, is_installed: bool) -> &mut Self {
    self.instance.is_installed = Some(is_installed);
    self
  }
  
  pub fn is_archived(&mut self, is_archived: bool) -> &mut Self {
    self.instance.is_archived = Some(is_archived);
    self
  }
  
}


/// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationBotToken {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkAuthenticationBotToken

  /// The bot token.
  token: Option<String>,


}




impl Function for CheckAuthenticationBotToken {}


impl CheckAuthenticationBotToken {
  
  pub fn builder() -> CheckAuthenticationBotTokenBuilder {
    let instance = Self {
      tdfname: "checkAuthenticationBotToken".to_string(),
      token: None,
      
    };
    CheckAuthenticationBotTokenBuilder::new(instance)
  }
  
  
  pub fn token(&self) -> &Option<String> { &self.token }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckAuthenticationBotTokenBuilder {
  instance: CheckAuthenticationBotToken
}

impl CheckAuthenticationBotTokenBuilder {
  fn new(instance: CheckAuthenticationBotToken) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationBotToken {
    self.instance.clone()
  }
  
  pub fn token(&mut self, token: String) -> &mut Self {
    self.instance.token = Some(token);
    self
  }
  
}


/// Checks the authentication code. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkAuthenticationCode

  /// The verification code received via SMS, Telegram message, phone call, or flash call.
  code: Option<String>,
  /// If the user is not yet registered, the first name of the user; 1-64 characters. You can also pass an empty string for unregistered user there to check verification code validness. In the latter case PHONE_NUMBER_UNOCCUPIED error will be returned for a valid code.
  first_name: Option<String>,
  /// If the user is not yet registered; the last name of the user; optional; 0-64 characters.
  last_name: Option<String>,


}




impl Function for CheckAuthenticationCode {}


impl CheckAuthenticationCode {
  
  pub fn builder() -> CheckAuthenticationCodeBuilder {
    let instance = Self {
      tdfname: "checkAuthenticationCode".to_string(),
      code: None,
      first_name: None,
      last_name: None,
      
    };
    CheckAuthenticationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  pub fn first_name(&self) -> &Option<String> { &self.first_name }
  
  pub fn last_name(&self) -> &Option<String> { &self.last_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckAuthenticationCodeBuilder {
  instance: CheckAuthenticationCode
}

impl CheckAuthenticationCodeBuilder {
  fn new(instance: CheckAuthenticationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
  pub fn first_name(&mut self, first_name: String) -> &mut Self {
    self.instance.first_name = Some(first_name);
    self
  }
  
  pub fn last_name(&mut self, last_name: String) -> &mut Self {
    self.instance.last_name = Some(last_name);
    self
  }
  
}


/// Checks the authentication password for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkAuthenticationPassword

  /// The password to check.
  password: Option<String>,


}




impl Function for CheckAuthenticationPassword {}


impl CheckAuthenticationPassword {
  
  pub fn builder() -> CheckAuthenticationPasswordBuilder {
    let instance = Self {
      tdfname: "checkAuthenticationPassword".to_string(),
      password: None,
      
    };
    CheckAuthenticationPasswordBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckAuthenticationPasswordBuilder {
  instance: CheckAuthenticationPassword
}

impl CheckAuthenticationPasswordBuilder {
  fn new(instance: CheckAuthenticationPassword) -> Self { Self { instance } }

  pub fn build(&self) -> CheckAuthenticationPassword {
    self.instance.clone()
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Checks the authentication code sent to confirm a new phone number of the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChangePhoneNumberCode

  /// Verification code received by SMS, phone call or flash call.
  code: Option<String>,


}




impl Function for CheckChangePhoneNumberCode {}


impl CheckChangePhoneNumberCode {
  
  pub fn builder() -> CheckChangePhoneNumberCodeBuilder {
    let instance = Self {
      tdfname: "checkChangePhoneNumberCode".to_string(),
      code: None,
      
    };
    CheckChangePhoneNumberCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChangePhoneNumberCodeBuilder {
  instance: CheckChangePhoneNumberCode
}

impl CheckChangePhoneNumberCodeBuilder {
  fn new(instance: CheckChangePhoneNumberCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChangePhoneNumberCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
}


/// Checks the validity of an invite link for a chat and returns information about the corresponding chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatInviteLink

  /// Invite link to be checked; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,


}




impl Function for CheckChatInviteLink {}


impl CheckChatInviteLink {
  
  pub fn builder() -> CheckChatInviteLinkBuilder {
    let instance = Self {
      tdfname: "checkChatInviteLink".to_string(),
      invite_link: None,
      
    };
    CheckChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> &Option<String> { &self.invite_link }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatInviteLinkBuilder {
  instance: CheckChatInviteLink
}

impl CheckChatInviteLinkBuilder {
  fn new(instance: CheckChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatInviteLink {
    self.instance.clone()
  }
  
  pub fn invite_link(&mut self, invite_link: String) -> &mut Self {
    self.instance.invite_link = Some(invite_link);
    self
  }
  
}


/// Checks whether a username can be set for a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckChatUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkChatUsername

  /// Chat identifier; should be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if chat is being created.
  chat_id: Option<i64>,
  /// Username to be checked.
  username: Option<String>,


}




impl Function for CheckChatUsername {}


impl CheckChatUsername {
  
  pub fn builder() -> CheckChatUsernameBuilder {
    let instance = Self {
      tdfname: "checkChatUsername".to_string(),
      chat_id: None,
      username: None,
      
    };
    CheckChatUsernameBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckChatUsernameBuilder {
  instance: CheckChatUsername
}

impl CheckChatUsernameBuilder {
  fn new(instance: CheckChatUsername) -> Self { Self { instance } }

  pub fn build(&self) -> CheckChatUsername {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
}


/// Checks the database encryption key for correctness. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkDatabaseEncryptionKey

  /// Encryption key to check or set up.
  encryption_key: Option<String>,


}




impl Function for CheckDatabaseEncryptionKey {}


impl CheckDatabaseEncryptionKey {
  
  pub fn builder() -> CheckDatabaseEncryptionKeyBuilder {
    let instance = Self {
      tdfname: "checkDatabaseEncryptionKey".to_string(),
      encryption_key: None,
      
    };
    CheckDatabaseEncryptionKeyBuilder::new(instance)
  }
  
  
  pub fn encryption_key(&self) -> &Option<String> { &self.encryption_key }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckDatabaseEncryptionKeyBuilder {
  instance: CheckDatabaseEncryptionKey
}

impl CheckDatabaseEncryptionKeyBuilder {
  fn new(instance: CheckDatabaseEncryptionKey) -> Self { Self { instance } }

  pub fn build(&self) -> CheckDatabaseEncryptionKey {
    self.instance.clone()
  }
  
  pub fn encryption_key(&mut self, encryption_key: String) -> &mut Self {
    self.instance.encryption_key = Some(encryption_key);
    self
  }
  
}


/// Checks the email address verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkEmailAddressVerificationCode

  /// Verification code.
  code: Option<String>,


}




impl Function for CheckEmailAddressVerificationCode {}


impl CheckEmailAddressVerificationCode {
  
  pub fn builder() -> CheckEmailAddressVerificationCodeBuilder {
    let instance = Self {
      tdfname: "checkEmailAddressVerificationCode".to_string(),
      code: None,
      
    };
    CheckEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckEmailAddressVerificationCodeBuilder {
  instance: CheckEmailAddressVerificationCode
}

impl CheckEmailAddressVerificationCodeBuilder {
  fn new(instance: CheckEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckEmailAddressVerificationCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
}


/// Checks phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkPhoneNumberConfirmationCode

  /// The phone number confirmation code.
  code: Option<String>,


}




impl Function for CheckPhoneNumberConfirmationCode {}


impl CheckPhoneNumberConfirmationCode {
  
  pub fn builder() -> CheckPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      tdfname: "checkPhoneNumberConfirmationCode".to_string(),
      code: None,
      
    };
    CheckPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckPhoneNumberConfirmationCodeBuilder {
  instance: CheckPhoneNumberConfirmationCode
}

impl CheckPhoneNumberConfirmationCodeBuilder {
  fn new(instance: CheckPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckPhoneNumberConfirmationCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
}


/// Checks the phone number verification code for Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkPhoneNumberVerificationCode

  /// Verification code.
  code: Option<String>,


}




impl Function for CheckPhoneNumberVerificationCode {}


impl CheckPhoneNumberVerificationCode {
  
  pub fn builder() -> CheckPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      tdfname: "checkPhoneNumberVerificationCode".to_string(),
      code: None,
      
    };
    CheckPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckPhoneNumberVerificationCodeBuilder {
  instance: CheckPhoneNumberVerificationCode
}

impl CheckPhoneNumberVerificationCodeBuilder {
  fn new(instance: CheckPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckPhoneNumberVerificationCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
}


/// Checks the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CheckRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // checkRecoveryEmailAddressCode

  /// Verification code.
  code: Option<String>,


}




impl Function for CheckRecoveryEmailAddressCode {}


impl CheckRecoveryEmailAddressCode {
  
  pub fn builder() -> CheckRecoveryEmailAddressCodeBuilder {
    let instance = Self {
      tdfname: "checkRecoveryEmailAddressCode".to_string(),
      code: None,
      
    };
    CheckRecoveryEmailAddressCodeBuilder::new(instance)
  }
  
  
  pub fn code(&self) -> &Option<String> { &self.code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CheckRecoveryEmailAddressCodeBuilder {
  instance: CheckRecoveryEmailAddressCode
}

impl CheckRecoveryEmailAddressCodeBuilder {
  fn new(instance: CheckRecoveryEmailAddressCode) -> Self { Self { instance } }

  pub fn build(&self) -> CheckRecoveryEmailAddressCode {
    self.instance.clone()
  }
  
  pub fn code(&mut self, code: String) -> &mut Self {
    self.instance.code = Some(code);
    self
  }
  
}


/// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleanFileName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // cleanFileName

  /// File name or path to the file.
  file_name: Option<String>,


}




impl Function for CleanFileName {}


impl CleanFileName {
  
  pub fn builder() -> CleanFileNameBuilder {
    let instance = Self {
      tdfname: "cleanFileName".to_string(),
      file_name: None,
      
    };
    CleanFileNameBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CleanFileNameBuilder {
  instance: CleanFileName
}

impl CleanFileNameBuilder {
  fn new(instance: CleanFileName) -> Self { Self { instance } }

  pub fn build(&self) -> CleanFileName {
    self.instance.clone()
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
}


/// Clears draft messages in all chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearAllDraftMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // clearAllDraftMessages

  /// If true, local draft messages in secret chats will not be cleared.
  exclude_secret_chats: Option<bool>,


}




impl Function for ClearAllDraftMessages {}


impl ClearAllDraftMessages {
  
  pub fn builder() -> ClearAllDraftMessagesBuilder {
    let instance = Self {
      tdfname: "clearAllDraftMessages".to_string(),
      exclude_secret_chats: None,
      
    };
    ClearAllDraftMessagesBuilder::new(instance)
  }
  
  
  pub fn exclude_secret_chats(&self) -> &Option<bool> { &self.exclude_secret_chats }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ClearAllDraftMessagesBuilder {
  instance: ClearAllDraftMessages
}

impl ClearAllDraftMessagesBuilder {
  fn new(instance: ClearAllDraftMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ClearAllDraftMessages {
    self.instance.clone()
  }
  
  pub fn exclude_secret_chats(&mut self, exclude_secret_chats: bool) -> &mut Self {
    self.instance.exclude_secret_chats = Some(exclude_secret_chats);
    self
  }
  
}


/// Clears all imported contacts, contact list remains unchanged.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearImportedContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // clearImportedContacts

}




impl Function for ClearImportedContacts {}


impl ClearImportedContacts {
  
  pub fn builder() -> ClearImportedContactsBuilder {
    let instance = Self {
      tdfname: "clearImportedContacts".to_string(),
      
    };
    ClearImportedContactsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ClearImportedContactsBuilder {
  instance: ClearImportedContacts
}

impl ClearImportedContactsBuilder {
  fn new(instance: ClearImportedContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ClearImportedContacts {
    self.instance.clone()
  }
  
}


/// Clears the list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // clearRecentStickers

  /// Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers.
  is_attached: Option<bool>,


}




impl Function for ClearRecentStickers {}


impl ClearRecentStickers {
  
  pub fn builder() -> ClearRecentStickersBuilder {
    let instance = Self {
      tdfname: "clearRecentStickers".to_string(),
      is_attached: None,
      
    };
    ClearRecentStickersBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> &Option<bool> { &self.is_attached }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ClearRecentStickersBuilder {
  instance: ClearRecentStickers
}

impl ClearRecentStickersBuilder {
  fn new(instance: ClearRecentStickers) -> Self { Self { instance } }

  pub fn build(&self) -> ClearRecentStickers {
    self.instance.clone()
  }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
}


/// Clears the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClearRecentlyFoundChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // clearRecentlyFoundChats

}




impl Function for ClearRecentlyFoundChats {}


impl ClearRecentlyFoundChats {
  
  pub fn builder() -> ClearRecentlyFoundChatsBuilder {
    let instance = Self {
      tdfname: "clearRecentlyFoundChats".to_string(),
      
    };
    ClearRecentlyFoundChatsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ClearRecentlyFoundChatsBuilder {
  instance: ClearRecentlyFoundChats
}

impl ClearRecentlyFoundChatsBuilder {
  fn new(instance: ClearRecentlyFoundChats) -> Self { Self { instance } }

  pub fn build(&self) -> ClearRecentlyFoundChats {
    self.instance.clone()
  }
  
}


/// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Close {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // close

}




impl Function for Close {}


impl Close {
  
  pub fn builder() -> CloseBuilder {
    let instance = Self {
      tdfname: "close".to_string(),
      
    };
    CloseBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CloseBuilder {
  instance: Close
}

impl CloseBuilder {
  fn new(instance: Close) -> Self { Self { instance } }

  pub fn build(&self) -> Close {
    self.instance.clone()
  }
  
}


/// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // closeChat

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for CloseChat {}


impl CloseChat {
  
  pub fn builder() -> CloseChatBuilder {
    let instance = Self {
      tdfname: "closeChat".to_string(),
      chat_id: None,
      
    };
    CloseChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CloseChatBuilder {
  instance: CloseChat
}

impl CloseChatBuilder {
  fn new(instance: CloseChat) -> Self { Self { instance } }

  pub fn build(&self) -> CloseChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Closes a secret chat, effectively transfering its state to 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloseSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // closeSecretChat

  /// Secret chat identifier.
  secret_chat_id: Option<i32>,


}




impl Function for CloseSecretChat {}


impl CloseSecretChat {
  
  pub fn builder() -> CloseSecretChatBuilder {
    let instance = Self {
      tdfname: "closeSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    CloseSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> &Option<i32> { &self.secret_chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CloseSecretChatBuilder {
  instance: CloseSecretChat
}

impl CloseSecretChatBuilder {
  fn new(instance: CloseSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CloseSecretChat {
    self.instance.clone()
  }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}


/// Returns an existing chat corresponding to a known basic group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createBasicGroupChat

  /// Basic group identifier.
  basic_group_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,


}




impl Function for CreateBasicGroupChat {}


impl CreateBasicGroupChat {
  
  pub fn builder() -> CreateBasicGroupChatBuilder {
    let instance = Self {
      tdfname: "createBasicGroupChat".to_string(),
      basic_group_id: None,
      force: None,
      
    };
    CreateBasicGroupChatBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  pub fn force(&self) -> &Option<bool> { &self.force }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateBasicGroupChatBuilder {
  instance: CreateBasicGroupChat
}

impl CreateBasicGroupChatBuilder {
  fn new(instance: CreateBasicGroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateBasicGroupChat {
    self.instance.clone()
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}


/// Creates a new call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createCall

  /// Identifier of the user to be called.
  user_id: Option<i32>,
  /// Description of the call protocols supported by the client.
  protocol: Option<CallProtocol>,


}




impl Function for CreateCall {}


impl CreateCall {
  
  pub fn builder() -> CreateCallBuilder {
    let instance = Self {
      tdfname: "createCall".to_string(),
      user_id: None,
      protocol: None,
      
    };
    CreateCallBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn protocol(&self) -> &Option<CallProtocol> { &self.protocol }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateCallBuilder {
  instance: CreateCall
}

impl CreateCallBuilder {
  fn new(instance: CreateCall) -> Self { Self { instance } }

  pub fn build(&self) -> CreateCall {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn protocol(&mut self, protocol: CallProtocol) -> &mut Self {
    self.instance.protocol = Some(protocol);
    self
  }
  
}


/// Creates a new basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewBasicGroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createNewBasicGroupChat

  /// Identifiers of users to be added to the basic group.
  user_ids: Option<Vec<i32>>,
  /// Title of the new basic group; 1-128 characters.
  title: Option<String>,


}




impl Function for CreateNewBasicGroupChat {}


impl CreateNewBasicGroupChat {
  
  pub fn builder() -> CreateNewBasicGroupChatBuilder {
    let instance = Self {
      tdfname: "createNewBasicGroupChat".to_string(),
      user_ids: None,
      title: None,
      
    };
    CreateNewBasicGroupChatBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateNewBasicGroupChatBuilder {
  instance: CreateNewBasicGroupChat
}

impl CreateNewBasicGroupChatBuilder {
  fn new(instance: CreateNewBasicGroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewBasicGroupChat {
    self.instance.clone()
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// Creates a new secret chat. Returns the newly created chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createNewSecretChat

  /// Identifier of the target user.
  user_id: Option<i32>,


}




impl Function for CreateNewSecretChat {}


impl CreateNewSecretChat {
  
  pub fn builder() -> CreateNewSecretChatBuilder {
    let instance = Self {
      tdfname: "createNewSecretChat".to_string(),
      user_id: None,
      
    };
    CreateNewSecretChatBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateNewSecretChatBuilder {
  instance: CreateNewSecretChat
}

impl CreateNewSecretChatBuilder {
  fn new(instance: CreateNewSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewSecretChat {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Creates a new sticker set; for bots only. Returns the newly created sticker set.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createNewStickerSet

  /// Sticker set owner.
  user_id: Option<i32>,
  /// Sticker set title; 1-64 characters.
  title: Option<String>,
  /// Sticker set name. Can contain only English letters, digits and underscores. Must end with "by<bot username>" (<bot_username> is case insensitive); 1-64 characters.
  name: Option<String>,
  /// True, if stickers are masks.
  is_masks: Option<bool>,
  /// List of stickers to be added to the set.
  stickers: Option<Vec<InputSticker>>,


}




impl Function for CreateNewStickerSet {}


impl CreateNewStickerSet {
  
  pub fn builder() -> CreateNewStickerSetBuilder {
    let instance = Self {
      tdfname: "createNewStickerSet".to_string(),
      user_id: None,
      title: None,
      name: None,
      is_masks: None,
      stickers: None,
      
    };
    CreateNewStickerSetBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn stickers(&self) -> &Option<Vec<InputSticker>> { &self.stickers }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateNewStickerSetBuilder {
  instance: CreateNewStickerSet
}

impl CreateNewStickerSetBuilder {
  fn new(instance: CreateNewStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewStickerSet {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn stickers(&mut self, stickers: Vec<InputSticker>) -> &mut Self {
    self.instance.stickers = Some(stickers);
    self
  }
  
}


/// Creates a new supergroup or channel and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateNewSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createNewSupergroupChat

  /// Title of the new chat; 1-128 characters.
  title: Option<String>,
  /// True, if a channel chat should be created.
  is_channel: Option<bool>,
  /// Chat description; 0-255 characters.
  description: Option<String>,


}




impl Function for CreateNewSupergroupChat {}


impl CreateNewSupergroupChat {
  
  pub fn builder() -> CreateNewSupergroupChatBuilder {
    let instance = Self {
      tdfname: "createNewSupergroupChat".to_string(),
      title: None,
      is_channel: None,
      description: None,
      
    };
    CreateNewSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  pub fn is_channel(&self) -> &Option<bool> { &self.is_channel }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateNewSupergroupChatBuilder {
  instance: CreateNewSupergroupChat
}

impl CreateNewSupergroupChatBuilder {
  fn new(instance: CreateNewSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateNewSupergroupChat {
    self.instance.clone()
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
  pub fn is_channel(&mut self, is_channel: bool) -> &mut Self {
    self.instance.is_channel = Some(is_channel);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Returns an existing chat corresponding to a given user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePrivateChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createPrivateChat

  /// User identifier.
  user_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,


}




impl Function for CreatePrivateChat {}


impl CreatePrivateChat {
  
  pub fn builder() -> CreatePrivateChatBuilder {
    let instance = Self {
      tdfname: "createPrivateChat".to_string(),
      user_id: None,
      force: None,
      
    };
    CreatePrivateChatBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn force(&self) -> &Option<bool> { &self.force }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreatePrivateChatBuilder {
  instance: CreatePrivateChat
}

impl CreatePrivateChatBuilder {
  fn new(instance: CreatePrivateChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreatePrivateChat {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}


/// Returns an existing chat corresponding to a known secret chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createSecretChat

  /// Secret chat identifier.
  secret_chat_id: Option<i32>,


}




impl Function for CreateSecretChat {}


impl CreateSecretChat {
  
  pub fn builder() -> CreateSecretChatBuilder {
    let instance = Self {
      tdfname: "createSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    CreateSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> &Option<i32> { &self.secret_chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateSecretChatBuilder {
  instance: CreateSecretChat
}

impl CreateSecretChatBuilder {
  fn new(instance: CreateSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateSecretChat {
    self.instance.clone()
  }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}


/// Returns an existing chat corresponding to a known supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createSupergroupChat

  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,
  /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect.
  force: Option<bool>,


}




impl Function for CreateSupergroupChat {}


impl CreateSupergroupChat {
  
  pub fn builder() -> CreateSupergroupChatBuilder {
    let instance = Self {
      tdfname: "createSupergroupChat".to_string(),
      supergroup_id: None,
      force: None,
      
    };
    CreateSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn force(&self) -> &Option<bool> { &self.force }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateSupergroupChatBuilder {
  instance: CreateSupergroupChat
}

impl CreateSupergroupChatBuilder {
  fn new(instance: CreateSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> CreateSupergroupChat {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}


/// Creates a new temporary password for processing payments.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateTemporaryPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // createTemporaryPassword

  /// Persistent user password.
  password: Option<String>,
  /// Time during which the temporary password will be valid, in seconds; should be between 60 and 86400.
  valid_for: Option<i32>,


}




impl Function for CreateTemporaryPassword {}


impl CreateTemporaryPassword {
  
  pub fn builder() -> CreateTemporaryPasswordBuilder {
    let instance = Self {
      tdfname: "createTemporaryPassword".to_string(),
      password: None,
      valid_for: None,
      
    };
    CreateTemporaryPasswordBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  pub fn valid_for(&self) -> &Option<i32> { &self.valid_for }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct CreateTemporaryPasswordBuilder {
  instance: CreateTemporaryPassword
}

impl CreateTemporaryPasswordBuilder {
  fn new(instance: CreateTemporaryPassword) -> Self { Self { instance } }

  pub fn build(&self) -> CreateTemporaryPassword {
    self.instance.clone()
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
  pub fn valid_for(&mut self, valid_for: i32) -> &mut Self {
    self.instance.valid_for = Some(valid_for);
    self
  }
  
}


/// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteAccount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteAccount

  /// The reason why the account was deleted; optional.
  reason: Option<String>,


}




impl Function for DeleteAccount {}


impl DeleteAccount {
  
  pub fn builder() -> DeleteAccountBuilder {
    let instance = Self {
      tdfname: "deleteAccount".to_string(),
      reason: None,
      
    };
    DeleteAccountBuilder::new(instance)
  }
  
  
  pub fn reason(&self) -> &Option<String> { &self.reason }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteAccountBuilder {
  instance: DeleteAccount
}

impl DeleteAccountBuilder {
  fn new(instance: DeleteAccount) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteAccount {
    self.instance.clone()
  }
  
  pub fn reason(&mut self, reason: String) -> &mut Self {
    self.instance.reason = Some(reason);
    self
  }
  
}


/// Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteChatHistory

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Pass true if the chat should be removed from the chat list.
  remove_from_chat_list: Option<bool>,
  /// Pass true to try to delete chat history for all users.
  revoke: Option<bool>,


}




impl Function for DeleteChatHistory {}


impl DeleteChatHistory {
  
  pub fn builder() -> DeleteChatHistoryBuilder {
    let instance = Self {
      tdfname: "deleteChatHistory".to_string(),
      chat_id: None,
      remove_from_chat_list: None,
      revoke: None,
      
    };
    DeleteChatHistoryBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn remove_from_chat_list(&self) -> &Option<bool> { &self.remove_from_chat_list }
  
  pub fn revoke(&self) -> &Option<bool> { &self.revoke }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteChatHistoryBuilder {
  instance: DeleteChatHistory
}

impl DeleteChatHistoryBuilder {
  fn new(instance: DeleteChatHistory) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatHistory {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn remove_from_chat_list(&mut self, remove_from_chat_list: bool) -> &mut Self {
    self.instance.remove_from_chat_list = Some(remove_from_chat_list);
    self
  }
  
  pub fn revoke(&mut self, revoke: bool) -> &mut Self {
    self.instance.revoke = Some(revoke);
    self
  }
  
}


/// Deletes all messages sent by the specified user to a chat. Supported only in supergroups; requires can_delete_messages administrator privileges.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatMessagesFromUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteChatMessagesFromUser

  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,


}




impl Function for DeleteChatMessagesFromUser {}


impl DeleteChatMessagesFromUser {
  
  pub fn builder() -> DeleteChatMessagesFromUserBuilder {
    let instance = Self {
      tdfname: "deleteChatMessagesFromUser".to_string(),
      chat_id: None,
      user_id: None,
      
    };
    DeleteChatMessagesFromUserBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteChatMessagesFromUserBuilder {
  instance: DeleteChatMessagesFromUser
}

impl DeleteChatMessagesFromUserBuilder {
  fn new(instance: DeleteChatMessagesFromUser) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatMessagesFromUser {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteChatReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteChatReplyMarkup

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The message identifier of the used keyboard.
  message_id: Option<i64>,


}




impl Function for DeleteChatReplyMarkup {}


impl DeleteChatReplyMarkup {
  
  pub fn builder() -> DeleteChatReplyMarkupBuilder {
    let instance = Self {
      tdfname: "deleteChatReplyMarkup".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    DeleteChatReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteChatReplyMarkupBuilder {
  instance: DeleteChatReplyMarkup
}

impl DeleteChatReplyMarkupBuilder {
  fn new(instance: DeleteChatReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteChatReplyMarkup {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Deletes a file from the TDLib file cache.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteFile

  /// Identifier of the file to delete.
  file_id: Option<i32>,


}




impl Function for DeleteFile {}


impl DeleteFile {
  
  pub fn builder() -> DeleteFileBuilder {
    let instance = Self {
      tdfname: "deleteFile".to_string(),
      file_id: None,
      
    };
    DeleteFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteFileBuilder {
  instance: DeleteFile
}

impl DeleteFileBuilder {
  fn new(instance: DeleteFile) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteFile {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}


/// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteLanguagePack

  /// Identifier of the language pack to delete.
  language_pack_id: Option<String>,


}




impl Function for DeleteLanguagePack {}


impl DeleteLanguagePack {
  
  pub fn builder() -> DeleteLanguagePackBuilder {
    let instance = Self {
      tdfname: "deleteLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    DeleteLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteLanguagePackBuilder {
  instance: DeleteLanguagePack
}

impl DeleteLanguagePackBuilder {
  fn new(instance: DeleteLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteLanguagePack {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
}


/// Deletes messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteMessages

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifiers of the messages to be deleted.
  message_ids: Option<Vec<i64>>,
  /// Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats.
  revoke: Option<bool>,


}




impl Function for DeleteMessages {}


impl DeleteMessages {
  
  pub fn builder() -> DeleteMessagesBuilder {
    let instance = Self {
      tdfname: "deleteMessages".to_string(),
      chat_id: None,
      message_ids: None,
      revoke: None,
      
    };
    DeleteMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  pub fn revoke(&self) -> &Option<bool> { &self.revoke }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteMessagesBuilder {
  instance: DeleteMessages
}

impl DeleteMessagesBuilder {
  fn new(instance: DeleteMessages) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn revoke(&mut self, revoke: bool) -> &mut Self {
    self.instance.revoke = Some(revoke);
    self
  }
  
}


/// Deletes a Telegram Passport element.
#[derive(Debug, Serialize, Deserialize)]
pub struct DeletePassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deletePassportElement

  /// Element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,


}


impl Clone for DeletePassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for DeletePassportElement {}


impl DeletePassportElement {
  
  pub fn builder() -> DeletePassportElementBuilder {
    let instance = Self {
      tdfname: "deletePassportElement".to_string(),
      type_: None,
      
    };
    DeletePassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeletePassportElementBuilder {
  instance: DeletePassportElement
}

impl DeletePassportElementBuilder {
  fn new(instance: DeletePassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> DeletePassportElement {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Deletes a profile photo. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteProfilePhoto

  /// Identifier of the profile photo to delete.
  profile_photo_id: Option<i64>,


}




impl Function for DeleteProfilePhoto {}


impl DeleteProfilePhoto {
  
  pub fn builder() -> DeleteProfilePhotoBuilder {
    let instance = Self {
      tdfname: "deleteProfilePhoto".to_string(),
      profile_photo_id: None,
      
    };
    DeleteProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn profile_photo_id(&self) -> &Option<i64> { &self.profile_photo_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteProfilePhotoBuilder {
  instance: DeleteProfilePhoto
}

impl DeleteProfilePhotoBuilder {
  fn new(instance: DeleteProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteProfilePhoto {
    self.instance.clone()
  }
  
  pub fn profile_photo_id(&mut self, profile_photo_id: i64) -> &mut Self {
    self.instance.profile_photo_id = Some(profile_photo_id);
    self
  }
  
}


/// Deletes saved credentials for all payment provider bots.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedCredentials {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteSavedCredentials

}




impl Function for DeleteSavedCredentials {}


impl DeleteSavedCredentials {
  
  pub fn builder() -> DeleteSavedCredentialsBuilder {
    let instance = Self {
      tdfname: "deleteSavedCredentials".to_string(),
      
    };
    DeleteSavedCredentialsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteSavedCredentialsBuilder {
  instance: DeleteSavedCredentials
}

impl DeleteSavedCredentialsBuilder {
  fn new(instance: DeleteSavedCredentials) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSavedCredentials {
    self.instance.clone()
  }
  
}


/// Deletes saved order info.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteSavedOrderInfo

}




impl Function for DeleteSavedOrderInfo {}


impl DeleteSavedOrderInfo {
  
  pub fn builder() -> DeleteSavedOrderInfoBuilder {
    let instance = Self {
      tdfname: "deleteSavedOrderInfo".to_string(),
      
    };
    DeleteSavedOrderInfoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteSavedOrderInfoBuilder {
  instance: DeleteSavedOrderInfo
}

impl DeleteSavedOrderInfoBuilder {
  fn new(instance: DeleteSavedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSavedOrderInfo {
    self.instance.clone()
  }
  
}


/// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires creator privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeleteSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // deleteSupergroup

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,


}




impl Function for DeleteSupergroup {}


impl DeleteSupergroup {
  
  pub fn builder() -> DeleteSupergroupBuilder {
    let instance = Self {
      tdfname: "deleteSupergroup".to_string(),
      supergroup_id: None,
      
    };
    DeleteSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DeleteSupergroupBuilder {
  instance: DeleteSupergroup
}

impl DeleteSupergroupBuilder {
  fn new(instance: DeleteSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> DeleteSupergroup {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}


/// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Destroy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // destroy

}




impl Function for Destroy {}


impl Destroy {
  
  pub fn builder() -> DestroyBuilder {
    let instance = Self {
      tdfname: "destroy".to_string(),
      
    };
    DestroyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DestroyBuilder {
  instance: Destroy
}

impl DestroyBuilder {
  fn new(instance: Destroy) -> Self { Self { instance } }

  pub fn build(&self) -> Destroy {
    self.instance.clone()
  }
  
}


/// Disables the currently enabled proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // disableProxy

}




impl Function for DisableProxy {}


impl DisableProxy {
  
  pub fn builder() -> DisableProxyBuilder {
    let instance = Self {
      tdfname: "disableProxy".to_string(),
      
    };
    DisableProxyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DisableProxyBuilder {
  instance: DisableProxy
}

impl DisableProxyBuilder {
  fn new(instance: DisableProxy) -> Self { Self { instance } }

  pub fn build(&self) -> DisableProxy {
    self.instance.clone()
  }
  
}


/// Discards a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiscardCall {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // discardCall

  /// Call identifier.
  call_id: Option<i32>,
  /// True, if the user was disconnected.
  is_disconnected: Option<bool>,
  /// The call duration, in seconds.
  duration: Option<i32>,
  /// Identifier of the connection used during the call.
  connection_id: Option<i64>,


}




impl Function for DiscardCall {}


impl DiscardCall {
  
  pub fn builder() -> DiscardCallBuilder {
    let instance = Self {
      tdfname: "discardCall".to_string(),
      call_id: None,
      is_disconnected: None,
      duration: None,
      connection_id: None,
      
    };
    DiscardCallBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> &Option<i32> { &self.call_id }
  
  pub fn is_disconnected(&self) -> &Option<bool> { &self.is_disconnected }
  
  pub fn duration(&self) -> &Option<i32> { &self.duration }
  
  pub fn connection_id(&self) -> &Option<i64> { &self.connection_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DiscardCallBuilder {
  instance: DiscardCall
}

impl DiscardCallBuilder {
  fn new(instance: DiscardCall) -> Self { Self { instance } }

  pub fn build(&self) -> DiscardCall {
    self.instance.clone()
  }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn is_disconnected(&mut self, is_disconnected: bool) -> &mut Self {
    self.instance.is_disconnected = Some(is_disconnected);
    self
  }
  
  pub fn duration(&mut self, duration: i32) -> &mut Self {
    self.instance.duration = Some(duration);
    self
  }
  
  pub fn connection_id(&mut self, connection_id: i64) -> &mut Self {
    self.instance.connection_id = Some(connection_id);
    self
  }
  
}


/// Disconnects all websites from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectAllWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // disconnectAllWebsites

}




impl Function for DisconnectAllWebsites {}


impl DisconnectAllWebsites {
  
  pub fn builder() -> DisconnectAllWebsitesBuilder {
    let instance = Self {
      tdfname: "disconnectAllWebsites".to_string(),
      
    };
    DisconnectAllWebsitesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DisconnectAllWebsitesBuilder {
  instance: DisconnectAllWebsites
}

impl DisconnectAllWebsitesBuilder {
  fn new(instance: DisconnectAllWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> DisconnectAllWebsites {
    self.instance.clone()
  }
  
}


/// Disconnects website from the current user's Telegram account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisconnectWebsite {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // disconnectWebsite

  /// Website identifier.
  website_id: Option<i64>,


}




impl Function for DisconnectWebsite {}


impl DisconnectWebsite {
  
  pub fn builder() -> DisconnectWebsiteBuilder {
    let instance = Self {
      tdfname: "disconnectWebsite".to_string(),
      website_id: None,
      
    };
    DisconnectWebsiteBuilder::new(instance)
  }
  
  
  pub fn website_id(&self) -> &Option<i64> { &self.website_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DisconnectWebsiteBuilder {
  instance: DisconnectWebsite
}

impl DisconnectWebsiteBuilder {
  fn new(instance: DisconnectWebsite) -> Self { Self { instance } }

  pub fn build(&self) -> DisconnectWebsite {
    self.instance.clone()
  }
  
  pub fn website_id(&mut self, website_id: i64) -> &mut Self {
    self.instance.website_id = Some(website_id);
    self
  }
  
}


/// Downloads a file from the cloud. Download progress and completion of the download will be notified through 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // downloadFile

  /// Identifier of the file to download.
  file_id: Option<i32>,
  /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first.
  priority: Option<i32>,
  /// The starting position from which the file should be downloaded.
  offset: Option<i32>,
  /// Number of bytes which should be downloaded starting from the "offset" position before the download will be automatically cancelled; use 0 to download without a limit.
  limit: Option<i32>,
  /// If false, this request returns file state just after the download has been started. If true, this request returns file state only after the download has succeeded, has failed, has been cancelled or a new downloadFile request with different offset/limit parameters was sent.
  synchronous: Option<bool>,


}




impl Function for DownloadFile {}


impl DownloadFile {
  
  pub fn builder() -> DownloadFileBuilder {
    let instance = Self {
      tdfname: "downloadFile".to_string(),
      file_id: None,
      priority: None,
      offset: None,
      limit: None,
      synchronous: None,
      
    };
    DownloadFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  pub fn priority(&self) -> &Option<i32> { &self.priority }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn synchronous(&self) -> &Option<bool> { &self.synchronous }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct DownloadFileBuilder {
  instance: DownloadFile
}

impl DownloadFileBuilder {
  fn new(instance: DownloadFile) -> Self { Self { instance } }

  pub fn build(&self) -> DownloadFile {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn priority(&mut self, priority: i32) -> &mut Self {
    self.instance.priority = Some(priority);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn synchronous(&mut self, synchronous: bool) -> &mut Self {
    self.instance.synchronous = Some(synchronous);
    self
  }
  
}


/// Edits information about a custom local language pack in the current localization target. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditCustomLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editCustomLanguagePackInfo

  /// New information about the custom local language pack.
  info: Option<LanguagePackInfo>,


}




impl Function for EditCustomLanguagePackInfo {}


impl EditCustomLanguagePackInfo {
  
  pub fn builder() -> EditCustomLanguagePackInfoBuilder {
    let instance = Self {
      tdfname: "editCustomLanguagePackInfo".to_string(),
      info: None,
      
    };
    EditCustomLanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> &Option<LanguagePackInfo> { &self.info }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditCustomLanguagePackInfoBuilder {
  instance: EditCustomLanguagePackInfo
}

impl EditCustomLanguagePackInfoBuilder {
  fn new(instance: EditCustomLanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> EditCustomLanguagePackInfo {
    self.instance.clone()
  }
  
  pub fn info(&mut self, info: LanguagePackInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
}


/// Edits the caption of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editInlineMessageCaption

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for EditInlineMessageCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditInlineMessageCaption {}


impl EditInlineMessageCaption {
  
  pub fn builder() -> EditInlineMessageCaptionBuilder {
    let instance = Self {
      tdfname: "editInlineMessageCaption".to_string(),
      inline_message_id: None,
      reply_markup: None,
      caption: None,
      
    };
    EditInlineMessageCaptionBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditInlineMessageCaptionBuilder {
  instance: EditInlineMessageCaption
}

impl EditInlineMessageCaptionBuilder {
  fn new(instance: EditInlineMessageCaption) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageCaption {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// Edits the content of a live location in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editInlineMessageLiveLocation

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,


}


impl Clone for EditInlineMessageLiveLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditInlineMessageLiveLocation {}


impl EditInlineMessageLiveLocation {
  
  pub fn builder() -> EditInlineMessageLiveLocationBuilder {
    let instance = Self {
      tdfname: "editInlineMessageLiveLocation".to_string(),
      inline_message_id: None,
      reply_markup: None,
      location: None,
      
    };
    EditInlineMessageLiveLocationBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditInlineMessageLiveLocationBuilder {
  instance: EditInlineMessageLiveLocation
}

impl EditInlineMessageLiveLocationBuilder {
  fn new(instance: EditInlineMessageLiveLocation) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageLiveLocation {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
}


/// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editInlineMessageMedia

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for EditInlineMessageMedia {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditInlineMessageMedia {}


impl EditInlineMessageMedia {
  
  pub fn builder() -> EditInlineMessageMediaBuilder {
    let instance = Self {
      tdfname: "editInlineMessageMedia".to_string(),
      inline_message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    EditInlineMessageMediaBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditInlineMessageMediaBuilder {
  instance: EditInlineMessageMedia
}

impl EditInlineMessageMediaBuilder {
  fn new(instance: EditInlineMessageMedia) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageMedia {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Edits the reply markup of an inline message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editInlineMessageReplyMarkup

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for EditInlineMessageReplyMarkup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditInlineMessageReplyMarkup {}


impl EditInlineMessageReplyMarkup {
  
  pub fn builder() -> EditInlineMessageReplyMarkupBuilder {
    let instance = Self {
      tdfname: "editInlineMessageReplyMarkup".to_string(),
      inline_message_id: None,
      reply_markup: None,
      
    };
    EditInlineMessageReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditInlineMessageReplyMarkupBuilder {
  instance: EditInlineMessageReplyMarkup
}

impl EditInlineMessageReplyMarkupBuilder {
  fn new(instance: EditInlineMessageReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageReplyMarkup {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}


/// Edits the text of an inline text or game message sent via a bot; for bots only.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditInlineMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editInlineMessageText

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for EditInlineMessageText {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditInlineMessageText {}


impl EditInlineMessageText {
  
  pub fn builder() -> EditInlineMessageTextBuilder {
    let instance = Self {
      tdfname: "editInlineMessageText".to_string(),
      inline_message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    EditInlineMessageTextBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditInlineMessageTextBuilder {
  instance: EditInlineMessageText
}

impl EditInlineMessageTextBuilder {
  fn new(instance: EditInlineMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> EditInlineMessageText {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Edits the message content caption. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageCaption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editMessageCaption

  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New message content caption; 0-GetOption("message_caption_length_max") characters.
  caption: Option<FormattedText>,


}


impl Clone for EditMessageCaption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditMessageCaption {}


impl EditMessageCaption {
  
  pub fn builder() -> EditMessageCaptionBuilder {
    let instance = Self {
      tdfname: "editMessageCaption".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      caption: None,
      
    };
    EditMessageCaptionBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn caption(&self) -> &Option<FormattedText> { &self.caption }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditMessageCaptionBuilder {
  instance: EditMessageCaption
}

impl EditMessageCaptionBuilder {
  fn new(instance: EditMessageCaption) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageCaption {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn caption(&mut self, caption: FormattedText) -> &mut Self {
    self.instance.caption = Some(caption);
    self
  }
  
}


/// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageLiveLocation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editMessageLiveLocation

  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New location content of the message; may be null. Pass null to stop sharing the live location.
  location: Option<Location>,


}


impl Clone for EditMessageLiveLocation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditMessageLiveLocation {}


impl EditMessageLiveLocation {
  
  pub fn builder() -> EditMessageLiveLocationBuilder {
    let instance = Self {
      tdfname: "editMessageLiveLocation".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      location: None,
      
    };
    EditMessageLiveLocationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditMessageLiveLocationBuilder {
  instance: EditMessageLiveLocation
}

impl EditMessageLiveLocationBuilder {
  fn new(instance: EditMessageLiveLocation) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageLiveLocation {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
}


/// Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageMedia {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editMessageMedia

  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for EditMessageMedia {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditMessageMedia {}


impl EditMessageMedia {
  
  pub fn builder() -> EditMessageMediaBuilder {
    let instance = Self {
      tdfname: "editMessageMedia".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    EditMessageMediaBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditMessageMediaBuilder {
  instance: EditMessageMedia
}

impl EditMessageMediaBuilder {
  fn new(instance: EditMessageMedia) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageMedia {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageReplyMarkup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editMessageReplyMarkup

  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for EditMessageReplyMarkup {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditMessageReplyMarkup {}


impl EditMessageReplyMarkup {
  
  pub fn builder() -> EditMessageReplyMarkupBuilder {
    let instance = Self {
      tdfname: "editMessageReplyMarkup".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      
    };
    EditMessageReplyMarkupBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditMessageReplyMarkupBuilder {
  instance: EditMessageReplyMarkup
}

impl EditMessageReplyMarkupBuilder {
  fn new(instance: EditMessageReplyMarkup) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageReplyMarkup {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}


/// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditMessageText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editMessageText

  /// The chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// New text content of the message. Should be of type InputMessageText.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for EditMessageText {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditMessageText {}


impl EditMessageText {
  
  pub fn builder() -> EditMessageTextBuilder {
    let instance = Self {
      tdfname: "editMessageText".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    EditMessageTextBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditMessageTextBuilder {
  instance: EditMessageText
}

impl EditMessageTextBuilder {
  fn new(instance: EditMessageText) -> Self { Self { instance } }

  pub fn build(&self) -> EditMessageText {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Edits an existing proxy server for network requests. Can be called before authorization.
#[derive(Debug, Serialize, Deserialize)]
pub struct EditProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // editProxy

  /// Proxy identifier.
  proxy_id: Option<i32>,
  /// Proxy server IP address.
  server: Option<String>,
  /// Proxy server port.
  port: Option<i32>,
  /// True, if the proxy should be enabled.
  enable: Option<bool>,
  /// Proxy type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<ProxyType>>,


}


impl Clone for EditProxy {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for EditProxy {}


impl EditProxy {
  
  pub fn builder() -> EditProxyBuilder {
    let instance = Self {
      tdfname: "editProxy".to_string(),
      proxy_id: None,
      server: None,
      port: None,
      enable: None,
      type_: None,
      
    };
    EditProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> &Option<i32> { &self.proxy_id }
  
  pub fn server(&self) -> &Option<String> { &self.server }
  
  pub fn port(&self) -> &Option<i32> { &self.port }
  
  pub fn enable(&self) -> &Option<bool> { &self.enable }
  
  pub fn type_(&self) -> &Option<Box<ProxyType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EditProxyBuilder {
  instance: EditProxy
}

impl EditProxyBuilder {
  fn new(instance: EditProxy) -> Self { Self { instance } }

  pub fn build(&self) -> EditProxy {
    self.instance.clone()
  }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
  pub fn server(&mut self, server: String) -> &mut Self {
    self.instance.server = Some(server);
    self
  }
  
  pub fn port(&mut self, port: i32) -> &mut Self {
    self.instance.port = Some(port);
    self
  }
  
  pub fn enable(&mut self, enable: bool) -> &mut Self {
    self.instance.enable = Some(enable);
    self
  }
  
  pub fn type_(&mut self, type_: Box<ProxyType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnableProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // enableProxy

  /// Proxy identifier.
  proxy_id: Option<i32>,


}




impl Function for EnableProxy {}


impl EnableProxy {
  
  pub fn builder() -> EnableProxyBuilder {
    let instance = Self {
      tdfname: "enableProxy".to_string(),
      proxy_id: None,
      
    };
    EnableProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> &Option<i32> { &self.proxy_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct EnableProxyBuilder {
  instance: EnableProxy
}

impl EnableProxyBuilder {
  fn new(instance: EnableProxy) -> Self { Self { instance } }

  pub fn build(&self) -> EnableProxy {
    self.instance.clone()
  }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}


/// Finishes the file generation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FinishFileGeneration {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // finishFileGeneration

  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// If set, means that file generation has failed and should be terminated.
  error: Option<Error>,


}




impl Function for FinishFileGeneration {}


impl FinishFileGeneration {
  
  pub fn builder() -> FinishFileGenerationBuilder {
    let instance = Self {
      tdfname: "finishFileGeneration".to_string(),
      generation_id: None,
      error: None,
      
    };
    FinishFileGenerationBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> &Option<i64> { &self.generation_id }
  
  pub fn error(&self) -> &Option<Error> { &self.error }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct FinishFileGenerationBuilder {
  instance: FinishFileGeneration
}

impl FinishFileGenerationBuilder {
  fn new(instance: FinishFileGeneration) -> Self { Self { instance } }

  pub fn build(&self) -> FinishFileGeneration {
    self.instance.clone()
  }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn error(&mut self, error: Error) -> &mut Self {
    self.instance.error = Some(error);
    self
  }
  
}


/// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForwardMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // forwardMessages

  /// Identifier of the chat to which to forward messages.
  chat_id: Option<i64>,
  /// Identifier of the chat from which to forward messages.
  from_chat_id: Option<i64>,
  /// Identifiers of the messages to forward.
  message_ids: Option<Vec<i64>>,
  /// Pass true to disable notification for the message, doesn't work if messages are forwarded to a secret chat.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// True, if the messages should be grouped into an album after forwarding. For this to work, no more than 10 messages may be forwarded, and all of them must be photo or video messages.
  as_album: Option<bool>,


}




impl Function for ForwardMessages {}


impl ForwardMessages {
  
  pub fn builder() -> ForwardMessagesBuilder {
    let instance = Self {
      tdfname: "forwardMessages".to_string(),
      chat_id: None,
      from_chat_id: None,
      message_ids: None,
      disable_notification: None,
      from_background: None,
      as_album: None,
      
    };
    ForwardMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn from_chat_id(&self) -> &Option<i64> { &self.from_chat_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  pub fn from_background(&self) -> &Option<bool> { &self.from_background }
  
  pub fn as_album(&self) -> &Option<bool> { &self.as_album }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ForwardMessagesBuilder {
  instance: ForwardMessages
}

impl ForwardMessagesBuilder {
  fn new(instance: ForwardMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ForwardMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn from_chat_id(&mut self, from_chat_id: i64) -> &mut Self {
    self.instance.from_chat_id = Some(from_chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn as_album(&mut self, as_album: bool) -> &mut Self {
    self.instance.as_album = Some(as_album);
    self
  }
  
}


/// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. In basic groups this can be called only by the group's creator; in supergroups and channels this requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateChatInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // generateChatInviteLink

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for GenerateChatInviteLink {}


impl GenerateChatInviteLink {
  
  pub fn builder() -> GenerateChatInviteLinkBuilder {
    let instance = Self {
      tdfname: "generateChatInviteLink".to_string(),
      chat_id: None,
      
    };
    GenerateChatInviteLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GenerateChatInviteLinkBuilder {
  instance: GenerateChatInviteLink
}

impl GenerateChatInviteLinkBuilder {
  fn new(instance: GenerateChatInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> GenerateChatInviteLink {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getAccountTtl

}




impl Function for GetAccountTtl {}


impl GetAccountTtl {
  
  pub fn builder() -> GetAccountTtlBuilder {
    let instance = Self {
      tdfname: "getAccountTtl".to_string(),
      
    };
    GetAccountTtlBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetAccountTtlBuilder {
  instance: GetAccountTtl
}

impl GetAccountTtlBuilder {
  fn new(instance: GetAccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> GetAccountTtl {
    self.instance.clone()
  }
  
}


/// Returns all active live locations that should be updated by the client. The list is persistent across application restarts only if the message database is used.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveLiveLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getActiveLiveLocationMessages

}




impl Function for GetActiveLiveLocationMessages {}


impl GetActiveLiveLocationMessages {
  
  pub fn builder() -> GetActiveLiveLocationMessagesBuilder {
    let instance = Self {
      tdfname: "getActiveLiveLocationMessages".to_string(),
      
    };
    GetActiveLiveLocationMessagesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetActiveLiveLocationMessagesBuilder {
  instance: GetActiveLiveLocationMessages
}

impl GetActiveLiveLocationMessagesBuilder {
  fn new(instance: GetActiveLiveLocationMessages) -> Self { Self { instance } }

  pub fn build(&self) -> GetActiveLiveLocationMessages {
    self.instance.clone()
  }
  
}


/// Returns all active sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetActiveSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getActiveSessions

}




impl Function for GetActiveSessions {}


impl GetActiveSessions {
  
  pub fn builder() -> GetActiveSessionsBuilder {
    let instance = Self {
      tdfname: "getActiveSessions".to_string(),
      
    };
    GetActiveSessionsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetActiveSessionsBuilder {
  instance: GetActiveSessions
}

impl GetActiveSessionsBuilder {
  fn new(instance: GetActiveSessions) -> Self { Self { instance } }

  pub fn build(&self) -> GetActiveSessions {
    self.instance.clone()
  }
  
}


/// Returns all available Telegram Passport elements.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAllPassportElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getAllPassportElements

  /// Password of the current user.
  password: Option<String>,


}




impl Function for GetAllPassportElements {}


impl GetAllPassportElements {
  
  pub fn builder() -> GetAllPassportElementsBuilder {
    let instance = Self {
      tdfname: "getAllPassportElements".to_string(),
      password: None,
      
    };
    GetAllPassportElementsBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetAllPassportElementsBuilder {
  instance: GetAllPassportElements
}

impl GetAllPassportElementsBuilder {
  fn new(instance: GetAllPassportElements) -> Self { Self { instance } }

  pub fn build(&self) -> GetAllPassportElements {
    self.instance.clone()
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Returns application config, provided by the server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetApplicationConfig {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getApplicationConfig

}




impl Function for GetApplicationConfig {}


impl GetApplicationConfig {
  
  pub fn builder() -> GetApplicationConfigBuilder {
    let instance = Self {
      tdfname: "getApplicationConfig".to_string(),
      
    };
    GetApplicationConfigBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetApplicationConfigBuilder {
  instance: GetApplicationConfig
}

impl GetApplicationConfigBuilder {
  fn new(instance: GetApplicationConfig) -> Self { Self { instance } }

  pub fn build(&self) -> GetApplicationConfig {
    self.instance.clone()
  }
  
}


/// Returns a list of archived sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetArchivedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getArchivedStickerSets

  /// Pass true to return mask stickers sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifier of the sticker set from which to return the result.
  offset_sticker_set_id: Option<i64>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,


}




impl Function for GetArchivedStickerSets {}


impl GetArchivedStickerSets {
  
  pub fn builder() -> GetArchivedStickerSetsBuilder {
    let instance = Self {
      tdfname: "getArchivedStickerSets".to_string(),
      is_masks: None,
      offset_sticker_set_id: None,
      limit: None,
      
    };
    GetArchivedStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn offset_sticker_set_id(&self) -> &Option<i64> { &self.offset_sticker_set_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetArchivedStickerSetsBuilder {
  instance: GetArchivedStickerSets
}

impl GetArchivedStickerSetsBuilder {
  fn new(instance: GetArchivedStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetArchivedStickerSets {
    self.instance.clone()
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn offset_sticker_set_id(&mut self, offset_sticker_set_id: i64) -> &mut Self {
    self.instance.offset_sticker_set_id = Some(offset_sticker_set_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAttachedStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getAttachedStickerSets

  /// File identifier.
  file_id: Option<i32>,


}




impl Function for GetAttachedStickerSets {}


impl GetAttachedStickerSets {
  
  pub fn builder() -> GetAttachedStickerSetsBuilder {
    let instance = Self {
      tdfname: "getAttachedStickerSets".to_string(),
      file_id: None,
      
    };
    GetAttachedStickerSetsBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetAttachedStickerSetsBuilder {
  instance: GetAttachedStickerSets
}

impl GetAttachedStickerSetsBuilder {
  fn new(instance: GetAttachedStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetAttachedStickerSets {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}


/// Returns the current authorization state; this is an offline request. For informational purposes only. Use 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetAuthorizationState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getAuthorizationState

}




impl Function for GetAuthorizationState {}


impl GetAuthorizationState {
  
  pub fn builder() -> GetAuthorizationStateBuilder {
    let instance = Self {
      tdfname: "getAuthorizationState".to_string(),
      
    };
    GetAuthorizationStateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetAuthorizationStateBuilder {
  instance: GetAuthorizationState
}

impl GetAuthorizationStateBuilder {
  fn new(instance: GetAuthorizationState) -> Self { Self { instance } }

  pub fn build(&self) -> GetAuthorizationState {
    self.instance.clone()
  }
  
}


/// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getBasicGroup

  /// Basic group identifier.
  basic_group_id: Option<i32>,


}




impl Function for GetBasicGroup {}


impl GetBasicGroup {
  
  pub fn builder() -> GetBasicGroupBuilder {
    let instance = Self {
      tdfname: "getBasicGroup".to_string(),
      basic_group_id: None,
      
    };
    GetBasicGroupBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetBasicGroupBuilder {
  instance: GetBasicGroup
}

impl GetBasicGroupBuilder {
  fn new(instance: GetBasicGroup) -> Self { Self { instance } }

  pub fn build(&self) -> GetBasicGroup {
    self.instance.clone()
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}


/// Returns full information about a basic group by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBasicGroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getBasicGroupFullInfo

  /// Basic group identifier.
  basic_group_id: Option<i32>,


}




impl Function for GetBasicGroupFullInfo {}


impl GetBasicGroupFullInfo {
  
  pub fn builder() -> GetBasicGroupFullInfoBuilder {
    let instance = Self {
      tdfname: "getBasicGroupFullInfo".to_string(),
      basic_group_id: None,
      
    };
    GetBasicGroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetBasicGroupFullInfoBuilder {
  instance: GetBasicGroupFullInfo
}

impl GetBasicGroupFullInfoBuilder {
  fn new(instance: GetBasicGroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetBasicGroupFullInfo {
    self.instance.clone()
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
}


/// Returns users that were blocked by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetBlockedUsers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getBlockedUsers

  /// Number of users to skip in the result; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of users to return; up to 100.
  limit: Option<i32>,


}




impl Function for GetBlockedUsers {}


impl GetBlockedUsers {
  
  pub fn builder() -> GetBlockedUsersBuilder {
    let instance = Self {
      tdfname: "getBlockedUsers".to_string(),
      offset: None,
      limit: None,
      
    };
    GetBlockedUsersBuilder::new(instance)
  }
  
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetBlockedUsersBuilder {
  instance: GetBlockedUsers
}

impl GetBlockedUsersBuilder {
  fn new(instance: GetBlockedUsers) -> Self { Self { instance } }

  pub fn build(&self) -> GetBlockedUsers {
    self.instance.clone()
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetCallbackQueryAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getCallbackQueryAnswer

  /// Identifier of the chat with the message.
  chat_id: Option<i64>,
  /// Identifier of the message from which the query originated.
  message_id: Option<i64>,
  /// Query payload.
  payload: Option<Box<CallbackQueryPayload>>,


}


impl Clone for GetCallbackQueryAnswer {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetCallbackQueryAnswer {}


impl GetCallbackQueryAnswer {
  
  pub fn builder() -> GetCallbackQueryAnswerBuilder {
    let instance = Self {
      tdfname: "getCallbackQueryAnswer".to_string(),
      chat_id: None,
      message_id: None,
      payload: None,
      
    };
    GetCallbackQueryAnswerBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn payload(&self) -> &Option<Box<CallbackQueryPayload>> { &self.payload }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetCallbackQueryAnswerBuilder {
  instance: GetCallbackQueryAnswer
}

impl GetCallbackQueryAnswerBuilder {
  fn new(instance: GetCallbackQueryAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> GetCallbackQueryAnswer {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn payload(&mut self, payload: Box<CallbackQueryPayload>) -> &mut Self {
    self.instance.payload = Some(payload);
    self
  }
  
}


/// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChat

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for GetChat {}


impl GetChat {
  
  pub fn builder() -> GetChatBuilder {
    let instance = Self {
      tdfname: "getChat".to_string(),
      chat_id: None,
      
    };
    GetChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatBuilder {
  instance: GetChat
}

impl GetChatBuilder {
  fn new(instance: GetChat) -> Self { Self { instance } }

  pub fn build(&self) -> GetChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns a list of users who are administrators of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatAdministrators

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for GetChatAdministrators {}


impl GetChatAdministrators {
  
  pub fn builder() -> GetChatAdministratorsBuilder {
    let instance = Self {
      tdfname: "getChatAdministrators".to_string(),
      chat_id: None,
      
    };
    GetChatAdministratorsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatAdministratorsBuilder {
  instance: GetChatAdministrators
}

impl GetChatAdministratorsBuilder {
  fn new(instance: GetChatAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatAdministrators {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only in supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatEventLog {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatEventLog

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Search query by which to filter events.
  query: Option<String>,
  /// Identifier of an event from which to return results. Use 0 to get results from the latest events.
  from_event_id: Option<i64>,
  /// Maximum number of events to return; up to 100.
  limit: Option<i32>,
  /// The types of events to return. By default, all types will be returned.
  filters: Option<ChatEventLogFilters>,
  /// User identifiers by which to filter events. By default, events relating to all users will be returned.
  user_ids: Option<Vec<i32>>,


}




impl Function for GetChatEventLog {}


impl GetChatEventLog {
  
  pub fn builder() -> GetChatEventLogBuilder {
    let instance = Self {
      tdfname: "getChatEventLog".to_string(),
      chat_id: None,
      query: None,
      from_event_id: None,
      limit: None,
      filters: None,
      user_ids: None,
      
    };
    GetChatEventLogBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn from_event_id(&self) -> &Option<i64> { &self.from_event_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn filters(&self) -> &Option<ChatEventLogFilters> { &self.filters }
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatEventLogBuilder {
  instance: GetChatEventLog
}

impl GetChatEventLogBuilder {
  fn new(instance: GetChatEventLog) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatEventLog {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn from_event_id(&mut self, from_event_id: i64) -> &mut Self {
    self.instance.from_event_id = Some(from_event_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filters(&mut self, filters: ChatEventLogFilters) -> &mut Self {
    self.instance.filters = Some(filters);
    self
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatHistory {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatHistory

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater or equal to -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages that are available locally without sending network requests.
  only_local: Option<bool>,


}




impl Function for GetChatHistory {}


impl GetChatHistory {
  
  pub fn builder() -> GetChatHistoryBuilder {
    let instance = Self {
      tdfname: "getChatHistory".to_string(),
      chat_id: None,
      from_message_id: None,
      offset: None,
      limit: None,
      only_local: None,
      
    };
    GetChatHistoryBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn from_message_id(&self) -> &Option<i64> { &self.from_message_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn only_local(&self) -> &Option<bool> { &self.only_local }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatHistoryBuilder {
  instance: GetChatHistory
}

impl GetChatHistoryBuilder {
  fn new(instance: GetChatHistory) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatHistory {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn only_local(&mut self, only_local: bool) -> &mut Self {
    self.instance.only_local = Some(only_local);
    self
  }
  
}


/// Returns information about a single member of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMember {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatMember

  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,


}




impl Function for GetChatMember {}


impl GetChatMember {
  
  pub fn builder() -> GetChatMemberBuilder {
    let instance = Self {
      tdfname: "getChatMember".to_string(),
      chat_id: None,
      user_id: None,
      
    };
    GetChatMemberBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatMemberBuilder {
  instance: GetChatMember
}

impl GetChatMemberBuilder {
  fn new(instance: GetChatMember) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMember {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Returns the last message sent in a chat no later than the specified date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatMessageByDate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatMessageByDate

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Point in time (Unix timestamp) relative to which to search for messages.
  date: Option<i32>,


}




impl Function for GetChatMessageByDate {}


impl GetChatMessageByDate {
  
  pub fn builder() -> GetChatMessageByDateBuilder {
    let instance = Self {
      tdfname: "getChatMessageByDate".to_string(),
      chat_id: None,
      date: None,
      
    };
    GetChatMessageByDateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn date(&self) -> &Option<i32> { &self.date }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatMessageByDateBuilder {
  instance: GetChatMessageByDate
}

impl GetChatMessageByDateBuilder {
  fn new(instance: GetChatMessageByDate) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMessageByDate {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn date(&mut self, date: i32) -> &mut Self {
    self.instance.date = Some(date);
    self
  }
  
}


/// Returns approximate number of messages of the specified type in the chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatMessageCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatMessageCount

  /// Identifier of the chat in which to count messages.
  chat_id: Option<i64>,
  /// Filter for message content; searchMessagesFilterEmpty is unsupported in this function.
  filter: Option<Box<SearchMessagesFilter>>,
  /// If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown.
  return_local: Option<bool>,


}


impl Clone for GetChatMessageCount {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetChatMessageCount {}


impl GetChatMessageCount {
  
  pub fn builder() -> GetChatMessageCountBuilder {
    let instance = Self {
      tdfname: "getChatMessageCount".to_string(),
      chat_id: None,
      filter: None,
      return_local: None,
      
    };
    GetChatMessageCountBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn filter(&self) -> &Option<Box<SearchMessagesFilter>> { &self.filter }
  
  pub fn return_local(&self) -> &Option<bool> { &self.return_local }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatMessageCountBuilder {
  instance: GetChatMessageCount
}

impl GetChatMessageCountBuilder {
  fn new(instance: GetChatMessageCount) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatMessageCount {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
  pub fn return_local(&mut self, return_local: bool) -> &mut Self {
    self.instance.return_local = Some(return_local);
    self
  }
  
}


/// Returns list of chats with non-default notification settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetChatNotificationSettingsExceptions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatNotificationSettingsExceptions

  /// If specified, only chats from the specified scope will be returned.
  scope: Option<Box<NotificationSettingsScope>>,
  /// If true, also chats with non-default sound will be returned.
  compare_sound: Option<bool>,


}


impl Clone for GetChatNotificationSettingsExceptions {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetChatNotificationSettingsExceptions {}


impl GetChatNotificationSettingsExceptions {
  
  pub fn builder() -> GetChatNotificationSettingsExceptionsBuilder {
    let instance = Self {
      tdfname: "getChatNotificationSettingsExceptions".to_string(),
      scope: None,
      compare_sound: None,
      
    };
    GetChatNotificationSettingsExceptionsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> &Option<Box<NotificationSettingsScope>> { &self.scope }
  
  pub fn compare_sound(&self) -> &Option<bool> { &self.compare_sound }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatNotificationSettingsExceptionsBuilder {
  instance: GetChatNotificationSettingsExceptions
}

impl GetChatNotificationSettingsExceptionsBuilder {
  fn new(instance: GetChatNotificationSettingsExceptions) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatNotificationSettingsExceptions {
    self.instance.clone()
  }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
  pub fn compare_sound(&mut self, compare_sound: bool) -> &mut Self {
    self.instance.compare_sound = Some(compare_sound);
    self
  }
  
}


/// Returns information about a pinned chat message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatPinnedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatPinnedMessage

  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,


}




impl Function for GetChatPinnedMessage {}


impl GetChatPinnedMessage {
  
  pub fn builder() -> GetChatPinnedMessageBuilder {
    let instance = Self {
      tdfname: "getChatPinnedMessage".to_string(),
      chat_id: None,
      
    };
    GetChatPinnedMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatPinnedMessageBuilder {
  instance: GetChatPinnedMessage
}

impl GetChatPinnedMessageBuilder {
  fn new(instance: GetChatPinnedMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatPinnedMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns information on whether the current chat can be reported as spam.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatReportSpamState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatReportSpamState

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for GetChatReportSpamState {}


impl GetChatReportSpamState {
  
  pub fn builder() -> GetChatReportSpamStateBuilder {
    let instance = Self {
      tdfname: "getChatReportSpamState".to_string(),
      chat_id: None,
      
    };
    GetChatReportSpamStateBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatReportSpamStateBuilder {
  instance: GetChatReportSpamState
}

impl GetChatReportSpamStateBuilder {
  fn new(instance: GetChatReportSpamState) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatReportSpamState {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns URL with the chat statistics. Currently this method can be used only for channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChatStatisticsUrl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChatStatisticsUrl

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Parameters from "tg://statsrefresh?params=******" link.
  parameters: Option<String>,
  /// Pass true if a URL with the dark theme must be returned.
  is_dark: Option<bool>,


}




impl Function for GetChatStatisticsUrl {}


impl GetChatStatisticsUrl {
  
  pub fn builder() -> GetChatStatisticsUrlBuilder {
    let instance = Self {
      tdfname: "getChatStatisticsUrl".to_string(),
      chat_id: None,
      parameters: None,
      is_dark: None,
      
    };
    GetChatStatisticsUrlBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn parameters(&self) -> &Option<String> { &self.parameters }
  
  pub fn is_dark(&self) -> &Option<bool> { &self.is_dark }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatStatisticsUrlBuilder {
  instance: GetChatStatisticsUrl
}

impl GetChatStatisticsUrlBuilder {
  fn new(instance: GetChatStatisticsUrl) -> Self { Self { instance } }

  pub fn build(&self) -> GetChatStatisticsUrl {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn parameters(&mut self, parameters: String) -> &mut Self {
    self.instance.parameters = Some(parameters);
    self
  }
  
  pub fn is_dark(&mut self, is_dark: bool) -> &mut Self {
    self.instance.is_dark = Some(is_dark);
    self
  }
  
}


/// Returns an ordered list of chats. Chats are sorted by the pair (order, chat_id) in decreasing order. (For example, to get a list of chats from the beginning, the offset_order should be equal to a biggest signed 64-bit number 9223372036854775807 == 2^63 - 1). For optimal performance the number of returned chats is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getChats

  /// Chat order to return chats from.
  offset_order: Option<i64>,
  /// Chat identifier to return chats from.
  offset_chat_id: Option<i64>,
  /// The maximum number of chats to be returned. It is possible that fewer chats than the limit are returned even if the end of the list is not reached.
  limit: Option<i32>,


}




impl Function for GetChats {}


impl GetChats {
  
  pub fn builder() -> GetChatsBuilder {
    let instance = Self {
      tdfname: "getChats".to_string(),
      offset_order: None,
      offset_chat_id: None,
      limit: None,
      
    };
    GetChatsBuilder::new(instance)
  }
  
  
  pub fn offset_order(&self) -> &Option<i64> { &self.offset_order }
  
  pub fn offset_chat_id(&self) -> &Option<i64> { &self.offset_chat_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetChatsBuilder {
  instance: GetChats
}

impl GetChatsBuilder {
  fn new(instance: GetChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetChats {
    self.instance.clone()
  }
  
  pub fn offset_order(&mut self, offset_order: i64) -> &mut Self {
    self.instance.offset_order = Some(offset_order);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns all website where the current user used Telegram to log in.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetConnectedWebsites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getConnectedWebsites

}




impl Function for GetConnectedWebsites {}


impl GetConnectedWebsites {
  
  pub fn builder() -> GetConnectedWebsitesBuilder {
    let instance = Self {
      tdfname: "getConnectedWebsites".to_string(),
      
    };
    GetConnectedWebsitesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetConnectedWebsitesBuilder {
  instance: GetConnectedWebsites
}

impl GetConnectedWebsitesBuilder {
  fn new(instance: GetConnectedWebsites) -> Self { Self { instance } }

  pub fn build(&self) -> GetConnectedWebsites {
    self.instance.clone()
  }
  
}


/// Returns all user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getContacts

}




impl Function for GetContacts {}


impl GetContacts {
  
  pub fn builder() -> GetContactsBuilder {
    let instance = Self {
      tdfname: "getContacts".to_string(),
      
    };
    GetContactsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetContactsBuilder {
  instance: GetContacts
}

impl GetContactsBuilder {
  fn new(instance: GetContacts) -> Self { Self { instance } }

  pub fn build(&self) -> GetContacts {
    self.instance.clone()
  }
  
}


/// Uses current user IP to found his country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCountryCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getCountryCode

}




impl Function for GetCountryCode {}


impl GetCountryCode {
  
  pub fn builder() -> GetCountryCodeBuilder {
    let instance = Self {
      tdfname: "getCountryCode".to_string(),
      
    };
    GetCountryCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetCountryCodeBuilder {
  instance: GetCountryCode
}

impl GetCountryCodeBuilder {
  fn new(instance: GetCountryCode) -> Self { Self { instance } }

  pub fn build(&self) -> GetCountryCode {
    self.instance.clone()
  }
  
}


/// Returns a list of public chats created by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCreatedPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getCreatedPublicChats

}




impl Function for GetCreatedPublicChats {}


impl GetCreatedPublicChats {
  
  pub fn builder() -> GetCreatedPublicChatsBuilder {
    let instance = Self {
      tdfname: "getCreatedPublicChats".to_string(),
      
    };
    GetCreatedPublicChatsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetCreatedPublicChatsBuilder {
  instance: GetCreatedPublicChats
}

impl GetCreatedPublicChatsBuilder {
  fn new(instance: GetCreatedPublicChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetCreatedPublicChats {
    self.instance.clone()
  }
  
}


/// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially usefull if TDLib is run in a separate process. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetCurrentState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getCurrentState

}




impl Function for GetCurrentState {}


impl GetCurrentState {
  
  pub fn builder() -> GetCurrentStateBuilder {
    let instance = Self {
      tdfname: "getCurrentState".to_string(),
      
    };
    GetCurrentStateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetCurrentStateBuilder {
  instance: GetCurrentState
}

impl GetCurrentStateBuilder {
  fn new(instance: GetCurrentState) -> Self { Self { instance } }

  pub fn build(&self) -> GetCurrentState {
    self.instance.clone()
  }
  
}


/// Returns database statistics.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDatabaseStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getDatabaseStatistics

}




impl Function for GetDatabaseStatistics {}


impl GetDatabaseStatistics {
  
  pub fn builder() -> GetDatabaseStatisticsBuilder {
    let instance = Self {
      tdfname: "getDatabaseStatistics".to_string(),
      
    };
    GetDatabaseStatisticsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetDatabaseStatisticsBuilder {
  instance: GetDatabaseStatistics
}

impl GetDatabaseStatisticsBuilder {
  fn new(instance: GetDatabaseStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetDatabaseStatistics {
    self.instance.clone()
  }
  
}


/// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetDeepLinkInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getDeepLinkInfo

  /// The link.
  link: Option<String>,


}




impl Function for GetDeepLinkInfo {}


impl GetDeepLinkInfo {
  
  pub fn builder() -> GetDeepLinkInfoBuilder {
    let instance = Self {
      tdfname: "getDeepLinkInfo".to_string(),
      link: None,
      
    };
    GetDeepLinkInfoBuilder::new(instance)
  }
  
  
  pub fn link(&self) -> &Option<String> { &self.link }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetDeepLinkInfoBuilder {
  instance: GetDeepLinkInfo
}

impl GetDeepLinkInfoBuilder {
  fn new(instance: GetDeepLinkInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetDeepLinkInfo {
    self.instance.clone()
  }
  
  pub fn link(&mut self, link: String) -> &mut Self {
    self.instance.link = Some(link);
    self
  }
  
}


/// Returns favorite stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFavoriteStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getFavoriteStickers

}




impl Function for GetFavoriteStickers {}


impl GetFavoriteStickers {
  
  pub fn builder() -> GetFavoriteStickersBuilder {
    let instance = Self {
      tdfname: "getFavoriteStickers".to_string(),
      
    };
    GetFavoriteStickersBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetFavoriteStickersBuilder {
  instance: GetFavoriteStickers
}

impl GetFavoriteStickersBuilder {
  fn new(instance: GetFavoriteStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetFavoriteStickers {
    self.instance.clone()
  }
  
}


/// Returns information about a file; this is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getFile

  /// Identifier of the file to get.
  file_id: Option<i32>,


}




impl Function for GetFile {}


impl GetFile {
  
  pub fn builder() -> GetFileBuilder {
    let instance = Self {
      tdfname: "getFile".to_string(),
      file_id: None,
      
    };
    GetFileBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetFileBuilder {
  instance: GetFile
}

impl GetFileBuilder {
  fn new(instance: GetFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetFile {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
}


/// Returns file downloaded prefix size from a given offset.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileDownloadedPrefixSize {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getFileDownloadedPrefixSize

  /// Identifier of the file.
  file_id: Option<i32>,
  /// Offset from which downloaded prefix size should be calculated.
  offset: Option<i32>,


}




impl Function for GetFileDownloadedPrefixSize {}


impl GetFileDownloadedPrefixSize {
  
  pub fn builder() -> GetFileDownloadedPrefixSizeBuilder {
    let instance = Self {
      tdfname: "getFileDownloadedPrefixSize".to_string(),
      file_id: None,
      offset: None,
      
    };
    GetFileDownloadedPrefixSizeBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetFileDownloadedPrefixSizeBuilder {
  instance: GetFileDownloadedPrefixSize
}

impl GetFileDownloadedPrefixSizeBuilder {
  fn new(instance: GetFileDownloadedPrefixSize) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileDownloadedPrefixSize {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
}


/// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileExtension {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getFileExtension

  /// The MIME type of the file.
  mime_type: Option<String>,


}




impl Function for GetFileExtension {}


impl GetFileExtension {
  
  pub fn builder() -> GetFileExtensionBuilder {
    let instance = Self {
      tdfname: "getFileExtension".to_string(),
      mime_type: None,
      
    };
    GetFileExtensionBuilder::new(instance)
  }
  
  
  pub fn mime_type(&self) -> &Option<String> { &self.mime_type }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetFileExtensionBuilder {
  instance: GetFileExtension
}

impl GetFileExtensionBuilder {
  fn new(instance: GetFileExtension) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileExtension {
    self.instance.clone()
  }
  
  pub fn mime_type(&mut self, mime_type: String) -> &mut Self {
    self.instance.mime_type = Some(mime_type);
    self
  }
  
}


/// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetFileMimeType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getFileMimeType

  /// The name of the file or path to the file.
  file_name: Option<String>,


}




impl Function for GetFileMimeType {}


impl GetFileMimeType {
  
  pub fn builder() -> GetFileMimeTypeBuilder {
    let instance = Self {
      tdfname: "getFileMimeType".to_string(),
      file_name: None,
      
    };
    GetFileMimeTypeBuilder::new(instance)
  }
  
  
  pub fn file_name(&self) -> &Option<String> { &self.file_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetFileMimeTypeBuilder {
  instance: GetFileMimeType
}

impl GetFileMimeTypeBuilder {
  fn new(instance: GetFileMimeType) -> Self { Self { instance } }

  pub fn build(&self) -> GetFileMimeType {
    self.instance.clone()
  }
  
  pub fn file_name(&mut self, file_name: String) -> &mut Self {
    self.instance.file_name = Some(file_name);
    self
  }
  
}


/// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getGameHighScores

  /// The chat that contains the message with the game.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,


}




impl Function for GetGameHighScores {}


impl GetGameHighScores {
  
  pub fn builder() -> GetGameHighScoresBuilder {
    let instance = Self {
      tdfname: "getGameHighScores".to_string(),
      chat_id: None,
      message_id: None,
      user_id: None,
      
    };
    GetGameHighScoresBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetGameHighScoresBuilder {
  instance: GetGameHighScores
}

impl GetGameHighScoresBuilder {
  fn new(instance: GetGameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GetGameHighScores {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetGroupsInCommon {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getGroupsInCommon

  /// User identifier.
  user_id: Option<i32>,
  /// Chat identifier starting from which to return chats; use 0 for the first request.
  offset_chat_id: Option<i64>,
  /// Maximum number of chats to be returned; up to 100.
  limit: Option<i32>,


}




impl Function for GetGroupsInCommon {}


impl GetGroupsInCommon {
  
  pub fn builder() -> GetGroupsInCommonBuilder {
    let instance = Self {
      tdfname: "getGroupsInCommon".to_string(),
      user_id: None,
      offset_chat_id: None,
      limit: None,
      
    };
    GetGroupsInCommonBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn offset_chat_id(&self) -> &Option<i64> { &self.offset_chat_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetGroupsInCommonBuilder {
  instance: GetGroupsInCommon
}

impl GetGroupsInCommonBuilder {
  fn new(instance: GetGroupsInCommon) -> Self { Self { instance } }

  pub fn build(&self) -> GetGroupsInCommon {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns the total number of imported contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetImportedContactCount {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getImportedContactCount

}




impl Function for GetImportedContactCount {}


impl GetImportedContactCount {
  
  pub fn builder() -> GetImportedContactCountBuilder {
    let instance = Self {
      tdfname: "getImportedContactCount".to_string(),
      
    };
    GetImportedContactCountBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetImportedContactCountBuilder {
  instance: GetImportedContactCount
}

impl GetImportedContactCountBuilder {
  fn new(instance: GetImportedContactCount) -> Self { Self { instance } }

  pub fn build(&self) -> GetImportedContactCount {
    self.instance.clone()
  }
  
}


/// Returns game high scores and some part of the high score table in the range of the specified user; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineGameHighScores {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getInlineGameHighScores

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// User identifier.
  user_id: Option<i32>,


}




impl Function for GetInlineGameHighScores {}


impl GetInlineGameHighScores {
  
  pub fn builder() -> GetInlineGameHighScoresBuilder {
    let instance = Self {
      tdfname: "getInlineGameHighScores".to_string(),
      inline_message_id: None,
      user_id: None,
      
    };
    GetInlineGameHighScoresBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetInlineGameHighScoresBuilder {
  instance: GetInlineGameHighScores
}

impl GetInlineGameHighScoresBuilder {
  fn new(instance: GetInlineGameHighScores) -> Self { Self { instance } }

  pub fn build(&self) -> GetInlineGameHighScores {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInlineQueryResults {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getInlineQueryResults

  /// The identifier of the target bot.
  bot_user_id: Option<i32>,
  /// Identifier of the chat, where the query was sent.
  chat_id: Option<i64>,
  /// Location of the user, only if needed.
  user_location: Option<Location>,
  /// Text of the query.
  query: Option<String>,
  /// Offset of the first entry to return.
  offset: Option<String>,


}




impl Function for GetInlineQueryResults {}


impl GetInlineQueryResults {
  
  pub fn builder() -> GetInlineQueryResultsBuilder {
    let instance = Self {
      tdfname: "getInlineQueryResults".to_string(),
      bot_user_id: None,
      chat_id: None,
      user_location: None,
      query: None,
      offset: None,
      
    };
    GetInlineQueryResultsBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> &Option<i32> { &self.bot_user_id }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_location(&self) -> &Option<Location> { &self.user_location }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn offset(&self) -> &Option<String> { &self.offset }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetInlineQueryResultsBuilder {
  instance: GetInlineQueryResults
}

impl GetInlineQueryResultsBuilder {
  fn new(instance: GetInlineQueryResults) -> Self { Self { instance } }

  pub fn build(&self) -> GetInlineQueryResults {
    self.instance.clone()
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_location(&mut self, user_location: Location) -> &mut Self {
    self.instance.user_location = Some(user_location);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn offset(&mut self, offset: String) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
}


/// Returns a list of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getInstalledStickerSets

  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,


}




impl Function for GetInstalledStickerSets {}


impl GetInstalledStickerSets {
  
  pub fn builder() -> GetInstalledStickerSetsBuilder {
    let instance = Self {
      tdfname: "getInstalledStickerSets".to_string(),
      is_masks: None,
      
    };
    GetInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetInstalledStickerSetsBuilder {
  instance: GetInstalledStickerSets
}

impl GetInstalledStickerSetsBuilder {
  fn new(instance: GetInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetInstalledStickerSets {
    self.instance.clone()
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
}


/// Returns the default text for invitation messages to be used as a placeholder when the current user invites friends to Telegram.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetInviteText {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getInviteText

}




impl Function for GetInviteText {}


impl GetInviteText {
  
  pub fn builder() -> GetInviteTextBuilder {
    let instance = Self {
      tdfname: "getInviteText".to_string(),
      
    };
    GetInviteTextBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetInviteTextBuilder {
  instance: GetInviteText
}

impl GetInviteTextBuilder {
  fn new(instance: GetInviteText) -> Self { Self { instance } }

  pub fn build(&self) -> GetInviteText {
    self.instance.clone()
  }
  
}


/// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLanguagePackInfo

  /// Language pack identifier.
  language_pack_id: Option<String>,


}




impl Function for GetLanguagePackInfo {}


impl GetLanguagePackInfo {
  
  pub fn builder() -> GetLanguagePackInfoBuilder {
    let instance = Self {
      tdfname: "getLanguagePackInfo".to_string(),
      language_pack_id: None,
      
    };
    GetLanguagePackInfoBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLanguagePackInfoBuilder {
  instance: GetLanguagePackInfo
}

impl GetLanguagePackInfoBuilder {
  fn new(instance: GetLanguagePackInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackInfo {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
}


/// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLanguagePackString

  /// Path to the language pack database in which strings are stored.
  language_pack_database_path: Option<String>,
  /// Localization target to which the language pack belongs.
  localization_target: Option<String>,
  /// Language pack identifier.
  language_pack_id: Option<String>,
  /// Language pack key of the string to be returned.
  key: Option<String>,


}




impl Function for GetLanguagePackString {}


impl GetLanguagePackString {
  
  pub fn builder() -> GetLanguagePackStringBuilder {
    let instance = Self {
      tdfname: "getLanguagePackString".to_string(),
      language_pack_database_path: None,
      localization_target: None,
      language_pack_id: None,
      key: None,
      
    };
    GetLanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn language_pack_database_path(&self) -> &Option<String> { &self.language_pack_database_path }
  
  pub fn localization_target(&self) -> &Option<String> { &self.localization_target }
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  pub fn key(&self) -> &Option<String> { &self.key }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLanguagePackStringBuilder {
  instance: GetLanguagePackString
}

impl GetLanguagePackStringBuilder {
  fn new(instance: GetLanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackString {
    self.instance.clone()
  }
  
  pub fn language_pack_database_path(&mut self, language_pack_database_path: String) -> &mut Self {
    self.instance.language_pack_database_path = Some(language_pack_database_path);
    self
  }
  
  pub fn localization_target(&mut self, localization_target: String) -> &mut Self {
    self.instance.localization_target = Some(localization_target);
    self
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
  pub fn key(&mut self, key: String) -> &mut Self {
    self.instance.key = Some(key);
    self
  }
  
}


/// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLanguagePackStrings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLanguagePackStrings

  /// Language pack identifier of the strings to be returned.
  language_pack_id: Option<String>,
  /// Language pack keys of the strings to be returned; leave empty to request all available strings.
  keys: Option<Vec<String>>,


}




impl Function for GetLanguagePackStrings {}


impl GetLanguagePackStrings {
  
  pub fn builder() -> GetLanguagePackStringsBuilder {
    let instance = Self {
      tdfname: "getLanguagePackStrings".to_string(),
      language_pack_id: None,
      keys: None,
      
    };
    GetLanguagePackStringsBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  pub fn keys(&self) -> &Option<Vec<String>> { &self.keys }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLanguagePackStringsBuilder {
  instance: GetLanguagePackStrings
}

impl GetLanguagePackStringsBuilder {
  fn new(instance: GetLanguagePackStrings) -> Self { Self { instance } }

  pub fn build(&self) -> GetLanguagePackStrings {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
  pub fn keys(&mut self, keys: Vec<String>) -> &mut Self {
    self.instance.keys = Some(keys);
    self
  }
  
}


/// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLocalizationTargetInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLocalizationTargetInfo

  /// If true, returns only locally available information without sending network requests.
  only_local: Option<bool>,


}




impl Function for GetLocalizationTargetInfo {}


impl GetLocalizationTargetInfo {
  
  pub fn builder() -> GetLocalizationTargetInfoBuilder {
    let instance = Self {
      tdfname: "getLocalizationTargetInfo".to_string(),
      only_local: None,
      
    };
    GetLocalizationTargetInfoBuilder::new(instance)
  }
  
  
  pub fn only_local(&self) -> &Option<bool> { &self.only_local }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLocalizationTargetInfoBuilder {
  instance: GetLocalizationTargetInfo
}

impl GetLocalizationTargetInfoBuilder {
  fn new(instance: GetLocalizationTargetInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetLocalizationTargetInfo {
    self.instance.clone()
  }
  
  pub fn only_local(&mut self, only_local: bool) -> &mut Self {
    self.instance.only_local = Some(only_local);
    self
  }
  
}


/// Returns information about currently used log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLogStream

}




impl Function for GetLogStream {}


impl GetLogStream {
  
  pub fn builder() -> GetLogStreamBuilder {
    let instance = Self {
      tdfname: "getLogStream".to_string(),
      
    };
    GetLogStreamBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLogStreamBuilder {
  instance: GetLogStream
}

impl GetLogStreamBuilder {
  fn new(instance: GetLogStream) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogStream {
    self.instance.clone()
  }
  
}


/// Returns current verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLogTagVerbosityLevel

  /// Logging tag to change verbosity level.
  tag: Option<String>,


}




impl Function for GetLogTagVerbosityLevel {}


impl GetLogTagVerbosityLevel {
  
  pub fn builder() -> GetLogTagVerbosityLevelBuilder {
    let instance = Self {
      tdfname: "getLogTagVerbosityLevel".to_string(),
      tag: None,
      
    };
    GetLogTagVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn tag(&self) -> &Option<String> { &self.tag }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLogTagVerbosityLevelBuilder {
  instance: GetLogTagVerbosityLevel
}

impl GetLogTagVerbosityLevelBuilder {
  fn new(instance: GetLogTagVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogTagVerbosityLevel {
    self.instance.clone()
  }
  
  pub fn tag(&mut self, tag: String) -> &mut Self {
    self.instance.tag = Some(tag);
    self
  }
  
}


/// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogTags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLogTags

}




impl Function for GetLogTags {}


impl GetLogTags {
  
  pub fn builder() -> GetLogTagsBuilder {
    let instance = Self {
      tdfname: "getLogTags".to_string(),
      
    };
    GetLogTagsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLogTagsBuilder {
  instance: GetLogTags
}

impl GetLogTagsBuilder {
  fn new(instance: GetLogTags) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogTags {
    self.instance.clone()
  }
  
}


/// Returns current verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getLogVerbosityLevel

}




impl Function for GetLogVerbosityLevel {}


impl GetLogVerbosityLevel {
  
  pub fn builder() -> GetLogVerbosityLevelBuilder {
    let instance = Self {
      tdfname: "getLogVerbosityLevel".to_string(),
      
    };
    GetLogVerbosityLevelBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetLogVerbosityLevelBuilder {
  instance: GetLogVerbosityLevel
}

impl GetLogVerbosityLevelBuilder {
  fn new(instance: GetLogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> GetLogVerbosityLevel {
    self.instance.clone()
  }
  
}


/// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMapThumbnailFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMapThumbnailFile

  /// Location of the map center.
  location: Option<Location>,
  /// Map zoom level; 13-20.
  zoom: Option<i32>,
  /// Map width in pixels before applying scale; 16-1024.
  width: Option<i32>,
  /// Map height in pixels before applying scale; 16-1024.
  height: Option<i32>,
  /// Map scale; 1-3.
  scale: Option<i32>,
  /// Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown.
  chat_id: Option<i64>,


}




impl Function for GetMapThumbnailFile {}


impl GetMapThumbnailFile {
  
  pub fn builder() -> GetMapThumbnailFileBuilder {
    let instance = Self {
      tdfname: "getMapThumbnailFile".to_string(),
      location: None,
      zoom: None,
      width: None,
      height: None,
      scale: None,
      chat_id: None,
      
    };
    GetMapThumbnailFileBuilder::new(instance)
  }
  
  
  pub fn location(&self) -> &Option<Location> { &self.location }
  
  pub fn zoom(&self) -> &Option<i32> { &self.zoom }
  
  pub fn width(&self) -> &Option<i32> { &self.width }
  
  pub fn height(&self) -> &Option<i32> { &self.height }
  
  pub fn scale(&self) -> &Option<i32> { &self.scale }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMapThumbnailFileBuilder {
  instance: GetMapThumbnailFile
}

impl GetMapThumbnailFileBuilder {
  fn new(instance: GetMapThumbnailFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetMapThumbnailFile {
    self.instance.clone()
  }
  
  pub fn location(&mut self, location: Location) -> &mut Self {
    self.instance.location = Some(location);
    self
  }
  
  pub fn zoom(&mut self, zoom: i32) -> &mut Self {
    self.instance.zoom = Some(zoom);
    self
  }
  
  pub fn width(&mut self, width: i32) -> &mut Self {
    self.instance.width = Some(width);
    self
  }
  
  pub fn height(&mut self, height: i32) -> &mut Self {
    self.instance.height = Some(height);
    self
  }
  
  pub fn scale(&mut self, scale: i32) -> &mut Self {
    self.instance.scale = Some(scale);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Returns the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMe {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMe

}




impl Function for GetMe {}


impl GetMe {
  
  pub fn builder() -> GetMeBuilder {
    let instance = Self {
      tdfname: "getMe".to_string(),
      
    };
    GetMeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMeBuilder {
  instance: GetMe
}

impl GetMeBuilder {
  fn new(instance: GetMe) -> Self { Self { instance } }

  pub fn build(&self) -> GetMe {
    self.instance.clone()
  }
  
}


/// Returns information about a message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMessage

  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,


}




impl Function for GetMessage {}


impl GetMessage {
  
  pub fn builder() -> GetMessageBuilder {
    let instance = Self {
      tdfname: "getMessage".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMessageBuilder {
  instance: GetMessage
}

impl GetMessageBuilder {
  fn new(instance: GetMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns a private HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels. The link will work only for members of the chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMessageLink

  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,


}




impl Function for GetMessageLink {}


impl GetMessageLink {
  
  pub fn builder() -> GetMessageLinkBuilder {
    let instance = Self {
      tdfname: "getMessageLink".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetMessageLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMessageLinkBuilder {
  instance: GetMessageLink
}

impl GetMessageLinkBuilder {
  fn new(instance: GetMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessageLink {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns information about a message, if it is available locally without sending network request. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessageLocally {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMessageLocally

  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message to get.
  message_id: Option<i64>,


}




impl Function for GetMessageLocally {}


impl GetMessageLocally {
  
  pub fn builder() -> GetMessageLocallyBuilder {
    let instance = Self {
      tdfname: "getMessageLocally".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetMessageLocallyBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMessageLocallyBuilder {
  instance: GetMessageLocally
}

impl GetMessageLocallyBuilder {
  fn new(instance: GetMessageLocally) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessageLocally {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns information about messages. If a message is not found, returns null on the corresponding position of the result.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getMessages

  /// Identifier of the chat the messages belong to.
  chat_id: Option<i64>,
  /// Identifiers of the messages to get.
  message_ids: Option<Vec<i64>>,


}




impl Function for GetMessages {}


impl GetMessages {
  
  pub fn builder() -> GetMessagesBuilder {
    let instance = Self {
      tdfname: "getMessages".to_string(),
      chat_id: None,
      message_ids: None,
      
    };
    GetMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetMessagesBuilder {
  instance: GetMessages
}

impl GetMessagesBuilder {
  fn new(instance: GetMessages) -> Self { Self { instance } }

  pub fn build(&self) -> GetMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}


/// Returns network data usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getNetworkStatistics

  /// If true, returns only data for the current library launch.
  only_current: Option<bool>,


}




impl Function for GetNetworkStatistics {}


impl GetNetworkStatistics {
  
  pub fn builder() -> GetNetworkStatisticsBuilder {
    let instance = Self {
      tdfname: "getNetworkStatistics".to_string(),
      only_current: None,
      
    };
    GetNetworkStatisticsBuilder::new(instance)
  }
  
  
  pub fn only_current(&self) -> &Option<bool> { &self.only_current }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetNetworkStatisticsBuilder {
  instance: GetNetworkStatistics
}

impl GetNetworkStatisticsBuilder {
  fn new(instance: GetNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetNetworkStatistics {
    self.instance.clone()
  }
  
  pub fn only_current(&mut self, only_current: bool) -> &mut Self {
    self.instance.only_current = Some(only_current);
    self
  }
  
}


/// Returns the value of an option by its name. (Check the list of available options on 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getOption

  /// The name of the option.
  name: Option<String>,


}




impl Function for GetOption {}


impl GetOption {
  
  pub fn builder() -> GetOptionBuilder {
    let instance = Self {
      tdfname: "getOption".to_string(),
      name: None,
      
    };
    GetOptionBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetOptionBuilder {
  instance: GetOption
}

impl GetOptionBuilder {
  fn new(instance: GetOption) -> Self { Self { instance } }

  pub fn build(&self) -> GetOption {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
}


/// Returns a Telegram Passport authorization form for sharing data with a service.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPassportAuthorizationForm

  /// User identifier of the service's bot.
  bot_user_id: Option<i32>,
  /// Telegram Passport element types requested by the service.
  scope: Option<String>,
  /// Service's public_key.
  public_key: Option<String>,
  /// Authorization form nonce provided by the service.
  nonce: Option<String>,


}




impl Function for GetPassportAuthorizationForm {}


impl GetPassportAuthorizationForm {
  
  pub fn builder() -> GetPassportAuthorizationFormBuilder {
    let instance = Self {
      tdfname: "getPassportAuthorizationForm".to_string(),
      bot_user_id: None,
      scope: None,
      public_key: None,
      nonce: None,
      
    };
    GetPassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> &Option<i32> { &self.bot_user_id }
  
  pub fn scope(&self) -> &Option<String> { &self.scope }
  
  pub fn public_key(&self) -> &Option<String> { &self.public_key }
  
  pub fn nonce(&self) -> &Option<String> { &self.nonce }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPassportAuthorizationFormBuilder {
  instance: GetPassportAuthorizationForm
}

impl GetPassportAuthorizationFormBuilder {
  fn new(instance: GetPassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportAuthorizationForm {
    self.instance.clone()
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn scope(&mut self, scope: String) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
  pub fn public_key(&mut self, public_key: String) -> &mut Self {
    self.instance.public_key = Some(public_key);
    self
  }
  
  pub fn nonce(&mut self, nonce: String) -> &mut Self {
    self.instance.nonce = Some(nonce);
    self
  }
  
}


/// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPassportAuthorizationFormAvailableElements {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPassportAuthorizationFormAvailableElements

  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Password of the current user.
  password: Option<String>,


}




impl Function for GetPassportAuthorizationFormAvailableElements {}


impl GetPassportAuthorizationFormAvailableElements {
  
  pub fn builder() -> GetPassportAuthorizationFormAvailableElementsBuilder {
    let instance = Self {
      tdfname: "getPassportAuthorizationFormAvailableElements".to_string(),
      autorization_form_id: None,
      password: None,
      
    };
    GetPassportAuthorizationFormAvailableElementsBuilder::new(instance)
  }
  
  
  pub fn autorization_form_id(&self) -> &Option<i32> { &self.autorization_form_id }
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPassportAuthorizationFormAvailableElementsBuilder {
  instance: GetPassportAuthorizationFormAvailableElements
}

impl GetPassportAuthorizationFormAvailableElementsBuilder {
  fn new(instance: GetPassportAuthorizationFormAvailableElements) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportAuthorizationFormAvailableElements {
    self.instance.clone()
  }
  
  pub fn autorization_form_id(&mut self, autorization_form_id: i32) -> &mut Self {
    self.instance.autorization_form_id = Some(autorization_form_id);
    self
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Returns one of the available Telegram Passport elements.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPassportElement

  /// Telegram Passport element type.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<PassportElementType>>,
  /// Password of the current user.
  password: Option<String>,


}


impl Clone for GetPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetPassportElement {}


impl GetPassportElement {
  
  pub fn builder() -> GetPassportElementBuilder {
    let instance = Self {
      tdfname: "getPassportElement".to_string(),
      type_: None,
      password: None,
      
    };
    GetPassportElementBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<PassportElementType>> { &self.type_ }
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPassportElementBuilder {
  instance: GetPassportElement
}

impl GetPassportElementBuilder {
  fn new(instance: GetPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> GetPassportElement {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<PassportElementType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Returns the current state of 2-step verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPasswordState

}




impl Function for GetPasswordState {}


impl GetPasswordState {
  
  pub fn builder() -> GetPasswordStateBuilder {
    let instance = Self {
      tdfname: "getPasswordState".to_string(),
      
    };
    GetPasswordStateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPasswordStateBuilder {
  instance: GetPasswordState
}

impl GetPasswordStateBuilder {
  fn new(instance: GetPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> GetPasswordState {
    self.instance.clone()
  }
  
}


/// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPaymentForm

  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,


}




impl Function for GetPaymentForm {}


impl GetPaymentForm {
  
  pub fn builder() -> GetPaymentFormBuilder {
    let instance = Self {
      tdfname: "getPaymentForm".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetPaymentFormBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPaymentFormBuilder {
  instance: GetPaymentForm
}

impl GetPaymentFormBuilder {
  fn new(instance: GetPaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> GetPaymentForm {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns information about a successful payment.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPaymentReceipt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPaymentReceipt

  /// Chat identifier of the PaymentSuccessful message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,


}




impl Function for GetPaymentReceipt {}


impl GetPaymentReceipt {
  
  pub fn builder() -> GetPaymentReceiptBuilder {
    let instance = Self {
      tdfname: "getPaymentReceipt".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetPaymentReceiptBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPaymentReceiptBuilder {
  instance: GetPaymentReceipt
}

impl GetPaymentReceiptBuilder {
  fn new(instance: GetPaymentReceipt) -> Self { Self { instance } }

  pub fn build(&self) -> GetPaymentReceipt {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPreferredCountryLanguage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPreferredCountryLanguage

  /// A two-letter ISO 3166-1 alpha-2 country code.
  country_code: Option<String>,


}




impl Function for GetPreferredCountryLanguage {}


impl GetPreferredCountryLanguage {
  
  pub fn builder() -> GetPreferredCountryLanguageBuilder {
    let instance = Self {
      tdfname: "getPreferredCountryLanguage".to_string(),
      country_code: None,
      
    };
    GetPreferredCountryLanguageBuilder::new(instance)
  }
  
  
  pub fn country_code(&self) -> &Option<String> { &self.country_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPreferredCountryLanguageBuilder {
  instance: GetPreferredCountryLanguage
}

impl GetPreferredCountryLanguageBuilder {
  fn new(instance: GetPreferredCountryLanguage) -> Self { Self { instance } }

  pub fn build(&self) -> GetPreferredCountryLanguage {
    self.instance.clone()
  }
  
  pub fn country_code(&mut self, country_code: String) -> &mut Self {
    self.instance.country_code = Some(country_code);
    self
  }
  
}


/// Returns list of proxies that are currently set up. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxies {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getProxies

}




impl Function for GetProxies {}


impl GetProxies {
  
  pub fn builder() -> GetProxiesBuilder {
    let instance = Self {
      tdfname: "getProxies".to_string(),
      
    };
    GetProxiesBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetProxiesBuilder {
  instance: GetProxies
}

impl GetProxiesBuilder {
  fn new(instance: GetProxies) -> Self { Self { instance } }

  pub fn build(&self) -> GetProxies {
    self.instance.clone()
  }
  
}


/// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetProxyLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getProxyLink

  /// Proxy identifier.
  proxy_id: Option<i32>,


}




impl Function for GetProxyLink {}


impl GetProxyLink {
  
  pub fn builder() -> GetProxyLinkBuilder {
    let instance = Self {
      tdfname: "getProxyLink".to_string(),
      proxy_id: None,
      
    };
    GetProxyLinkBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> &Option<i32> { &self.proxy_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetProxyLinkBuilder {
  instance: GetProxyLink
}

impl GetProxyLinkBuilder {
  fn new(instance: GetProxyLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetProxyLink {
    self.instance.clone()
  }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}


/// Returns a public HTTPS link to a message. Available only for messages in public supergroups and channels.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPublicMessageLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPublicMessageLink

  /// Identifier of the chat to which the message belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// Pass true if a link for a whole media album should be returned.
  for_album: Option<bool>,


}




impl Function for GetPublicMessageLink {}


impl GetPublicMessageLink {
  
  pub fn builder() -> GetPublicMessageLinkBuilder {
    let instance = Self {
      tdfname: "getPublicMessageLink".to_string(),
      chat_id: None,
      message_id: None,
      for_album: None,
      
    };
    GetPublicMessageLinkBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn for_album(&self) -> &Option<bool> { &self.for_album }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPublicMessageLinkBuilder {
  instance: GetPublicMessageLink
}

impl GetPublicMessageLinkBuilder {
  fn new(instance: GetPublicMessageLink) -> Self { Self { instance } }

  pub fn build(&self) -> GetPublicMessageLink {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn for_album(&mut self, for_album: bool) -> &mut Self {
    self.instance.for_album = Some(for_album);
    self
  }
  
}


/// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetPushReceiverId {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getPushReceiverId

  /// JSON-encoded push notification payload.
  payload: Option<String>,


}




impl Function for GetPushReceiverId {}


impl GetPushReceiverId {
  
  pub fn builder() -> GetPushReceiverIdBuilder {
    let instance = Self {
      tdfname: "getPushReceiverId".to_string(),
      payload: None,
      
    };
    GetPushReceiverIdBuilder::new(instance)
  }
  
  
  pub fn payload(&self) -> &Option<String> { &self.payload }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetPushReceiverIdBuilder {
  instance: GetPushReceiverId
}

impl GetPushReceiverIdBuilder {
  fn new(instance: GetPushReceiverId) -> Self { Self { instance } }

  pub fn build(&self) -> GetPushReceiverId {
    self.instance.clone()
  }
  
  pub fn payload(&mut self, payload: String) -> &mut Self {
    self.instance.payload = Some(payload);
    self
  }
  
}


/// Returns up to 20 recently used inline bots in the order of their last usage.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentInlineBots {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRecentInlineBots

}




impl Function for GetRecentInlineBots {}


impl GetRecentInlineBots {
  
  pub fn builder() -> GetRecentInlineBotsBuilder {
    let instance = Self {
      tdfname: "getRecentInlineBots".to_string(),
      
    };
    GetRecentInlineBotsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRecentInlineBotsBuilder {
  instance: GetRecentInlineBots
}

impl GetRecentInlineBotsBuilder {
  fn new(instance: GetRecentInlineBots) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentInlineBots {
    self.instance.clone()
  }
  
}


/// Returns a list of recently used stickers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRecentStickers

  /// Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers.
  is_attached: Option<bool>,


}




impl Function for GetRecentStickers {}


impl GetRecentStickers {
  
  pub fn builder() -> GetRecentStickersBuilder {
    let instance = Self {
      tdfname: "getRecentStickers".to_string(),
      is_attached: None,
      
    };
    GetRecentStickersBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> &Option<bool> { &self.is_attached }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRecentStickersBuilder {
  instance: GetRecentStickers
}

impl GetRecentStickersBuilder {
  fn new(instance: GetRecentStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentStickers {
    self.instance.clone()
  }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
}


/// Returns t.me URLs recently visited by a newly registered user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecentlyVisitedTMeUrls {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRecentlyVisitedTMeUrls

  /// Google Play referrer to identify the user.
  referrer: Option<String>,


}




impl Function for GetRecentlyVisitedTMeUrls {}


impl GetRecentlyVisitedTMeUrls {
  
  pub fn builder() -> GetRecentlyVisitedTMeUrlsBuilder {
    let instance = Self {
      tdfname: "getRecentlyVisitedTMeUrls".to_string(),
      referrer: None,
      
    };
    GetRecentlyVisitedTMeUrlsBuilder::new(instance)
  }
  
  
  pub fn referrer(&self) -> &Option<String> { &self.referrer }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRecentlyVisitedTMeUrlsBuilder {
  instance: GetRecentlyVisitedTMeUrls
}

impl GetRecentlyVisitedTMeUrlsBuilder {
  fn new(instance: GetRecentlyVisitedTMeUrls) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecentlyVisitedTMeUrls {
    self.instance.clone()
  }
  
  pub fn referrer(&mut self, referrer: String) -> &mut Self {
    self.instance.referrer = Some(referrer);
    self
  }
  
}


/// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRecoveryEmailAddress

  /// The password for the current user.
  password: Option<String>,


}




impl Function for GetRecoveryEmailAddress {}


impl GetRecoveryEmailAddress {
  
  pub fn builder() -> GetRecoveryEmailAddressBuilder {
    let instance = Self {
      tdfname: "getRecoveryEmailAddress".to_string(),
      password: None,
      
    };
    GetRecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRecoveryEmailAddressBuilder {
  instance: GetRecoveryEmailAddress
}

impl GetRecoveryEmailAddressBuilder {
  fn new(instance: GetRecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> GetRecoveryEmailAddress {
    self.instance.clone()
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetRemoteFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRemoteFile

  /// Remote identifier of the file to get.
  remote_file_id: Option<String>,
  /// File type, if known.
  file_type: Option<Box<FileType>>,


}


impl Clone for GetRemoteFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetRemoteFile {}


impl GetRemoteFile {
  
  pub fn builder() -> GetRemoteFileBuilder {
    let instance = Self {
      tdfname: "getRemoteFile".to_string(),
      remote_file_id: None,
      file_type: None,
      
    };
    GetRemoteFileBuilder::new(instance)
  }
  
  
  pub fn remote_file_id(&self) -> &Option<String> { &self.remote_file_id }
  
  pub fn file_type(&self) -> &Option<Box<FileType>> { &self.file_type }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRemoteFileBuilder {
  instance: GetRemoteFile
}

impl GetRemoteFileBuilder {
  fn new(instance: GetRemoteFile) -> Self { Self { instance } }

  pub fn build(&self) -> GetRemoteFile {
    self.instance.clone()
  }
  
  pub fn remote_file_id(&mut self, remote_file_id: String) -> &mut Self {
    self.instance.remote_file_id = Some(remote_file_id);
    self
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
}


/// Returns information about a message that is replied by given message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetRepliedMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getRepliedMessage

  /// Identifier of the chat the message belongs to.
  chat_id: Option<i64>,
  /// Identifier of the message reply to which get.
  message_id: Option<i64>,


}




impl Function for GetRepliedMessage {}


impl GetRepliedMessage {
  
  pub fn builder() -> GetRepliedMessageBuilder {
    let instance = Self {
      tdfname: "getRepliedMessage".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    GetRepliedMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetRepliedMessageBuilder {
  instance: GetRepliedMessage
}

impl GetRepliedMessageBuilder {
  fn new(instance: GetRepliedMessage) -> Self { Self { instance } }

  pub fn build(&self) -> GetRepliedMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Returns saved animations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedAnimations {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSavedAnimations

}




impl Function for GetSavedAnimations {}


impl GetSavedAnimations {
  
  pub fn builder() -> GetSavedAnimationsBuilder {
    let instance = Self {
      tdfname: "getSavedAnimations".to_string(),
      
    };
    GetSavedAnimationsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSavedAnimationsBuilder {
  instance: GetSavedAnimations
}

impl GetSavedAnimationsBuilder {
  fn new(instance: GetSavedAnimations) -> Self { Self { instance } }

  pub fn build(&self) -> GetSavedAnimations {
    self.instance.clone()
  }
  
}


/// Returns saved order info, if any.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSavedOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSavedOrderInfo

}




impl Function for GetSavedOrderInfo {}


impl GetSavedOrderInfo {
  
  pub fn builder() -> GetSavedOrderInfoBuilder {
    let instance = Self {
      tdfname: "getSavedOrderInfo".to_string(),
      
    };
    GetSavedOrderInfoBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSavedOrderInfoBuilder {
  instance: GetSavedOrderInfo
}

impl GetSavedOrderInfoBuilder {
  fn new(instance: GetSavedOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetSavedOrderInfo {
    self.instance.clone()
  }
  
}


/// Returns the notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getScopeNotificationSettings

  /// Types of chats for which to return the notification settings information.
  scope: Option<Box<NotificationSettingsScope>>,


}


impl Clone for GetScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetScopeNotificationSettings {}


impl GetScopeNotificationSettings {
  
  pub fn builder() -> GetScopeNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "getScopeNotificationSettings".to_string(),
      scope: None,
      
    };
    GetScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> &Option<Box<NotificationSettingsScope>> { &self.scope }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetScopeNotificationSettingsBuilder {
  instance: GetScopeNotificationSettings
}

impl GetScopeNotificationSettingsBuilder {
  fn new(instance: GetScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> GetScopeNotificationSettings {
    self.instance.clone()
  }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
}


/// Returns information about a secret chat by its identifier. This is an offline request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSecretChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSecretChat

  /// Secret chat identifier.
  secret_chat_id: Option<i32>,


}




impl Function for GetSecretChat {}


impl GetSecretChat {
  
  pub fn builder() -> GetSecretChatBuilder {
    let instance = Self {
      tdfname: "getSecretChat".to_string(),
      secret_chat_id: None,
      
    };
    GetSecretChatBuilder::new(instance)
  }
  
  
  pub fn secret_chat_id(&self) -> &Option<i32> { &self.secret_chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSecretChatBuilder {
  instance: GetSecretChat
}

impl GetSecretChatBuilder {
  fn new(instance: GetSecretChat) -> Self { Self { instance } }

  pub fn build(&self) -> GetSecretChat {
    self.instance.clone()
  }
  
  pub fn secret_chat_id(&mut self, secret_chat_id: i32) -> &mut Self {
    self.instance.secret_chat_id = Some(secret_chat_id);
    self
  }
  
}


/// Returns emoji corresponding to a sticker.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetStickerEmojis {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getStickerEmojis

  /// Sticker file identifier.
  sticker: Option<Box<InputFile>>,


}


impl Clone for GetStickerEmojis {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetStickerEmojis {}


impl GetStickerEmojis {
  
  pub fn builder() -> GetStickerEmojisBuilder {
    let instance = Self {
      tdfname: "getStickerEmojis".to_string(),
      sticker: None,
      
    };
    GetStickerEmojisBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetStickerEmojisBuilder {
  instance: GetStickerEmojis
}

impl GetStickerEmojisBuilder {
  fn new(instance: GetStickerEmojis) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickerEmojis {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Returns information about a sticker set by its identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getStickerSet

  /// Identifier of the sticker set.
  set_id: Option<i64>,


}




impl Function for GetStickerSet {}


impl GetStickerSet {
  
  pub fn builder() -> GetStickerSetBuilder {
    let instance = Self {
      tdfname: "getStickerSet".to_string(),
      set_id: None,
      
    };
    GetStickerSetBuilder::new(instance)
  }
  
  
  pub fn set_id(&self) -> &Option<i64> { &self.set_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetStickerSetBuilder {
  instance: GetStickerSet
}

impl GetStickerSetBuilder {
  fn new(instance: GetStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickerSet {
    self.instance.clone()
  }
  
  pub fn set_id(&mut self, set_id: i64) -> &mut Self {
    self.instance.set_id = Some(set_id);
    self
  }
  
}


/// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getStickers

  /// String representation of emoji. If empty, returns all known installed stickers.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,


}




impl Function for GetStickers {}


impl GetStickers {
  
  pub fn builder() -> GetStickersBuilder {
    let instance = Self {
      tdfname: "getStickers".to_string(),
      emoji: None,
      limit: None,
      
    };
    GetStickersBuilder::new(instance)
  }
  
  
  pub fn emoji(&self) -> &Option<String> { &self.emoji }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetStickersBuilder {
  instance: GetStickers
}

impl GetStickersBuilder {
  fn new(instance: GetStickers) -> Self { Self { instance } }

  pub fn build(&self) -> GetStickers {
    self.instance.clone()
  }
  
  pub fn emoji(&mut self, emoji: String) -> &mut Self {
    self.instance.emoji = Some(emoji);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getStorageStatistics

  /// Maximum number of chats with the largest storage usage for which separate statistics should be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0.
  chat_limit: Option<i32>,


}




impl Function for GetStorageStatistics {}


impl GetStorageStatistics {
  
  pub fn builder() -> GetStorageStatisticsBuilder {
    let instance = Self {
      tdfname: "getStorageStatistics".to_string(),
      chat_limit: None,
      
    };
    GetStorageStatisticsBuilder::new(instance)
  }
  
  
  pub fn chat_limit(&self) -> &Option<i32> { &self.chat_limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetStorageStatisticsBuilder {
  instance: GetStorageStatistics
}

impl GetStorageStatisticsBuilder {
  fn new(instance: GetStorageStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> GetStorageStatistics {
    self.instance.clone()
  }
  
  pub fn chat_limit(&mut self, chat_limit: i32) -> &mut Self {
    self.instance.chat_limit = Some(chat_limit);
    self
  }
  
}


/// Quickly returns approximate storage usage statistics. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetStorageStatisticsFast {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getStorageStatisticsFast

}




impl Function for GetStorageStatisticsFast {}


impl GetStorageStatisticsFast {
  
  pub fn builder() -> GetStorageStatisticsFastBuilder {
    let instance = Self {
      tdfname: "getStorageStatisticsFast".to_string(),
      
    };
    GetStorageStatisticsFastBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetStorageStatisticsFastBuilder {
  instance: GetStorageStatisticsFast
}

impl GetStorageStatisticsFastBuilder {
  fn new(instance: GetStorageStatisticsFast) -> Self { Self { instance } }

  pub fn build(&self) -> GetStorageStatisticsFast {
    self.instance.clone()
  }
  
}


/// Returns information about a supergroup or channel by its identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSupergroup

  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,


}




impl Function for GetSupergroup {}


impl GetSupergroup {
  
  pub fn builder() -> GetSupergroupBuilder {
    let instance = Self {
      tdfname: "getSupergroup".to_string(),
      supergroup_id: None,
      
    };
    GetSupergroupBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSupergroupBuilder {
  instance: GetSupergroup
}

impl GetSupergroupBuilder {
  fn new(instance: GetSupergroup) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroup {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}


/// Returns full information about a supergroup or channel by its identifier, cached for up to 1 minute.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupergroupFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSupergroupFullInfo

  /// Supergroup or channel identifier.
  supergroup_id: Option<i32>,


}




impl Function for GetSupergroupFullInfo {}


impl GetSupergroupFullInfo {
  
  pub fn builder() -> GetSupergroupFullInfoBuilder {
    let instance = Self {
      tdfname: "getSupergroupFullInfo".to_string(),
      supergroup_id: None,
      
    };
    GetSupergroupFullInfoBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSupergroupFullInfoBuilder {
  instance: GetSupergroupFullInfo
}

impl GetSupergroupFullInfoBuilder {
  fn new(instance: GetSupergroupFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroupFullInfo {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
}


/// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetSupergroupMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSupergroupMembers

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// The type of users to return. By default, supergroupMembersRecent.
  filter: Option<Box<SupergroupMembersFilter>>,
  /// Number of users to skip.
  offset: Option<i32>,
  /// The maximum number of users be returned; up to 200.
  limit: Option<i32>,


}


impl Clone for GetSupergroupMembers {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetSupergroupMembers {}


impl GetSupergroupMembers {
  
  pub fn builder() -> GetSupergroupMembersBuilder {
    let instance = Self {
      tdfname: "getSupergroupMembers".to_string(),
      supergroup_id: None,
      filter: None,
      offset: None,
      limit: None,
      
    };
    GetSupergroupMembersBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn filter(&self) -> &Option<Box<SupergroupMembersFilter>> { &self.filter }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSupergroupMembersBuilder {
  instance: GetSupergroupMembers
}

impl GetSupergroupMembersBuilder {
  fn new(instance: GetSupergroupMembers) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupergroupMembers {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SupergroupMembersFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns a user that can be contacted to get support.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetSupportUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getSupportUser

}




impl Function for GetSupportUser {}


impl GetSupportUser {
  
  pub fn builder() -> GetSupportUserBuilder {
    let instance = Self {
      tdfname: "getSupportUser".to_string(),
      
    };
    GetSupportUserBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetSupportUserBuilder {
  instance: GetSupportUser
}

impl GetSupportUserBuilder {
  fn new(instance: GetSupportUser) -> Self { Self { instance } }

  pub fn build(&self) -> GetSupportUser {
    self.instance.clone()
  }
  
}


/// Returns information about the current temporary password.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTemporaryPasswordState {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getTemporaryPasswordState

}




impl Function for GetTemporaryPasswordState {}


impl GetTemporaryPasswordState {
  
  pub fn builder() -> GetTemporaryPasswordStateBuilder {
    let instance = Self {
      tdfname: "getTemporaryPasswordState".to_string(),
      
    };
    GetTemporaryPasswordStateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetTemporaryPasswordStateBuilder {
  instance: GetTemporaryPasswordState
}

impl GetTemporaryPasswordStateBuilder {
  fn new(instance: GetTemporaryPasswordState) -> Self { Self { instance } }

  pub fn build(&self) -> GetTemporaryPasswordState {
    self.instance.clone()
  }
  
}


/// Returns all entities (mentions, hashtags, cashtags, bot commands, URLs, and email addresses) contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getTextEntities

  /// The text in which to look for entites.
  text: Option<String>,


}




impl Function for GetTextEntities {}


impl GetTextEntities {
  
  pub fn builder() -> GetTextEntitiesBuilder {
    let instance = Self {
      tdfname: "getTextEntities".to_string(),
      text: None,
      
    };
    GetTextEntitiesBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetTextEntitiesBuilder {
  instance: GetTextEntities
}

impl GetTextEntitiesBuilder {
  fn new(instance: GetTextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> GetTextEntities {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// Returns a list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetTopChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getTopChats

  /// Category of chats to be returned.
  category: Option<Box<TopChatCategory>>,
  /// Maximum number of chats to be returned; up to 30.
  limit: Option<i32>,


}


impl Clone for GetTopChats {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetTopChats {}


impl GetTopChats {
  
  pub fn builder() -> GetTopChatsBuilder {
    let instance = Self {
      tdfname: "getTopChats".to_string(),
      category: None,
      limit: None,
      
    };
    GetTopChatsBuilder::new(instance)
  }
  
  
  pub fn category(&self) -> &Option<Box<TopChatCategory>> { &self.category }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetTopChatsBuilder {
  instance: GetTopChats
}

impl GetTopChatsBuilder {
  fn new(instance: GetTopChats) -> Self { Self { instance } }

  pub fn build(&self) -> GetTopChats {
    self.instance.clone()
  }
  
  pub fn category(&mut self, category: Box<TopChatCategory>) -> &mut Self {
    self.instance.category = Some(category);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns a list of trending sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getTrendingStickerSets

}




impl Function for GetTrendingStickerSets {}


impl GetTrendingStickerSets {
  
  pub fn builder() -> GetTrendingStickerSetsBuilder {
    let instance = Self {
      tdfname: "getTrendingStickerSets".to_string(),
      
    };
    GetTrendingStickerSetsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetTrendingStickerSetsBuilder {
  instance: GetTrendingStickerSets
}

impl GetTrendingStickerSetsBuilder {
  fn new(instance: GetTrendingStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> GetTrendingStickerSets {
    self.instance.clone()
  }
  
}


/// Returns information about a user by their identifier. This is an offline request if the current user is not a bot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getUser

  /// User identifier.
  user_id: Option<i32>,


}




impl Function for GetUser {}


impl GetUser {
  
  pub fn builder() -> GetUserBuilder {
    let instance = Self {
      tdfname: "getUser".to_string(),
      user_id: None,
      
    };
    GetUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetUserBuilder {
  instance: GetUser
}

impl GetUserBuilder {
  fn new(instance: GetUser) -> Self { Self { instance } }

  pub fn build(&self) -> GetUser {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Returns full information about a user by their identifier.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserFullInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getUserFullInfo

  /// User identifier.
  user_id: Option<i32>,


}




impl Function for GetUserFullInfo {}


impl GetUserFullInfo {
  
  pub fn builder() -> GetUserFullInfoBuilder {
    let instance = Self {
      tdfname: "getUserFullInfo".to_string(),
      user_id: None,
      
    };
    GetUserFullInfoBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetUserFullInfoBuilder {
  instance: GetUserFullInfo
}

impl GetUserFullInfoBuilder {
  fn new(instance: GetUserFullInfo) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserFullInfo {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Returns the current privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct GetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getUserPrivacySettingRules

  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,


}


impl Clone for GetUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for GetUserPrivacySettingRules {}


impl GetUserPrivacySettingRules {
  
  pub fn builder() -> GetUserPrivacySettingRulesBuilder {
    let instance = Self {
      tdfname: "getUserPrivacySettingRules".to_string(),
      setting: None,
      
    };
    GetUserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn setting(&self) -> &Option<Box<UserPrivacySetting>> { &self.setting }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetUserPrivacySettingRulesBuilder {
  instance: GetUserPrivacySettingRules
}

impl GetUserPrivacySettingRulesBuilder {
  fn new(instance: GetUserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserPrivacySettingRules {
    self.instance.clone()
  }
  
  pub fn setting(&mut self, setting: Box<UserPrivacySetting>) -> &mut Self {
    self.instance.setting = Some(setting);
    self
  }
  
}


/// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetUserProfilePhotos {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getUserProfilePhotos

  /// User identifier.
  user_id: Option<i32>,
  /// The number of photos to skip; must be non-negative.
  offset: Option<i32>,
  /// Maximum number of photos to be returned; up to 100.
  limit: Option<i32>,


}




impl Function for GetUserProfilePhotos {}


impl GetUserProfilePhotos {
  
  pub fn builder() -> GetUserProfilePhotosBuilder {
    let instance = Self {
      tdfname: "getUserProfilePhotos".to_string(),
      user_id: None,
      offset: None,
      limit: None,
      
    };
    GetUserProfilePhotosBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetUserProfilePhotosBuilder {
  instance: GetUserProfilePhotos
}

impl GetUserProfilePhotosBuilder {
  fn new(instance: GetUserProfilePhotos) -> Self { Self { instance } }

  pub fn build(&self) -> GetUserProfilePhotos {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Returns background wallpapers.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWallpapers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getWallpapers

}




impl Function for GetWallpapers {}


impl GetWallpapers {
  
  pub fn builder() -> GetWallpapersBuilder {
    let instance = Self {
      tdfname: "getWallpapers".to_string(),
      
    };
    GetWallpapersBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetWallpapersBuilder {
  instance: GetWallpapers
}

impl GetWallpapersBuilder {
  fn new(instance: GetWallpapers) -> Self { Self { instance } }

  pub fn build(&self) -> GetWallpapers {
    self.instance.clone()
  }
  
}


/// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPageInstantView {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getWebPageInstantView

  /// The web page URL.
  url: Option<String>,
  /// If true, the full instant view for the web page will be returned.
  force_full: Option<bool>,


}




impl Function for GetWebPageInstantView {}


impl GetWebPageInstantView {
  
  pub fn builder() -> GetWebPageInstantViewBuilder {
    let instance = Self {
      tdfname: "getWebPageInstantView".to_string(),
      url: None,
      force_full: None,
      
    };
    GetWebPageInstantViewBuilder::new(instance)
  }
  
  
  pub fn url(&self) -> &Option<String> { &self.url }
  
  pub fn force_full(&self) -> &Option<bool> { &self.force_full }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetWebPageInstantViewBuilder {
  instance: GetWebPageInstantView
}

impl GetWebPageInstantViewBuilder {
  fn new(instance: GetWebPageInstantView) -> Self { Self { instance } }

  pub fn build(&self) -> GetWebPageInstantView {
    self.instance.clone()
  }
  
  pub fn url(&mut self, url: String) -> &mut Self {
    self.instance.url = Some(url);
    self
  }
  
  pub fn force_full(&mut self, force_full: bool) -> &mut Self {
    self.instance.force_full = Some(force_full);
    self
  }
  
}


/// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetWebPagePreview {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // getWebPagePreview

  /// Message text with formatting.
  text: Option<FormattedText>,


}




impl Function for GetWebPagePreview {}


impl GetWebPagePreview {
  
  pub fn builder() -> GetWebPagePreviewBuilder {
    let instance = Self {
      tdfname: "getWebPagePreview".to_string(),
      text: None,
      
    };
    GetWebPagePreviewBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<FormattedText> { &self.text }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct GetWebPagePreviewBuilder {
  instance: GetWebPagePreview
}

impl GetWebPagePreviewBuilder {
  fn new(instance: GetWebPagePreview) -> Self { Self { instance } }

  pub fn build(&self) -> GetWebPagePreview {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: FormattedText) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
}


/// Adds new contacts or edits existing contacts; contacts' user identifiers are ignored.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // importContacts

  /// The list of contacts to import or edit, contact's vCard are ignored and are not imported.
  contacts: Option<Vec<Contact>>,


}




impl Function for ImportContacts {}


impl ImportContacts {
  
  pub fn builder() -> ImportContactsBuilder {
    let instance = Self {
      tdfname: "importContacts".to_string(),
      contacts: None,
      
    };
    ImportContactsBuilder::new(instance)
  }
  
  
  pub fn contacts(&self) -> &Option<Vec<Contact>> { &self.contacts }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ImportContactsBuilder {
  instance: ImportContacts
}

impl ImportContactsBuilder {
  fn new(instance: ImportContacts) -> Self { Self { instance } }

  pub fn build(&self) -> ImportContacts {
    self.instance.clone()
  }
  
  pub fn contacts(&mut self, contacts: Vec<Contact>) -> &mut Self {
    self.instance.contacts = Some(contacts);
    self
  }
  
}


/// Adds current user as a new member to a chat. Private and secret chats can't be joined using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // joinChat

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for JoinChat {}


impl JoinChat {
  
  pub fn builder() -> JoinChatBuilder {
    let instance = Self {
      tdfname: "joinChat".to_string(),
      chat_id: None,
      
    };
    JoinChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct JoinChatBuilder {
  instance: JoinChat
}

impl JoinChatBuilder {
  fn new(instance: JoinChat) -> Self { Self { instance } }

  pub fn build(&self) -> JoinChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JoinChatByInviteLink {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // joinChatByInviteLink

  /// Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/".
  invite_link: Option<String>,


}




impl Function for JoinChatByInviteLink {}


impl JoinChatByInviteLink {
  
  pub fn builder() -> JoinChatByInviteLinkBuilder {
    let instance = Self {
      tdfname: "joinChatByInviteLink".to_string(),
      invite_link: None,
      
    };
    JoinChatByInviteLinkBuilder::new(instance)
  }
  
  
  pub fn invite_link(&self) -> &Option<String> { &self.invite_link }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct JoinChatByInviteLinkBuilder {
  instance: JoinChatByInviteLink
}

impl JoinChatByInviteLinkBuilder {
  fn new(instance: JoinChatByInviteLink) -> Self { Self { instance } }

  pub fn build(&self) -> JoinChatByInviteLink {
    self.instance.clone()
  }
  
  pub fn invite_link(&mut self, invite_link: String) -> &mut Self {
    self.instance.invite_link = Some(invite_link);
    self
  }
  
}


/// Removes current user from chat members. Private and secret chats can't be left using this method.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LeaveChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // leaveChat

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for LeaveChat {}


impl LeaveChat {
  
  pub fn builder() -> LeaveChatBuilder {
    let instance = Self {
      tdfname: "leaveChat".to_string(),
      chat_id: None,
      
    };
    LeaveChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LeaveChatBuilder {
  instance: LeaveChat
}

impl LeaveChatBuilder {
  fn new(instance: LeaveChat) -> Self { Self { instance } }

  pub fn build(&self) -> LeaveChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogOut {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // logOut

}




impl Function for LogOut {}


impl LogOut {
  
  pub fn builder() -> LogOutBuilder {
    let instance = Self {
      tdfname: "logOut".to_string(),
      
    };
    LogOutBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct LogOutBuilder {
  instance: LogOut
}

impl LogOutBuilder {
  fn new(instance: LogOut) -> Self { Self { instance } }

  pub fn build(&self) -> LogOut {
    self.instance.clone()
  }
  
}


/// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // openChat

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for OpenChat {}


impl OpenChat {
  
  pub fn builder() -> OpenChatBuilder {
    let instance = Self {
      tdfname: "openChat".to_string(),
      chat_id: None,
      
    };
    OpenChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OpenChatBuilder {
  instance: OpenChat
}

impl OpenChatBuilder {
  fn new(instance: OpenChat) -> Self { Self { instance } }

  pub fn build(&self) -> OpenChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OpenMessageContent {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // openMessageContent

  /// Chat identifier of the message.
  chat_id: Option<i64>,
  /// Identifier of the message with the opened content.
  message_id: Option<i64>,


}




impl Function for OpenMessageContent {}


impl OpenMessageContent {
  
  pub fn builder() -> OpenMessageContentBuilder {
    let instance = Self {
      tdfname: "openMessageContent".to_string(),
      chat_id: None,
      message_id: None,
      
    };
    OpenMessageContentBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OpenMessageContentBuilder {
  instance: OpenMessageContent
}

impl OpenMessageContentBuilder {
  fn new(instance: OpenMessageContent) -> Self { Self { instance } }

  pub fn build(&self) -> OpenMessageContent {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
}


/// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted.
#[derive(Debug, Serialize, Deserialize)]
pub struct OptimizeStorage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // optimizeStorage

  /// Limit on the total size of files after deletion. Pass -1 to use the default limit.
  size: Option<i64>,
  /// Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit.
  ttl: Option<i32>,
  /// Limit on the total count of files after deletion. Pass -1 to use the default limit.
  count: Option<i32>,
  /// The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value.
  immunity_delay: Option<i32>,
  /// If not empty, only files with the given type(s) are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted.
  file_types: Option<Vec<Box<FileType>>>,
  /// If not empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos).
  chat_ids: Option<Vec<i64>>,
  /// If not empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos).
  exclude_chat_ids: Option<Vec<i64>>,
  /// Same as in getStorageStatistics. Affects only returned statistics.
  chat_limit: Option<i32>,


}


impl Clone for OptimizeStorage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for OptimizeStorage {}


impl OptimizeStorage {
  
  pub fn builder() -> OptimizeStorageBuilder {
    let instance = Self {
      tdfname: "optimizeStorage".to_string(),
      size: None,
      ttl: None,
      count: None,
      immunity_delay: None,
      file_types: None,
      chat_ids: None,
      exclude_chat_ids: None,
      chat_limit: None,
      
    };
    OptimizeStorageBuilder::new(instance)
  }
  
  
  pub fn size(&self) -> &Option<i64> { &self.size }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  pub fn immunity_delay(&self) -> &Option<i32> { &self.immunity_delay }
  
  pub fn file_types(&self) -> &Option<Vec<Box<FileType>>> { &self.file_types }
  
  pub fn chat_ids(&self) -> &Option<Vec<i64>> { &self.chat_ids }
  
  pub fn exclude_chat_ids(&self) -> &Option<Vec<i64>> { &self.exclude_chat_ids }
  
  pub fn chat_limit(&self) -> &Option<i32> { &self.chat_limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct OptimizeStorageBuilder {
  instance: OptimizeStorage
}

impl OptimizeStorageBuilder {
  fn new(instance: OptimizeStorage) -> Self { Self { instance } }

  pub fn build(&self) -> OptimizeStorage {
    self.instance.clone()
  }
  
  pub fn size(&mut self, size: i64) -> &mut Self {
    self.instance.size = Some(size);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
  pub fn immunity_delay(&mut self, immunity_delay: i32) -> &mut Self {
    self.instance.immunity_delay = Some(immunity_delay);
    self
  }
  
  pub fn file_types(&mut self, file_types: Vec<Box<FileType>>) -> &mut Self {
    self.instance.file_types = Some(file_types);
    self
  }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
  pub fn exclude_chat_ids(&mut self, exclude_chat_ids: Vec<i64>) -> &mut Self {
    self.instance.exclude_chat_ids = Some(exclude_chat_ids);
    self
  }
  
  pub fn chat_limit(&mut self, chat_limit: i32) -> &mut Self {
    self.instance.chat_limit = Some(chat_limit);
    self
  }
  
}


/// Parses Bold, Italic, Code, Pre, PreCode and TextUrl entities contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct ParseTextEntities {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // parseTextEntities

  /// The text which should be parsed.
  text: Option<String>,
  /// Text parse mode.
  parse_mode: Option<Box<TextParseMode>>,


}


impl Clone for ParseTextEntities {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for ParseTextEntities {}


impl ParseTextEntities {
  
  pub fn builder() -> ParseTextEntitiesBuilder {
    let instance = Self {
      tdfname: "parseTextEntities".to_string(),
      text: None,
      parse_mode: None,
      
    };
    ParseTextEntitiesBuilder::new(instance)
  }
  
  
  pub fn text(&self) -> &Option<String> { &self.text }
  
  pub fn parse_mode(&self) -> &Option<Box<TextParseMode>> { &self.parse_mode }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ParseTextEntitiesBuilder {
  instance: ParseTextEntities
}

impl ParseTextEntitiesBuilder {
  fn new(instance: ParseTextEntities) -> Self { Self { instance } }

  pub fn build(&self) -> ParseTextEntities {
    self.instance.clone()
  }
  
  pub fn text(&mut self, text: String) -> &mut Self {
    self.instance.text = Some(text);
    self
  }
  
  pub fn parse_mode(&mut self, parse_mode: Box<TextParseMode>) -> &mut Self {
    self.instance.parse_mode = Some(parse_mode);
    self
  }
  
}


/// Pins a message in a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pinChatMessage

  /// Identifier of the chat.
  chat_id: Option<i64>,
  /// Identifier of the new pinned message.
  message_id: Option<i64>,
  /// True, if there should be no notification about the pinned message.
  disable_notification: Option<bool>,


}




impl Function for PinChatMessage {}


impl PinChatMessage {
  
  pub fn builder() -> PinChatMessageBuilder {
    let instance = Self {
      tdfname: "pinChatMessage".to_string(),
      chat_id: None,
      message_id: None,
      disable_notification: None,
      
    };
    PinChatMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PinChatMessageBuilder {
  instance: PinChatMessage
}

impl PinChatMessageBuilder {
  fn new(instance: PinChatMessage) -> Self { Self { instance } }

  pub fn build(&self) -> PinChatMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
}


/// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PingProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // pingProxy

  /// Proxy identifier. Use 0 to ping a Telegram server without a proxy.
  proxy_id: Option<i32>,


}




impl Function for PingProxy {}


impl PingProxy {
  
  pub fn builder() -> PingProxyBuilder {
    let instance = Self {
      tdfname: "pingProxy".to_string(),
      proxy_id: None,
      
    };
    PingProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> &Option<i32> { &self.proxy_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct PingProxyBuilder {
  instance: PingProxy
}

impl PingProxyBuilder {
  fn new(instance: PingProxy) -> Self { Self { instance } }

  pub fn build(&self) -> PingProxy {
    self.instance.clone()
  }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}


/// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessPushNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // processPushNotification

  /// JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added.
  payload: Option<String>,


}




impl Function for ProcessPushNotification {}


impl ProcessPushNotification {
  
  pub fn builder() -> ProcessPushNotificationBuilder {
    let instance = Self {
      tdfname: "processPushNotification".to_string(),
      payload: None,
      
    };
    ProcessPushNotificationBuilder::new(instance)
  }
  
  
  pub fn payload(&self) -> &Option<String> { &self.payload }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ProcessPushNotificationBuilder {
  instance: ProcessPushNotification
}

impl ProcessPushNotificationBuilder {
  fn new(instance: ProcessPushNotification) -> Self { Self { instance } }

  pub fn build(&self) -> ProcessPushNotification {
    self.instance.clone()
  }
  
  pub fn payload(&mut self, payload: String) -> &mut Self {
    self.instance.payload = Some(payload);
    self
  }
  
}


/// Marks all mentions in a chat as read.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadAllChatMentions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // readAllChatMentions

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for ReadAllChatMentions {}


impl ReadAllChatMentions {
  
  pub fn builder() -> ReadAllChatMentionsBuilder {
    let instance = Self {
      tdfname: "readAllChatMentions".to_string(),
      chat_id: None,
      
    };
    ReadAllChatMentionsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReadAllChatMentionsBuilder {
  instance: ReadAllChatMentions
}

impl ReadAllChatMentionsBuilder {
  fn new(instance: ReadAllChatMentions) -> Self { Self { instance } }

  pub fn build(&self) -> ReadAllChatMentions {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct read from the file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReadFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // readFilePart

  /// Identifier of the file. The file must be located in the TDLib file cache.
  file_id: Option<i32>,
  /// The offset from which to read the file.
  offset: Option<i32>,
  /// Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position.
  count: Option<i32>,


}




impl Function for ReadFilePart {}


impl ReadFilePart {
  
  pub fn builder() -> ReadFilePartBuilder {
    let instance = Self {
      tdfname: "readFilePart".to_string(),
      file_id: None,
      offset: None,
      count: None,
      
    };
    ReadFilePartBuilder::new(instance)
  }
  
  
  pub fn file_id(&self) -> &Option<i32> { &self.file_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn count(&self) -> &Option<i32> { &self.count }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReadFilePartBuilder {
  instance: ReadFilePart
}

impl ReadFilePartBuilder {
  fn new(instance: ReadFilePart) -> Self { Self { instance } }

  pub fn build(&self) -> ReadFilePart {
    self.instance.clone()
  }
  
  pub fn file_id(&mut self, file_id: i32) -> &mut Self {
    self.instance.file_id = Some(file_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn count(&mut self, count: i32) -> &mut Self {
    self.instance.count = Some(count);
    self
  }
  
}


/// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverAuthenticationPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // recoverAuthenticationPassword

  /// Recovery code to check.
  recovery_code: Option<String>,


}




impl Function for RecoverAuthenticationPassword {}


impl RecoverAuthenticationPassword {
  
  pub fn builder() -> RecoverAuthenticationPasswordBuilder {
    let instance = Self {
      tdfname: "recoverAuthenticationPassword".to_string(),
      recovery_code: None,
      
    };
    RecoverAuthenticationPasswordBuilder::new(instance)
  }
  
  
  pub fn recovery_code(&self) -> &Option<String> { &self.recovery_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RecoverAuthenticationPasswordBuilder {
  instance: RecoverAuthenticationPassword
}

impl RecoverAuthenticationPasswordBuilder {
  fn new(instance: RecoverAuthenticationPassword) -> Self { Self { instance } }

  pub fn build(&self) -> RecoverAuthenticationPassword {
    self.instance.clone()
  }
  
  pub fn recovery_code(&mut self, recovery_code: String) -> &mut Self {
    self.instance.recovery_code = Some(recovery_code);
    self
  }
  
}


/// Recovers the password using a recovery code sent to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecoverPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // recoverPassword

  /// Recovery code to check.
  recovery_code: Option<String>,


}




impl Function for RecoverPassword {}


impl RecoverPassword {
  
  pub fn builder() -> RecoverPasswordBuilder {
    let instance = Self {
      tdfname: "recoverPassword".to_string(),
      recovery_code: None,
      
    };
    RecoverPasswordBuilder::new(instance)
  }
  
  
  pub fn recovery_code(&self) -> &Option<String> { &self.recovery_code }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RecoverPasswordBuilder {
  instance: RecoverPassword
}

impl RecoverPasswordBuilder {
  fn new(instance: RecoverPassword) -> Self { Self { instance } }

  pub fn build(&self) -> RecoverPassword {
    self.instance.clone()
  }
  
  pub fn recovery_code(&mut self, recovery_code: String) -> &mut Self {
    self.instance.recovery_code = Some(recovery_code);
    self
  }
  
}


/// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription.
#[derive(Debug, Serialize, Deserialize)]
pub struct RegisterDevice {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // registerDevice

  /// Device token.
  device_token: Option<Box<DeviceToken>>,
  /// List of user identifiers of other users currently using the client.
  other_user_ids: Option<Vec<i32>>,


}


impl Clone for RegisterDevice {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RegisterDevice {}


impl RegisterDevice {
  
  pub fn builder() -> RegisterDeviceBuilder {
    let instance = Self {
      tdfname: "registerDevice".to_string(),
      device_token: None,
      other_user_ids: None,
      
    };
    RegisterDeviceBuilder::new(instance)
  }
  
  
  pub fn device_token(&self) -> &Option<Box<DeviceToken>> { &self.device_token }
  
  pub fn other_user_ids(&self) -> &Option<Vec<i32>> { &self.other_user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RegisterDeviceBuilder {
  instance: RegisterDevice
}

impl RegisterDeviceBuilder {
  fn new(instance: RegisterDevice) -> Self { Self { instance } }

  pub fn build(&self) -> RegisterDevice {
    self.instance.clone()
  }
  
  pub fn device_token(&mut self, device_token: Box<DeviceToken>) -> &mut Self {
    self.instance.device_token = Some(device_token);
    self
  }
  
  pub fn other_user_ids(&mut self, other_user_ids: Vec<i32>) -> &mut Self {
    self.instance.other_user_ids = Some(other_user_ids);
    self
  }
  
}


/// Removes users from the contact list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeContacts

  /// Identifiers of users to be deleted.
  user_ids: Option<Vec<i32>>,


}




impl Function for RemoveContacts {}


impl RemoveContacts {
  
  pub fn builder() -> RemoveContactsBuilder {
    let instance = Self {
      tdfname: "removeContacts".to_string(),
      user_ids: None,
      
    };
    RemoveContactsBuilder::new(instance)
  }
  
  
  pub fn user_ids(&self) -> &Option<Vec<i32>> { &self.user_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveContactsBuilder {
  instance: RemoveContacts
}

impl RemoveContactsBuilder {
  fn new(instance: RemoveContacts) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveContacts {
    self.instance.clone()
  }
  
  pub fn user_ids(&mut self, user_ids: Vec<i32>) -> &mut Self {
    self.instance.user_ids = Some(user_ids);
    self
  }
  
}


/// Removes a sticker from the list of favorite stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveFavoriteSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeFavoriteSticker

  /// Sticker file to delete from the list.
  sticker: Option<Box<InputFile>>,


}


impl Clone for RemoveFavoriteSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RemoveFavoriteSticker {}


impl RemoveFavoriteSticker {
  
  pub fn builder() -> RemoveFavoriteStickerBuilder {
    let instance = Self {
      tdfname: "removeFavoriteSticker".to_string(),
      sticker: None,
      
    };
    RemoveFavoriteStickerBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveFavoriteStickerBuilder {
  instance: RemoveFavoriteSticker
}

impl RemoveFavoriteStickerBuilder {
  fn new(instance: RemoveFavoriteSticker) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveFavoriteSticker {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeNotification

  /// Identifier of notification group to which the notification belongs.
  notification_group_id: Option<i32>,
  /// Identifier of removed notification.
  notification_id: Option<i32>,


}




impl Function for RemoveNotification {}


impl RemoveNotification {
  
  pub fn builder() -> RemoveNotificationBuilder {
    let instance = Self {
      tdfname: "removeNotification".to_string(),
      notification_group_id: None,
      notification_id: None,
      
    };
    RemoveNotificationBuilder::new(instance)
  }
  
  
  pub fn notification_group_id(&self) -> &Option<i32> { &self.notification_group_id }
  
  pub fn notification_id(&self) -> &Option<i32> { &self.notification_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveNotificationBuilder {
  instance: RemoveNotification
}

impl RemoveNotificationBuilder {
  fn new(instance: RemoveNotification) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveNotification {
    self.instance.clone()
  }
  
  pub fn notification_group_id(&mut self, notification_group_id: i32) -> &mut Self {
    self.instance.notification_group_id = Some(notification_group_id);
    self
  }
  
  pub fn notification_id(&mut self, notification_id: i32) -> &mut Self {
    self.instance.notification_id = Some(notification_id);
    self
  }
  
}


/// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveNotificationGroup {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeNotificationGroup

  /// Notification group identifier.
  notification_group_id: Option<i32>,
  /// Maximum identifier of removed notifications.
  max_notification_id: Option<i32>,


}




impl Function for RemoveNotificationGroup {}


impl RemoveNotificationGroup {
  
  pub fn builder() -> RemoveNotificationGroupBuilder {
    let instance = Self {
      tdfname: "removeNotificationGroup".to_string(),
      notification_group_id: None,
      max_notification_id: None,
      
    };
    RemoveNotificationGroupBuilder::new(instance)
  }
  
  
  pub fn notification_group_id(&self) -> &Option<i32> { &self.notification_group_id }
  
  pub fn max_notification_id(&self) -> &Option<i32> { &self.max_notification_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveNotificationGroupBuilder {
  instance: RemoveNotificationGroup
}

impl RemoveNotificationGroupBuilder {
  fn new(instance: RemoveNotificationGroup) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveNotificationGroup {
    self.instance.clone()
  }
  
  pub fn notification_group_id(&mut self, notification_group_id: i32) -> &mut Self {
    self.instance.notification_group_id = Some(notification_group_id);
    self
  }
  
  pub fn max_notification_id(&mut self, max_notification_id: i32) -> &mut Self {
    self.instance.max_notification_id = Some(max_notification_id);
    self
  }
  
}


/// Removes a proxy server. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveProxy {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeProxy

  /// Proxy identifier.
  proxy_id: Option<i32>,


}




impl Function for RemoveProxy {}


impl RemoveProxy {
  
  pub fn builder() -> RemoveProxyBuilder {
    let instance = Self {
      tdfname: "removeProxy".to_string(),
      proxy_id: None,
      
    };
    RemoveProxyBuilder::new(instance)
  }
  
  
  pub fn proxy_id(&self) -> &Option<i32> { &self.proxy_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveProxyBuilder {
  instance: RemoveProxy
}

impl RemoveProxyBuilder {
  fn new(instance: RemoveProxy) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveProxy {
    self.instance.clone()
  }
  
  pub fn proxy_id(&mut self, proxy_id: i32) -> &mut Self {
    self.instance.proxy_id = Some(proxy_id);
    self
  }
  
}


/// Removes a hashtag from the list of recently used hashtags.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentHashtag {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeRecentHashtag

  /// Hashtag to delete.
  hashtag: Option<String>,


}




impl Function for RemoveRecentHashtag {}


impl RemoveRecentHashtag {
  
  pub fn builder() -> RemoveRecentHashtagBuilder {
    let instance = Self {
      tdfname: "removeRecentHashtag".to_string(),
      hashtag: None,
      
    };
    RemoveRecentHashtagBuilder::new(instance)
  }
  
  
  pub fn hashtag(&self) -> &Option<String> { &self.hashtag }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveRecentHashtagBuilder {
  instance: RemoveRecentHashtag
}

impl RemoveRecentHashtagBuilder {
  fn new(instance: RemoveRecentHashtag) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentHashtag {
    self.instance.clone()
  }
  
  pub fn hashtag(&mut self, hashtag: String) -> &mut Self {
    self.instance.hashtag = Some(hashtag);
    self
  }
  
}


/// Removes a sticker from the list of recently used stickers.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveRecentSticker {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeRecentSticker

  /// Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers.
  is_attached: Option<bool>,
  /// Sticker file to delete.
  sticker: Option<Box<InputFile>>,


}


impl Clone for RemoveRecentSticker {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RemoveRecentSticker {}


impl RemoveRecentSticker {
  
  pub fn builder() -> RemoveRecentStickerBuilder {
    let instance = Self {
      tdfname: "removeRecentSticker".to_string(),
      is_attached: None,
      sticker: None,
      
    };
    RemoveRecentStickerBuilder::new(instance)
  }
  
  
  pub fn is_attached(&self) -> &Option<bool> { &self.is_attached }
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveRecentStickerBuilder {
  instance: RemoveRecentSticker
}

impl RemoveRecentStickerBuilder {
  fn new(instance: RemoveRecentSticker) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentSticker {
    self.instance.clone()
  }
  
  pub fn is_attached(&mut self, is_attached: bool) -> &mut Self {
    self.instance.is_attached = Some(is_attached);
    self
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Removes a chat from the list of recently found chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveRecentlyFoundChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeRecentlyFoundChat

  /// Identifier of the chat to be removed.
  chat_id: Option<i64>,


}




impl Function for RemoveRecentlyFoundChat {}


impl RemoveRecentlyFoundChat {
  
  pub fn builder() -> RemoveRecentlyFoundChatBuilder {
    let instance = Self {
      tdfname: "removeRecentlyFoundChat".to_string(),
      chat_id: None,
      
    };
    RemoveRecentlyFoundChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveRecentlyFoundChatBuilder {
  instance: RemoveRecentlyFoundChat
}

impl RemoveRecentlyFoundChatBuilder {
  fn new(instance: RemoveRecentlyFoundChat) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveRecentlyFoundChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Removes an animation from the list of saved animations.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveSavedAnimation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeSavedAnimation

  /// Animation file to be removed.
  animation: Option<Box<InputFile>>,


}


impl Clone for RemoveSavedAnimation {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RemoveSavedAnimation {}


impl RemoveSavedAnimation {
  
  pub fn builder() -> RemoveSavedAnimationBuilder {
    let instance = Self {
      tdfname: "removeSavedAnimation".to_string(),
      animation: None,
      
    };
    RemoveSavedAnimationBuilder::new(instance)
  }
  
  
  pub fn animation(&self) -> &Option<Box<InputFile>> { &self.animation }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveSavedAnimationBuilder {
  instance: RemoveSavedAnimation
}

impl RemoveSavedAnimationBuilder {
  fn new(instance: RemoveSavedAnimation) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveSavedAnimation {
    self.instance.clone()
  }
  
  pub fn animation(&mut self, animation: Box<InputFile>) -> &mut Self {
    self.instance.animation = Some(animation);
    self
  }
  
}


/// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveStickerFromSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeStickerFromSet

  /// Sticker.
  sticker: Option<Box<InputFile>>,


}


impl Clone for RemoveStickerFromSet {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RemoveStickerFromSet {}


impl RemoveStickerFromSet {
  
  pub fn builder() -> RemoveStickerFromSetBuilder {
    let instance = Self {
      tdfname: "removeStickerFromSet".to_string(),
      sticker: None,
      
    };
    RemoveStickerFromSetBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveStickerFromSetBuilder {
  instance: RemoveStickerFromSet
}

impl RemoveStickerFromSetBuilder {
  fn new(instance: RemoveStickerFromSet) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveStickerFromSet {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
}


/// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled.
#[derive(Debug, Serialize, Deserialize)]
pub struct RemoveTopChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // removeTopChat

  /// Category of frequently used chats.
  category: Option<Box<TopChatCategory>>,
  /// Chat identifier.
  chat_id: Option<i64>,


}


impl Clone for RemoveTopChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for RemoveTopChat {}


impl RemoveTopChat {
  
  pub fn builder() -> RemoveTopChatBuilder {
    let instance = Self {
      tdfname: "removeTopChat".to_string(),
      category: None,
      chat_id: None,
      
    };
    RemoveTopChatBuilder::new(instance)
  }
  
  
  pub fn category(&self) -> &Option<Box<TopChatCategory>> { &self.category }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RemoveTopChatBuilder {
  instance: RemoveTopChat
}

impl RemoveTopChatBuilder {
  fn new(instance: RemoveTopChat) -> Self { Self { instance } }

  pub fn build(&self) -> RemoveTopChat {
    self.instance.clone()
  }
  
  pub fn category(&mut self, category: Box<TopChatCategory>) -> &mut Self {
    self.instance.category = Some(category);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Changes the order of installed sticker sets.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReorderInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // reorderInstalledStickerSets

  /// Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets.
  is_masks: Option<bool>,
  /// Identifiers of installed sticker sets in the new correct order.
  sticker_set_ids: Option<Vec<i64>>,


}




impl Function for ReorderInstalledStickerSets {}


impl ReorderInstalledStickerSets {
  
  pub fn builder() -> ReorderInstalledStickerSetsBuilder {
    let instance = Self {
      tdfname: "reorderInstalledStickerSets".to_string(),
      is_masks: None,
      sticker_set_ids: None,
      
    };
    ReorderInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn sticker_set_ids(&self) -> &Option<Vec<i64>> { &self.sticker_set_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReorderInstalledStickerSetsBuilder {
  instance: ReorderInstalledStickerSets
}

impl ReorderInstalledStickerSetsBuilder {
  fn new(instance: ReorderInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> ReorderInstalledStickerSets {
    self.instance.clone()
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn sticker_set_ids(&mut self, sticker_set_ids: Vec<i64>) -> &mut Self {
    self.instance.sticker_set_ids = Some(sticker_set_ids);
    self
  }
  
}


/// Reports a chat to the Telegram moderators. Supported only for supergroups, channels, or private chats with bots, since other chats can't be checked by moderators.
#[derive(Debug, Serialize, Deserialize)]
pub struct ReportChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // reportChat

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The reason for reporting the chat.
  reason: Option<Box<ChatReportReason>>,
  /// Identifiers of reported messages, if any.
  message_ids: Option<Vec<i64>>,


}


impl Clone for ReportChat {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for ReportChat {}


impl ReportChat {
  
  pub fn builder() -> ReportChatBuilder {
    let instance = Self {
      tdfname: "reportChat".to_string(),
      chat_id: None,
      reason: None,
      message_ids: None,
      
    };
    ReportChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn reason(&self) -> &Option<Box<ChatReportReason>> { &self.reason }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReportChatBuilder {
  instance: ReportChat
}

impl ReportChatBuilder {
  fn new(instance: ReportChat) -> Self { Self { instance } }

  pub fn build(&self) -> ReportChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reason(&mut self, reason: Box<ChatReportReason>) -> &mut Self {
    self.instance.reason = Some(reason);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}


/// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportSupergroupSpam {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // reportSupergroupSpam

  /// Supergroup identifier.
  supergroup_id: Option<i32>,
  /// User identifier.
  user_id: Option<i32>,
  /// Identifiers of messages sent in the supergroup by the user. This list must be non-empty.
  message_ids: Option<Vec<i64>>,


}




impl Function for ReportSupergroupSpam {}


impl ReportSupergroupSpam {
  
  pub fn builder() -> ReportSupergroupSpamBuilder {
    let instance = Self {
      tdfname: "reportSupergroupSpam".to_string(),
      supergroup_id: None,
      user_id: None,
      message_ids: None,
      
    };
    ReportSupergroupSpamBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ReportSupergroupSpamBuilder {
  instance: ReportSupergroupSpam
}

impl ReportSupergroupSpamBuilder {
  fn new(instance: ReportSupergroupSpam) -> Self { Self { instance } }

  pub fn build(&self) -> ReportSupergroupSpam {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
}


/// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestAuthenticationPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // requestAuthenticationPasswordRecovery

}




impl Function for RequestAuthenticationPasswordRecovery {}


impl RequestAuthenticationPasswordRecovery {
  
  pub fn builder() -> RequestAuthenticationPasswordRecoveryBuilder {
    let instance = Self {
      tdfname: "requestAuthenticationPasswordRecovery".to_string(),
      
    };
    RequestAuthenticationPasswordRecoveryBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RequestAuthenticationPasswordRecoveryBuilder {
  instance: RequestAuthenticationPasswordRecovery
}

impl RequestAuthenticationPasswordRecoveryBuilder {
  fn new(instance: RequestAuthenticationPasswordRecovery) -> Self { Self { instance } }

  pub fn build(&self) -> RequestAuthenticationPasswordRecovery {
    self.instance.clone()
  }
  
}


/// Requests to send a password recovery code to an email address that was previously set up.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestPasswordRecovery {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // requestPasswordRecovery

}




impl Function for RequestPasswordRecovery {}


impl RequestPasswordRecovery {
  
  pub fn builder() -> RequestPasswordRecoveryBuilder {
    let instance = Self {
      tdfname: "requestPasswordRecovery".to_string(),
      
    };
    RequestPasswordRecoveryBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct RequestPasswordRecoveryBuilder {
  instance: RequestPasswordRecovery
}

impl RequestPasswordRecoveryBuilder {
  fn new(instance: RequestPasswordRecovery) -> Self { Self { instance } }

  pub fn build(&self) -> RequestPasswordRecovery {
    self.instance.clone()
  }
  
}


/// Re-sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendAuthenticationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendAuthenticationCode

}




impl Function for ResendAuthenticationCode {}


impl ResendAuthenticationCode {
  
  pub fn builder() -> ResendAuthenticationCodeBuilder {
    let instance = Self {
      tdfname: "resendAuthenticationCode".to_string(),
      
    };
    ResendAuthenticationCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendAuthenticationCodeBuilder {
  instance: ResendAuthenticationCode
}

impl ResendAuthenticationCodeBuilder {
  fn new(instance: ResendAuthenticationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendAuthenticationCode {
    self.instance.clone()
  }
  
}


/// Re-sends the authentication code sent to confirm a new phone number for the user. Works only if the previously received 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendChangePhoneNumberCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendChangePhoneNumberCode

}




impl Function for ResendChangePhoneNumberCode {}


impl ResendChangePhoneNumberCode {
  
  pub fn builder() -> ResendChangePhoneNumberCodeBuilder {
    let instance = Self {
      tdfname: "resendChangePhoneNumberCode".to_string(),
      
    };
    ResendChangePhoneNumberCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendChangePhoneNumberCodeBuilder {
  instance: ResendChangePhoneNumberCode
}

impl ResendChangePhoneNumberCodeBuilder {
  fn new(instance: ResendChangePhoneNumberCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendChangePhoneNumberCode {
    self.instance.clone()
  }
  
}


/// Re-sends the code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendEmailAddressVerificationCode

}




impl Function for ResendEmailAddressVerificationCode {}


impl ResendEmailAddressVerificationCode {
  
  pub fn builder() -> ResendEmailAddressVerificationCodeBuilder {
    let instance = Self {
      tdfname: "resendEmailAddressVerificationCode".to_string(),
      
    };
    ResendEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendEmailAddressVerificationCodeBuilder {
  instance: ResendEmailAddressVerificationCode
}

impl ResendEmailAddressVerificationCodeBuilder {
  fn new(instance: ResendEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendEmailAddressVerificationCode {
    self.instance.clone()
  }
  
}


/// Resends phone number confirmation code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendPhoneNumberConfirmationCode

}




impl Function for ResendPhoneNumberConfirmationCode {}


impl ResendPhoneNumberConfirmationCode {
  
  pub fn builder() -> ResendPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      tdfname: "resendPhoneNumberConfirmationCode".to_string(),
      
    };
    ResendPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendPhoneNumberConfirmationCodeBuilder {
  instance: ResendPhoneNumberConfirmationCode
}

impl ResendPhoneNumberConfirmationCodeBuilder {
  fn new(instance: ResendPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendPhoneNumberConfirmationCode {
    self.instance.clone()
  }
  
}


/// Re-sends the code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendPhoneNumberVerificationCode

}




impl Function for ResendPhoneNumberVerificationCode {}


impl ResendPhoneNumberVerificationCode {
  
  pub fn builder() -> ResendPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      tdfname: "resendPhoneNumberVerificationCode".to_string(),
      
    };
    ResendPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendPhoneNumberVerificationCodeBuilder {
  instance: ResendPhoneNumberVerificationCode
}

impl ResendPhoneNumberVerificationCodeBuilder {
  fn new(instance: ResendPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendPhoneNumberVerificationCode {
    self.instance.clone()
  }
  
}


/// Resends the 2-step verification recovery email address verification code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResendRecoveryEmailAddressCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resendRecoveryEmailAddressCode

}




impl Function for ResendRecoveryEmailAddressCode {}


impl ResendRecoveryEmailAddressCode {
  
  pub fn builder() -> ResendRecoveryEmailAddressCodeBuilder {
    let instance = Self {
      tdfname: "resendRecoveryEmailAddressCode".to_string(),
      
    };
    ResendRecoveryEmailAddressCodeBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResendRecoveryEmailAddressCodeBuilder {
  instance: ResendRecoveryEmailAddressCode
}

impl ResendRecoveryEmailAddressCodeBuilder {
  fn new(instance: ResendRecoveryEmailAddressCode) -> Self { Self { instance } }

  pub fn build(&self) -> ResendRecoveryEmailAddressCode {
    self.instance.clone()
  }
  
}


/// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetAllNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resetAllNotificationSettings

}




impl Function for ResetAllNotificationSettings {}


impl ResetAllNotificationSettings {
  
  pub fn builder() -> ResetAllNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "resetAllNotificationSettings".to_string(),
      
    };
    ResetAllNotificationSettingsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResetAllNotificationSettingsBuilder {
  instance: ResetAllNotificationSettings
}

impl ResetAllNotificationSettingsBuilder {
  fn new(instance: ResetAllNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> ResetAllNotificationSettings {
    self.instance.clone()
  }
  
}


/// Resets all network data usage statistics to zero. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResetNetworkStatistics {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // resetNetworkStatistics

}




impl Function for ResetNetworkStatistics {}


impl ResetNetworkStatistics {
  
  pub fn builder() -> ResetNetworkStatisticsBuilder {
    let instance = Self {
      tdfname: "resetNetworkStatistics".to_string(),
      
    };
    ResetNetworkStatisticsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ResetNetworkStatisticsBuilder {
  instance: ResetNetworkStatistics
}

impl ResetNetworkStatisticsBuilder {
  fn new(instance: ResetNetworkStatistics) -> Self { Self { instance } }

  pub fn build(&self) -> ResetNetworkStatistics {
    self.instance.clone()
  }
  
}


/// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchCallMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchCallMessages

  /// Identifier of the message from which to search; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// If true, returns only messages with missed calls.
  only_missed: Option<bool>,


}




impl Function for SearchCallMessages {}


impl SearchCallMessages {
  
  pub fn builder() -> SearchCallMessagesBuilder {
    let instance = Self {
      tdfname: "searchCallMessages".to_string(),
      from_message_id: None,
      limit: None,
      only_missed: None,
      
    };
    SearchCallMessagesBuilder::new(instance)
  }
  
  
  pub fn from_message_id(&self) -> &Option<i64> { &self.from_message_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn only_missed(&self) -> &Option<bool> { &self.only_missed }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchCallMessagesBuilder {
  instance: SearchCallMessages
}

impl SearchCallMessagesBuilder {
  fn new(instance: SearchCallMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchCallMessages {
    self.instance.clone()
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn only_missed(&mut self, only_missed: bool) -> &mut Self {
    self.instance.only_missed = Some(only_missed);
    self
  }
  
}


/// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMembers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchChatMembers

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// The maximum number of users to be returned.
  limit: Option<i32>,
  /// The type of users to return. By default, chatMembersFilterMembers.
  filter: Option<Box<ChatMembersFilter>>,


}


impl Clone for SearchChatMembers {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SearchChatMembers {}


impl SearchChatMembers {
  
  pub fn builder() -> SearchChatMembersBuilder {
    let instance = Self {
      tdfname: "searchChatMembers".to_string(),
      chat_id: None,
      query: None,
      limit: None,
      filter: None,
      
    };
    SearchChatMembersBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn filter(&self) -> &Option<Box<ChatMembersFilter>> { &self.filter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchChatMembersBuilder {
  instance: SearchChatMembers
}

impl SearchChatMembersBuilder {
  fn new(instance: SearchChatMembers) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatMembers {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<ChatMembersFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}


/// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query (
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchChatMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchChatMessages

  /// Identifier of the chat in which to search messages.
  chat_id: Option<i64>,
  /// Query to search for.
  query: Option<String>,
  /// If not 0, only messages sent by the specified user will be returned. Not supported in secret chats.
  sender_user_id: Option<i32>,
  /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message.
  from_message_id: Option<i64>,
  /// Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages.
  offset: Option<i32>,
  /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// Filter for message content in the search results.
  filter: Option<Box<SearchMessagesFilter>>,


}


impl Clone for SearchChatMessages {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SearchChatMessages {}


impl SearchChatMessages {
  
  pub fn builder() -> SearchChatMessagesBuilder {
    let instance = Self {
      tdfname: "searchChatMessages".to_string(),
      chat_id: None,
      query: None,
      sender_user_id: None,
      from_message_id: None,
      offset: None,
      limit: None,
      filter: None,
      
    };
    SearchChatMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn sender_user_id(&self) -> &Option<i32> { &self.sender_user_id }
  
  pub fn from_message_id(&self) -> &Option<i64> { &self.from_message_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn filter(&self) -> &Option<Box<SearchMessagesFilter>> { &self.filter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchChatMessagesBuilder {
  instance: SearchChatMessages
}

impl SearchChatMessagesBuilder {
  fn new(instance: SearchChatMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn sender_user_id(&mut self, sender_user_id: i32) -> &mut Self {
    self.instance.sender_user_id = Some(sender_user_id);
    self
  }
  
  pub fn from_message_id(&mut self, from_message_id: i64) -> &mut Self {
    self.instance.from_message_id = Some(from_message_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}


/// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatRecentLocationMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchChatRecentLocationMessages

  /// Chat identifier.
  chat_id: Option<i64>,
  /// Maximum number of messages to be returned.
  limit: Option<i32>,


}




impl Function for SearchChatRecentLocationMessages {}


impl SearchChatRecentLocationMessages {
  
  pub fn builder() -> SearchChatRecentLocationMessagesBuilder {
    let instance = Self {
      tdfname: "searchChatRecentLocationMessages".to_string(),
      chat_id: None,
      limit: None,
      
    };
    SearchChatRecentLocationMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchChatRecentLocationMessagesBuilder {
  instance: SearchChatRecentLocationMessages
}

impl SearchChatRecentLocationMessagesBuilder {
  fn new(instance: SearchChatRecentLocationMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatRecentLocationMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchChats

  /// Query to search for. If the query is empty, returns up to 20 recently found chats.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,


}




impl Function for SearchChats {}


impl SearchChats {
  
  pub fn builder() -> SearchChatsBuilder {
    let instance = Self {
      tdfname: "searchChats".to_string(),
      query: None,
      limit: None,
      
    };
    SearchChatsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchChatsBuilder {
  instance: SearchChats
}

impl SearchChatsBuilder {
  fn new(instance: SearchChats) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChats {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the chat list.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchChatsOnServer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchChatsOnServer

  /// Query to search for.
  query: Option<String>,
  /// Maximum number of chats to be returned.
  limit: Option<i32>,


}




impl Function for SearchChatsOnServer {}


impl SearchChatsOnServer {
  
  pub fn builder() -> SearchChatsOnServerBuilder {
    let instance = Self {
      tdfname: "searchChatsOnServer".to_string(),
      query: None,
      limit: None,
      
    };
    SearchChatsOnServerBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchChatsOnServerBuilder {
  instance: SearchChatsOnServer
}

impl SearchChatsOnServerBuilder {
  fn new(instance: SearchChatsOnServer) -> Self { Self { instance } }

  pub fn build(&self) -> SearchChatsOnServer {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for the specified query in the first names, last names and usernames of the known user contacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchContacts {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchContacts

  /// Query to search for; may be empty to return all contacts.
  query: Option<String>,
  /// Maximum number of users to be returned.
  limit: Option<i32>,


}




impl Function for SearchContacts {}


impl SearchContacts {
  
  pub fn builder() -> SearchContactsBuilder {
    let instance = Self {
      tdfname: "searchContacts".to_string(),
      query: None,
      limit: None,
      
    };
    SearchContactsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchContactsBuilder {
  instance: SearchContacts
}

impl SearchContactsBuilder {
  fn new(instance: SearchContacts) -> Self { Self { instance } }

  pub fn build(&self) -> SearchContacts {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for recently used hashtags by their prefix.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchHashtags {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchHashtags

  /// Hashtag prefix to search for.
  prefix: Option<String>,
  /// Maximum number of hashtags to be returned.
  limit: Option<i32>,


}




impl Function for SearchHashtags {}


impl SearchHashtags {
  
  pub fn builder() -> SearchHashtagsBuilder {
    let instance = Self {
      tdfname: "searchHashtags".to_string(),
      prefix: None,
      limit: None,
      
    };
    SearchHashtagsBuilder::new(instance)
  }
  
  
  pub fn prefix(&self) -> &Option<String> { &self.prefix }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchHashtagsBuilder {
  instance: SearchHashtags
}

impl SearchHashtagsBuilder {
  fn new(instance: SearchHashtags) -> Self { Self { instance } }

  pub fn build(&self) -> SearchHashtags {
    self.instance.clone()
  }
  
  pub fn prefix(&mut self, prefix: String) -> &mut Self {
    self.instance.prefix = Some(prefix);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for installed sticker sets by looking for specified query in their title and name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchInstalledStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchInstalledStickerSets

  /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets.
  is_masks: Option<bool>,
  /// Query to search for.
  query: Option<String>,
  /// Maximum number of sticker sets to return.
  limit: Option<i32>,


}




impl Function for SearchInstalledStickerSets {}


impl SearchInstalledStickerSets {
  
  pub fn builder() -> SearchInstalledStickerSetsBuilder {
    let instance = Self {
      tdfname: "searchInstalledStickerSets".to_string(),
      is_masks: None,
      query: None,
      limit: None,
      
    };
    SearchInstalledStickerSetsBuilder::new(instance)
  }
  
  
  pub fn is_masks(&self) -> &Option<bool> { &self.is_masks }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchInstalledStickerSetsBuilder {
  instance: SearchInstalledStickerSets
}

impl SearchInstalledStickerSetsBuilder {
  fn new(instance: SearchInstalledStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> SearchInstalledStickerSets {
    self.instance.clone()
  }
  
  pub fn is_masks(&mut self, is_masks: bool) -> &mut Self {
    self.instance.is_masks = Some(is_masks);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchMessages

  /// Query to search for.
  query: Option<String>,
  /// The date of the message starting from which the results should be fetched. Use 0 or any date in the future to get results from the last message.
  offset_date: Option<i32>,
  /// The chat identifier of the last found message, or 0 for the first request.
  offset_chat_id: Option<i64>,
  /// The message identifier of the last found message, or 0 for the first request.
  offset_message_id: Option<i64>,
  /// The maximum number of messages to be returned, up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,


}




impl Function for SearchMessages {}


impl SearchMessages {
  
  pub fn builder() -> SearchMessagesBuilder {
    let instance = Self {
      tdfname: "searchMessages".to_string(),
      query: None,
      offset_date: None,
      offset_chat_id: None,
      offset_message_id: None,
      limit: None,
      
    };
    SearchMessagesBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn offset_date(&self) -> &Option<i32> { &self.offset_date }
  
  pub fn offset_chat_id(&self) -> &Option<i64> { &self.offset_chat_id }
  
  pub fn offset_message_id(&self) -> &Option<i64> { &self.offset_message_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchMessagesBuilder {
  instance: SearchMessages
}

impl SearchMessagesBuilder {
  fn new(instance: SearchMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchMessages {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn offset_date(&mut self, offset_date: i32) -> &mut Self {
    self.instance.offset_date = Some(offset_date);
    self
  }
  
  pub fn offset_chat_id(&mut self, offset_chat_id: i64) -> &mut Self {
    self.instance.offset_chat_id = Some(offset_chat_id);
    self
  }
  
  pub fn offset_message_id(&mut self, offset_message_id: i64) -> &mut Self {
    self.instance.offset_message_id = Some(offset_message_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchPublicChat

  /// Username to be resolved.
  username: Option<String>,


}




impl Function for SearchPublicChat {}


impl SearchPublicChat {
  
  pub fn builder() -> SearchPublicChatBuilder {
    let instance = Self {
      tdfname: "searchPublicChat".to_string(),
      username: None,
      
    };
    SearchPublicChatBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchPublicChatBuilder {
  instance: SearchPublicChat
}

impl SearchPublicChatBuilder {
  fn new(instance: SearchPublicChat) -> Self { Self { instance } }

  pub fn build(&self) -> SearchPublicChat {
    self.instance.clone()
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
}


/// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchPublicChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchPublicChats

  /// Query to search for.
  query: Option<String>,


}




impl Function for SearchPublicChats {}


impl SearchPublicChats {
  
  pub fn builder() -> SearchPublicChatsBuilder {
    let instance = Self {
      tdfname: "searchPublicChats".to_string(),
      query: None,
      
    };
    SearchPublicChatsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchPublicChatsBuilder {
  instance: SearchPublicChats
}

impl SearchPublicChatsBuilder {
  fn new(instance: SearchPublicChats) -> Self { Self { instance } }

  pub fn build(&self) -> SearchPublicChats {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
}


/// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library.
#[derive(Debug, Serialize, Deserialize)]
pub struct SearchSecretMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchSecretMessages

  /// Identifier of the chat in which to search. Specify 0 to search in all secret chats.
  chat_id: Option<i64>,
  /// Query to search for. If empty, searchChatMessages should be used instead.
  query: Option<String>,
  /// The identifier from the result of a previous request, use 0 to get results from the last message.
  from_search_id: Option<i64>,
  /// Maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached.
  limit: Option<i32>,
  /// A filter for the content of messages in the search results.
  filter: Option<Box<SearchMessagesFilter>>,


}


impl Clone for SearchSecretMessages {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SearchSecretMessages {}


impl SearchSecretMessages {
  
  pub fn builder() -> SearchSecretMessagesBuilder {
    let instance = Self {
      tdfname: "searchSecretMessages".to_string(),
      chat_id: None,
      query: None,
      from_search_id: None,
      limit: None,
      filter: None,
      
    };
    SearchSecretMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  pub fn from_search_id(&self) -> &Option<i64> { &self.from_search_id }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  pub fn filter(&self) -> &Option<Box<SearchMessagesFilter>> { &self.filter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchSecretMessagesBuilder {
  instance: SearchSecretMessages
}

impl SearchSecretMessagesBuilder {
  fn new(instance: SearchSecretMessages) -> Self { Self { instance } }

  pub fn build(&self) -> SearchSecretMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
  pub fn from_search_id(&mut self, from_search_id: i64) -> &mut Self {
    self.instance.from_search_id = Some(from_search_id);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
  pub fn filter(&mut self, filter: Box<SearchMessagesFilter>) -> &mut Self {
    self.instance.filter = Some(filter);
    self
  }
  
}


/// Searches for a sticker set by its name.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchStickerSet

  /// Name of the sticker set.
  name: Option<String>,


}




impl Function for SearchStickerSet {}


impl SearchStickerSet {
  
  pub fn builder() -> SearchStickerSetBuilder {
    let instance = Self {
      tdfname: "searchStickerSet".to_string(),
      name: None,
      
    };
    SearchStickerSetBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchStickerSetBuilder {
  instance: SearchStickerSet
}

impl SearchStickerSetBuilder {
  fn new(instance: SearchStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickerSet {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
}


/// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchStickerSets

  /// Query to search for.
  query: Option<String>,


}




impl Function for SearchStickerSets {}


impl SearchStickerSets {
  
  pub fn builder() -> SearchStickerSetsBuilder {
    let instance = Self {
      tdfname: "searchStickerSets".to_string(),
      query: None,
      
    };
    SearchStickerSetsBuilder::new(instance)
  }
  
  
  pub fn query(&self) -> &Option<String> { &self.query }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchStickerSetsBuilder {
  instance: SearchStickerSets
}

impl SearchStickerSetsBuilder {
  fn new(instance: SearchStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickerSets {
    self.instance.clone()
  }
  
  pub fn query(&mut self, query: String) -> &mut Self {
    self.instance.query = Some(query);
    self
  }
  
}


/// Searches for stickers from public sticker sets that correspond to a given emoji.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SearchStickers {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // searchStickers

  /// String representation of emoji; must be non-empty.
  emoji: Option<String>,
  /// Maximum number of stickers to be returned.
  limit: Option<i32>,


}




impl Function for SearchStickers {}


impl SearchStickers {
  
  pub fn builder() -> SearchStickersBuilder {
    let instance = Self {
      tdfname: "searchStickers".to_string(),
      emoji: None,
      limit: None,
      
    };
    SearchStickersBuilder::new(instance)
  }
  
  
  pub fn emoji(&self) -> &Option<String> { &self.emoji }
  
  pub fn limit(&self) -> &Option<i32> { &self.limit }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SearchStickersBuilder {
  instance: SearchStickers
}

impl SearchStickersBuilder {
  fn new(instance: SearchStickers) -> Self { Self { instance } }

  pub fn build(&self) -> SearchStickers {
    self.instance.clone()
  }
  
  pub fn emoji(&mut self, emoji: String) -> &mut Self {
    self.instance.emoji = Some(emoji);
    self
  }
  
  pub fn limit(&mut self, limit: i32) -> &mut Self {
    self.instance.limit = Some(limit);
    self
  }
  
}


/// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendBotStartMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendBotStartMessage

  /// Identifier of the bot.
  bot_user_id: Option<i32>,
  /// Identifier of the target chat.
  chat_id: Option<i64>,
  /// A hidden parameter sent to the bot for deep linking purposes (https://api.telegram.org/bots#deep-linking).
  parameter: Option<String>,


}




impl Function for SendBotStartMessage {}


impl SendBotStartMessage {
  
  pub fn builder() -> SendBotStartMessageBuilder {
    let instance = Self {
      tdfname: "sendBotStartMessage".to_string(),
      bot_user_id: None,
      chat_id: None,
      parameter: None,
      
    };
    SendBotStartMessageBuilder::new(instance)
  }
  
  
  pub fn bot_user_id(&self) -> &Option<i32> { &self.bot_user_id }
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn parameter(&self) -> &Option<String> { &self.parameter }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendBotStartMessageBuilder {
  instance: SendBotStartMessage
}

impl SendBotStartMessageBuilder {
  fn new(instance: SendBotStartMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendBotStartMessage {
    self.instance.clone()
  }
  
  pub fn bot_user_id(&mut self, bot_user_id: i32) -> &mut Self {
    self.instance.bot_user_id = Some(bot_user_id);
    self
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn parameter(&mut self, parameter: String) -> &mut Self {
    self.instance.parameter = Some(parameter);
    self
  }
  
}


/// Sends debug information for a call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallDebugInformation {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendCallDebugInformation

  /// Call identifier.
  call_id: Option<i32>,
  /// Debug information in application-specific format.
  debug_information: Option<String>,


}




impl Function for SendCallDebugInformation {}


impl SendCallDebugInformation {
  
  pub fn builder() -> SendCallDebugInformationBuilder {
    let instance = Self {
      tdfname: "sendCallDebugInformation".to_string(),
      call_id: None,
      debug_information: None,
      
    };
    SendCallDebugInformationBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> &Option<i32> { &self.call_id }
  
  pub fn debug_information(&self) -> &Option<String> { &self.debug_information }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendCallDebugInformationBuilder {
  instance: SendCallDebugInformation
}

impl SendCallDebugInformationBuilder {
  fn new(instance: SendCallDebugInformation) -> Self { Self { instance } }

  pub fn build(&self) -> SendCallDebugInformation {
    self.instance.clone()
  }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn debug_information(&mut self, debug_information: String) -> &mut Self {
    self.instance.debug_information = Some(debug_information);
    self
  }
  
}


/// Sends a call rating.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCallRating {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendCallRating

  /// Call identifier.
  call_id: Option<i32>,
  /// Call rating; 1-5.
  rating: Option<i32>,
  /// An optional user comment if the rating is less than 5.
  comment: Option<String>,


}




impl Function for SendCallRating {}


impl SendCallRating {
  
  pub fn builder() -> SendCallRatingBuilder {
    let instance = Self {
      tdfname: "sendCallRating".to_string(),
      call_id: None,
      rating: None,
      comment: None,
      
    };
    SendCallRatingBuilder::new(instance)
  }
  
  
  pub fn call_id(&self) -> &Option<i32> { &self.call_id }
  
  pub fn rating(&self) -> &Option<i32> { &self.rating }
  
  pub fn comment(&self) -> &Option<String> { &self.comment }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendCallRatingBuilder {
  instance: SendCallRating
}

impl SendCallRatingBuilder {
  fn new(instance: SendCallRating) -> Self { Self { instance } }

  pub fn build(&self) -> SendCallRating {
    self.instance.clone()
  }
  
  pub fn call_id(&mut self, call_id: i32) -> &mut Self {
    self.instance.call_id = Some(call_id);
    self
  }
  
  pub fn rating(&mut self, rating: i32) -> &mut Self {
    self.instance.rating = Some(rating);
    self
  }
  
  pub fn comment(&mut self, comment: String) -> &mut Self {
    self.instance.comment = Some(comment);
    self
  }
  
}


/// Sends a notification about user activity in a chat.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendChatAction {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendChatAction

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The action description.
  action: Option<Box<ChatAction>>,


}


impl Clone for SendChatAction {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SendChatAction {}


impl SendChatAction {
  
  pub fn builder() -> SendChatActionBuilder {
    let instance = Self {
      tdfname: "sendChatAction".to_string(),
      chat_id: None,
      action: None,
      
    };
    SendChatActionBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn action(&self) -> &Option<Box<ChatAction>> { &self.action }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendChatActionBuilder {
  instance: SendChatAction
}

impl SendChatActionBuilder {
  fn new(instance: SendChatAction) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatAction {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn action(&mut self, action: Box<ChatAction>) -> &mut Self {
    self.instance.action = Some(action);
    self
  }
  
}


/// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatScreenshotTakenNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendChatScreenshotTakenNotification

  /// Chat identifier.
  chat_id: Option<i64>,


}




impl Function for SendChatScreenshotTakenNotification {}


impl SendChatScreenshotTakenNotification {
  
  pub fn builder() -> SendChatScreenshotTakenNotificationBuilder {
    let instance = Self {
      tdfname: "sendChatScreenshotTakenNotification".to_string(),
      chat_id: None,
      
    };
    SendChatScreenshotTakenNotificationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendChatScreenshotTakenNotificationBuilder {
  instance: SendChatScreenshotTakenNotification
}

impl SendChatScreenshotTakenNotificationBuilder {
  fn new(instance: SendChatScreenshotTakenNotification) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatScreenshotTakenNotification {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendChatSetTtlMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendChatSetTtlMessage

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New TTL value, in seconds.
  ttl: Option<i32>,


}




impl Function for SendChatSetTtlMessage {}


impl SendChatSetTtlMessage {
  
  pub fn builder() -> SendChatSetTtlMessageBuilder {
    let instance = Self {
      tdfname: "sendChatSetTtlMessage".to_string(),
      chat_id: None,
      ttl: None,
      
    };
    SendChatSetTtlMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn ttl(&self) -> &Option<i32> { &self.ttl }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendChatSetTtlMessageBuilder {
  instance: SendChatSetTtlMessage
}

impl SendChatSetTtlMessageBuilder {
  fn new(instance: SendChatSetTtlMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendChatSetTtlMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn ttl(&mut self, ttl: i32) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}


/// Sends a custom request; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendCustomRequest {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendCustomRequest

  /// The method name.
  method: Option<String>,
  /// JSON-serialized method parameters.
  parameters: Option<String>,


}




impl Function for SendCustomRequest {}


impl SendCustomRequest {
  
  pub fn builder() -> SendCustomRequestBuilder {
    let instance = Self {
      tdfname: "sendCustomRequest".to_string(),
      method: None,
      parameters: None,
      
    };
    SendCustomRequestBuilder::new(instance)
  }
  
  
  pub fn method(&self) -> &Option<String> { &self.method }
  
  pub fn parameters(&self) -> &Option<String> { &self.parameters }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendCustomRequestBuilder {
  instance: SendCustomRequest
}

impl SendCustomRequestBuilder {
  fn new(instance: SendCustomRequest) -> Self { Self { instance } }

  pub fn build(&self) -> SendCustomRequest {
    self.instance.clone()
  }
  
  pub fn method(&mut self, method: String) -> &mut Self {
    self.instance.method = Some(method);
    self
  }
  
  pub fn parameters(&mut self, parameters: String) -> &mut Self {
    self.instance.parameters = Some(parameters);
    self
  }
  
}


/// Sends a code to verify an email address to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendEmailAddressVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendEmailAddressVerificationCode

  /// Email address.
  email_address: Option<String>,


}




impl Function for SendEmailAddressVerificationCode {}


impl SendEmailAddressVerificationCode {
  
  pub fn builder() -> SendEmailAddressVerificationCodeBuilder {
    let instance = Self {
      tdfname: "sendEmailAddressVerificationCode".to_string(),
      email_address: None,
      
    };
    SendEmailAddressVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn email_address(&self) -> &Option<String> { &self.email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendEmailAddressVerificationCodeBuilder {
  instance: SendEmailAddressVerificationCode
}

impl SendEmailAddressVerificationCodeBuilder {
  fn new(instance: SendEmailAddressVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendEmailAddressVerificationCode {
    self.instance.clone()
  }
  
  pub fn email_address(&mut self, email_address: String) -> &mut Self {
    self.instance.email_address = Some(email_address);
    self
  }
  
}


/// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendInlineQueryResultMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendInlineQueryResultMessage

  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from background.
  from_background: Option<bool>,
  /// Identifier of the inline query.
  query_id: Option<i64>,
  /// Identifier of the inline result.
  result_id: Option<String>,
  /// If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username").
  hide_via_bot: Option<bool>,


}




impl Function for SendInlineQueryResultMessage {}


impl SendInlineQueryResultMessage {
  
  pub fn builder() -> SendInlineQueryResultMessageBuilder {
    let instance = Self {
      tdfname: "sendInlineQueryResultMessage".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      query_id: None,
      result_id: None,
      hide_via_bot: None,
      
    };
    SendInlineQueryResultMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  pub fn from_background(&self) -> &Option<bool> { &self.from_background }
  
  pub fn query_id(&self) -> &Option<i64> { &self.query_id }
  
  pub fn result_id(&self) -> &Option<String> { &self.result_id }
  
  pub fn hide_via_bot(&self) -> &Option<bool> { &self.hide_via_bot }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendInlineQueryResultMessageBuilder {
  instance: SendInlineQueryResultMessage
}

impl SendInlineQueryResultMessageBuilder {
  fn new(instance: SendInlineQueryResultMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendInlineQueryResultMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn query_id(&mut self, query_id: i64) -> &mut Self {
    self.instance.query_id = Some(query_id);
    self
  }
  
  pub fn result_id(&mut self, result_id: String) -> &mut Self {
    self.instance.result_id = Some(result_id);
    self
  }
  
  pub fn hide_via_bot(&mut self, hide_via_bot: bool) -> &mut Self {
    self.instance.hide_via_bot = Some(hide_via_bot);
    self
  }
  
}


/// Sends a message. Returns the sent message.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendMessage

  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of the message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the message. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the message is sent from the background.
  from_background: Option<bool>,
  /// Markup for replying to the message; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,
  /// The content of the message to be sent.
  input_message_content: Option<Box<InputMessageContent>>,


}


impl Clone for SendMessage {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SendMessage {}


impl SendMessage {
  
  pub fn builder() -> SendMessageBuilder {
    let instance = Self {
      tdfname: "sendMessage".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      reply_markup: None,
      input_message_content: None,
      
    };
    SendMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  pub fn from_background(&self) -> &Option<bool> { &self.from_background }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  pub fn input_message_content(&self) -> &Option<Box<InputMessageContent>> { &self.input_message_content }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendMessageBuilder {
  instance: SendMessage
}

impl SendMessageBuilder {
  fn new(instance: SendMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SendMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
  pub fn input_message_content(&mut self, input_message_content: Box<InputMessageContent>) -> &mut Self {
    self.instance.input_message_content = Some(input_message_content);
    self
  }
  
}


/// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendMessageAlbum {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendMessageAlbum

  /// Target chat.
  chat_id: Option<i64>,
  /// Identifier of a message to reply to or 0.
  reply_to_message_id: Option<i64>,
  /// Pass true to disable notification for the messages. Not supported in secret chats.
  disable_notification: Option<bool>,
  /// Pass true if the messages are sent from the background.
  from_background: Option<bool>,
  /// Contents of messages to be sent.
  input_message_contents: Option<Vec<Box<InputMessageContent>>>,


}


impl Clone for SendMessageAlbum {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SendMessageAlbum {}


impl SendMessageAlbum {
  
  pub fn builder() -> SendMessageAlbumBuilder {
    let instance = Self {
      tdfname: "sendMessageAlbum".to_string(),
      chat_id: None,
      reply_to_message_id: None,
      disable_notification: None,
      from_background: None,
      input_message_contents: None,
      
    };
    SendMessageAlbumBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn reply_to_message_id(&self) -> &Option<i64> { &self.reply_to_message_id }
  
  pub fn disable_notification(&self) -> &Option<bool> { &self.disable_notification }
  
  pub fn from_background(&self) -> &Option<bool> { &self.from_background }
  
  pub fn input_message_contents(&self) -> &Option<Vec<Box<InputMessageContent>>> { &self.input_message_contents }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendMessageAlbumBuilder {
  instance: SendMessageAlbum
}

impl SendMessageAlbumBuilder {
  fn new(instance: SendMessageAlbum) -> Self { Self { instance } }

  pub fn build(&self) -> SendMessageAlbum {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn reply_to_message_id(&mut self, reply_to_message_id: i64) -> &mut Self {
    self.instance.reply_to_message_id = Some(reply_to_message_id);
    self
  }
  
  pub fn disable_notification(&mut self, disable_notification: bool) -> &mut Self {
    self.instance.disable_notification = Some(disable_notification);
    self
  }
  
  pub fn from_background(&mut self, from_background: bool) -> &mut Self {
    self.instance.from_background = Some(from_background);
    self
  }
  
  pub fn input_message_contents(&mut self, input_message_contents: Vec<Box<InputMessageContent>>) -> &mut Self {
    self.instance.input_message_contents = Some(input_message_contents);
    self
  }
  
}


/// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after 
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPassportAuthorizationForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendPassportAuthorizationForm

  /// Authorization form identifier.
  autorization_form_id: Option<i32>,
  /// Types of Telegram Passport elements chosen by user to complete the authorization form.
  types: Option<Vec<Box<PassportElementType>>>,


}


impl Clone for SendPassportAuthorizationForm {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SendPassportAuthorizationForm {}


impl SendPassportAuthorizationForm {
  
  pub fn builder() -> SendPassportAuthorizationFormBuilder {
    let instance = Self {
      tdfname: "sendPassportAuthorizationForm".to_string(),
      autorization_form_id: None,
      types: None,
      
    };
    SendPassportAuthorizationFormBuilder::new(instance)
  }
  
  
  pub fn autorization_form_id(&self) -> &Option<i32> { &self.autorization_form_id }
  
  pub fn types(&self) -> &Option<Vec<Box<PassportElementType>>> { &self.types }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendPassportAuthorizationFormBuilder {
  instance: SendPassportAuthorizationForm
}

impl SendPassportAuthorizationFormBuilder {
  fn new(instance: SendPassportAuthorizationForm) -> Self { Self { instance } }

  pub fn build(&self) -> SendPassportAuthorizationForm {
    self.instance.clone()
  }
  
  pub fn autorization_form_id(&mut self, autorization_form_id: i32) -> &mut Self {
    self.instance.autorization_form_id = Some(autorization_form_id);
    self
  }
  
  pub fn types(&mut self, types: Vec<Box<PassportElementType>>) -> &mut Self {
    self.instance.types = Some(types);
    self
  }
  
}


/// Sends a filled-out payment form to the bot for final verification.
#[derive(Debug, Serialize, Deserialize)]
pub struct SendPaymentForm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendPaymentForm

  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// Identifier returned by ValidateOrderInfo, or an empty string.
  order_info_id: Option<String>,
  /// Identifier of a chosen shipping option, if applicable.
  shipping_option_id: Option<String>,
  /// The credentials chosen by user for payment.
  credentials: Option<Box<InputCredentials>>,


}


impl Clone for SendPaymentForm {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SendPaymentForm {}


impl SendPaymentForm {
  
  pub fn builder() -> SendPaymentFormBuilder {
    let instance = Self {
      tdfname: "sendPaymentForm".to_string(),
      chat_id: None,
      message_id: None,
      order_info_id: None,
      shipping_option_id: None,
      credentials: None,
      
    };
    SendPaymentFormBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn order_info_id(&self) -> &Option<String> { &self.order_info_id }
  
  pub fn shipping_option_id(&self) -> &Option<String> { &self.shipping_option_id }
  
  pub fn credentials(&self) -> &Option<Box<InputCredentials>> { &self.credentials }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendPaymentFormBuilder {
  instance: SendPaymentForm
}

impl SendPaymentFormBuilder {
  fn new(instance: SendPaymentForm) -> Self { Self { instance } }

  pub fn build(&self) -> SendPaymentForm {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn order_info_id(&mut self, order_info_id: String) -> &mut Self {
    self.instance.order_info_id = Some(order_info_id);
    self
  }
  
  pub fn shipping_option_id(&mut self, shipping_option_id: String) -> &mut Self {
    self.instance.shipping_option_id = Some(shipping_option_id);
    self
  }
  
  pub fn credentials(&mut self, credentials: Box<InputCredentials>) -> &mut Self {
    self.instance.credentials = Some(credentials);
    self
  }
  
}


/// Sends phone number confirmation code. Should be called when user presses "
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberConfirmationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendPhoneNumberConfirmationCode

  /// Value of the "hash" parameter from the link.
  hash: Option<String>,
  /// Value of the "phone" parameter from the link.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,


}




impl Function for SendPhoneNumberConfirmationCode {}


impl SendPhoneNumberConfirmationCode {
  
  pub fn builder() -> SendPhoneNumberConfirmationCodeBuilder {
    let instance = Self {
      tdfname: "sendPhoneNumberConfirmationCode".to_string(),
      hash: None,
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    SendPhoneNumberConfirmationCodeBuilder::new(instance)
  }
  
  
  pub fn hash(&self) -> &Option<String> { &self.hash }
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn allow_flash_call(&self) -> &Option<bool> { &self.allow_flash_call }
  
  pub fn is_current_phone_number(&self) -> &Option<bool> { &self.is_current_phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendPhoneNumberConfirmationCodeBuilder {
  instance: SendPhoneNumberConfirmationCode
}

impl SendPhoneNumberConfirmationCodeBuilder {
  fn new(instance: SendPhoneNumberConfirmationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendPhoneNumberConfirmationCode {
    self.instance.clone()
  }
  
  pub fn hash(&mut self, hash: String) -> &mut Self {
    self.instance.hash = Some(hash);
    self
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}


/// Sends a code to verify a phone number to be added to a user's Telegram Passport.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendPhoneNumberVerificationCode {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // sendPhoneNumberVerificationCode

  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,


}




impl Function for SendPhoneNumberVerificationCode {}


impl SendPhoneNumberVerificationCode {
  
  pub fn builder() -> SendPhoneNumberVerificationCodeBuilder {
    let instance = Self {
      tdfname: "sendPhoneNumberVerificationCode".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    SendPhoneNumberVerificationCodeBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn allow_flash_call(&self) -> &Option<bool> { &self.allow_flash_call }
  
  pub fn is_current_phone_number(&self) -> &Option<bool> { &self.is_current_phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SendPhoneNumberVerificationCodeBuilder {
  instance: SendPhoneNumberVerificationCode
}

impl SendPhoneNumberVerificationCodeBuilder {
  fn new(instance: SendPhoneNumberVerificationCode) -> Self { Self { instance } }

  pub fn build(&self) -> SendPhoneNumberVerificationCode {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}


/// Changes the period of inactivity after which the account of the current user will automatically be deleted.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAccountTtl {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setAccountTtl

  /// New account TTL.
  ttl: Option<AccountTtl>,


}




impl Function for SetAccountTtl {}


impl SetAccountTtl {
  
  pub fn builder() -> SetAccountTtlBuilder {
    let instance = Self {
      tdfname: "setAccountTtl".to_string(),
      ttl: None,
      
    };
    SetAccountTtlBuilder::new(instance)
  }
  
  
  pub fn ttl(&self) -> &Option<AccountTtl> { &self.ttl }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetAccountTtlBuilder {
  instance: SetAccountTtl
}

impl SetAccountTtlBuilder {
  fn new(instance: SetAccountTtl) -> Self { Self { instance } }

  pub fn build(&self) -> SetAccountTtl {
    self.instance.clone()
  }
  
  pub fn ttl(&mut self, ttl: AccountTtl) -> &mut Self {
    self.instance.ttl = Some(ttl);
    self
  }
  
}


/// Succeeds after a specified amount of time has passed. Can be called before authorization. Can be called before initialization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAlarm {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setAlarm

  /// Number of seconds before the function returns.
  seconds: Option<f64>,


}




impl Function for SetAlarm {}


impl SetAlarm {
  
  pub fn builder() -> SetAlarmBuilder {
    let instance = Self {
      tdfname: "setAlarm".to_string(),
      seconds: None,
      
    };
    SetAlarmBuilder::new(instance)
  }
  
  
  pub fn seconds(&self) -> &Option<f64> { &self.seconds }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetAlarmBuilder {
  instance: SetAlarm
}

impl SetAlarmBuilder {
  fn new(instance: SetAlarm) -> Self { Self { instance } }

  pub fn build(&self) -> SetAlarm {
    self.instance.clone()
  }
  
  pub fn seconds(&mut self, seconds: f64) -> &mut Self {
    self.instance.seconds = Some(seconds);
    self
  }
  
}


/// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAuthenticationPhoneNumber {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setAuthenticationPhoneNumber

  /// The phone number of the user, in international format.
  phone_number: Option<String>,
  /// Pass true if the authentication code may be sent via flash call to the specified phone number.
  allow_flash_call: Option<bool>,
  /// Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false.
  is_current_phone_number: Option<bool>,


}




impl Function for SetAuthenticationPhoneNumber {}


impl SetAuthenticationPhoneNumber {
  
  pub fn builder() -> SetAuthenticationPhoneNumberBuilder {
    let instance = Self {
      tdfname: "setAuthenticationPhoneNumber".to_string(),
      phone_number: None,
      allow_flash_call: None,
      is_current_phone_number: None,
      
    };
    SetAuthenticationPhoneNumberBuilder::new(instance)
  }
  
  
  pub fn phone_number(&self) -> &Option<String> { &self.phone_number }
  
  pub fn allow_flash_call(&self) -> &Option<bool> { &self.allow_flash_call }
  
  pub fn is_current_phone_number(&self) -> &Option<bool> { &self.is_current_phone_number }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetAuthenticationPhoneNumberBuilder {
  instance: SetAuthenticationPhoneNumber
}

impl SetAuthenticationPhoneNumberBuilder {
  fn new(instance: SetAuthenticationPhoneNumber) -> Self { Self { instance } }

  pub fn build(&self) -> SetAuthenticationPhoneNumber {
    self.instance.clone()
  }
  
  pub fn phone_number(&mut self, phone_number: String) -> &mut Self {
    self.instance.phone_number = Some(phone_number);
    self
  }
  
  pub fn allow_flash_call(&mut self, allow_flash_call: bool) -> &mut Self {
    self.instance.allow_flash_call = Some(allow_flash_call);
    self
  }
  
  pub fn is_current_phone_number(&mut self, is_current_phone_number: bool) -> &mut Self {
    self.instance.is_current_phone_number = Some(is_current_phone_number);
    self
  }
  
}


/// Changes the bio of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBio {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setBio

  /// The new value of the user bio; 0-70 characters without line feeds.
  bio: Option<String>,


}




impl Function for SetBio {}


impl SetBio {
  
  pub fn builder() -> SetBioBuilder {
    let instance = Self {
      tdfname: "setBio".to_string(),
      bio: None,
      
    };
    SetBioBuilder::new(instance)
  }
  
  
  pub fn bio(&self) -> &Option<String> { &self.bio }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetBioBuilder {
  instance: SetBio
}

impl SetBioBuilder {
  fn new(instance: SetBio) -> Self { Self { instance } }

  pub fn build(&self) -> SetBio {
    self.instance.clone()
  }
  
  pub fn bio(&mut self, bio: String) -> &mut Self {
    self.instance.bio = Some(bio);
    self
  }
  
}


/// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBotUpdatesStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setBotUpdatesStatus

  /// The number of pending updates.
  pending_update_count: Option<i32>,
  /// The last error message.
  error_message: Option<String>,


}




impl Function for SetBotUpdatesStatus {}


impl SetBotUpdatesStatus {
  
  pub fn builder() -> SetBotUpdatesStatusBuilder {
    let instance = Self {
      tdfname: "setBotUpdatesStatus".to_string(),
      pending_update_count: None,
      error_message: None,
      
    };
    SetBotUpdatesStatusBuilder::new(instance)
  }
  
  
  pub fn pending_update_count(&self) -> &Option<i32> { &self.pending_update_count }
  
  pub fn error_message(&self) -> &Option<String> { &self.error_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetBotUpdatesStatusBuilder {
  instance: SetBotUpdatesStatus
}

impl SetBotUpdatesStatusBuilder {
  fn new(instance: SetBotUpdatesStatus) -> Self { Self { instance } }

  pub fn build(&self) -> SetBotUpdatesStatus {
    self.instance.clone()
  }
  
  pub fn pending_update_count(&mut self, pending_update_count: i32) -> &mut Self {
    self.instance.pending_update_count = Some(pending_update_count);
    self
  }
  
  pub fn error_message(&mut self, error_message: String) -> &mut Self {
    self.instance.error_message = Some(error_message);
    self
  }
  
}


/// Changes client data associated with a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatClientData {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatClientData

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of client_data.
  client_data: Option<String>,


}




impl Function for SetChatClientData {}


impl SetChatClientData {
  
  pub fn builder() -> SetChatClientDataBuilder {
    let instance = Self {
      tdfname: "setChatClientData".to_string(),
      chat_id: None,
      client_data: None,
      
    };
    SetChatClientDataBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn client_data(&self) -> &Option<String> { &self.client_data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatClientDataBuilder {
  instance: SetChatClientData
}

impl SetChatClientDataBuilder {
  fn new(instance: SetChatClientData) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatClientData {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn client_data(&mut self, client_data: String) -> &mut Self {
    self.instance.client_data = Some(client_data);
    self
  }
  
}


/// Changes the draft message in a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatDraftMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatDraftMessage

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New draft message; may be null.
  draft_message: Option<DraftMessage>,


}




impl Function for SetChatDraftMessage {}


impl SetChatDraftMessage {
  
  pub fn builder() -> SetChatDraftMessageBuilder {
    let instance = Self {
      tdfname: "setChatDraftMessage".to_string(),
      chat_id: None,
      draft_message: None,
      
    };
    SetChatDraftMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn draft_message(&self) -> &Option<DraftMessage> { &self.draft_message }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatDraftMessageBuilder {
  instance: SetChatDraftMessage
}

impl SetChatDraftMessageBuilder {
  fn new(instance: SetChatDraftMessage) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatDraftMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn draft_message(&mut self, draft_message: DraftMessage) -> &mut Self {
    self.instance.draft_message = Some(draft_message);
    self
  }
  
}


/// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat; instead, use 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatMemberStatus {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatMemberStatus

  /// Chat identifier.
  chat_id: Option<i64>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new status of the member in the chat.
  status: Option<Box<ChatMemberStatus>>,


}


impl Clone for SetChatMemberStatus {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetChatMemberStatus {}


impl SetChatMemberStatus {
  
  pub fn builder() -> SetChatMemberStatusBuilder {
    let instance = Self {
      tdfname: "setChatMemberStatus".to_string(),
      chat_id: None,
      user_id: None,
      status: None,
      
    };
    SetChatMemberStatusBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn status(&self) -> &Option<Box<ChatMemberStatus>> { &self.status }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatMemberStatusBuilder {
  instance: SetChatMemberStatus
}

impl SetChatMemberStatusBuilder {
  fn new(instance: SetChatMemberStatus) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatMemberStatus {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn status(&mut self, status: Box<ChatMemberStatus>) -> &mut Self {
    self.instance.status = Some(status);
    self
  }
  
}


/// Changes the notification settings of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatNotificationSettings

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New notification settings for the chat.
  notification_settings: Option<ChatNotificationSettings>,


}




impl Function for SetChatNotificationSettings {}


impl SetChatNotificationSettings {
  
  pub fn builder() -> SetChatNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "setChatNotificationSettings".to_string(),
      chat_id: None,
      notification_settings: None,
      
    };
    SetChatNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn notification_settings(&self) -> &Option<ChatNotificationSettings> { &self.notification_settings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatNotificationSettingsBuilder {
  instance: SetChatNotificationSettings
}

impl SetChatNotificationSettingsBuilder {
  fn new(instance: SetChatNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatNotificationSettings {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ChatNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
}


/// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The photo will not be changed before request to the server has been completed.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetChatPhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatPhoto

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New chat photo. You can use a zero InputFileId to delete the chat photo. Files that are accessible only by HTTP URL are not acceptable.
  photo: Option<Box<InputFile>>,


}


impl Clone for SetChatPhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetChatPhoto {}


impl SetChatPhoto {
  
  pub fn builder() -> SetChatPhotoBuilder {
    let instance = Self {
      tdfname: "setChatPhoto".to_string(),
      chat_id: None,
      photo: None,
      
    };
    SetChatPhotoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn photo(&self) -> &Option<Box<InputFile>> { &self.photo }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatPhotoBuilder {
  instance: SetChatPhoto
}

impl SetChatPhotoBuilder {
  fn new(instance: SetChatPhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatPhoto {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}


/// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The title will not be changed until the request to the server has been completed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetChatTitle {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setChatTitle

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New title of the chat; 1-128 characters.
  title: Option<String>,


}




impl Function for SetChatTitle {}


impl SetChatTitle {
  
  pub fn builder() -> SetChatTitleBuilder {
    let instance = Self {
      tdfname: "setChatTitle".to_string(),
      chat_id: None,
      title: None,
      
    };
    SetChatTitleBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn title(&self) -> &Option<String> { &self.title }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetChatTitleBuilder {
  instance: SetChatTitle
}

impl SetChatTitleBuilder {
  fn new(instance: SetChatTitle) -> Self { Self { instance } }

  pub fn build(&self) -> SetChatTitle {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn title(&mut self, title: String) -> &mut Self {
    self.instance.title = Some(title);
    self
  }
  
}


/// Adds or changes a custom local language pack to the current localization target.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setCustomLanguagePack

  /// Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization.
  info: Option<LanguagePackInfo>,
  /// Strings of the new language pack.
  strings: Option<Vec<LanguagePackString>>,


}




impl Function for SetCustomLanguagePack {}


impl SetCustomLanguagePack {
  
  pub fn builder() -> SetCustomLanguagePackBuilder {
    let instance = Self {
      tdfname: "setCustomLanguagePack".to_string(),
      info: None,
      strings: None,
      
    };
    SetCustomLanguagePackBuilder::new(instance)
  }
  
  
  pub fn info(&self) -> &Option<LanguagePackInfo> { &self.info }
  
  pub fn strings(&self) -> &Option<Vec<LanguagePackString>> { &self.strings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetCustomLanguagePackBuilder {
  instance: SetCustomLanguagePack
}

impl SetCustomLanguagePackBuilder {
  fn new(instance: SetCustomLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> SetCustomLanguagePack {
    self.instance.clone()
  }
  
  pub fn info(&mut self, info: LanguagePackInfo) -> &mut Self {
    self.instance.info = Some(info);
    self
  }
  
  pub fn strings(&mut self, strings: Vec<LanguagePackString>) -> &mut Self {
    self.instance.strings = Some(strings);
    self
  }
  
}


/// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetCustomLanguagePackString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setCustomLanguagePackString

  /// Identifier of a previously added custom local language pack in the current localization target.
  language_pack_id: Option<String>,
  /// New language pack string.
  new_string: Option<LanguagePackString>,


}




impl Function for SetCustomLanguagePackString {}


impl SetCustomLanguagePackString {
  
  pub fn builder() -> SetCustomLanguagePackStringBuilder {
    let instance = Self {
      tdfname: "setCustomLanguagePackString".to_string(),
      language_pack_id: None,
      new_string: None,
      
    };
    SetCustomLanguagePackStringBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  pub fn new_string(&self) -> &Option<LanguagePackString> { &self.new_string }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetCustomLanguagePackStringBuilder {
  instance: SetCustomLanguagePackString
}

impl SetCustomLanguagePackStringBuilder {
  fn new(instance: SetCustomLanguagePackString) -> Self { Self { instance } }

  pub fn build(&self) -> SetCustomLanguagePackString {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
  pub fn new_string(&mut self, new_string: LanguagePackString) -> &mut Self {
    self.instance.new_string = Some(new_string);
    self
  }
  
}


/// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDatabaseEncryptionKey {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setDatabaseEncryptionKey

  /// New encryption key.
  new_encryption_key: Option<String>,


}




impl Function for SetDatabaseEncryptionKey {}


impl SetDatabaseEncryptionKey {
  
  pub fn builder() -> SetDatabaseEncryptionKeyBuilder {
    let instance = Self {
      tdfname: "setDatabaseEncryptionKey".to_string(),
      new_encryption_key: None,
      
    };
    SetDatabaseEncryptionKeyBuilder::new(instance)
  }
  
  
  pub fn new_encryption_key(&self) -> &Option<String> { &self.new_encryption_key }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetDatabaseEncryptionKeyBuilder {
  instance: SetDatabaseEncryptionKey
}

impl SetDatabaseEncryptionKeyBuilder {
  fn new(instance: SetDatabaseEncryptionKey) -> Self { Self { instance } }

  pub fn build(&self) -> SetDatabaseEncryptionKey {
    self.instance.clone()
  }
  
  pub fn new_encryption_key(&mut self, new_encryption_key: String) -> &mut Self {
    self.instance.new_encryption_key = Some(new_encryption_key);
    self
  }
  
}


/// Informs TDLib on a file generation prograss.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetFileGenerationProgress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setFileGenerationProgress

  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// Expected size of the generated file, in bytes; 0 if unknown.
  expected_size: Option<i32>,
  /// The number of bytes already generated.
  local_prefix_size: Option<i32>,


}




impl Function for SetFileGenerationProgress {}


impl SetFileGenerationProgress {
  
  pub fn builder() -> SetFileGenerationProgressBuilder {
    let instance = Self {
      tdfname: "setFileGenerationProgress".to_string(),
      generation_id: None,
      expected_size: None,
      local_prefix_size: None,
      
    };
    SetFileGenerationProgressBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> &Option<i64> { &self.generation_id }
  
  pub fn expected_size(&self) -> &Option<i32> { &self.expected_size }
  
  pub fn local_prefix_size(&self) -> &Option<i32> { &self.local_prefix_size }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetFileGenerationProgressBuilder {
  instance: SetFileGenerationProgress
}

impl SetFileGenerationProgressBuilder {
  fn new(instance: SetFileGenerationProgress) -> Self { Self { instance } }

  pub fn build(&self) -> SetFileGenerationProgress {
    self.instance.clone()
  }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn expected_size(&mut self, expected_size: i32) -> &mut Self {
    self.instance.expected_size = Some(expected_size);
    self
  }
  
  pub fn local_prefix_size(&mut self, local_prefix_size: i32) -> &mut Self {
    self.instance.local_prefix_size = Some(local_prefix_size);
    self
  }
  
}


/// Updates the game score of the specified user in the game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setGameScore

  /// The chat to which the message with the game belongs.
  chat_id: Option<i64>,
  /// Identifier of the message.
  message_id: Option<i64>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,


}




impl Function for SetGameScore {}


impl SetGameScore {
  
  pub fn builder() -> SetGameScoreBuilder {
    let instance = Self {
      tdfname: "setGameScore".to_string(),
      chat_id: None,
      message_id: None,
      edit_message: None,
      user_id: None,
      score: None,
      force: None,
      
    };
    SetGameScoreBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn edit_message(&self) -> &Option<bool> { &self.edit_message }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn score(&self) -> &Option<i32> { &self.score }
  
  pub fn force(&self) -> &Option<bool> { &self.force }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetGameScoreBuilder {
  instance: SetGameScore
}

impl SetGameScoreBuilder {
  fn new(instance: SetGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> SetGameScore {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn edit_message(&mut self, edit_message: bool) -> &mut Self {
    self.instance.edit_message = Some(edit_message);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}


/// Updates the game score of the specified user in a game; for bots only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetInlineGameScore {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setInlineGameScore

  /// Inline message identifier.
  inline_message_id: Option<String>,
  /// True, if the message should be edited.
  edit_message: Option<bool>,
  /// User identifier.
  user_id: Option<i32>,
  /// The new score.
  score: Option<i32>,
  /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table.
  force: Option<bool>,


}




impl Function for SetInlineGameScore {}


impl SetInlineGameScore {
  
  pub fn builder() -> SetInlineGameScoreBuilder {
    let instance = Self {
      tdfname: "setInlineGameScore".to_string(),
      inline_message_id: None,
      edit_message: None,
      user_id: None,
      score: None,
      force: None,
      
    };
    SetInlineGameScoreBuilder::new(instance)
  }
  
  
  pub fn inline_message_id(&self) -> &Option<String> { &self.inline_message_id }
  
  pub fn edit_message(&self) -> &Option<bool> { &self.edit_message }
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn score(&self) -> &Option<i32> { &self.score }
  
  pub fn force(&self) -> &Option<bool> { &self.force }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetInlineGameScoreBuilder {
  instance: SetInlineGameScore
}

impl SetInlineGameScoreBuilder {
  fn new(instance: SetInlineGameScore) -> Self { Self { instance } }

  pub fn build(&self) -> SetInlineGameScore {
    self.instance.clone()
  }
  
  pub fn inline_message_id(&mut self, inline_message_id: String) -> &mut Self {
    self.instance.inline_message_id = Some(inline_message_id);
    self
  }
  
  pub fn edit_message(&mut self, edit_message: bool) -> &mut Self {
    self.instance.edit_message = Some(edit_message);
    self
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn score(&mut self, score: i32) -> &mut Self {
    self.instance.score = Some(score);
    self
  }
  
  pub fn force(&mut self, force: bool) -> &mut Self {
    self.instance.force = Some(force);
    self
  }
  
}


/// Sets new log stream for internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetLogStream {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setLogStream

  /// New log stream.
  log_stream: Option<Box<LogStream>>,


}


impl Clone for SetLogStream {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetLogStream {}


impl SetLogStream {
  
  pub fn builder() -> SetLogStreamBuilder {
    let instance = Self {
      tdfname: "setLogStream".to_string(),
      log_stream: None,
      
    };
    SetLogStreamBuilder::new(instance)
  }
  
  
  pub fn log_stream(&self) -> &Option<Box<LogStream>> { &self.log_stream }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetLogStreamBuilder {
  instance: SetLogStream
}

impl SetLogStreamBuilder {
  fn new(instance: SetLogStream) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogStream {
    self.instance.clone()
  }
  
  pub fn log_stream(&mut self, log_stream: Box<LogStream>) -> &mut Self {
    self.instance.log_stream = Some(log_stream);
    self
  }
  
}


/// Sets the verbosity level for a specified TDLib internal log tag. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogTagVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setLogTagVerbosityLevel

  /// Logging tag to change verbosity level.
  tag: Option<String>,
  /// New verbosity level; 1-1024.
  new_verbosity_level: Option<i32>,


}




impl Function for SetLogTagVerbosityLevel {}


impl SetLogTagVerbosityLevel {
  
  pub fn builder() -> SetLogTagVerbosityLevelBuilder {
    let instance = Self {
      tdfname: "setLogTagVerbosityLevel".to_string(),
      tag: None,
      new_verbosity_level: None,
      
    };
    SetLogTagVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn tag(&self) -> &Option<String> { &self.tag }
  
  pub fn new_verbosity_level(&self) -> &Option<i32> { &self.new_verbosity_level }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetLogTagVerbosityLevelBuilder {
  instance: SetLogTagVerbosityLevel
}

impl SetLogTagVerbosityLevelBuilder {
  fn new(instance: SetLogTagVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogTagVerbosityLevel {
    self.instance.clone()
  }
  
  pub fn tag(&mut self, tag: String) -> &mut Self {
    self.instance.tag = Some(tag);
    self
  }
  
  pub fn new_verbosity_level(&mut self, new_verbosity_level: i32) -> &mut Self {
    self.instance.new_verbosity_level = Some(new_verbosity_level);
    self
  }
  
}


/// Sets the verbosity level of the internal logging of TDLib. This is an offline method. Can be called before authorization. Can be called synchronously.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetLogVerbosityLevel {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setLogVerbosityLevel

  /// New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging.
  new_verbosity_level: Option<i32>,


}




impl Function for SetLogVerbosityLevel {}


impl SetLogVerbosityLevel {
  
  pub fn builder() -> SetLogVerbosityLevelBuilder {
    let instance = Self {
      tdfname: "setLogVerbosityLevel".to_string(),
      new_verbosity_level: None,
      
    };
    SetLogVerbosityLevelBuilder::new(instance)
  }
  
  
  pub fn new_verbosity_level(&self) -> &Option<i32> { &self.new_verbosity_level }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetLogVerbosityLevelBuilder {
  instance: SetLogVerbosityLevel
}

impl SetLogVerbosityLevelBuilder {
  fn new(instance: SetLogVerbosityLevel) -> Self { Self { instance } }

  pub fn build(&self) -> SetLogVerbosityLevel {
    self.instance.clone()
  }
  
  pub fn new_verbosity_level(&mut self, new_verbosity_level: i32) -> &mut Self {
    self.instance.new_verbosity_level = Some(new_verbosity_level);
    self
  }
  
}


/// Changes the first and last name of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetName {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setName

  /// The new value of the first name for the user; 1-64 characters.
  first_name: Option<String>,
  /// The new value of the optional last name for the user; 0-64 characters.
  last_name: Option<String>,


}




impl Function for SetName {}


impl SetName {
  
  pub fn builder() -> SetNameBuilder {
    let instance = Self {
      tdfname: "setName".to_string(),
      first_name: None,
      last_name: None,
      
    };
    SetNameBuilder::new(instance)
  }
  
  
  pub fn first_name(&self) -> &Option<String> { &self.first_name }
  
  pub fn last_name(&self) -> &Option<String> { &self.last_name }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetNameBuilder {
  instance: SetName
}

impl SetNameBuilder {
  fn new(instance: SetName) -> Self { Self { instance } }

  pub fn build(&self) -> SetName {
    self.instance.clone()
  }
  
  pub fn first_name(&mut self, first_name: String) -> &mut Self {
    self.instance.first_name = Some(first_name);
    self
  }
  
  pub fn last_name(&mut self, last_name: String) -> &mut Self {
    self.instance.last_name = Some(last_name);
    self
  }
  
}


/// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetNetworkType {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setNetworkType

  /// The new network type. By default, networkTypeOther.
  #[serde(rename(serialize = "type", deserialize = "type"))] type_: Option<Box<NetworkType>>,


}


impl Clone for SetNetworkType {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetNetworkType {}


impl SetNetworkType {
  
  pub fn builder() -> SetNetworkTypeBuilder {
    let instance = Self {
      tdfname: "setNetworkType".to_string(),
      type_: None,
      
    };
    SetNetworkTypeBuilder::new(instance)
  }
  
  
  pub fn type_(&self) -> &Option<Box<NetworkType>> { &self.type_ }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetNetworkTypeBuilder {
  instance: SetNetworkType
}

impl SetNetworkTypeBuilder {
  fn new(instance: SetNetworkType) -> Self { Self { instance } }

  pub fn build(&self) -> SetNetworkType {
    self.instance.clone()
  }
  
  pub fn type_(&mut self, type_: Box<NetworkType>) -> &mut Self {
    self.instance.type_ = Some(type_);
    self
  }
  
}


/// Sets the value of an option. (Check the list of available options on 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetOption {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setOption

  /// The name of the option.
  name: Option<String>,
  /// The new value of the option.
  value: Option<Box<OptionValue>>,


}


impl Clone for SetOption {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetOption {}


impl SetOption {
  
  pub fn builder() -> SetOptionBuilder {
    let instance = Self {
      tdfname: "setOption".to_string(),
      name: None,
      value: None,
      
    };
    SetOptionBuilder::new(instance)
  }
  
  
  pub fn name(&self) -> &Option<String> { &self.name }
  
  pub fn value(&self) -> &Option<Box<OptionValue>> { &self.value }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetOptionBuilder {
  instance: SetOption
}

impl SetOptionBuilder {
  fn new(instance: SetOption) -> Self { Self { instance } }

  pub fn build(&self) -> SetOption {
    self.instance.clone()
  }
  
  pub fn name(&mut self, name: String) -> &mut Self {
    self.instance.name = Some(name);
    self
  }
  
  pub fn value(&mut self, value: Box<OptionValue>) -> &mut Self {
    self.instance.value = Some(value);
    self
  }
  
}


/// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetPassportElement {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setPassportElement

  /// Input Telegram Passport element.
  element: Option<Box<InputPassportElement>>,
  /// Password of the current user.
  password: Option<String>,


}


impl Clone for SetPassportElement {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetPassportElement {}


impl SetPassportElement {
  
  pub fn builder() -> SetPassportElementBuilder {
    let instance = Self {
      tdfname: "setPassportElement".to_string(),
      element: None,
      password: None,
      
    };
    SetPassportElementBuilder::new(instance)
  }
  
  
  pub fn element(&self) -> &Option<Box<InputPassportElement>> { &self.element }
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetPassportElementBuilder {
  instance: SetPassportElement
}

impl SetPassportElementBuilder {
  fn new(instance: SetPassportElement) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassportElement {
    self.instance.clone()
  }
  
  pub fn element(&mut self, element: Box<InputPassportElement>) -> &mut Self {
    self.instance.element = Some(element);
    self
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
}


/// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassportElementErrors {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setPassportElementErrors

  /// User identifier.
  user_id: Option<i32>,
  /// The errors.
  errors: Option<Vec<InputPassportElementError>>,


}




impl Function for SetPassportElementErrors {}


impl SetPassportElementErrors {
  
  pub fn builder() -> SetPassportElementErrorsBuilder {
    let instance = Self {
      tdfname: "setPassportElementErrors".to_string(),
      user_id: None,
      errors: None,
      
    };
    SetPassportElementErrorsBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn errors(&self) -> &Option<Vec<InputPassportElementError>> { &self.errors }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetPassportElementErrorsBuilder {
  instance: SetPassportElementErrors
}

impl SetPassportElementErrorsBuilder {
  fn new(instance: SetPassportElementErrors) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassportElementErrors {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn errors(&mut self, errors: Vec<InputPassportElementError>) -> &mut Self {
    self.instance.errors = Some(errors);
    self
  }
  
}


/// Changes the password for the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPassword {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setPassword

  /// Previous password of the user.
  old_password: Option<String>,
  /// New password of the user; may be empty to remove the password.
  new_password: Option<String>,
  /// New password hint; may be empty.
  new_hint: Option<String>,
  /// Pass true if the recovery email address should be changed.
  set_recovery_email_address: Option<bool>,
  /// New recovery email address; may be empty.
  new_recovery_email_address: Option<String>,


}




impl Function for SetPassword {}


impl SetPassword {
  
  pub fn builder() -> SetPasswordBuilder {
    let instance = Self {
      tdfname: "setPassword".to_string(),
      old_password: None,
      new_password: None,
      new_hint: None,
      set_recovery_email_address: None,
      new_recovery_email_address: None,
      
    };
    SetPasswordBuilder::new(instance)
  }
  
  
  pub fn old_password(&self) -> &Option<String> { &self.old_password }
  
  pub fn new_password(&self) -> &Option<String> { &self.new_password }
  
  pub fn new_hint(&self) -> &Option<String> { &self.new_hint }
  
  pub fn set_recovery_email_address(&self) -> &Option<bool> { &self.set_recovery_email_address }
  
  pub fn new_recovery_email_address(&self) -> &Option<String> { &self.new_recovery_email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetPasswordBuilder {
  instance: SetPassword
}

impl SetPasswordBuilder {
  fn new(instance: SetPassword) -> Self { Self { instance } }

  pub fn build(&self) -> SetPassword {
    self.instance.clone()
  }
  
  pub fn old_password(&mut self, old_password: String) -> &mut Self {
    self.instance.old_password = Some(old_password);
    self
  }
  
  pub fn new_password(&mut self, new_password: String) -> &mut Self {
    self.instance.new_password = Some(new_password);
    self
  }
  
  pub fn new_hint(&mut self, new_hint: String) -> &mut Self {
    self.instance.new_hint = Some(new_hint);
    self
  }
  
  pub fn set_recovery_email_address(&mut self, set_recovery_email_address: bool) -> &mut Self {
    self.instance.set_recovery_email_address = Some(set_recovery_email_address);
    self
  }
  
  pub fn new_recovery_email_address(&mut self, new_recovery_email_address: String) -> &mut Self {
    self.instance.new_recovery_email_address = Some(new_recovery_email_address);
    self
  }
  
}


/// Changes the order of pinned chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPinnedChats {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setPinnedChats

  /// The new list of pinned chats.
  chat_ids: Option<Vec<i64>>,


}




impl Function for SetPinnedChats {}


impl SetPinnedChats {
  
  pub fn builder() -> SetPinnedChatsBuilder {
    let instance = Self {
      tdfname: "setPinnedChats".to_string(),
      chat_ids: None,
      
    };
    SetPinnedChatsBuilder::new(instance)
  }
  
  
  pub fn chat_ids(&self) -> &Option<Vec<i64>> { &self.chat_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetPinnedChatsBuilder {
  instance: SetPinnedChats
}

impl SetPinnedChatsBuilder {
  fn new(instance: SetPinnedChats) -> Self { Self { instance } }

  pub fn build(&self) -> SetPinnedChats {
    self.instance.clone()
  }
  
  pub fn chat_ids(&mut self, chat_ids: Vec<i64>) -> &mut Self {
    self.instance.chat_ids = Some(chat_ids);
    self
  }
  
}


/// Changes user answer to a poll.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetPollAnswer {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setPollAnswer

  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// 0-based identifiers of options, chosen by the user. Currently user can't choose more than 1 option.
  option_ids: Option<Vec<i32>>,


}




impl Function for SetPollAnswer {}


impl SetPollAnswer {
  
  pub fn builder() -> SetPollAnswerBuilder {
    let instance = Self {
      tdfname: "setPollAnswer".to_string(),
      chat_id: None,
      message_id: None,
      option_ids: None,
      
    };
    SetPollAnswerBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn option_ids(&self) -> &Option<Vec<i32>> { &self.option_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetPollAnswerBuilder {
  instance: SetPollAnswer
}

impl SetPollAnswerBuilder {
  fn new(instance: SetPollAnswer) -> Self { Self { instance } }

  pub fn build(&self) -> SetPollAnswer {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn option_ids(&mut self, option_ids: Vec<i32>) -> &mut Self {
    self.instance.option_ids = Some(option_ids);
    self
  }
  
}


/// Uploads a new profile photo for the current user. If something changes, 
#[derive(Debug, Serialize, Deserialize)]
pub struct SetProfilePhoto {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setProfilePhoto

  /// Profile photo to set. inputFileId and inputFileRemote may still be unsupported.
  photo: Option<Box<InputFile>>,


}


impl Clone for SetProfilePhoto {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetProfilePhoto {}


impl SetProfilePhoto {
  
  pub fn builder() -> SetProfilePhotoBuilder {
    let instance = Self {
      tdfname: "setProfilePhoto".to_string(),
      photo: None,
      
    };
    SetProfilePhotoBuilder::new(instance)
  }
  
  
  pub fn photo(&self) -> &Option<Box<InputFile>> { &self.photo }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetProfilePhotoBuilder {
  instance: SetProfilePhoto
}

impl SetProfilePhotoBuilder {
  fn new(instance: SetProfilePhoto) -> Self { Self { instance } }

  pub fn build(&self) -> SetProfilePhoto {
    self.instance.clone()
  }
  
  pub fn photo(&mut self, photo: Box<InputFile>) -> &mut Self {
    self.instance.photo = Some(photo);
    self
  }
  
}


/// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetRecoveryEmailAddress {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setRecoveryEmailAddress

  /// Password of the current user.
  password: Option<String>,
  /// New recovery email address.
  new_recovery_email_address: Option<String>,


}




impl Function for SetRecoveryEmailAddress {}


impl SetRecoveryEmailAddress {
  
  pub fn builder() -> SetRecoveryEmailAddressBuilder {
    let instance = Self {
      tdfname: "setRecoveryEmailAddress".to_string(),
      password: None,
      new_recovery_email_address: None,
      
    };
    SetRecoveryEmailAddressBuilder::new(instance)
  }
  
  
  pub fn password(&self) -> &Option<String> { &self.password }
  
  pub fn new_recovery_email_address(&self) -> &Option<String> { &self.new_recovery_email_address }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetRecoveryEmailAddressBuilder {
  instance: SetRecoveryEmailAddress
}

impl SetRecoveryEmailAddressBuilder {
  fn new(instance: SetRecoveryEmailAddress) -> Self { Self { instance } }

  pub fn build(&self) -> SetRecoveryEmailAddress {
    self.instance.clone()
  }
  
  pub fn password(&mut self, password: String) -> &mut Self {
    self.instance.password = Some(password);
    self
  }
  
  pub fn new_recovery_email_address(&mut self, new_recovery_email_address: String) -> &mut Self {
    self.instance.new_recovery_email_address = Some(new_recovery_email_address);
    self
  }
  
}


/// Changes notification settings for chats of a given type.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetScopeNotificationSettings {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setScopeNotificationSettings

  /// Types of chats for which to change the notification settings.
  scope: Option<Box<NotificationSettingsScope>>,
  /// The new notification settings for the given scope.
  notification_settings: Option<ScopeNotificationSettings>,


}


impl Clone for SetScopeNotificationSettings {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetScopeNotificationSettings {}


impl SetScopeNotificationSettings {
  
  pub fn builder() -> SetScopeNotificationSettingsBuilder {
    let instance = Self {
      tdfname: "setScopeNotificationSettings".to_string(),
      scope: None,
      notification_settings: None,
      
    };
    SetScopeNotificationSettingsBuilder::new(instance)
  }
  
  
  pub fn scope(&self) -> &Option<Box<NotificationSettingsScope>> { &self.scope }
  
  pub fn notification_settings(&self) -> &Option<ScopeNotificationSettings> { &self.notification_settings }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetScopeNotificationSettingsBuilder {
  instance: SetScopeNotificationSettings
}

impl SetScopeNotificationSettingsBuilder {
  fn new(instance: SetScopeNotificationSettings) -> Self { Self { instance } }

  pub fn build(&self) -> SetScopeNotificationSettings {
    self.instance.clone()
  }
  
  pub fn scope(&mut self, scope: Box<NotificationSettingsScope>) -> &mut Self {
    self.instance.scope = Some(scope);
    self
  }
  
  pub fn notification_settings(&mut self, notification_settings: ScopeNotificationSettings) -> &mut Self {
    self.instance.notification_settings = Some(notification_settings);
    self
  }
  
}


/// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetStickerPositionInSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setStickerPositionInSet

  /// Sticker.
  sticker: Option<Box<InputFile>>,
  /// New position of the sticker in the set, zero-based.
  position: Option<i32>,


}


impl Clone for SetStickerPositionInSet {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetStickerPositionInSet {}


impl SetStickerPositionInSet {
  
  pub fn builder() -> SetStickerPositionInSetBuilder {
    let instance = Self {
      tdfname: "setStickerPositionInSet".to_string(),
      sticker: None,
      position: None,
      
    };
    SetStickerPositionInSetBuilder::new(instance)
  }
  
  
  pub fn sticker(&self) -> &Option<Box<InputFile>> { &self.sticker }
  
  pub fn position(&self) -> &Option<i32> { &self.position }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetStickerPositionInSetBuilder {
  instance: SetStickerPositionInSet
}

impl SetStickerPositionInSetBuilder {
  fn new(instance: SetStickerPositionInSet) -> Self { Self { instance } }

  pub fn build(&self) -> SetStickerPositionInSet {
    self.instance.clone()
  }
  
  pub fn sticker(&mut self, sticker: Box<InputFile>) -> &mut Self {
    self.instance.sticker = Some(sticker);
    self
  }
  
  pub fn position(&mut self, position: i32) -> &mut Self {
    self.instance.position = Some(position);
    self
  }
  
}


/// Changes information about a supergroup or channel; requires appropriate administrator rights.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupDescription {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setSupergroupDescription

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New supergroup or channel description; 0-255 characters.
  description: Option<String>,


}




impl Function for SetSupergroupDescription {}


impl SetSupergroupDescription {
  
  pub fn builder() -> SetSupergroupDescriptionBuilder {
    let instance = Self {
      tdfname: "setSupergroupDescription".to_string(),
      supergroup_id: None,
      description: None,
      
    };
    SetSupergroupDescriptionBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn description(&self) -> &Option<String> { &self.description }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetSupergroupDescriptionBuilder {
  instance: SetSupergroupDescription
}

impl SetSupergroupDescriptionBuilder {
  fn new(instance: SetSupergroupDescription) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupDescription {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn description(&mut self, description: String) -> &mut Self {
    self.instance.description = Some(description);
    self
  }
  
}


/// Changes the sticker set of a supergroup; requires appropriate rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupStickerSet {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setSupergroupStickerSet

  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set.
  sticker_set_id: Option<i64>,


}




impl Function for SetSupergroupStickerSet {}


impl SetSupergroupStickerSet {
  
  pub fn builder() -> SetSupergroupStickerSetBuilder {
    let instance = Self {
      tdfname: "setSupergroupStickerSet".to_string(),
      supergroup_id: None,
      sticker_set_id: None,
      
    };
    SetSupergroupStickerSetBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn sticker_set_id(&self) -> &Option<i64> { &self.sticker_set_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetSupergroupStickerSetBuilder {
  instance: SetSupergroupStickerSet
}

impl SetSupergroupStickerSetBuilder {
  fn new(instance: SetSupergroupStickerSet) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupStickerSet {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn sticker_set_id(&mut self, sticker_set_id: i64) -> &mut Self {
    self.instance.sticker_set_id = Some(sticker_set_id);
    self
  }
  
}


/// Changes the username of a supergroup or channel, requires creator privileges in the supergroup or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetSupergroupUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setSupergroupUsername

  /// Identifier of the supergroup or channel.
  supergroup_id: Option<i32>,
  /// New value of the username. Use an empty string to remove the username.
  username: Option<String>,


}




impl Function for SetSupergroupUsername {}


impl SetSupergroupUsername {
  
  pub fn builder() -> SetSupergroupUsernameBuilder {
    let instance = Self {
      tdfname: "setSupergroupUsername".to_string(),
      supergroup_id: None,
      username: None,
      
    };
    SetSupergroupUsernameBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetSupergroupUsernameBuilder {
  instance: SetSupergroupUsername
}

impl SetSupergroupUsernameBuilder {
  fn new(instance: SetSupergroupUsername) -> Self { Self { instance } }

  pub fn build(&self) -> SetSupergroupUsername {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
}


/// Sets the parameters for TDLib initialization. Works only when the current authorization state is 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetTdlibParameters {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setTdlibParameters

  /// Parameters.
  parameters: Option<TdlibParameters>,


}




impl Function for SetTdlibParameters {}


impl SetTdlibParameters {
  
  pub fn builder() -> SetTdlibParametersBuilder {
    let instance = Self {
      tdfname: "setTdlibParameters".to_string(),
      parameters: None,
      
    };
    SetTdlibParametersBuilder::new(instance)
  }
  
  
  pub fn parameters(&self) -> &Option<TdlibParameters> { &self.parameters }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetTdlibParametersBuilder {
  instance: SetTdlibParameters
}

impl SetTdlibParametersBuilder {
  fn new(instance: SetTdlibParameters) -> Self { Self { instance } }

  pub fn build(&self) -> SetTdlibParameters {
    self.instance.clone()
  }
  
  pub fn parameters(&mut self, parameters: TdlibParameters) -> &mut Self {
    self.instance.parameters = Some(parameters);
    self
  }
  
}


/// Changes user privacy settings.
#[derive(Debug, Serialize, Deserialize)]
pub struct SetUserPrivacySettingRules {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setUserPrivacySettingRules

  /// The privacy setting.
  setting: Option<Box<UserPrivacySetting>>,
  /// The new privacy rules.
  rules: Option<UserPrivacySettingRules>,


}


impl Clone for SetUserPrivacySettingRules {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for SetUserPrivacySettingRules {}


impl SetUserPrivacySettingRules {
  
  pub fn builder() -> SetUserPrivacySettingRulesBuilder {
    let instance = Self {
      tdfname: "setUserPrivacySettingRules".to_string(),
      setting: None,
      rules: None,
      
    };
    SetUserPrivacySettingRulesBuilder::new(instance)
  }
  
  
  pub fn setting(&self) -> &Option<Box<UserPrivacySetting>> { &self.setting }
  
  pub fn rules(&self) -> &Option<UserPrivacySettingRules> { &self.rules }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetUserPrivacySettingRulesBuilder {
  instance: SetUserPrivacySettingRules
}

impl SetUserPrivacySettingRulesBuilder {
  fn new(instance: SetUserPrivacySettingRules) -> Self { Self { instance } }

  pub fn build(&self) -> SetUserPrivacySettingRules {
    self.instance.clone()
  }
  
  pub fn setting(&mut self, setting: Box<UserPrivacySetting>) -> &mut Self {
    self.instance.setting = Some(setting);
    self
  }
  
  pub fn rules(&mut self, rules: UserPrivacySettingRules) -> &mut Self {
    self.instance.rules = Some(rules);
    self
  }
  
}


/// Changes the username of the current user. If something changes, 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetUsername {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // setUsername

  /// The new value of the username. Use an empty string to remove the username.
  username: Option<String>,


}




impl Function for SetUsername {}


impl SetUsername {
  
  pub fn builder() -> SetUsernameBuilder {
    let instance = Self {
      tdfname: "setUsername".to_string(),
      username: None,
      
    };
    SetUsernameBuilder::new(instance)
  }
  
  
  pub fn username(&self) -> &Option<String> { &self.username }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SetUsernameBuilder {
  instance: SetUsername
}

impl SetUsernameBuilder {
  fn new(instance: SetUsername) -> Self { Self { instance } }

  pub fn build(&self) -> SetUsername {
    self.instance.clone()
  }
  
  pub fn username(&mut self, username: String) -> &mut Self {
    self.instance.username = Some(username);
    self
  }
  
}


/// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set.
#[derive(Debug, Serialize, Deserialize)]
pub struct StopPoll {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // stopPoll

  /// Identifier of the chat to which the poll belongs.
  chat_id: Option<i64>,
  /// Identifier of the message containing the poll.
  message_id: Option<i64>,
  /// The new message reply markup; for bots only.
  reply_markup: Option<Box<ReplyMarkup>>,


}


impl Clone for StopPoll {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for StopPoll {}


impl StopPoll {
  
  pub fn builder() -> StopPollBuilder {
    let instance = Self {
      tdfname: "stopPoll".to_string(),
      chat_id: None,
      message_id: None,
      reply_markup: None,
      
    };
    StopPollBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn reply_markup(&self) -> &Option<Box<ReplyMarkup>> { &self.reply_markup }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct StopPollBuilder {
  instance: StopPoll
}

impl StopPollBuilder {
  fn new(instance: StopPoll) -> Self { Self { instance } }

  pub fn build(&self) -> StopPoll {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn reply_markup(&mut self, reply_markup: Box<ReplyMarkup>) -> &mut Self {
    self.instance.reply_markup = Some(reply_markup);
    self
  }
  
}


/// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynchronizeLanguagePack {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // synchronizeLanguagePack

  /// Language pack identifier.
  language_pack_id: Option<String>,


}




impl Function for SynchronizeLanguagePack {}


impl SynchronizeLanguagePack {
  
  pub fn builder() -> SynchronizeLanguagePackBuilder {
    let instance = Self {
      tdfname: "synchronizeLanguagePack".to_string(),
      language_pack_id: None,
      
    };
    SynchronizeLanguagePackBuilder::new(instance)
  }
  
  
  pub fn language_pack_id(&self) -> &Option<String> { &self.language_pack_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct SynchronizeLanguagePackBuilder {
  instance: SynchronizeLanguagePack
}

impl SynchronizeLanguagePackBuilder {
  fn new(instance: SynchronizeLanguagePack) -> Self { Self { instance } }

  pub fn build(&self) -> SynchronizeLanguagePack {
    self.instance.clone()
  }
  
  pub fn language_pack_id(&mut self, language_pack_id: String) -> &mut Self {
    self.instance.language_pack_id = Some(language_pack_id);
    self
  }
  
}


/// Terminates all other sessions of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateAllOtherSessions {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // terminateAllOtherSessions

}




impl Function for TerminateAllOtherSessions {}


impl TerminateAllOtherSessions {
  
  pub fn builder() -> TerminateAllOtherSessionsBuilder {
    let instance = Self {
      tdfname: "terminateAllOtherSessions".to_string(),
      
    };
    TerminateAllOtherSessionsBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TerminateAllOtherSessionsBuilder {
  instance: TerminateAllOtherSessions
}

impl TerminateAllOtherSessionsBuilder {
  fn new(instance: TerminateAllOtherSessions) -> Self { Self { instance } }

  pub fn build(&self) -> TerminateAllOtherSessions {
    self.instance.clone()
  }
  
}


/// Terminates a session of the current user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminateSession {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // terminateSession

  /// Session identifier.
  session_id: Option<i64>,


}




impl Function for TerminateSession {}


impl TerminateSession {
  
  pub fn builder() -> TerminateSessionBuilder {
    let instance = Self {
      tdfname: "terminateSession".to_string(),
      session_id: None,
      
    };
    TerminateSessionBuilder::new(instance)
  }
  
  
  pub fn session_id(&self) -> &Option<i64> { &self.session_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TerminateSessionBuilder {
  instance: TerminateSession
}

impl TerminateSessionBuilder {
  fn new(instance: TerminateSession) -> Self { Self { instance } }

  pub fn build(&self) -> TerminateSession {
    self.instance.clone()
  }
  
  pub fn session_id(&mut self, session_id: i64) -> &mut Self {
    self.instance.session_id = Some(session_id);
    self
  }
  
}


/// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallBytes {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallBytes

  /// Bytes to return.
  x: Option<String>,


}




impl Function for TestCallBytes {}


impl TestCallBytes {
  
  pub fn builder() -> TestCallBytesBuilder {
    let instance = Self {
      tdfname: "testCallBytes".to_string(),
      x: None,
      
    };
    TestCallBytesBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<String> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallBytesBuilder {
  instance: TestCallBytes
}

impl TestCallBytesBuilder {
  fn new(instance: TestCallBytes) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallBytes {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: String) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Does nothing; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallEmpty {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallEmpty

}




impl Function for TestCallEmpty {}


impl TestCallEmpty {
  
  pub fn builder() -> TestCallEmptyBuilder {
    let instance = Self {
      tdfname: "testCallEmpty".to_string(),
      
    };
    TestCallEmptyBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallEmptyBuilder {
  instance: TestCallEmpty
}

impl TestCallEmptyBuilder {
  fn new(instance: TestCallEmpty) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallEmpty {
    self.instance.clone()
  }
  
}


/// Returns the received string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallString

  /// String to return.
  x: Option<String>,


}




impl Function for TestCallString {}


impl TestCallString {
  
  pub fn builder() -> TestCallStringBuilder {
    let instance = Self {
      tdfname: "testCallString".to_string(),
      x: None,
      
    };
    TestCallStringBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<String> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallStringBuilder {
  instance: TestCallString
}

impl TestCallStringBuilder {
  fn new(instance: TestCallString) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallString {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: String) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallVectorInt

  /// Vector of numbers to return.
  x: Option<Vec<i32>>,


}




impl Function for TestCallVectorInt {}


impl TestCallVectorInt {
  
  pub fn builder() -> TestCallVectorIntBuilder {
    let instance = Self {
      tdfname: "testCallVectorInt".to_string(),
      x: None,
      
    };
    TestCallVectorIntBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<Vec<i32>> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallVectorIntBuilder {
  instance: TestCallVectorInt
}

impl TestCallVectorIntBuilder {
  fn new(instance: TestCallVectorInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorInt {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: Vec<i32>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorIntObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallVectorIntObject

  /// Vector of objects to return.
  x: Option<Vec<TestInt>>,


}




impl Function for TestCallVectorIntObject {}


impl TestCallVectorIntObject {
  
  pub fn builder() -> TestCallVectorIntObjectBuilder {
    let instance = Self {
      tdfname: "testCallVectorIntObject".to_string(),
      x: None,
      
    };
    TestCallVectorIntObjectBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<Vec<TestInt>> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallVectorIntObjectBuilder {
  instance: TestCallVectorIntObject
}

impl TestCallVectorIntObjectBuilder {
  fn new(instance: TestCallVectorIntObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorIntObject {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: Vec<TestInt>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorString {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallVectorString

  /// Vector of strings to return.
  x: Option<Vec<String>>,


}




impl Function for TestCallVectorString {}


impl TestCallVectorString {
  
  pub fn builder() -> TestCallVectorStringBuilder {
    let instance = Self {
      tdfname: "testCallVectorString".to_string(),
      x: None,
      
    };
    TestCallVectorStringBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<Vec<String>> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallVectorStringBuilder {
  instance: TestCallVectorString
}

impl TestCallVectorStringBuilder {
  fn new(instance: TestCallVectorString) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorString {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: Vec<String>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestCallVectorStringObject {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testCallVectorStringObject

  /// Vector of objects to return.
  x: Option<Vec<TestString>>,


}




impl Function for TestCallVectorStringObject {}


impl TestCallVectorStringObject {
  
  pub fn builder() -> TestCallVectorStringObjectBuilder {
    let instance = Self {
      tdfname: "testCallVectorStringObject".to_string(),
      x: None,
      
    };
    TestCallVectorStringObjectBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<Vec<TestString>> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestCallVectorStringObjectBuilder {
  instance: TestCallVectorStringObject
}

impl TestCallVectorStringObjectBuilder {
  fn new(instance: TestCallVectorStringObject) -> Self { Self { instance } }

  pub fn build(&self) -> TestCallVectorStringObject {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: Vec<TestString>) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Forces an updates.getDifference call to the Telegram servers; for testing only.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestGetDifference {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testGetDifference

}




impl Function for TestGetDifference {}


impl TestGetDifference {
  
  pub fn builder() -> TestGetDifferenceBuilder {
    let instance = Self {
      tdfname: "testGetDifference".to_string(),
      
    };
    TestGetDifferenceBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestGetDifferenceBuilder {
  instance: TestGetDifference
}

impl TestGetDifferenceBuilder {
  fn new(instance: TestGetDifference) -> Self { Self { instance } }

  pub fn build(&self) -> TestGetDifference {
    self.instance.clone()
  }
  
}


/// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestNetwork {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testNetwork

}




impl Function for TestNetwork {}


impl TestNetwork {
  
  pub fn builder() -> TestNetworkBuilder {
    let instance = Self {
      tdfname: "testNetwork".to_string(),
      
    };
    TestNetworkBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestNetworkBuilder {
  instance: TestNetwork
}

impl TestNetworkBuilder {
  fn new(instance: TestNetwork) -> Self { Self { instance } }

  pub fn build(&self) -> TestNetwork {
    self.instance.clone()
  }
  
}


/// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestSquareInt {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testSquareInt

  /// Number to square.
  x: Option<i32>,


}




impl Function for TestSquareInt {}


impl TestSquareInt {
  
  pub fn builder() -> TestSquareIntBuilder {
    let instance = Self {
      tdfname: "testSquareInt".to_string(),
      x: None,
      
    };
    TestSquareIntBuilder::new(instance)
  }
  
  
  pub fn x(&self) -> &Option<i32> { &self.x }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestSquareIntBuilder {
  instance: TestSquareInt
}

impl TestSquareIntBuilder {
  fn new(instance: TestSquareInt) -> Self { Self { instance } }

  pub fn build(&self) -> TestSquareInt {
    self.instance.clone()
  }
  
  pub fn x(&mut self, x: i32) -> &mut Self {
    self.instance.x = Some(x);
    self
  }
  
}


/// Does nothing and ensures that the Error object is used; for testing only. This is an offline method. Can be called before authorization.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseError {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testUseError

}




impl Function for TestUseError {}


impl TestUseError {
  
  pub fn builder() -> TestUseErrorBuilder {
    let instance = Self {
      tdfname: "testUseError".to_string(),
      
    };
    TestUseErrorBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestUseErrorBuilder {
  instance: TestUseError
}

impl TestUseErrorBuilder {
  fn new(instance: TestUseError) -> Self { Self { instance } }

  pub fn build(&self) -> TestUseError {
    self.instance.clone()
  }
  
}


/// Does nothing and ensures that the 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestUseUpdate {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // testUseUpdate

}




impl Function for TestUseUpdate {}


impl TestUseUpdate {
  
  pub fn builder() -> TestUseUpdateBuilder {
    let instance = Self {
      tdfname: "testUseUpdate".to_string(),
      
    };
    TestUseUpdateBuilder::new(instance)
  }
  
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct TestUseUpdateBuilder {
  instance: TestUseUpdate
}

impl TestUseUpdateBuilder {
  fn new(instance: TestUseUpdate) -> Self { Self { instance } }

  pub fn build(&self) -> TestUseUpdate {
    self.instance.clone()
  }
  
}


/// Toggles the "All members are admins" setting in basic groups; requires creator privileges in the group.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleBasicGroupAdministrators {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleBasicGroupAdministrators

  /// Identifier of the basic group.
  basic_group_id: Option<i32>,
  /// New value of everyone_is_administrator.
  everyone_is_administrator: Option<bool>,


}




impl Function for ToggleBasicGroupAdministrators {}


impl ToggleBasicGroupAdministrators {
  
  pub fn builder() -> ToggleBasicGroupAdministratorsBuilder {
    let instance = Self {
      tdfname: "toggleBasicGroupAdministrators".to_string(),
      basic_group_id: None,
      everyone_is_administrator: None,
      
    };
    ToggleBasicGroupAdministratorsBuilder::new(instance)
  }
  
  
  pub fn basic_group_id(&self) -> &Option<i32> { &self.basic_group_id }
  
  pub fn everyone_is_administrator(&self) -> &Option<bool> { &self.everyone_is_administrator }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleBasicGroupAdministratorsBuilder {
  instance: ToggleBasicGroupAdministrators
}

impl ToggleBasicGroupAdministratorsBuilder {
  fn new(instance: ToggleBasicGroupAdministrators) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleBasicGroupAdministrators {
    self.instance.clone()
  }
  
  pub fn basic_group_id(&mut self, basic_group_id: i32) -> &mut Self {
    self.instance.basic_group_id = Some(basic_group_id);
    self
  }
  
  pub fn everyone_is_administrator(&mut self, everyone_is_administrator: bool) -> &mut Self {
    self.instance.everyone_is_administrator = Some(everyone_is_administrator);
    self
  }
  
}


/// Changes the value of the default disable_notification parameter, used when a message is sent to a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatDefaultDisableNotification {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleChatDefaultDisableNotification

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of default_disable_notification.
  default_disable_notification: Option<bool>,


}




impl Function for ToggleChatDefaultDisableNotification {}


impl ToggleChatDefaultDisableNotification {
  
  pub fn builder() -> ToggleChatDefaultDisableNotificationBuilder {
    let instance = Self {
      tdfname: "toggleChatDefaultDisableNotification".to_string(),
      chat_id: None,
      default_disable_notification: None,
      
    };
    ToggleChatDefaultDisableNotificationBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn default_disable_notification(&self) -> &Option<bool> { &self.default_disable_notification }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleChatDefaultDisableNotificationBuilder {
  instance: ToggleChatDefaultDisableNotification
}

impl ToggleChatDefaultDisableNotificationBuilder {
  fn new(instance: ToggleChatDefaultDisableNotification) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatDefaultDisableNotification {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn default_disable_notification(&mut self, default_disable_notification: bool) -> &mut Self {
    self.instance.default_disable_notification = Some(default_disable_notification);
    self
  }
  
}


/// Changes the marked as unread state of a chat.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsMarkedAsUnread {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleChatIsMarkedAsUnread

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_marked_as_unread.
  is_marked_as_unread: Option<bool>,


}




impl Function for ToggleChatIsMarkedAsUnread {}


impl ToggleChatIsMarkedAsUnread {
  
  pub fn builder() -> ToggleChatIsMarkedAsUnreadBuilder {
    let instance = Self {
      tdfname: "toggleChatIsMarkedAsUnread".to_string(),
      chat_id: None,
      is_marked_as_unread: None,
      
    };
    ToggleChatIsMarkedAsUnreadBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_marked_as_unread(&self) -> &Option<bool> { &self.is_marked_as_unread }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleChatIsMarkedAsUnreadBuilder {
  instance: ToggleChatIsMarkedAsUnread
}

impl ToggleChatIsMarkedAsUnreadBuilder {
  fn new(instance: ToggleChatIsMarkedAsUnread) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatIsMarkedAsUnread {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_marked_as_unread(&mut self, is_marked_as_unread: bool) -> &mut Self {
    self.instance.is_marked_as_unread = Some(is_marked_as_unread);
    self
  }
  
}


/// Changes the pinned state of a chat. You can pin up to GetOption("pinned_chat_count_max") non-secret chats and the same number of secret chats.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleChatIsPinned {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleChatIsPinned

  /// Chat identifier.
  chat_id: Option<i64>,
  /// New value of is_pinned.
  is_pinned: Option<bool>,


}




impl Function for ToggleChatIsPinned {}


impl ToggleChatIsPinned {
  
  pub fn builder() -> ToggleChatIsPinnedBuilder {
    let instance = Self {
      tdfname: "toggleChatIsPinned".to_string(),
      chat_id: None,
      is_pinned: None,
      
    };
    ToggleChatIsPinnedBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn is_pinned(&self) -> &Option<bool> { &self.is_pinned }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleChatIsPinnedBuilder {
  instance: ToggleChatIsPinned
}

impl ToggleChatIsPinnedBuilder {
  fn new(instance: ToggleChatIsPinned) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleChatIsPinned {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn is_pinned(&mut self, is_pinned: bool) -> &mut Self {
    self.instance.is_pinned = Some(is_pinned);
    self
  }
  
}


/// Toggles whether all members of a supergroup can add new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupInvites {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleSupergroupInvites

  /// Identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// New value of anyone_can_invite.
  anyone_can_invite: Option<bool>,


}




impl Function for ToggleSupergroupInvites {}


impl ToggleSupergroupInvites {
  
  pub fn builder() -> ToggleSupergroupInvitesBuilder {
    let instance = Self {
      tdfname: "toggleSupergroupInvites".to_string(),
      supergroup_id: None,
      anyone_can_invite: None,
      
    };
    ToggleSupergroupInvitesBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn anyone_can_invite(&self) -> &Option<bool> { &self.anyone_can_invite }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleSupergroupInvitesBuilder {
  instance: ToggleSupergroupInvites
}

impl ToggleSupergroupInvitesBuilder {
  fn new(instance: ToggleSupergroupInvites) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupInvites {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn anyone_can_invite(&mut self, anyone_can_invite: bool) -> &mut Self {
    self.instance.anyone_can_invite = Some(anyone_can_invite);
    self
  }
  
}


/// Toggles whether the message history of a supergroup is available to new members; requires appropriate administrator rights in the supergroup.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupIsAllHistoryAvailable {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleSupergroupIsAllHistoryAvailable

  /// The identifier of the supergroup.
  supergroup_id: Option<i32>,
  /// The new value of is_all_history_available.
  is_all_history_available: Option<bool>,


}




impl Function for ToggleSupergroupIsAllHistoryAvailable {}


impl ToggleSupergroupIsAllHistoryAvailable {
  
  pub fn builder() -> ToggleSupergroupIsAllHistoryAvailableBuilder {
    let instance = Self {
      tdfname: "toggleSupergroupIsAllHistoryAvailable".to_string(),
      supergroup_id: None,
      is_all_history_available: None,
      
    };
    ToggleSupergroupIsAllHistoryAvailableBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn is_all_history_available(&self) -> &Option<bool> { &self.is_all_history_available }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleSupergroupIsAllHistoryAvailableBuilder {
  instance: ToggleSupergroupIsAllHistoryAvailable
}

impl ToggleSupergroupIsAllHistoryAvailableBuilder {
  fn new(instance: ToggleSupergroupIsAllHistoryAvailable) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupIsAllHistoryAvailable {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn is_all_history_available(&mut self, is_all_history_available: bool) -> &mut Self {
    self.instance.is_all_history_available = Some(is_all_history_available);
    self
  }
  
}


/// Toggles sender signatures messages sent in a channel; requires appropriate administrator rights in the channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToggleSupergroupSignMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // toggleSupergroupSignMessages

  /// Identifier of the channel.
  supergroup_id: Option<i32>,
  /// New value of sign_messages.
  sign_messages: Option<bool>,


}




impl Function for ToggleSupergroupSignMessages {}


impl ToggleSupergroupSignMessages {
  
  pub fn builder() -> ToggleSupergroupSignMessagesBuilder {
    let instance = Self {
      tdfname: "toggleSupergroupSignMessages".to_string(),
      supergroup_id: None,
      sign_messages: None,
      
    };
    ToggleSupergroupSignMessagesBuilder::new(instance)
  }
  
  
  pub fn supergroup_id(&self) -> &Option<i32> { &self.supergroup_id }
  
  pub fn sign_messages(&self) -> &Option<bool> { &self.sign_messages }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ToggleSupergroupSignMessagesBuilder {
  instance: ToggleSupergroupSignMessages
}

impl ToggleSupergroupSignMessagesBuilder {
  fn new(instance: ToggleSupergroupSignMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ToggleSupergroupSignMessages {
    self.instance.clone()
  }
  
  pub fn supergroup_id(&mut self, supergroup_id: i32) -> &mut Self {
    self.instance.supergroup_id = Some(supergroup_id);
    self
  }
  
  pub fn sign_messages(&mut self, sign_messages: bool) -> &mut Self {
    self.instance.sign_messages = Some(sign_messages);
    self
  }
  
}


/// Removes a user from the blacklist.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnblockUser {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // unblockUser

  /// User identifier.
  user_id: Option<i32>,


}




impl Function for UnblockUser {}


impl UnblockUser {
  
  pub fn builder() -> UnblockUserBuilder {
    let instance = Self {
      tdfname: "unblockUser".to_string(),
      user_id: None,
      
    };
    UnblockUserBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UnblockUserBuilder {
  instance: UnblockUser
}

impl UnblockUserBuilder {
  fn new(instance: UnblockUser) -> Self { Self { instance } }

  pub fn build(&self) -> UnblockUser {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
}


/// Removes the pinned message from a chat; requires appropriate administrator rights in the group or channel.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UnpinChatMessage {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // unpinChatMessage

  /// Identifier of the chat.
  chat_id: Option<i64>,


}




impl Function for UnpinChatMessage {}


impl UnpinChatMessage {
  
  pub fn builder() -> UnpinChatMessageBuilder {
    let instance = Self {
      tdfname: "unpinChatMessage".to_string(),
      chat_id: None,
      
    };
    UnpinChatMessageBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UnpinChatMessageBuilder {
  instance: UnpinChatMessage
}

impl UnpinChatMessageBuilder {
  fn new(instance: UnpinChatMessage) -> Self { Self { instance } }

  pub fn build(&self) -> UnpinChatMessage {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Creates a new supergroup from an existing basic group and sends a corresponding 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpgradeBasicGroupChatToSupergroupChat {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // upgradeBasicGroupChatToSupergroupChat

  /// Identifier of the chat to upgrade.
  chat_id: Option<i64>,


}




impl Function for UpgradeBasicGroupChatToSupergroupChat {}


impl UpgradeBasicGroupChatToSupergroupChat {
  
  pub fn builder() -> UpgradeBasicGroupChatToSupergroupChatBuilder {
    let instance = Self {
      tdfname: "upgradeBasicGroupChatToSupergroupChat".to_string(),
      chat_id: None,
      
    };
    UpgradeBasicGroupChatToSupergroupChatBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UpgradeBasicGroupChatToSupergroupChatBuilder {
  instance: UpgradeBasicGroupChatToSupergroupChat
}

impl UpgradeBasicGroupChatToSupergroupChatBuilder {
  fn new(instance: UpgradeBasicGroupChatToSupergroupChat) -> Self { Self { instance } }

  pub fn build(&self) -> UpgradeBasicGroupChatToSupergroupChat {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
}


/// Asynchronously uploads a file to the cloud without sending it in a message. 
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // uploadFile

  /// File to upload.
  file: Option<Box<InputFile>>,
  /// File type.
  file_type: Option<Box<FileType>>,
  /// Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first.
  priority: Option<i32>,


}


impl Clone for UploadFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for UploadFile {}


impl UploadFile {
  
  pub fn builder() -> UploadFileBuilder {
    let instance = Self {
      tdfname: "uploadFile".to_string(),
      file: None,
      file_type: None,
      priority: None,
      
    };
    UploadFileBuilder::new(instance)
  }
  
  
  pub fn file(&self) -> &Option<Box<InputFile>> { &self.file }
  
  pub fn file_type(&self) -> &Option<Box<FileType>> { &self.file_type }
  
  pub fn priority(&self) -> &Option<i32> { &self.priority }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UploadFileBuilder {
  instance: UploadFile
}

impl UploadFileBuilder {
  fn new(instance: UploadFile) -> Self { Self { instance } }

  pub fn build(&self) -> UploadFile {
    self.instance.clone()
  }
  
  pub fn file(&mut self, file: Box<InputFile>) -> &mut Self {
    self.instance.file = Some(file);
    self
  }
  
  pub fn file_type(&mut self, file_type: Box<FileType>) -> &mut Self {
    self.instance.file_type = Some(file_type);
    self
  }
  
  pub fn priority(&mut self, priority: i32) -> &mut Self {
    self.instance.priority = Some(priority);
    self
  }
  
}


/// Uploads a PNG image with a sticker; for bots only; returns the uploaded file.
#[derive(Debug, Serialize, Deserialize)]
pub struct UploadStickerFile {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // uploadStickerFile

  /// Sticker file owner.
  user_id: Option<i32>,
  /// PNG image with the sticker; must be up to 512 kB in size and fit in 512x512 square.
  png_sticker: Option<Box<InputFile>>,


}


impl Clone for UploadStickerFile {
  fn clone(&self) -> Self {
    let json = serde_json::to_string(self).unwrap();
    serde_json::from_str(&json[..]).unwrap()
  }
}



impl Function for UploadStickerFile {}


impl UploadStickerFile {
  
  pub fn builder() -> UploadStickerFileBuilder {
    let instance = Self {
      tdfname: "uploadStickerFile".to_string(),
      user_id: None,
      png_sticker: None,
      
    };
    UploadStickerFileBuilder::new(instance)
  }
  
  
  pub fn user_id(&self) -> &Option<i32> { &self.user_id }
  
  pub fn png_sticker(&self) -> &Option<Box<InputFile>> { &self.png_sticker }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct UploadStickerFileBuilder {
  instance: UploadStickerFile
}

impl UploadStickerFileBuilder {
  fn new(instance: UploadStickerFile) -> Self { Self { instance } }

  pub fn build(&self) -> UploadStickerFile {
    self.instance.clone()
  }
  
  pub fn user_id(&mut self, user_id: i32) -> &mut Self {
    self.instance.user_id = Some(user_id);
    self
  }
  
  pub fn png_sticker(&mut self, png_sticker: Box<InputFile>) -> &mut Self {
    self.instance.png_sticker = Some(png_sticker);
    self
  }
  
}


/// Validates the order information provided by a user and returns the available shipping options for a flexible invoice.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidateOrderInfo {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // validateOrderInfo

  /// Chat identifier of the Invoice message.
  chat_id: Option<i64>,
  /// Message identifier.
  message_id: Option<i64>,
  /// The order information, provided by the user.
  order_info: Option<OrderInfo>,
  /// True, if the order information can be saved.
  allow_save: Option<bool>,


}




impl Function for ValidateOrderInfo {}


impl ValidateOrderInfo {
  
  pub fn builder() -> ValidateOrderInfoBuilder {
    let instance = Self {
      tdfname: "validateOrderInfo".to_string(),
      chat_id: None,
      message_id: None,
      order_info: None,
      allow_save: None,
      
    };
    ValidateOrderInfoBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_id(&self) -> &Option<i64> { &self.message_id }
  
  pub fn order_info(&self) -> &Option<OrderInfo> { &self.order_info }
  
  pub fn allow_save(&self) -> &Option<bool> { &self.allow_save }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ValidateOrderInfoBuilder {
  instance: ValidateOrderInfo
}

impl ValidateOrderInfoBuilder {
  fn new(instance: ValidateOrderInfo) -> Self { Self { instance } }

  pub fn build(&self) -> ValidateOrderInfo {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_id(&mut self, message_id: i64) -> &mut Self {
    self.instance.message_id = Some(message_id);
    self
  }
  
  pub fn order_info(&mut self, order_info: OrderInfo) -> &mut Self {
    self.instance.order_info = Some(order_info);
    self
  }
  
  pub fn allow_save(&mut self, allow_save: bool) -> &mut Self {
    self.instance.allow_save = Some(allow_save);
    self
  }
  
}


/// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewMessages {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // viewMessages

  /// Chat identifier.
  chat_id: Option<i64>,
  /// The identifiers of the messages being viewed.
  message_ids: Option<Vec<i64>>,
  /// True, if messages in closed chats should be marked as read.
  force_read: Option<bool>,


}




impl Function for ViewMessages {}


impl ViewMessages {
  
  pub fn builder() -> ViewMessagesBuilder {
    let instance = Self {
      tdfname: "viewMessages".to_string(),
      chat_id: None,
      message_ids: None,
      force_read: None,
      
    };
    ViewMessagesBuilder::new(instance)
  }
  
  
  pub fn chat_id(&self) -> &Option<i64> { &self.chat_id }
  
  pub fn message_ids(&self) -> &Option<Vec<i64>> { &self.message_ids }
  
  pub fn force_read(&self) -> &Option<bool> { &self.force_read }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ViewMessagesBuilder {
  instance: ViewMessages
}

impl ViewMessagesBuilder {
  fn new(instance: ViewMessages) -> Self { Self { instance } }

  pub fn build(&self) -> ViewMessages {
    self.instance.clone()
  }
  
  pub fn chat_id(&mut self, chat_id: i64) -> &mut Self {
    self.instance.chat_id = Some(chat_id);
    self
  }
  
  pub fn message_ids(&mut self, message_ids: Vec<i64>) -> &mut Self {
    self.instance.message_ids = Some(message_ids);
    self
  }
  
  pub fn force_read(&mut self, force_read: bool) -> &mut Self {
    self.instance.force_read = Some(force_read);
    self
  }
  
}


/// Informs the server that some trending sticker sets have been viewed by the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ViewTrendingStickerSets {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // viewTrendingStickerSets

  /// Identifiers of viewed trending sticker sets.
  sticker_set_ids: Option<Vec<i64>>,


}




impl Function for ViewTrendingStickerSets {}


impl ViewTrendingStickerSets {
  
  pub fn builder() -> ViewTrendingStickerSetsBuilder {
    let instance = Self {
      tdfname: "viewTrendingStickerSets".to_string(),
      sticker_set_ids: None,
      
    };
    ViewTrendingStickerSetsBuilder::new(instance)
  }
  
  
  pub fn sticker_set_ids(&self) -> &Option<Vec<i64>> { &self.sticker_set_ids }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct ViewTrendingStickerSetsBuilder {
  instance: ViewTrendingStickerSets
}

impl ViewTrendingStickerSetsBuilder {
  fn new(instance: ViewTrendingStickerSets) -> Self { Self { instance } }

  pub fn build(&self) -> ViewTrendingStickerSets {
    self.instance.clone()
  }
  
  pub fn sticker_set_ids(&mut self, sticker_set_ids: Vec<i64>) -> &mut Self {
    self.instance.sticker_set_ids = Some(sticker_set_ids);
    self
  }
  
}


/// Writes a part of a generated file. This method is intended to be used only if the client has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WriteGeneratedFilePart {
  #[doc(hidden)]
  #[serde(rename(serialize = "@type", deserialize = "@type"))]
  tdfname: String, // writeGeneratedFilePart

  /// The identifier of the generation process.
  generation_id: Option<i64>,
  /// The offset from which to write the data to the file.
  offset: Option<i32>,
  /// The data to write.
  data: Option<String>,


}




impl Function for WriteGeneratedFilePart {}


impl WriteGeneratedFilePart {
  
  pub fn builder() -> WriteGeneratedFilePartBuilder {
    let instance = Self {
      tdfname: "writeGeneratedFilePart".to_string(),
      generation_id: None,
      offset: None,
      data: None,
      
    };
    WriteGeneratedFilePartBuilder::new(instance)
  }
  
  
  pub fn generation_id(&self) -> &Option<i64> { &self.generation_id }
  
  pub fn offset(&self) -> &Option<i32> { &self.offset }
  
  pub fn data(&self) -> &Option<String> { &self.data }
  
  #[doc(hidden)]
  pub fn tdfname(&self) -> String { self.tdfname.clone() }

  pub fn to_json(&self) -> String { serde_json::to_string(self).unwrap() }
}



#[derive(Debug)]
pub struct WriteGeneratedFilePartBuilder {
  instance: WriteGeneratedFilePart
}

impl WriteGeneratedFilePartBuilder {
  fn new(instance: WriteGeneratedFilePart) -> Self { Self { instance } }

  pub fn build(&self) -> WriteGeneratedFilePart {
    self.instance.clone()
  }
  
  pub fn generation_id(&mut self, generation_id: i64) -> &mut Self {
    self.instance.generation_id = Some(generation_id);
    self
  }
  
  pub fn offset(&mut self, offset: i32) -> &mut Self {
    self.instance.offset = Some(offset);
    self
  }
  
  pub fn data(&mut self, data: String) -> &mut Self {
    self.instance.data = Some(data);
    self
  }
  
}


